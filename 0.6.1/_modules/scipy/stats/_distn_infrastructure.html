
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>scipy.stats._distn_infrastructure &mdash; statsmodels 0.6.1 documentation</title>
    
    <link rel="stylesheet" href="../../../_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '0.6.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <link rel="shortcut icon" href="../../../_static/statsmodels_hybi_favico.ico"/>
    <link rel="author" title="About these documents" href="../../../about.html" />
    <link rel="top" title="statsmodels 0.6.1 documentation" href="../../../index.html" />
    <link rel="up" title="Module code" href="../../index.html" />
<link rel="stylesheet" href="../../_static/facebox.css" type="text/css" />
<link rel="stylesheet" href="../_static/examples.css" type="text/css" />
<script type="text/javascript" src="../../../_static/scripts.js">
</script>
<script type="text/javascript" src="../../../_static/facebox.js">
</script>

  </head>
  <body role="document">
<div class="headerwrap">
    <div class = "header">
        
        <a href = "../../../index.html">
<img src="../../../_static/statsmodels_hybi_banner.png" alt="Logo"
    style="padding-left: 15px"/></a>
        
    </div>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
<li><a href ="../../../install.html">Install</a></li> &nbsp;|&nbsp;
<li><a href="https://groups.google.com/group/pystatsmodels?hl=en">Support</a></li> &nbsp;|&nbsp;
<li><a href="https://github.com/statsmodels/statsmodels/issues">Bugs</a></li> &nbsp;|&nbsp;
<li><a href="../../../dev/index.html">Develop</a></li> &nbsp;|&nbsp;
<li><a href="../../../examples/index.html">Examples</a></li> &nbsp;|&nbsp;
<li><a href="../../../faq.html">FAQ</a></li> &nbsp;|&nbsp;

          <li class="nav-item nav-item-1"><a href="../../index.html" accesskey="U">Module code</a> |</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            




  <h1>Source code for scipy.stats._distn_infrastructure</h1><div class="highlight"><pre>
<span class="c">#</span>
<span class="c"># Author:  Travis Oliphant  2002-2011 with contributions from</span>
<span class="c">#          SciPy Developers 2004-2011</span>
<span class="c">#</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">division</span><span class="p">,</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">absolute_import</span>

<span class="kn">from</span> <span class="nn">scipy.lib.six</span> <span class="kn">import</span> <span class="n">string_types</span><span class="p">,</span> <span class="n">exec_</span>

<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">keyword</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">inspect</span>
<span class="kn">import</span> <span class="nn">types</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">from</span> <span class="nn">scipy.misc</span> <span class="kn">import</span> <span class="n">doccer</span>
<span class="kn">from</span> <span class="nn">._distr_params</span> <span class="kn">import</span> <span class="n">distcont</span><span class="p">,</span> <span class="n">distdiscrete</span>

<span class="kn">from</span> <span class="nn">scipy.special</span> <span class="kn">import</span> <span class="p">(</span><span class="n">comb</span><span class="p">,</span> <span class="n">chndtr</span><span class="p">,</span> <span class="n">gammaln</span><span class="p">,</span> <span class="n">hyp0f1</span><span class="p">,</span>
                           <span class="n">entr</span><span class="p">,</span> <span class="n">kl_div</span><span class="p">)</span>

<span class="c"># for root finding for discrete distribution ppf, and max likelihood estimation</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">optimize</span>

<span class="c"># for functions of continuous distributions (e.g. moments, entropy, cdf)</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">integrate</span>

<span class="c"># to approximate the pdf of a continuous distribution given its cdf</span>
<span class="kn">from</span> <span class="nn">scipy.misc</span> <span class="kn">import</span> <span class="n">derivative</span>

<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="p">(</span><span class="n">arange</span><span class="p">,</span> <span class="n">putmask</span><span class="p">,</span> <span class="n">ravel</span><span class="p">,</span> <span class="n">take</span><span class="p">,</span> <span class="n">ones</span><span class="p">,</span> <span class="nb">sum</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span>
                   <span class="n">product</span><span class="p">,</span> <span class="n">reshape</span><span class="p">,</span> <span class="n">zeros</span><span class="p">,</span> <span class="n">floor</span><span class="p">,</span> <span class="n">logical_and</span><span class="p">,</span> <span class="n">log</span><span class="p">,</span> <span class="n">sqrt</span><span class="p">,</span> <span class="n">exp</span><span class="p">,</span>
                   <span class="n">ndarray</span><span class="p">)</span>

<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="p">(</span><span class="n">place</span><span class="p">,</span> <span class="nb">any</span><span class="p">,</span> <span class="n">argsort</span><span class="p">,</span> <span class="n">argmax</span><span class="p">,</span> <span class="n">vectorize</span><span class="p">,</span>
                   <span class="n">asarray</span><span class="p">,</span> <span class="n">nan</span><span class="p">,</span> <span class="n">inf</span><span class="p">,</span> <span class="n">isinf</span><span class="p">,</span> <span class="n">NINF</span><span class="p">,</span> <span class="n">empty</span><span class="p">)</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">numpy.random</span> <span class="kn">as</span> <span class="nn">mtrand</span>

<span class="kn">from</span> <span class="nn">._constants</span> <span class="kn">import</span> <span class="n">_EPS</span><span class="p">,</span> <span class="n">_XMAX</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">new</span> <span class="kn">import</span> <span class="n">instancemethod</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="c"># Python 3</span>
    <span class="k">def</span> <span class="nf">instancemethod</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">cls</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">types</span><span class="o">.</span><span class="n">MethodType</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">obj</span><span class="p">)</span>


<span class="c"># These are the docstring parts used for substitution in specific</span>
<span class="c"># distribution docstrings</span>

<span class="n">docheaders</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;methods&#39;</span><span class="p">:</span> <span class="s">&quot;&quot;&quot;</span><span class="se">\n</span><span class="s">Methods</span><span class="se">\n</span><span class="s">-------</span><span class="se">\n</span><span class="s">&quot;&quot;&quot;</span><span class="p">,</span>
              <span class="s">&#39;parameters&#39;</span><span class="p">:</span> <span class="s">&quot;&quot;&quot;</span><span class="se">\n</span><span class="s">Parameters</span><span class="se">\n</span><span class="s">---------</span><span class="se">\n</span><span class="s">&quot;&quot;&quot;</span><span class="p">,</span>
              <span class="s">&#39;notes&#39;</span><span class="p">:</span> <span class="s">&quot;&quot;&quot;</span><span class="se">\n</span><span class="s">Notes</span><span class="se">\n</span><span class="s">-----</span><span class="se">\n</span><span class="s">&quot;&quot;&quot;</span><span class="p">,</span>
              <span class="s">&#39;examples&#39;</span><span class="p">:</span> <span class="s">&quot;&quot;&quot;</span><span class="se">\n</span><span class="s">Examples</span><span class="se">\n</span><span class="s">--------</span><span class="se">\n</span><span class="s">&quot;&quot;&quot;</span><span class="p">}</span>

<span class="n">_doc_rvs</span> <span class="o">=</span> <span class="s">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s">``rvs(</span><span class="si">%(shapes)s</span><span class="s">, loc=0, scale=1, size=1)``</span>
<span class="s">    Random variates.</span>
<span class="s">&quot;&quot;&quot;</span>
<span class="n">_doc_pdf</span> <span class="o">=</span> <span class="s">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s">``pdf(x, </span><span class="si">%(shapes)s</span><span class="s">, loc=0, scale=1)``</span>
<span class="s">    Probability density function.</span>
<span class="s">&quot;&quot;&quot;</span>
<span class="n">_doc_logpdf</span> <span class="o">=</span> <span class="s">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s">``logpdf(x, </span><span class="si">%(shapes)s</span><span class="s">, loc=0, scale=1)``</span>
<span class="s">    Log of the probability density function.</span>
<span class="s">&quot;&quot;&quot;</span>
<span class="n">_doc_pmf</span> <span class="o">=</span> <span class="s">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s">``pmf(x, </span><span class="si">%(shapes)s</span><span class="s">, loc=0, scale=1)``</span>
<span class="s">    Probability mass function.</span>
<span class="s">&quot;&quot;&quot;</span>
<span class="n">_doc_logpmf</span> <span class="o">=</span> <span class="s">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s">``logpmf(x, </span><span class="si">%(shapes)s</span><span class="s">, loc=0, scale=1)``</span>
<span class="s">    Log of the probability mass function.</span>
<span class="s">&quot;&quot;&quot;</span>
<span class="n">_doc_cdf</span> <span class="o">=</span> <span class="s">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s">``cdf(x, </span><span class="si">%(shapes)s</span><span class="s">, loc=0, scale=1)``</span>
<span class="s">    Cumulative density function.</span>
<span class="s">&quot;&quot;&quot;</span>
<span class="n">_doc_logcdf</span> <span class="o">=</span> <span class="s">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s">``logcdf(x, </span><span class="si">%(shapes)s</span><span class="s">, loc=0, scale=1)``</span>
<span class="s">    Log of the cumulative density function.</span>
<span class="s">&quot;&quot;&quot;</span>
<span class="n">_doc_sf</span> <span class="o">=</span> <span class="s">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s">``sf(x, </span><span class="si">%(shapes)s</span><span class="s">, loc=0, scale=1)``</span>
<span class="s">    Survival function (1-cdf --- sometimes more accurate).</span>
<span class="s">&quot;&quot;&quot;</span>
<span class="n">_doc_logsf</span> <span class="o">=</span> <span class="s">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s">``logsf(x, </span><span class="si">%(shapes)s</span><span class="s">, loc=0, scale=1)``</span>
<span class="s">    Log of the survival function.</span>
<span class="s">&quot;&quot;&quot;</span>
<span class="n">_doc_ppf</span> <span class="o">=</span> <span class="s">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s">``ppf(q, </span><span class="si">%(shapes)s</span><span class="s">, loc=0, scale=1)``</span>
<span class="s">    Percent point function (inverse of cdf --- percentiles).</span>
<span class="s">&quot;&quot;&quot;</span>
<span class="n">_doc_isf</span> <span class="o">=</span> <span class="s">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s">``isf(q, </span><span class="si">%(shapes)s</span><span class="s">, loc=0, scale=1)``</span>
<span class="s">    Inverse survival function (inverse of sf).</span>
<span class="s">&quot;&quot;&quot;</span>
<span class="n">_doc_moment</span> <span class="o">=</span> <span class="s">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s">``moment(n, </span><span class="si">%(shapes)s</span><span class="s">, loc=0, scale=1)``</span>
<span class="s">    Non-central moment of order n</span>
<span class="s">&quot;&quot;&quot;</span>
<span class="n">_doc_stats</span> <span class="o">=</span> <span class="s">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s">``stats(</span><span class="si">%(shapes)s</span><span class="s">, loc=0, scale=1, moments=&#39;mv&#39;)``</span>
<span class="s">    Mean(&#39;m&#39;), variance(&#39;v&#39;), skew(&#39;s&#39;), and/or kurtosis(&#39;k&#39;).</span>
<span class="s">&quot;&quot;&quot;</span>
<span class="n">_doc_entropy</span> <span class="o">=</span> <span class="s">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s">``entropy(</span><span class="si">%(shapes)s</span><span class="s">, loc=0, scale=1)``</span>
<span class="s">    (Differential) entropy of the RV.</span>
<span class="s">&quot;&quot;&quot;</span>
<span class="n">_doc_fit</span> <span class="o">=</span> <span class="s">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s">``fit(data, </span><span class="si">%(shapes)s</span><span class="s">, loc=0, scale=1)``</span>
<span class="s">    Parameter estimates for generic data.</span>
<span class="s">&quot;&quot;&quot;</span>
<span class="n">_doc_expect</span> <span class="o">=</span> <span class="s">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s">``expect(func, </span><span class="si">%(shapes)s</span><span class="s">, loc=0, scale=1, lb=None, ub=None, conditional=False, **kwds)``</span>
<span class="s">    Expected value of a function (of one argument) with respect to the distribution.</span>
<span class="s">&quot;&quot;&quot;</span>
<span class="n">_doc_expect_discrete</span> <span class="o">=</span> <span class="s">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s">``expect(func, </span><span class="si">%(shapes)s</span><span class="s">, loc=0, lb=None, ub=None, conditional=False)``</span>
<span class="s">    Expected value of a function (of one argument) with respect to the distribution.</span>
<span class="s">&quot;&quot;&quot;</span>
<span class="n">_doc_median</span> <span class="o">=</span> <span class="s">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s">``median(</span><span class="si">%(shapes)s</span><span class="s">, loc=0, scale=1)``</span>
<span class="s">    Median of the distribution.</span>
<span class="s">&quot;&quot;&quot;</span>
<span class="n">_doc_mean</span> <span class="o">=</span> <span class="s">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s">``mean(</span><span class="si">%(shapes)s</span><span class="s">, loc=0, scale=1)``</span>
<span class="s">    Mean of the distribution.</span>
<span class="s">&quot;&quot;&quot;</span>
<span class="n">_doc_var</span> <span class="o">=</span> <span class="s">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s">``var(</span><span class="si">%(shapes)s</span><span class="s">, loc=0, scale=1)``</span>
<span class="s">    Variance of the distribution.</span>
<span class="s">&quot;&quot;&quot;</span>
<span class="n">_doc_std</span> <span class="o">=</span> <span class="s">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s">``std(</span><span class="si">%(shapes)s</span><span class="s">, loc=0, scale=1)``</span>
<span class="s">    Standard deviation of the distribution.</span>
<span class="s">&quot;&quot;&quot;</span>
<span class="n">_doc_interval</span> <span class="o">=</span> <span class="s">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s">``interval(alpha, </span><span class="si">%(shapes)s</span><span class="s">, loc=0, scale=1)``</span>
<span class="s">    Endpoints of the range that contains alpha percent of the distribution</span>
<span class="s">&quot;&quot;&quot;</span>
<span class="n">_doc_allmethods</span> <span class="o">=</span> <span class="s">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">docheaders</span><span class="p">[</span><span class="s">&#39;methods&#39;</span><span class="p">],</span> <span class="n">_doc_rvs</span><span class="p">,</span> <span class="n">_doc_pdf</span><span class="p">,</span>
                           <span class="n">_doc_logpdf</span><span class="p">,</span> <span class="n">_doc_cdf</span><span class="p">,</span> <span class="n">_doc_logcdf</span><span class="p">,</span> <span class="n">_doc_sf</span><span class="p">,</span>
                           <span class="n">_doc_logsf</span><span class="p">,</span> <span class="n">_doc_ppf</span><span class="p">,</span> <span class="n">_doc_isf</span><span class="p">,</span> <span class="n">_doc_moment</span><span class="p">,</span>
                           <span class="n">_doc_stats</span><span class="p">,</span> <span class="n">_doc_entropy</span><span class="p">,</span> <span class="n">_doc_fit</span><span class="p">,</span>
                           <span class="n">_doc_expect</span><span class="p">,</span> <span class="n">_doc_median</span><span class="p">,</span>
                           <span class="n">_doc_mean</span><span class="p">,</span> <span class="n">_doc_var</span><span class="p">,</span> <span class="n">_doc_std</span><span class="p">,</span> <span class="n">_doc_interval</span><span class="p">])</span>

<span class="c"># Note that the two lines for %(shapes) are searched for and replaced in</span>
<span class="c"># rv_continuous and rv_discrete - update there if the exact string changes</span>
<span class="n">_doc_default_callparams</span> <span class="o">=</span> <span class="s">&quot;&quot;&quot;</span>
<span class="s">Parameters</span>
<span class="s">----------</span>
<span class="s">x : array_like</span>
<span class="s">    quantiles</span>
<span class="s">q : array_like</span>
<span class="s">    lower or upper tail probability</span>
<span class="si">%(shapes)s</span><span class="s"> : array_like</span>
<span class="s">    shape parameters</span>
<span class="s">loc : array_like, optional</span>
<span class="s">    location parameter (default=0)</span>
<span class="s">scale : array_like, optional</span>
<span class="s">    scale parameter (default=1)</span>
<span class="s">size : int or tuple of ints, optional</span>
<span class="s">    shape of random variates (default computed from input arguments )</span>
<span class="s">moments : str, optional</span>
<span class="s">    composed of letters [&#39;mvsk&#39;] specifying which moments to compute where</span>
<span class="s">    &#39;m&#39; = mean, &#39;v&#39; = variance, &#39;s&#39; = (Fisher&#39;s) skew and</span>
<span class="s">    &#39;k&#39; = (Fisher&#39;s) kurtosis.</span>
<span class="s">    Default is &#39;mv&#39;.</span>
<span class="s">&quot;&quot;&quot;</span>
<span class="n">_doc_default_longsummary</span> <span class="o">=</span> <span class="s">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s">Continuous random variables are defined from a standard form and may</span>
<span class="s">require some shape parameters to complete its specification.  Any</span>
<span class="s">optional keyword parameters can be passed to the methods of the RV</span>
<span class="s">object as given below:</span>
<span class="s">&quot;&quot;&quot;</span>
<span class="n">_doc_default_frozen_note</span> <span class="o">=</span> <span class="s">&quot;&quot;&quot;</span>
<span class="s">Alternatively, the object may be called (as a function) to fix the shape,</span>
<span class="s">location, and scale parameters returning a &quot;frozen&quot; continuous RV object:</span>

<span class="s">rv = </span><span class="si">%(name)s</span><span class="s">(</span><span class="si">%(shapes)s</span><span class="s">, loc=0, scale=1)</span>
<span class="s">    - Frozen RV object with the same methods but holding the given shape,</span>
<span class="s">      location, and scale fixed.</span>
<span class="s">&quot;&quot;&quot;</span>
<span class="n">_doc_default_example</span> <span class="o">=</span> <span class="s">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s">Examples</span>
<span class="s">--------</span>
<span class="s">&gt;&gt;&gt; from scipy.stats import </span><span class="si">%(name)s</span><span class="s"></span>
<span class="s">&gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="s">&gt;&gt;&gt; fig, ax = plt.subplots(1, 1)</span>

<span class="s">Calculate a few first moments:</span>

<span class="si">%(set_vals_stmt)s</span><span class="s"></span>
<span class="s">&gt;&gt;&gt; mean, var, skew, kurt = </span><span class="si">%(name)s</span><span class="s">.stats(</span><span class="si">%(shapes)s</span><span class="s">, moments=&#39;mvsk&#39;)</span>

<span class="s">Display the probability density function (``pdf``):</span>

<span class="s">&gt;&gt;&gt; x = np.linspace(</span><span class="si">%(name)s</span><span class="s">.ppf(0.01, </span><span class="si">%(shapes)s</span><span class="s">),</span>
<span class="s">...               </span><span class="si">%(name)s</span><span class="s">.ppf(0.99, </span><span class="si">%(shapes)s</span><span class="s">), 100)</span>
<span class="s">&gt;&gt;&gt; ax.plot(x, </span><span class="si">%(name)s</span><span class="s">.pdf(x, </span><span class="si">%(shapes)s</span><span class="s">),</span>
<span class="s">...          &#39;r-&#39;, lw=5, alpha=0.6, label=&#39;</span><span class="si">%(name)s</span><span class="s"> pdf&#39;)</span>

<span class="s">Alternatively, freeze the distribution and display the frozen pdf:</span>

<span class="s">&gt;&gt;&gt; rv = </span><span class="si">%(name)s</span><span class="s">(</span><span class="si">%(shapes)s</span><span class="s">)</span>
<span class="s">&gt;&gt;&gt; ax.plot(x, rv.pdf(x), &#39;k-&#39;, lw=2, label=&#39;frozen pdf&#39;)</span>

<span class="s">Check accuracy of ``cdf`` and ``ppf``:</span>

<span class="s">&gt;&gt;&gt; vals = </span><span class="si">%(name)s</span><span class="s">.ppf([0.001, 0.5, 0.999], </span><span class="si">%(shapes)s</span><span class="s">)</span>
<span class="s">&gt;&gt;&gt; np.allclose([0.001, 0.5, 0.999], </span><span class="si">%(name)s</span><span class="s">.cdf(vals, </span><span class="si">%(shapes)s</span><span class="s">))</span>
<span class="s">True</span>

<span class="s">Generate random numbers:</span>

<span class="s">&gt;&gt;&gt; r = </span><span class="si">%(name)s</span><span class="s">.rvs(</span><span class="si">%(shapes)s</span><span class="s">, size=1000)</span>

<span class="s">And compare the histogram:</span>

<span class="s">&gt;&gt;&gt; ax.hist(r, normed=True, histtype=&#39;stepfilled&#39;, alpha=0.2)</span>
<span class="s">&gt;&gt;&gt; ax.legend(loc=&#39;best&#39;, frameon=False)</span>
<span class="s">&gt;&gt;&gt; plt.show()</span>
<span class="s">&quot;&quot;&quot;</span>

<span class="n">_doc_default</span> <span class="o">=</span> <span class="s">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">_doc_default_longsummary</span><span class="p">,</span>
                        <span class="n">_doc_allmethods</span><span class="p">,</span>
                        <span class="n">_doc_default_callparams</span><span class="p">,</span>
                        <span class="n">_doc_default_frozen_note</span><span class="p">,</span>
                        <span class="n">_doc_default_example</span><span class="p">])</span>

<span class="n">_doc_default_before_notes</span> <span class="o">=</span> <span class="s">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">_doc_default_longsummary</span><span class="p">,</span>
                                     <span class="n">_doc_allmethods</span><span class="p">,</span>
                                     <span class="n">_doc_default_callparams</span><span class="p">,</span>
                                     <span class="n">_doc_default_frozen_note</span><span class="p">])</span>

<span class="n">docdict</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s">&#39;rvs&#39;</span><span class="p">:</span> <span class="n">_doc_rvs</span><span class="p">,</span>
    <span class="s">&#39;pdf&#39;</span><span class="p">:</span> <span class="n">_doc_pdf</span><span class="p">,</span>
    <span class="s">&#39;logpdf&#39;</span><span class="p">:</span> <span class="n">_doc_logpdf</span><span class="p">,</span>
    <span class="s">&#39;cdf&#39;</span><span class="p">:</span> <span class="n">_doc_cdf</span><span class="p">,</span>
    <span class="s">&#39;logcdf&#39;</span><span class="p">:</span> <span class="n">_doc_logcdf</span><span class="p">,</span>
    <span class="s">&#39;sf&#39;</span><span class="p">:</span> <span class="n">_doc_sf</span><span class="p">,</span>
    <span class="s">&#39;logsf&#39;</span><span class="p">:</span> <span class="n">_doc_logsf</span><span class="p">,</span>
    <span class="s">&#39;ppf&#39;</span><span class="p">:</span> <span class="n">_doc_ppf</span><span class="p">,</span>
    <span class="s">&#39;isf&#39;</span><span class="p">:</span> <span class="n">_doc_isf</span><span class="p">,</span>
    <span class="s">&#39;stats&#39;</span><span class="p">:</span> <span class="n">_doc_stats</span><span class="p">,</span>
    <span class="s">&#39;entropy&#39;</span><span class="p">:</span> <span class="n">_doc_entropy</span><span class="p">,</span>
    <span class="s">&#39;fit&#39;</span><span class="p">:</span> <span class="n">_doc_fit</span><span class="p">,</span>
    <span class="s">&#39;moment&#39;</span><span class="p">:</span> <span class="n">_doc_moment</span><span class="p">,</span>
    <span class="s">&#39;expect&#39;</span><span class="p">:</span> <span class="n">_doc_expect</span><span class="p">,</span>
    <span class="s">&#39;interval&#39;</span><span class="p">:</span> <span class="n">_doc_interval</span><span class="p">,</span>
    <span class="s">&#39;mean&#39;</span><span class="p">:</span> <span class="n">_doc_mean</span><span class="p">,</span>
    <span class="s">&#39;std&#39;</span><span class="p">:</span> <span class="n">_doc_std</span><span class="p">,</span>
    <span class="s">&#39;var&#39;</span><span class="p">:</span> <span class="n">_doc_var</span><span class="p">,</span>
    <span class="s">&#39;median&#39;</span><span class="p">:</span> <span class="n">_doc_median</span><span class="p">,</span>
    <span class="s">&#39;allmethods&#39;</span><span class="p">:</span> <span class="n">_doc_allmethods</span><span class="p">,</span>
    <span class="s">&#39;callparams&#39;</span><span class="p">:</span> <span class="n">_doc_default_callparams</span><span class="p">,</span>
    <span class="s">&#39;longsummary&#39;</span><span class="p">:</span> <span class="n">_doc_default_longsummary</span><span class="p">,</span>
    <span class="s">&#39;frozennote&#39;</span><span class="p">:</span> <span class="n">_doc_default_frozen_note</span><span class="p">,</span>
    <span class="s">&#39;example&#39;</span><span class="p">:</span> <span class="n">_doc_default_example</span><span class="p">,</span>
    <span class="s">&#39;default&#39;</span><span class="p">:</span> <span class="n">_doc_default</span><span class="p">,</span>
    <span class="s">&#39;before_notes&#39;</span><span class="p">:</span> <span class="n">_doc_default_before_notes</span>
<span class="p">}</span>

<span class="c"># Reuse common content between continuous and discrete docs, change some</span>
<span class="c"># minor bits.</span>
<span class="n">docdict_discrete</span> <span class="o">=</span> <span class="n">docdict</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

<span class="n">docdict_discrete</span><span class="p">[</span><span class="s">&#39;pmf&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_doc_pmf</span>
<span class="n">docdict_discrete</span><span class="p">[</span><span class="s">&#39;logpmf&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_doc_logpmf</span>
<span class="n">docdict_discrete</span><span class="p">[</span><span class="s">&#39;expect&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_doc_expect_discrete</span>
<span class="n">_doc_disc_methods</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;rvs&#39;</span><span class="p">,</span> <span class="s">&#39;pmf&#39;</span><span class="p">,</span> <span class="s">&#39;logpmf&#39;</span><span class="p">,</span> <span class="s">&#39;cdf&#39;</span><span class="p">,</span> <span class="s">&#39;logcdf&#39;</span><span class="p">,</span> <span class="s">&#39;sf&#39;</span><span class="p">,</span> <span class="s">&#39;logsf&#39;</span><span class="p">,</span>
                     <span class="s">&#39;ppf&#39;</span><span class="p">,</span> <span class="s">&#39;isf&#39;</span><span class="p">,</span> <span class="s">&#39;stats&#39;</span><span class="p">,</span> <span class="s">&#39;entropy&#39;</span><span class="p">,</span> <span class="s">&#39;expect&#39;</span><span class="p">,</span> <span class="s">&#39;median&#39;</span><span class="p">,</span>
                     <span class="s">&#39;mean&#39;</span><span class="p">,</span> <span class="s">&#39;var&#39;</span><span class="p">,</span> <span class="s">&#39;std&#39;</span><span class="p">,</span> <span class="s">&#39;interval&#39;</span><span class="p">]</span>
<span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">_doc_disc_methods</span><span class="p">:</span>
    <span class="n">docdict_discrete</span><span class="p">[</span><span class="n">obj</span><span class="p">]</span> <span class="o">=</span> <span class="n">docdict_discrete</span><span class="p">[</span><span class="n">obj</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&#39;, scale=1&#39;</span><span class="p">,</span> <span class="s">&#39;&#39;</span><span class="p">)</span>
<span class="n">docdict_discrete</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;pdf&#39;</span><span class="p">)</span>
<span class="n">docdict_discrete</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;logpdf&#39;</span><span class="p">)</span>

<span class="n">_doc_allmethods</span> <span class="o">=</span> <span class="s">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">docdict_discrete</span><span class="p">[</span><span class="n">obj</span><span class="p">]</span> <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">_doc_disc_methods</span><span class="p">])</span>
<span class="n">docdict_discrete</span><span class="p">[</span><span class="s">&#39;allmethods&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">docheaders</span><span class="p">[</span><span class="s">&#39;methods&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">_doc_allmethods</span>

<span class="n">docdict_discrete</span><span class="p">[</span><span class="s">&#39;longsummary&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_doc_default_longsummary</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span>
    <span class="s">&#39;Continuous&#39;</span><span class="p">,</span> <span class="s">&#39;Discrete&#39;</span><span class="p">)</span>
<span class="n">_doc_default_frozen_note</span> <span class="o">=</span> <span class="s">&quot;&quot;&quot;</span>
<span class="s">Alternatively, the object may be called (as a function) to fix the shape and</span>
<span class="s">location parameters returning a &quot;frozen&quot; discrete RV object:</span>

<span class="s">rv = </span><span class="si">%(name)s</span><span class="s">(</span><span class="si">%(shapes)s</span><span class="s">, loc=0)</span>
<span class="s">    - Frozen RV object with the same methods but holding the given shape and</span>
<span class="s">      location fixed.</span>
<span class="s">&quot;&quot;&quot;</span>
<span class="n">docdict_discrete</span><span class="p">[</span><span class="s">&#39;frozennote&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_doc_default_frozen_note</span>

<span class="n">_doc_default_discrete_example</span> <span class="o">=</span> <span class="s">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s">Examples</span>
<span class="s">--------</span>
<span class="s">&gt;&gt;&gt; from scipy.stats import </span><span class="si">%(name)s</span><span class="s"></span>
<span class="s">&gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="s">&gt;&gt;&gt; fig, ax = plt.subplots(1, 1)</span>

<span class="s">Calculate a few first moments:</span>

<span class="si">%(set_vals_stmt)s</span><span class="s"></span>
<span class="s">&gt;&gt;&gt; mean, var, skew, kurt = </span><span class="si">%(name)s</span><span class="s">.stats(</span><span class="si">%(shapes)s</span><span class="s">, moments=&#39;mvsk&#39;)</span>

<span class="s">Display the probability mass function (``pmf``):</span>

<span class="s">&gt;&gt;&gt; x = np.arange(</span><span class="si">%(name)s</span><span class="s">.ppf(0.01, </span><span class="si">%(shapes)s</span><span class="s">),</span>
<span class="s">...               </span><span class="si">%(name)s</span><span class="s">.ppf(0.99, </span><span class="si">%(shapes)s</span><span class="s">))</span>
<span class="s">&gt;&gt;&gt; ax.plot(x, </span><span class="si">%(name)s</span><span class="s">.pmf(x, </span><span class="si">%(shapes)s</span><span class="s">), &#39;bo&#39;, ms=8, label=&#39;</span><span class="si">%(name)s</span><span class="s"> pmf&#39;)</span>
<span class="s">&gt;&gt;&gt; ax.vlines(x, 0, </span><span class="si">%(name)s</span><span class="s">.pmf(x, </span><span class="si">%(shapes)s</span><span class="s">), colors=&#39;b&#39;, lw=5, alpha=0.5)</span>

<span class="s">Alternatively, freeze the distribution and display the frozen ``pmf``:</span>

<span class="s">&gt;&gt;&gt; rv = </span><span class="si">%(name)s</span><span class="s">(</span><span class="si">%(shapes)s</span><span class="s">)</span>
<span class="s">&gt;&gt;&gt; ax.vlines(x, 0, rv.pmf(x), colors=&#39;k&#39;, linestyles=&#39;-&#39;, lw=1,</span>
<span class="s">...         label=&#39;frozen pmf&#39;)</span>
<span class="s">&gt;&gt;&gt; ax.legend(loc=&#39;best&#39;, frameon=False)</span>
<span class="s">&gt;&gt;&gt; plt.show()</span>

<span class="s">Check accuracy of ``cdf`` and ``ppf``:</span>

<span class="s">&gt;&gt;&gt; prob = </span><span class="si">%(name)s</span><span class="s">.cdf(x, </span><span class="si">%(shapes)s</span><span class="s">)</span>
<span class="s">&gt;&gt;&gt; np.allclose(x, </span><span class="si">%(name)s</span><span class="s">.ppf(prob, </span><span class="si">%(shapes)s</span><span class="s">))</span>
<span class="s">True</span>

<span class="s">Generate random numbers:</span>

<span class="s">&gt;&gt;&gt; r = </span><span class="si">%(name)s</span><span class="s">.rvs(</span><span class="si">%(shapes)s</span><span class="s">, size=1000)</span>
<span class="s">&quot;&quot;&quot;</span>
<span class="n">docdict_discrete</span><span class="p">[</span><span class="s">&#39;example&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_doc_default_discrete_example</span>

<span class="n">_doc_default_before_notes</span> <span class="o">=</span> <span class="s">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">docdict_discrete</span><span class="p">[</span><span class="s">&#39;longsummary&#39;</span><span class="p">],</span>
                                     <span class="n">docdict_discrete</span><span class="p">[</span><span class="s">&#39;allmethods&#39;</span><span class="p">],</span>
                                     <span class="n">docdict_discrete</span><span class="p">[</span><span class="s">&#39;callparams&#39;</span><span class="p">],</span>
                                     <span class="n">docdict_discrete</span><span class="p">[</span><span class="s">&#39;frozennote&#39;</span><span class="p">]])</span>
<span class="n">docdict_discrete</span><span class="p">[</span><span class="s">&#39;before_notes&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_doc_default_before_notes</span>

<span class="n">_doc_default_disc</span> <span class="o">=</span> <span class="s">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">docdict_discrete</span><span class="p">[</span><span class="s">&#39;longsummary&#39;</span><span class="p">],</span>
                             <span class="n">docdict_discrete</span><span class="p">[</span><span class="s">&#39;allmethods&#39;</span><span class="p">],</span>
                             <span class="n">docdict_discrete</span><span class="p">[</span><span class="s">&#39;frozennote&#39;</span><span class="p">],</span>
                             <span class="n">docdict_discrete</span><span class="p">[</span><span class="s">&#39;example&#39;</span><span class="p">]])</span>
<span class="n">docdict_discrete</span><span class="p">[</span><span class="s">&#39;default&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_doc_default_disc</span>


<span class="c"># clean up all the separate docstring elements, we do not need them anymore</span>
<span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="p">[</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">dir</span><span class="p">()</span> <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&#39;_doc_&#39;</span><span class="p">)]:</span>
    <span class="k">exec</span><span class="p">(</span><span class="s">&#39;del &#39;</span> <span class="o">+</span> <span class="n">obj</span><span class="p">)</span>
<span class="k">del</span> <span class="n">obj</span>
<span class="k">try</span><span class="p">:</span>
    <span class="k">del</span> <span class="n">s</span>
<span class="k">except</span> <span class="ne">NameError</span><span class="p">:</span>
    <span class="c"># in Python 3, loop variables are not visible after the loop</span>
    <span class="k">pass</span>


<span class="k">def</span> <span class="nf">_moment</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">mu</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
    <span class="k">return</span> <span class="p">((</span><span class="n">data</span> <span class="o">-</span> <span class="n">mu</span><span class="p">)</span><span class="o">**</span><span class="n">n</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">_moment_from_stats</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">mu2</span><span class="p">,</span> <span class="n">g1</span><span class="p">,</span> <span class="n">g2</span><span class="p">,</span> <span class="n">moment_func</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">return</span> <span class="mf">1.0</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">mu</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">moment_func</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">mu</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">2</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">mu2</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">mu</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">moment_func</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">mu2</span> <span class="o">+</span> <span class="n">mu</span><span class="o">*</span><span class="n">mu</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">3</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">g1</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">mu2</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">mu</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">moment_func</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mu3</span> <span class="o">=</span> <span class="n">g1</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">mu2</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">)</span>  <span class="c"># 3rd central moment</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">mu3</span><span class="o">+</span><span class="mi">3</span><span class="o">*</span><span class="n">mu</span><span class="o">*</span><span class="n">mu2</span><span class="o">+</span><span class="n">mu</span><span class="o">*</span><span class="n">mu</span><span class="o">*</span><span class="n">mu</span>  <span class="c"># 3rd non-central moment</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">4</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">g1</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">g2</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">mu2</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">mu</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">moment_func</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mu4</span> <span class="o">=</span> <span class="p">(</span><span class="n">g2</span><span class="o">+</span><span class="mf">3.0</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">mu2</span><span class="o">**</span><span class="mf">2.0</span><span class="p">)</span>  <span class="c"># 4th central moment</span>
            <span class="n">mu3</span> <span class="o">=</span> <span class="n">g1</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">mu2</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">)</span>  <span class="c"># 3rd central moment</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">mu4</span><span class="o">+</span><span class="mi">4</span><span class="o">*</span><span class="n">mu</span><span class="o">*</span><span class="n">mu3</span><span class="o">+</span><span class="mi">6</span><span class="o">*</span><span class="n">mu</span><span class="o">*</span><span class="n">mu</span><span class="o">*</span><span class="n">mu2</span><span class="o">+</span><span class="n">mu</span><span class="o">*</span><span class="n">mu</span><span class="o">*</span><span class="n">mu</span><span class="o">*</span><span class="n">mu</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">val</span> <span class="o">=</span> <span class="n">moment_func</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">val</span>


<span class="k">def</span> <span class="nf">_skew</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    skew is third central moment / variance**(1.5)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="n">mu</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
    <span class="n">m2</span> <span class="o">=</span> <span class="p">((</span><span class="n">data</span> <span class="o">-</span> <span class="n">mu</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
    <span class="n">m3</span> <span class="o">=</span> <span class="p">((</span><span class="n">data</span> <span class="o">-</span> <span class="n">mu</span><span class="p">)</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">m3</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">m2</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_kurtosis</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    kurtosis is fourth central moment / variance**2 - 3</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="n">mu</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
    <span class="n">m2</span> <span class="o">=</span> <span class="p">((</span><span class="n">data</span> <span class="o">-</span> <span class="n">mu</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
    <span class="n">m4</span> <span class="o">=</span> <span class="p">((</span><span class="n">data</span> <span class="o">-</span> <span class="n">mu</span><span class="p">)</span><span class="o">**</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">m4</span> <span class="o">/</span> <span class="n">m2</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">3</span>


<span class="c"># Frozen RV class</span>
<span class="k">class</span> <span class="nc">rv_frozen</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dist</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">args</span> <span class="o">=</span> <span class="n">args</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kwds</span> <span class="o">=</span> <span class="n">kwds</span>

        <span class="c"># create a new instance</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dist</span> <span class="o">=</span> <span class="n">dist</span><span class="o">.</span><span class="n">__class__</span><span class="p">(</span><span class="o">**</span><span class="n">dist</span><span class="o">.</span><span class="n">_ctor_param</span><span class="p">)</span>

        <span class="c"># a, b may be set in _argcheck, depending on *args, **kwds. Ouch.</span>
        <span class="n">shapes</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist</span><span class="o">.</span><span class="n">_parse_args</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dist</span><span class="o">.</span><span class="n">_argcheck</span><span class="p">(</span><span class="o">*</span><span class="n">shapes</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">pdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>   <span class="c"># raises AttributeError in frozen discrete distribution</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">kwds</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">logpdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist</span><span class="o">.</span><span class="n">logpdf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">kwds</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">cdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">kwds</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">logcdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist</span><span class="o">.</span><span class="n">logcdf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">kwds</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ppf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">q</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">kwds</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">isf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">q</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist</span><span class="o">.</span><span class="n">isf</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">kwds</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">rvs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="n">kwds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kwds</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">kwds</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s">&#39;size&#39;</span><span class="p">:</span> <span class="n">size</span><span class="p">})</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">sf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist</span><span class="o">.</span><span class="n">sf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">kwds</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">logsf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist</span><span class="o">.</span><span class="n">logsf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">kwds</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">stats</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">moments</span><span class="o">=</span><span class="s">&#39;mv&#39;</span><span class="p">):</span>
        <span class="n">kwds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kwds</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">kwds</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s">&#39;moments&#39;</span><span class="p">:</span> <span class="n">moments</span><span class="p">})</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist</span><span class="o">.</span><span class="n">stats</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">median</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">kwds</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">mean</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">kwds</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">var</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">kwds</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">std</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">kwds</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">moment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist</span><span class="o">.</span><span class="n">moment</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">kwds</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">entropy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist</span><span class="o">.</span><span class="n">entropy</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">kwds</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">pmf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist</span><span class="o">.</span><span class="n">pmf</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">kwds</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">logpmf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist</span><span class="o">.</span><span class="n">logpmf</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">kwds</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">interval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist</span><span class="o">.</span><span class="n">interval</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">kwds</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">valarray</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">nan</span><span class="p">,</span> <span class="n">typecode</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return an array of all value.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">out</span> <span class="o">=</span> <span class="n">ones</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span> <span class="o">*</span> <span class="n">value</span>
    <span class="k">if</span> <span class="n">typecode</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">typecode</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">):</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">out</span>


<span class="k">def</span> <span class="nf">_lazywhere</span><span class="p">(</span><span class="n">cond</span><span class="p">,</span> <span class="n">arrays</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">fillvalue</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">f2</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    np.where(cond, x, fillvalue) always evaluates x even where cond is False.</span>
<span class="sd">    This one only evaluates f(arr1[cond], arr2[cond], ...).</span>
<span class="sd">    For example,</span>
<span class="sd">    &gt;&gt;&gt; a, b = np.array([1, 2, 3, 4]), np.array([5, 6, 7, 8])</span>
<span class="sd">    &gt;&gt;&gt; def f(a, b):</span>
<span class="sd">        return a*b</span>
<span class="sd">    &gt;&gt;&gt; _lazywhere(a &gt; 2, (a, b), f, np.nan)</span>
<span class="sd">    array([ nan,  nan,  21.,  32.])</span>

<span class="sd">    Notice it assumes that all `arrays` are of the same shape, or can be</span>
<span class="sd">    broadcasted together.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">fillvalue</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">f2</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;One of (fillvalue, f2) must be given.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fillvalue</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">f2</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Only one of (fillvalue, f2) can be given.&quot;</span><span class="p">)</span>

    <span class="n">arrays</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_arrays</span><span class="p">(</span><span class="o">*</span><span class="n">arrays</span><span class="p">)</span>
    <span class="n">temp</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">extract</span><span class="p">(</span><span class="n">cond</span><span class="p">,</span> <span class="n">arr</span><span class="p">)</span> <span class="k">for</span> <span class="n">arr</span> <span class="ow">in</span> <span class="n">arrays</span><span class="p">)</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">valarray</span><span class="p">(</span><span class="n">shape</span><span class="p">(</span><span class="n">arrays</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">value</span><span class="o">=</span><span class="n">fillvalue</span><span class="p">)</span>
    <span class="n">np</span><span class="o">.</span><span class="n">place</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">cond</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">temp</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">f2</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">extract</span><span class="p">(</span><span class="o">~</span><span class="n">cond</span><span class="p">,</span> <span class="n">arr</span><span class="p">)</span> <span class="k">for</span> <span class="n">arr</span> <span class="ow">in</span> <span class="n">arrays</span><span class="p">)</span>
        <span class="n">np</span><span class="o">.</span><span class="n">place</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="o">~</span><span class="n">cond</span><span class="p">,</span> <span class="n">f2</span><span class="p">(</span><span class="o">*</span><span class="n">temp</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">out</span>


<span class="c"># This should be rewritten</span>
<span class="k">def</span> <span class="nf">argsreduce</span><span class="p">(</span><span class="n">cond</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the sequence of ravel(args[i]) where ravel(condition) is</span>
<span class="sd">    True in 1D.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; rand = np.random.random_sample</span>
<span class="sd">    &gt;&gt;&gt; A = rand((4, 5))</span>
<span class="sd">    &gt;&gt;&gt; B = 2</span>
<span class="sd">    &gt;&gt;&gt; C = rand((1, 5))</span>
<span class="sd">    &gt;&gt;&gt; cond = np.ones(A.shape)</span>
<span class="sd">    &gt;&gt;&gt; [A1, B1, C1] = argsreduce(cond, A, B, C)</span>
<span class="sd">    &gt;&gt;&gt; B1.shape</span>
<span class="sd">    (20,)</span>
<span class="sd">    &gt;&gt;&gt; cond[2,:] = 0</span>
<span class="sd">    &gt;&gt;&gt; [A2, B2, C2] = argsreduce(cond, A, B, C)</span>
<span class="sd">    &gt;&gt;&gt; B2.shape</span>
<span class="sd">    (15,)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">newargs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">newargs</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">newargs</span> <span class="o">=</span> <span class="p">[</span><span class="n">newargs</span><span class="p">,</span> <span class="p">]</span>
    <span class="n">expand_arr</span> <span class="o">=</span> <span class="p">(</span><span class="n">cond</span> <span class="o">==</span> <span class="n">cond</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">extract</span><span class="p">(</span><span class="n">cond</span><span class="p">,</span> <span class="n">arr1</span> <span class="o">*</span> <span class="n">expand_arr</span><span class="p">)</span> <span class="k">for</span> <span class="n">arr1</span> <span class="ow">in</span> <span class="n">newargs</span><span class="p">]</span>


<span class="n">parse_arg_template</span> <span class="o">=</span> <span class="s">&quot;&quot;&quot;</span>
<span class="s">def _parse_args(self, </span><span class="si">%(shape_arg_str)s</span><span class="s"> </span><span class="si">%(locscale_in)s</span><span class="s">):</span>
<span class="s">    return (</span><span class="si">%(shape_arg_str)s</span><span class="s">), </span><span class="si">%(locscale_out)s</span><span class="s"></span>

<span class="s">def _parse_args_rvs(self, </span><span class="si">%(shape_arg_str)s</span><span class="s"> </span><span class="si">%(locscale_in)s</span><span class="s">, size=None):</span>
<span class="s">    return (</span><span class="si">%(shape_arg_str)s</span><span class="s">), </span><span class="si">%(locscale_out)s</span><span class="s">, size</span>

<span class="s">def _parse_args_stats(self, </span><span class="si">%(shape_arg_str)s</span><span class="s"> </span><span class="si">%(locscale_in)s</span><span class="s">, moments=&#39;mv&#39;):</span>
<span class="s">    return (</span><span class="si">%(shape_arg_str)s</span><span class="s">), </span><span class="si">%(locscale_out)s</span><span class="s">, moments</span>
<span class="s">&quot;&quot;&quot;</span>


<span class="c"># Both the continuous and discrete distributions depend on ncx2.</span>
<span class="c"># I think the function name ncx2 is an abbreviation for noncentral chi squared.</span>

<span class="k">def</span> <span class="nf">_ncx2_log_pdf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">nc</span><span class="p">):</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">df</span><span class="o">/</span><span class="mf">2.0</span><span class="p">)</span>
    <span class="n">fac</span> <span class="o">=</span> <span class="o">-</span><span class="n">nc</span><span class="o">/</span><span class="mf">2.0</span> <span class="o">-</span> <span class="n">x</span><span class="o">/</span><span class="mf">2.0</span> <span class="o">+</span> <span class="p">(</span><span class="n">a</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">log</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">a</span><span class="o">*</span><span class="n">log</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="n">gammaln</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">fac</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">log</span><span class="p">(</span><span class="n">hyp0f1</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">nc</span> <span class="o">*</span> <span class="n">x</span><span class="o">/</span><span class="mf">4.0</span><span class="p">)))</span>


<span class="k">def</span> <span class="nf">_ncx2_pdf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">nc</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">_ncx2_log_pdf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">nc</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">_ncx2_cdf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">nc</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">chndtr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">nc</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">rv_generic</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Class which encapsulates common functionality between rv_discrete</span>
<span class="sd">    and rv_continuous.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">rv_generic</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span>

        <span class="c"># figure out if _stats signature has &#39;moments&#39; keyword</span>
        <span class="n">sign</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">getargspec</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_stats</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_stats_has_moments</span> <span class="o">=</span> <span class="p">((</span><span class="n">sign</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">or</span>
                                   <span class="p">(</span><span class="s">&#39;moments&#39;</span> <span class="ow">in</span> <span class="n">sign</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

    <span class="k">def</span> <span class="nf">_construct_argparser</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">meths_to_inspect</span><span class="p">,</span> <span class="n">locscale_in</span><span class="p">,</span> <span class="n">locscale_out</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Construct the parser for the shape arguments.</span>

<span class="sd">        Generates the argument-parsing functions dynamically and attaches</span>
<span class="sd">        them to the instance.</span>
<span class="sd">        Is supposed to be called in __init__ of a class for each distribution.</span>

<span class="sd">        If self.shapes is a non-empty string, interprets it as a</span>
<span class="sd">        comma-separated list of shape parameters.</span>

<span class="sd">        Otherwise inspects the call signatures of `meths_to_inspect`</span>
<span class="sd">        and constructs the argument-parsing functions from these.</span>
<span class="sd">        In this case also sets `shapes` and `numargs`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">shapes</span><span class="p">:</span>
            <span class="c"># sanitize the user-supplied shapes</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shapes</span><span class="p">,</span> <span class="n">string_types</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;shapes must be a string.&#39;</span><span class="p">)</span>

            <span class="n">shapes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shapes</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&#39;,&#39;</span><span class="p">,</span> <span class="s">&#39; &#39;</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>

            <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">shapes</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">keyword</span><span class="o">.</span><span class="n">iskeyword</span><span class="p">(</span><span class="n">field</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">SyntaxError</span><span class="p">(</span><span class="s">&#39;keywords cannot be used as shapes.&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s">&#39;^[_a-zA-Z][_a-zA-Z0-9]*$&#39;</span><span class="p">,</span> <span class="n">field</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">SyntaxError</span><span class="p">(</span>
                        <span class="s">&#39;shapes must be valid python identifiers&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># find out the call signatures (_pdf, _cdf etc), deduce shape</span>
            <span class="c"># arguments</span>
            <span class="n">shapes_list</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">meth</span> <span class="ow">in</span> <span class="n">meths_to_inspect</span><span class="p">:</span>
                <span class="n">shapes_args</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">getargspec</span><span class="p">(</span><span class="n">meth</span><span class="p">)</span>
                <span class="n">shapes_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">shapes_args</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>

                <span class="c"># *args or **kwargs are not allowed w/automatic shapes</span>
                <span class="c"># (generic methods have &#39;self, x&#39; only)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">shapes_args</span><span class="o">.</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">shapes_args</span><span class="o">.</span><span class="n">varargs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                            <span class="s">&#39;*args are not allowed w/out explicit shapes&#39;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">shapes_args</span><span class="o">.</span><span class="n">keywords</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                            <span class="s">&#39;**kwds are not allowed w/out explicit shapes&#39;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">shapes_args</span><span class="o">.</span><span class="n">defaults</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;defaults are not allowed for shapes&#39;</span><span class="p">)</span>

            <span class="n">shapes</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">shapes_list</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
            <span class="n">shapes</span> <span class="o">=</span> <span class="n">shapes</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span>  <span class="c"># remove self, x,</span>

            <span class="c"># make sure the signatures are consistent</span>
            <span class="c"># (generic methods have &#39;self, x&#39; only)</span>
            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">shapes_list</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">item</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span> <span class="o">!=</span> <span class="n">shapes</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;Shape arguments are inconsistent.&#39;</span><span class="p">)</span>

        <span class="c"># have the arguments, construct the method from template</span>
        <span class="n">shapes_str</span> <span class="o">=</span> <span class="s">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">shapes</span><span class="p">)</span> <span class="o">+</span> <span class="s">&#39;, &#39;</span> <span class="k">if</span> <span class="n">shapes</span> <span class="k">else</span> <span class="s">&#39;&#39;</span>  <span class="c"># NB: not None</span>
        <span class="n">dct</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">shape_arg_str</span><span class="o">=</span><span class="n">shapes_str</span><span class="p">,</span>
                   <span class="n">locscale_in</span><span class="o">=</span><span class="n">locscale_in</span><span class="p">,</span>
                   <span class="n">locscale_out</span><span class="o">=</span><span class="n">locscale_out</span><span class="p">,</span>
                   <span class="p">)</span>
        <span class="n">ns</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">exec_</span><span class="p">(</span><span class="n">parse_arg_template</span> <span class="o">%</span> <span class="n">dct</span><span class="p">,</span> <span class="n">ns</span><span class="p">)</span>
        <span class="c"># NB: attach to the instance, not class</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&#39;_parse_args&#39;</span><span class="p">,</span> <span class="s">&#39;_parse_args_stats&#39;</span><span class="p">,</span> <span class="s">&#39;_parse_args_rvs&#39;</span><span class="p">]:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span>
                    <span class="n">instancemethod</span><span class="p">(</span><span class="n">ns</span><span class="p">[</span><span class="n">name</span><span class="p">],</span> <span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">)</span>
                    <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">shapes</span> <span class="o">=</span> <span class="s">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">shapes</span><span class="p">)</span> <span class="k">if</span> <span class="n">shapes</span> <span class="k">else</span> <span class="bp">None</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;numargs&#39;</span><span class="p">):</span>
            <span class="c"># allows more general subclassing with *args</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">numargs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">shapes</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_construct_doc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">docdict</span><span class="p">,</span> <span class="n">shapes_vals</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Construct the instance docstring with string substitutions.&quot;&quot;&quot;</span>
        <span class="n">tempdict</span> <span class="o">=</span> <span class="n">docdict</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">tempdict</span><span class="p">[</span><span class="s">&#39;name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="ow">or</span> <span class="s">&#39;distname&#39;</span>
        <span class="n">tempdict</span><span class="p">[</span><span class="s">&#39;shapes&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shapes</span> <span class="ow">or</span> <span class="s">&#39;&#39;</span>

        <span class="k">if</span> <span class="n">shapes_vals</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">shapes_vals</span> <span class="o">=</span> <span class="p">()</span>
        <span class="n">vals</span> <span class="o">=</span> <span class="s">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">shapes_vals</span><span class="p">)</span>
        <span class="n">tempdict</span><span class="p">[</span><span class="s">&#39;vals&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">vals</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">shapes</span><span class="p">:</span>
            <span class="n">tempdict</span><span class="p">[</span><span class="s">&#39;set_vals_stmt&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;&gt;&gt;&gt; </span><span class="si">%s</span><span class="s"> = </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shapes</span><span class="p">,</span> <span class="n">vals</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tempdict</span><span class="p">[</span><span class="s">&#39;set_vals_stmt&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">shapes</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="c"># remove shapes from call parameters if there are none</span>
            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&#39;callparams&#39;</span><span class="p">,</span> <span class="s">&#39;default&#39;</span><span class="p">,</span> <span class="s">&#39;before_notes&#39;</span><span class="p">]:</span>
                <span class="n">tempdict</span><span class="p">[</span><span class="n">item</span><span class="p">]</span> <span class="o">=</span> <span class="n">tempdict</span><span class="p">[</span><span class="n">item</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span>
                    <span class="s">&quot;</span><span class="se">\n</span><span class="si">%(shapes)s</span><span class="s"> : array_like</span><span class="se">\n</span><span class="s">    shape parameters&quot;</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">shapes</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="c"># necessary because we use %(shapes)s in two forms (w w/o &quot;, &quot;)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__doc__</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__doc__</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%(shapes)s</span><span class="s">, &quot;</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__doc__</span> <span class="o">=</span> <span class="n">doccer</span><span class="o">.</span><span class="n">docformat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__doc__</span><span class="p">,</span> <span class="n">tempdict</span><span class="p">)</span>

        <span class="c"># correct for empty shapes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__doc__</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__doc__</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&#39;(, &#39;</span><span class="p">,</span> <span class="s">&#39;(&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&#39;, )&#39;</span><span class="p">,</span> <span class="s">&#39;)&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">freeze</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Freeze the distribution for the given arguments.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        arg1, arg2, arg3,... : array_like</span>
<span class="sd">            The shape parameter(s) for the distribution.  Should include all</span>
<span class="sd">            the non-optional arguments, may include ``loc`` and ``scale``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        rv_frozen : rv_frozen instance</span>
<span class="sd">            The frozen distribution.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">rv_frozen</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">freeze</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>

    <span class="c"># The actual calculation functions (no basic checking need be done)</span>
    <span class="c"># If these are defined, the others won&#39;t be looked at.</span>
    <span class="c"># Otherwise, the other set can be defined.</span>
    <span class="k">def</span> <span class="nf">_stats</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span>

    <span class="c">#  Central moments</span>
    <span class="k">def</span> <span class="nf">_munp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="c"># Silence floating point warnings from integration.</span>
        <span class="n">olderr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">seterr</span><span class="p">(</span><span class="nb">all</span><span class="o">=</span><span class="s">&#39;ignore&#39;</span><span class="p">)</span>
        <span class="n">vals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generic_moment</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="n">np</span><span class="o">.</span><span class="n">seterr</span><span class="p">(</span><span class="o">**</span><span class="n">olderr</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">vals</span>

    <span class="c">## These are the methods you must define (standard form functions)</span>
    <span class="c">## NB: generic _pdf, _logpdf, _cdf are different for</span>
    <span class="c">## rv_continuous and rv_discrete hence are defined in there</span>
    <span class="k">def</span> <span class="nf">_argcheck</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Default check for correct values on args and keywords.</span>

<span class="sd">        Returns condition array of 1&#39;s where arguments are correct and</span>
<span class="sd">         0&#39;s where they are not.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cond</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
            <span class="n">cond</span> <span class="o">=</span> <span class="n">logical_and</span><span class="p">(</span><span class="n">cond</span><span class="p">,</span> <span class="p">(</span><span class="n">asarray</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">cond</span>

    <span class="c">##(return 1-d using self._size to get number)</span>
    <span class="k">def</span> <span class="nf">_rvs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="c">## Use basic inverse cdf algorithm for RV generation as default.</span>
        <span class="n">U</span> <span class="o">=</span> <span class="n">mtrand</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_size</span><span class="p">)</span>
        <span class="n">Y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ppf</span><span class="p">(</span><span class="n">U</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Y</span>

    <span class="k">def</span> <span class="nf">_logcdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cdf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_sf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="k">return</span> <span class="mf">1.0</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">_cdf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_logsf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_ppf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ppfvec</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_isf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ppf</span><span class="p">(</span><span class="mf">1.0</span><span class="o">-</span><span class="n">q</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>  <span class="c"># use correct _ppf for subclasses</span>

    <span class="c"># These are actually called, and should not be overwritten if you</span>
    <span class="c"># want to keep error checking.</span>
    <span class="k">def</span> <span class="nf">rvs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Random variates of given type.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        arg1, arg2, arg3,... : array_like</span>
<span class="sd">            The shape parameter(s) for the distribution (see docstring of the</span>
<span class="sd">            instance object for more information).</span>
<span class="sd">        loc : array_like, optional</span>
<span class="sd">            Location parameter (default=0).</span>
<span class="sd">        scale : array_like, optional</span>
<span class="sd">            Scale parameter (default=1).</span>
<span class="sd">        size : int or tuple of ints, optional</span>
<span class="sd">            Defining number of random variates (default=1).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        rvs : ndarray or scalar</span>
<span class="sd">            Random variates of given `size`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">discrete</span> <span class="o">=</span> <span class="n">kwds</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;discrete&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="n">args</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="n">size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_args_rvs</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
        <span class="n">cond</span> <span class="o">=</span> <span class="n">logical_and</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_argcheck</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">),</span> <span class="p">(</span><span class="n">scale</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">cond</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Domain error in arguments.&quot;</span><span class="p">)</span>

        <span class="c"># self._size is total size of all output values</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_size</span> <span class="o">=</span> <span class="n">product</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_size</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_size</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">size</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">scale</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">loc</span><span class="o">*</span><span class="n">ones</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="s">&#39;d&#39;</span><span class="p">)</span>

        <span class="n">vals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rvs</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_size</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">vals</span> <span class="o">=</span> <span class="n">reshape</span><span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>

        <span class="n">vals</span> <span class="o">=</span> <span class="n">vals</span> <span class="o">*</span> <span class="n">scale</span> <span class="o">+</span> <span class="n">loc</span>

        <span class="c"># Cast to int if discrete</span>
        <span class="k">if</span> <span class="n">discrete</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">vals</span><span class="p">):</span>
                <span class="n">vals</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">vals</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">vals</span> <span class="o">=</span> <span class="n">vals</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">vals</span>

    <span class="k">def</span> <span class="nf">stats</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Some statistics of the given RV</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        arg1, arg2, arg3,... : array_like</span>
<span class="sd">            The shape parameter(s) for the distribution (see docstring of the</span>
<span class="sd">            instance object for more information)</span>
<span class="sd">        loc : array_like, optional</span>
<span class="sd">            location parameter (default=0)</span>
<span class="sd">        scale : array_like, optional (discrete RVs only)</span>
<span class="sd">            scale parameter (default=1)</span>
<span class="sd">        moments : str, optional</span>
<span class="sd">            composed of letters [&#39;mvsk&#39;] defining which moments to compute:</span>
<span class="sd">            &#39;m&#39; = mean,</span>
<span class="sd">            &#39;v&#39; = variance,</span>
<span class="sd">            &#39;s&#39; = (Fisher&#39;s) skew,</span>
<span class="sd">            &#39;k&#39; = (Fisher&#39;s) kurtosis.</span>
<span class="sd">            (default=&#39;mv&#39;)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        stats : sequence</span>
<span class="sd">            of requested moments.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">args</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="n">moments</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_args_stats</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
        <span class="c"># scale = 1 by construction for discrete RVs</span>
        <span class="n">loc</span><span class="p">,</span> <span class="n">scale</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">asarray</span><span class="p">,</span> <span class="p">(</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="p">))</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">asarray</span><span class="p">,</span> <span class="n">args</span><span class="p">))</span>
        <span class="n">cond</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_argcheck</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">scale</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">loc</span> <span class="o">==</span> <span class="n">loc</span><span class="p">)</span>
        <span class="n">output</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">default</span> <span class="o">=</span> <span class="n">valarray</span><span class="p">(</span><span class="n">shape</span><span class="p">(</span><span class="n">cond</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">badvalue</span><span class="p">)</span>

        <span class="c"># Use only entries that are valid in calculation</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">cond</span><span class="p">):</span>
            <span class="n">goodargs</span> <span class="o">=</span> <span class="n">argsreduce</span><span class="p">(</span><span class="n">cond</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="n">args</span><span class="o">+</span><span class="p">(</span><span class="n">scale</span><span class="p">,</span> <span class="n">loc</span><span class="p">)))</span>
            <span class="n">scale</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">goodargs</span> <span class="o">=</span> <span class="n">goodargs</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="n">goodargs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">goodargs</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stats_has_moments</span><span class="p">:</span>
                <span class="n">mu</span><span class="p">,</span> <span class="n">mu2</span><span class="p">,</span> <span class="n">g1</span><span class="p">,</span> <span class="n">g2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stats</span><span class="p">(</span><span class="o">*</span><span class="n">goodargs</span><span class="p">,</span>
                                              <span class="o">**</span><span class="p">{</span><span class="s">&#39;moments&#39;</span><span class="p">:</span> <span class="n">moments</span><span class="p">})</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">mu</span><span class="p">,</span> <span class="n">mu2</span><span class="p">,</span> <span class="n">g1</span><span class="p">,</span> <span class="n">g2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stats</span><span class="p">(</span><span class="o">*</span><span class="n">goodargs</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">g1</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">mu3</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">mu2</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">mu2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_munp</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="o">*</span><span class="n">goodargs</span><span class="p">)</span>
                <span class="c"># (mu2**1.5) breaks down for nan and inf</span>
                <span class="n">mu3</span> <span class="o">=</span> <span class="n">g1</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">mu2</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">)</span>

            <span class="k">if</span> <span class="s">&#39;m&#39;</span> <span class="ow">in</span> <span class="n">moments</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">mu</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">mu</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_munp</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="n">goodargs</span><span class="p">)</span>
                <span class="n">out0</span> <span class="o">=</span> <span class="n">default</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">place</span><span class="p">(</span><span class="n">out0</span><span class="p">,</span> <span class="n">cond</span><span class="p">,</span> <span class="n">mu</span> <span class="o">*</span> <span class="n">scale</span> <span class="o">+</span> <span class="n">loc</span><span class="p">)</span>
                <span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">out0</span><span class="p">)</span>

            <span class="k">if</span> <span class="s">&#39;v&#39;</span> <span class="ow">in</span> <span class="n">moments</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">mu2</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">mu2p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_munp</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="o">*</span><span class="n">goodargs</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">mu</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                        <span class="n">mu</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_munp</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="n">goodargs</span><span class="p">)</span>
                    <span class="n">mu2</span> <span class="o">=</span> <span class="n">mu2p</span> <span class="o">-</span> <span class="n">mu</span> <span class="o">*</span> <span class="n">mu</span>
                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">mu</span><span class="p">):</span>
                        <span class="c">#if mean is inf then var is also inf</span>
                        <span class="n">mu2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
                <span class="n">out0</span> <span class="o">=</span> <span class="n">default</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">place</span><span class="p">(</span><span class="n">out0</span><span class="p">,</span> <span class="n">cond</span><span class="p">,</span> <span class="n">mu2</span> <span class="o">*</span> <span class="n">scale</span> <span class="o">*</span> <span class="n">scale</span><span class="p">)</span>
                <span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">out0</span><span class="p">)</span>

            <span class="k">if</span> <span class="s">&#39;s&#39;</span> <span class="ow">in</span> <span class="n">moments</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">g1</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">mu3p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_munp</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="o">*</span><span class="n">goodargs</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">mu</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                        <span class="n">mu</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_munp</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="n">goodargs</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">mu2</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                        <span class="n">mu2p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_munp</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="o">*</span><span class="n">goodargs</span><span class="p">)</span>
                        <span class="n">mu2</span> <span class="o">=</span> <span class="n">mu2p</span> <span class="o">-</span> <span class="n">mu</span> <span class="o">*</span> <span class="n">mu</span>
                    <span class="n">mu3</span> <span class="o">=</span> <span class="n">mu3p</span> <span class="o">-</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">mu</span> <span class="o">*</span> <span class="n">mu2</span> <span class="o">-</span> <span class="n">mu</span><span class="o">**</span><span class="mi">3</span>
                    <span class="n">g1</span> <span class="o">=</span> <span class="n">mu3</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">mu2</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">)</span>
                <span class="n">out0</span> <span class="o">=</span> <span class="n">default</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">place</span><span class="p">(</span><span class="n">out0</span><span class="p">,</span> <span class="n">cond</span><span class="p">,</span> <span class="n">g1</span><span class="p">)</span>
                <span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">out0</span><span class="p">)</span>

            <span class="k">if</span> <span class="s">&#39;k&#39;</span> <span class="ow">in</span> <span class="n">moments</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">g2</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">mu4p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_munp</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="o">*</span><span class="n">goodargs</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">mu</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                        <span class="n">mu</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_munp</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="n">goodargs</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">mu2</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                        <span class="n">mu2p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_munp</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="o">*</span><span class="n">goodargs</span><span class="p">)</span>
                        <span class="n">mu2</span> <span class="o">=</span> <span class="n">mu2p</span> <span class="o">-</span> <span class="n">mu</span> <span class="o">*</span> <span class="n">mu</span>
                    <span class="k">if</span> <span class="n">mu3</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                        <span class="n">mu3p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_munp</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="o">*</span><span class="n">goodargs</span><span class="p">)</span>
                        <span class="n">mu3</span> <span class="o">=</span> <span class="n">mu3p</span> <span class="o">-</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">mu</span> <span class="o">*</span> <span class="n">mu2</span> <span class="o">-</span> <span class="n">mu</span><span class="o">**</span><span class="mi">3</span>
                    <span class="n">mu4</span> <span class="o">=</span> <span class="n">mu4p</span> <span class="o">-</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">mu</span> <span class="o">*</span> <span class="n">mu3</span> <span class="o">-</span> <span class="mi">6</span> <span class="o">*</span> <span class="n">mu</span> <span class="o">*</span> <span class="n">mu</span> <span class="o">*</span> <span class="n">mu2</span> <span class="o">-</span> <span class="n">mu</span><span class="o">**</span><span class="mi">4</span>
                    <span class="n">g2</span> <span class="o">=</span> <span class="n">mu4</span> <span class="o">/</span> <span class="n">mu2</span><span class="o">**</span><span class="mf">2.0</span> <span class="o">-</span> <span class="mf">3.0</span>
                <span class="n">out0</span> <span class="o">=</span> <span class="n">default</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">place</span><span class="p">(</span><span class="n">out0</span><span class="p">,</span> <span class="n">cond</span><span class="p">,</span> <span class="n">g2</span><span class="p">)</span>
                <span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">out0</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c"># no valid args</span>
            <span class="n">output</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">moments</span><span class="p">:</span>
                <span class="n">out0</span> <span class="o">=</span> <span class="n">default</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">out0</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">output</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">output</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">entropy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Differential entropy of the RV.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        arg1, arg2, arg3,... : array_like</span>
<span class="sd">            The shape parameter(s) for the distribution (see docstring of the</span>
<span class="sd">            instance object for more information).</span>
<span class="sd">        loc : array_like, optional</span>
<span class="sd">            Location parameter (default=0).</span>
<span class="sd">        scale : array_like, optional  (continuous distributions only).</span>
<span class="sd">            Scale parameter (default=1).</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Entropy is defined base `e`:</span>

<span class="sd">        &gt;&gt;&gt; drv = rv_discrete(values=((0, 1), (0.5, 0.5)))</span>
<span class="sd">        &gt;&gt;&gt; np.allclose(drv.entropy(), np.log(2.0))</span>
<span class="sd">        True</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">args</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_args</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
        <span class="c"># NB: for discrete distributions scale=1 by construction in _parse_args</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">asarray</span><span class="p">,</span> <span class="n">args</span><span class="p">))</span>
        <span class="n">cond0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_argcheck</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">scale</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">loc</span> <span class="o">==</span> <span class="n">loc</span><span class="p">)</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="p">(</span><span class="n">cond0</span><span class="p">),</span> <span class="s">&#39;d&#39;</span><span class="p">)</span>
        <span class="n">place</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">cond0</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">badvalue</span><span class="p">)</span>
        <span class="n">goodargs</span> <span class="o">=</span> <span class="n">argsreduce</span><span class="p">(</span><span class="n">cond0</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="c"># I don&#39;t know when or why vecentropy got broken when numargs == 0</span>
        <span class="c"># 09.08.2013: is this still relevant? cf check_vecentropy test</span>
        <span class="c"># in tests/test_continuous_basic.py</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">numargs</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">place</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">cond0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_entropy</span><span class="p">()</span> <span class="o">+</span> <span class="n">log</span><span class="p">(</span><span class="n">scale</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">place</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">cond0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vecentropy</span><span class="p">(</span><span class="o">*</span><span class="n">goodargs</span><span class="p">)</span> <span class="o">+</span> <span class="n">log</span><span class="p">(</span><span class="n">scale</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">output</span>

    <span class="k">def</span> <span class="nf">moment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        n&#39;th order non-central moment of distribution.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n : int, n&gt;=1</span>
<span class="sd">            Order of moment.</span>
<span class="sd">        arg1, arg2, arg3,... : float</span>
<span class="sd">            The shape parameter(s) for the distribution (see docstring of the</span>
<span class="sd">            instance object for more information).</span>
<span class="sd">        kwds : keyword arguments, optional</span>
<span class="sd">            These can include &quot;loc&quot; and &quot;scale&quot;, as well as other keyword</span>
<span class="sd">            arguments relevant for a given distribution.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">args</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_args</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_argcheck</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">scale</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)):</span>
            <span class="k">return</span> <span class="n">nan</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">floor</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">!=</span> <span class="n">n</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Moment must be an integer.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Moment must be positive.&quot;</span><span class="p">)</span>
        <span class="n">mu</span><span class="p">,</span> <span class="n">mu2</span><span class="p">,</span> <span class="n">g1</span><span class="p">,</span> <span class="n">g2</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stats_has_moments</span><span class="p">:</span>
                <span class="n">mdict</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;moments&#39;</span><span class="p">:</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="s">&#39;m&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="s">&#39;v&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span> <span class="s">&#39;vs&#39;</span><span class="p">,</span> <span class="mi">4</span><span class="p">:</span> <span class="s">&#39;vk&#39;</span><span class="p">}[</span><span class="n">n</span><span class="p">]}</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">mdict</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">mu</span><span class="p">,</span> <span class="n">mu2</span><span class="p">,</span> <span class="n">g1</span><span class="p">,</span> <span class="n">g2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stats</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">mdict</span><span class="p">)</span>
        <span class="n">val</span> <span class="o">=</span> <span class="n">_moment_from_stats</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">mu2</span><span class="p">,</span> <span class="n">g1</span><span class="p">,</span> <span class="n">g2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_munp</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>

        <span class="c"># Convert to transformed  X = L + S*Y</span>
        <span class="c"># E[X^n] = E[(L+S*Y)^n] = L^n sum(comb(n, k)*(S/L)^k E[Y^k], k=0...n)</span>
        <span class="k">if</span> <span class="n">loc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">scale</span><span class="o">**</span><span class="n">n</span> <span class="o">*</span> <span class="n">val</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">fac</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">scale</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">loc</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="n">valk</span> <span class="o">=</span> <span class="n">_moment_from_stats</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">mu2</span><span class="p">,</span> <span class="n">g1</span><span class="p">,</span> <span class="n">g2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_munp</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>
                <span class="n">result</span> <span class="o">+=</span> <span class="n">comb</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">fac</span><span class="o">**</span><span class="n">k</span><span class="p">)</span> <span class="o">*</span> <span class="n">valk</span>
            <span class="n">result</span> <span class="o">+=</span> <span class="n">fac</span><span class="o">**</span><span class="n">n</span> <span class="o">*</span> <span class="n">val</span>
            <span class="k">return</span> <span class="n">result</span> <span class="o">*</span> <span class="n">loc</span><span class="o">**</span><span class="n">n</span>

    <span class="k">def</span> <span class="nf">median</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Median of the distribution.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        arg1, arg2, arg3,... : array_like</span>
<span class="sd">            The shape parameter(s) for the distribution (see docstring of the</span>
<span class="sd">            instance object for more information)</span>
<span class="sd">        loc : array_like, optional</span>
<span class="sd">            Location parameter, Default is 0.</span>
<span class="sd">        scale : array_like, optional</span>
<span class="sd">            Scale parameter, Default is 1.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        median : float</span>
<span class="sd">            The median of the distribution.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        stats.distributions.rv_discrete.ppf</span>
<span class="sd">            Inverse of the CDF</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">mean</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Mean of the distribution</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        arg1, arg2, arg3,... : array_like</span>
<span class="sd">            The shape parameter(s) for the distribution (see docstring of the</span>
<span class="sd">            instance object for more information)</span>
<span class="sd">        loc : array_like, optional</span>
<span class="sd">            location parameter (default=0)</span>
<span class="sd">        scale : array_like, optional</span>
<span class="sd">            scale parameter (default=1)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        mean : float</span>
<span class="sd">            the mean of the distribution</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kwds</span><span class="p">[</span><span class="s">&#39;moments&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;m&#39;</span>
        <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="n">res</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">res</span><span class="p">[()]</span>
        <span class="k">return</span> <span class="n">res</span>

    <span class="k">def</span> <span class="nf">var</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Variance of the distribution</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        arg1, arg2, arg3,... : array_like</span>
<span class="sd">            The shape parameter(s) for the distribution (see docstring of the</span>
<span class="sd">            instance object for more information)</span>
<span class="sd">        loc : array_like, optional</span>
<span class="sd">            location parameter (default=0)</span>
<span class="sd">        scale : array_like, optional</span>
<span class="sd">            scale parameter (default=1)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        var : float</span>
<span class="sd">            the variance of the distribution</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kwds</span><span class="p">[</span><span class="s">&#39;moments&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;v&#39;</span>
        <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="n">res</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">res</span><span class="p">[()]</span>
        <span class="k">return</span> <span class="n">res</span>

    <span class="k">def</span> <span class="nf">std</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Standard deviation of the distribution.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        arg1, arg2, arg3,... : array_like</span>
<span class="sd">            The shape parameter(s) for the distribution (see docstring of the</span>
<span class="sd">            instance object for more information)</span>
<span class="sd">        loc : array_like, optional</span>
<span class="sd">            location parameter (default=0)</span>
<span class="sd">        scale : array_like, optional</span>
<span class="sd">            scale parameter (default=1)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        std : float</span>
<span class="sd">            standard deviation of the distribution</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kwds</span><span class="p">[</span><span class="s">&#39;moments&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;v&#39;</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">res</span>

    <span class="k">def</span> <span class="nf">interval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Confidence interval with equal areas around the median.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        alpha : array_like of float</span>
<span class="sd">            Probability that an rv will be drawn from the returned range.</span>
<span class="sd">            Each value should be in the range [0, 1].</span>
<span class="sd">        arg1, arg2, ... : array_like</span>
<span class="sd">            The shape parameter(s) for the distribution (see docstring of the</span>
<span class="sd">            instance object for more information).</span>
<span class="sd">        loc : array_like, optional</span>
<span class="sd">            location parameter, Default is 0.</span>
<span class="sd">        scale : array_like, optional</span>
<span class="sd">            scale parameter, Default is 1.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        a, b : ndarray of float</span>
<span class="sd">            end-points of range that contain ``100 * alpha %`` of the rv&#39;s</span>
<span class="sd">            possible values.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">((</span><span class="n">alpha</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">alpha</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;alpha must be between 0 and 1 inclusive&quot;</span><span class="p">)</span>
        <span class="n">q1</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.0</span><span class="o">-</span><span class="n">alpha</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
        <span class="n">q2</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.0</span><span class="o">+</span><span class="n">alpha</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
        <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="n">q1</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
        <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="n">q2</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span>


<span class="c">##  continuous random variables: implement maybe later</span>
<span class="c">##</span>
<span class="c">##  hf  --- Hazard Function (PDF / SF)</span>
<span class="c">##  chf  --- Cumulative hazard function (-log(SF))</span>
<span class="c">##  psf --- Probability sparsity function (reciprocal of the pdf) in</span>
<span class="c">##                units of percent-point-function (as a function of q).</span>
<span class="c">##                Also, the derivative of the percent-point function.</span>

<span class="k">class</span> <span class="nc">rv_continuous</span><span class="p">(</span><span class="n">rv_generic</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A generic continuous random variable class meant for subclassing.</span>

<span class="sd">    `rv_continuous` is a base class to construct specific distribution classes</span>
<span class="sd">    and instances from for continuous random variables. It cannot be used</span>
<span class="sd">    directly as a distribution.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    momtype : int, optional</span>
<span class="sd">        The type of generic moment calculation to use: 0 for pdf, 1 (default)</span>
<span class="sd">        for ppf.</span>
<span class="sd">    a : float, optional</span>
<span class="sd">        Lower bound of the support of the distribution, default is minus</span>
<span class="sd">        infinity.</span>
<span class="sd">    b : float, optional</span>
<span class="sd">        Upper bound of the support of the distribution, default is plus</span>
<span class="sd">        infinity.</span>
<span class="sd">    xtol : float, optional</span>
<span class="sd">        The tolerance for fixed point calculation for generic ppf.</span>
<span class="sd">    badvalue : object, optional</span>
<span class="sd">        The value in a result arrays that indicates a value that for which</span>
<span class="sd">        some argument restriction is violated, default is np.nan.</span>
<span class="sd">    name : str, optional</span>
<span class="sd">        The name of the instance. This string is used to construct the default</span>
<span class="sd">        example for distributions.</span>
<span class="sd">    longname : str, optional</span>
<span class="sd">        This string is used as part of the first line of the docstring returned</span>
<span class="sd">        when a subclass has no docstring of its own. Note: `longname` exists</span>
<span class="sd">        for backwards compatibility, do not use for new subclasses.</span>
<span class="sd">    shapes : str, optional</span>
<span class="sd">        The shape of the distribution. For example ``&quot;m, n&quot;`` for a</span>
<span class="sd">        distribution that takes two integers as the two shape arguments for all</span>
<span class="sd">        its methods.</span>
<span class="sd">    extradoc :  str, optional, deprecated</span>
<span class="sd">        This string is used as the last part of the docstring returned when a</span>
<span class="sd">        subclass has no docstring of its own. Note: `extradoc` exists for</span>
<span class="sd">        backwards compatibility, do not use for new subclasses.</span>

<span class="sd">    Methods</span>
<span class="sd">    -------</span>
<span class="sd">    ``rvs(&lt;shape(s)&gt;, loc=0, scale=1, size=1)``</span>
<span class="sd">        random variates</span>

<span class="sd">    ``pdf(x, &lt;shape(s)&gt;, loc=0, scale=1)``</span>
<span class="sd">        probability density function</span>

<span class="sd">    ``logpdf(x, &lt;shape(s)&gt;, loc=0, scale=1)``</span>
<span class="sd">        log of the probability density function</span>

<span class="sd">    ``cdf(x, &lt;shape(s)&gt;, loc=0, scale=1)``</span>
<span class="sd">        cumulative density function</span>

<span class="sd">    ``logcdf(x, &lt;shape(s)&gt;, loc=0, scale=1)``</span>
<span class="sd">        log of the cumulative density function</span>

<span class="sd">    ``sf(x, &lt;shape(s)&gt;, loc=0, scale=1)``</span>
<span class="sd">        survival function (1-cdf --- sometimes more accurate)</span>

<span class="sd">    ``logsf(x, &lt;shape(s)&gt;, loc=0, scale=1)``</span>
<span class="sd">        log of the survival function</span>

<span class="sd">    ``ppf(q, &lt;shape(s)&gt;, loc=0, scale=1)``</span>
<span class="sd">      percent point function (inverse of cdf --- quantiles)</span>

<span class="sd">    ``isf(q, &lt;shape(s)&gt;, loc=0, scale=1)``</span>
<span class="sd">        inverse survival function (inverse of sf)</span>

<span class="sd">    ``moment(n, &lt;shape(s)&gt;, loc=0, scale=1)``</span>
<span class="sd">        non-central n-th moment of the distribution.  May not work for array</span>
<span class="sd">        arguments.</span>

<span class="sd">    ``stats(&lt;shape(s)&gt;, loc=0, scale=1, moments=&#39;mv&#39;)``</span>
<span class="sd">        mean(&#39;m&#39;), variance(&#39;v&#39;), skew(&#39;s&#39;), and/or kurtosis(&#39;k&#39;)</span>

<span class="sd">    ``entropy(&lt;shape(s)&gt;, loc=0, scale=1)``</span>
<span class="sd">        (differential) entropy of the RV.</span>

<span class="sd">    ``fit(data, &lt;shape(s)&gt;, loc=0, scale=1)``</span>
<span class="sd">        Parameter estimates for generic data</span>

<span class="sd">    ``expect(func=None, args=(), loc=0, scale=1, lb=None, ub=None, conditional=False, **kwds)``</span>
<span class="sd">        Expected value of a function with respect to the distribution.</span>
<span class="sd">        Additional kwd arguments passed to integrate.quad</span>

<span class="sd">    ``median(&lt;shape(s)&gt;, loc=0, scale=1)``</span>
<span class="sd">        Median of the distribution.</span>

<span class="sd">    ``mean(&lt;shape(s)&gt;, loc=0, scale=1)``</span>
<span class="sd">        Mean of the distribution.</span>

<span class="sd">    ``std(&lt;shape(s)&gt;, loc=0, scale=1)``</span>
<span class="sd">        Standard deviation of the distribution.</span>

<span class="sd">    ``var(&lt;shape(s)&gt;, loc=0, scale=1)``</span>
<span class="sd">        Variance of the distribution.</span>

<span class="sd">    ``interval(alpha, &lt;shape(s)&gt;, loc=0, scale=1)``</span>
<span class="sd">        Interval that with `alpha` percent probability contains a random</span>
<span class="sd">        realization of this distribution.</span>

<span class="sd">    ``__call__(&lt;shape(s)&gt;, loc=0, scale=1)``</span>
<span class="sd">        Calling a distribution instance creates a frozen RV object with the</span>
<span class="sd">        same methods but holding the given shape, location, and scale fixed.</span>
<span class="sd">        See Notes section.</span>

<span class="sd">    **Parameters for Methods**</span>

<span class="sd">    x : array_like</span>
<span class="sd">        quantiles</span>
<span class="sd">    q : array_like</span>
<span class="sd">        lower or upper tail probability</span>
<span class="sd">    &lt;shape(s)&gt; : array_like</span>
<span class="sd">        shape parameters</span>
<span class="sd">    loc : array_like, optional</span>
<span class="sd">        location parameter (default=0)</span>
<span class="sd">    scale : array_like, optional</span>
<span class="sd">        scale parameter (default=1)</span>
<span class="sd">    size : int or tuple of ints, optional</span>
<span class="sd">        shape of random variates (default computed from input arguments )</span>
<span class="sd">    moments : string, optional</span>
<span class="sd">        composed of letters [&#39;mvsk&#39;] specifying which moments to compute where</span>
<span class="sd">        &#39;m&#39; = mean, &#39;v&#39; = variance, &#39;s&#39; = (Fisher&#39;s) skew and</span>
<span class="sd">        &#39;k&#39; = (Fisher&#39;s) kurtosis. (default=&#39;mv&#39;)</span>
<span class="sd">    n : int</span>
<span class="sd">        order of moment to calculate in method moments</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>

<span class="sd">    **Methods that can be overwritten by subclasses**</span>
<span class="sd">    ::</span>

<span class="sd">      _rvs</span>
<span class="sd">      _pdf</span>
<span class="sd">      _cdf</span>
<span class="sd">      _sf</span>
<span class="sd">      _ppf</span>
<span class="sd">      _isf</span>
<span class="sd">      _stats</span>
<span class="sd">      _munp</span>
<span class="sd">      _entropy</span>
<span class="sd">      _argcheck</span>

<span class="sd">    There are additional (internal and private) generic methods that can</span>
<span class="sd">    be useful for cross-checking and for debugging, but might work in all</span>
<span class="sd">    cases when directly called.</span>

<span class="sd">    **Frozen Distribution**</span>

<span class="sd">    Alternatively, the object may be called (as a function) to fix the shape,</span>
<span class="sd">    location, and scale parameters returning a &quot;frozen&quot; continuous RV object:</span>

<span class="sd">    rv = generic(&lt;shape(s)&gt;, loc=0, scale=1)</span>
<span class="sd">        frozen RV object with the same methods but holding the given shape,</span>
<span class="sd">        location, and scale fixed</span>

<span class="sd">    **Subclassing**</span>

<span class="sd">    New random variables can be defined by subclassing rv_continuous class</span>
<span class="sd">    and re-defining at least the ``_pdf`` or the ``_cdf`` method (normalized</span>
<span class="sd">    to location 0 and scale 1) which will be given clean arguments (in between</span>
<span class="sd">    a and b) and passing the argument check method.</span>

<span class="sd">    If positive argument checking is not correct for your RV</span>
<span class="sd">    then you will also need to re-define the ``_argcheck`` method.</span>

<span class="sd">    Correct, but potentially slow defaults exist for the remaining</span>
<span class="sd">    methods but for speed and/or accuracy you can over-ride::</span>

<span class="sd">      _logpdf, _cdf, _logcdf, _ppf, _rvs, _isf, _sf, _logsf</span>

<span class="sd">    Rarely would you override ``_isf``, ``_sf`` or ``_logsf``, but you could.</span>

<span class="sd">    Statistics are computed using numerical integration by default.</span>
<span class="sd">    For speed you can redefine this using ``_stats``:</span>

<span class="sd">     - take shape parameters and return mu, mu2, g1, g2</span>
<span class="sd">     - If you can&#39;t compute one of these, return it as None</span>
<span class="sd">     - Can also be defined with a keyword argument ``moments=&lt;str&gt;``,</span>
<span class="sd">       where &lt;str&gt; is a string composed of &#39;m&#39;, &#39;v&#39;, &#39;s&#39;,</span>
<span class="sd">       and/or &#39;k&#39;.  Only the components appearing in string</span>
<span class="sd">       should be computed and returned in the order &#39;m&#39;, &#39;v&#39;,</span>
<span class="sd">       &#39;s&#39;, or &#39;k&#39;  with missing values returned as None.</span>

<span class="sd">    Alternatively, you can override ``_munp``, which takes n and shape</span>
<span class="sd">    parameters and returns the nth non-central moment of the distribution.</span>

<span class="sd">    A note on ``shapes``: subclasses need not specify them explicitly. In this</span>
<span class="sd">    case, the `shapes` will be automatically deduced from the signatures of the</span>
<span class="sd">    overridden methods.</span>
<span class="sd">    If, for some reason, you prefer to avoid relying on introspection, you can</span>
<span class="sd">    specify ``shapes`` explicitly as an argument to the instance constructor.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    To create a new Gaussian distribution, we would do the following::</span>

<span class="sd">        class gaussian_gen(rv_continuous):</span>
<span class="sd">            &quot;Gaussian distribution&quot;</span>
<span class="sd">            def _pdf(self, x):</span>
<span class="sd">                ...</span>
<span class="sd">            ...</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">momtype</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">xtol</span><span class="o">=</span><span class="mf">1e-14</span><span class="p">,</span>
                 <span class="n">badvalue</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">longname</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="n">shapes</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">extradoc</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">rv_continuous</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span>

        <span class="c"># save the ctor parameters, cf generic freeze</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ctor_param</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="n">momtype</span><span class="o">=</span><span class="n">momtype</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="n">b</span><span class="p">,</span> <span class="n">xtol</span><span class="o">=</span><span class="n">xtol</span><span class="p">,</span>
            <span class="n">badvalue</span><span class="o">=</span><span class="n">badvalue</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">longname</span><span class="o">=</span><span class="n">longname</span><span class="p">,</span>
            <span class="n">shapes</span><span class="o">=</span><span class="n">shapes</span><span class="p">,</span> <span class="n">extradoc</span><span class="o">=</span><span class="n">extradoc</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">badvalue</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">badvalue</span> <span class="o">=</span> <span class="n">nan</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="s">&#39;Distribution&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">badvalue</span> <span class="o">=</span> <span class="n">badvalue</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="n">a</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">b</span> <span class="o">=</span> <span class="n">b</span>
        <span class="k">if</span> <span class="n">a</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="o">-</span><span class="n">inf</span>
        <span class="k">if</span> <span class="n">b</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">b</span> <span class="o">=</span> <span class="n">inf</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xtol</span> <span class="o">=</span> <span class="n">xtol</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_size</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">moment_type</span> <span class="o">=</span> <span class="n">momtype</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shapes</span> <span class="o">=</span> <span class="n">shapes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_construct_argparser</span><span class="p">(</span><span class="n">meths_to_inspect</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_pdf</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cdf</span><span class="p">],</span>
                                  <span class="n">locscale_in</span><span class="o">=</span><span class="s">&#39;loc=0, scale=1&#39;</span><span class="p">,</span>
                                  <span class="n">locscale_out</span><span class="o">=</span><span class="s">&#39;loc, scale&#39;</span><span class="p">)</span>

        <span class="c"># nin correction</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ppfvec</span> <span class="o">=</span> <span class="n">vectorize</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ppf_single</span><span class="p">,</span> <span class="n">otypes</span><span class="o">=</span><span class="s">&#39;d&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ppfvec</span><span class="o">.</span><span class="n">nin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">numargs</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vecentropy</span> <span class="o">=</span> <span class="n">vectorize</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_entropy</span><span class="p">,</span> <span class="n">otypes</span><span class="o">=</span><span class="s">&#39;d&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cdfvec</span> <span class="o">=</span> <span class="n">vectorize</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cdf_single</span><span class="p">,</span> <span class="n">otypes</span><span class="o">=</span><span class="s">&#39;d&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cdfvec</span><span class="o">.</span><span class="n">nin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">numargs</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="c"># backwards compat.  these were removed in 0.14.0, put back but</span>
        <span class="c"># deprecated in 0.14.1:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vecfunc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deprecate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ppfvec</span><span class="p">,</span> <span class="s">&quot;vecfunc&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">veccdf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deprecate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cdfvec</span><span class="p">,</span> <span class="s">&quot;veccdf&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">extradoc</span> <span class="o">=</span> <span class="n">extradoc</span>
        <span class="k">if</span> <span class="n">momtype</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">generic_moment</span> <span class="o">=</span> <span class="n">vectorize</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mom0_sc</span><span class="p">,</span> <span class="n">otypes</span><span class="o">=</span><span class="s">&#39;d&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">generic_moment</span> <span class="o">=</span> <span class="n">vectorize</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mom1_sc</span><span class="p">,</span> <span class="n">otypes</span><span class="o">=</span><span class="s">&#39;d&#39;</span><span class="p">)</span>
        <span class="c"># Because of the *args argument of _mom0_sc, vectorize cannot count the</span>
        <span class="c"># number of arguments correctly.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">generic_moment</span><span class="o">.</span><span class="n">nin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">numargs</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">longname</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&#39;aeiouAEIOU&#39;</span><span class="p">]:</span>
                <span class="n">hstr</span> <span class="o">=</span> <span class="s">&quot;An &quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">hstr</span> <span class="o">=</span> <span class="s">&quot;A &quot;</span>
            <span class="n">longname</span> <span class="o">=</span> <span class="n">hstr</span> <span class="o">+</span> <span class="n">name</span>

        <span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">optimize</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c"># Skip adding docstrings if interpreter is run with -OO</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__doc__</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_construct_default_doc</span><span class="p">(</span><span class="n">longname</span><span class="o">=</span><span class="n">longname</span><span class="p">,</span>
                                            <span class="n">extradoc</span><span class="o">=</span><span class="n">extradoc</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dct</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">distcont</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_construct_doc</span><span class="p">(</span><span class="n">docdict</span><span class="p">,</span> <span class="n">dct</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_construct_default_doc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">longname</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">extradoc</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Construct instance docstring from the default template.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">longname</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">longname</span> <span class="o">=</span> <span class="s">&#39;A&#39;</span>
        <span class="k">if</span> <span class="n">extradoc</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">extradoc</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>
        <span class="k">if</span> <span class="n">extradoc</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\n\n</span><span class="s">&#39;</span><span class="p">):</span>
            <span class="n">extradoc</span> <span class="o">=</span> <span class="n">extradoc</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__doc__</span> <span class="o">=</span> <span class="s">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s">&#39;</span><span class="si">%s</span><span class="s"> continuous random variable.&#39;</span> <span class="o">%</span> <span class="n">longname</span><span class="p">,</span>
                                <span class="s">&#39;</span><span class="se">\n\n</span><span class="si">%(before_notes)s</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">,</span> <span class="n">docheaders</span><span class="p">[</span><span class="s">&#39;notes&#39;</span><span class="p">],</span>
                                <span class="n">extradoc</span><span class="p">,</span> <span class="s">&#39;</span><span class="se">\n</span><span class="si">%(example)s</span><span class="s">&#39;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_construct_doc</span><span class="p">(</span><span class="n">docdict</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_ppf_to_solve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">)</span><span class="o">+</span><span class="n">args</span><span class="p">)</span><span class="o">-</span><span class="n">q</span>

    <span class="k">def</span> <span class="nf">_ppf_single</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="n">left</span> <span class="o">=</span> <span class="n">right</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span> <span class="o">&gt;</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">:</span>
            <span class="n">left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">:</span>
            <span class="n">right</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span>

        <span class="n">factor</span> <span class="o">=</span> <span class="mf">10.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">left</span><span class="p">:</span>  <span class="c"># i.e. self.a = -inf</span>
            <span class="n">left</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.</span><span class="o">*</span><span class="n">factor</span>
            <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ppf_to_solve</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">0.</span><span class="p">:</span>
                <span class="n">right</span> <span class="o">=</span> <span class="n">left</span>
                <span class="n">left</span> <span class="o">*=</span> <span class="n">factor</span>
            <span class="c"># left is now such that cdf(left) &lt; q</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">right</span><span class="p">:</span>  <span class="c"># i.e. self.b = inf</span>
            <span class="n">right</span> <span class="o">=</span> <span class="n">factor</span>
            <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ppf_to_solve</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">0.</span><span class="p">:</span>
                <span class="n">left</span> <span class="o">=</span> <span class="n">right</span>
                <span class="n">right</span> <span class="o">*=</span> <span class="n">factor</span>
            <span class="c"># right is now such that cdf(right) &gt; q</span>

        <span class="k">return</span> <span class="n">optimize</span><span class="o">.</span><span class="n">brentq</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ppf_to_solve</span><span class="p">,</span>
                               <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">q</span><span class="p">,)</span><span class="o">+</span><span class="n">args</span><span class="p">,</span> <span class="n">xtol</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">xtol</span><span class="p">)</span>

    <span class="c"># moment from definition</span>
    <span class="k">def</span> <span class="nf">_mom_integ0</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">x</span><span class="o">**</span><span class="n">m</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_mom0_sc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">integrate</span><span class="o">.</span><span class="n">quad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mom_integ0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">,</span>
                              <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">m</span><span class="p">,)</span><span class="o">+</span><span class="n">args</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c"># moment calculated using ppf</span>
    <span class="k">def</span> <span class="nf">_mom_integ1</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">))</span><span class="o">**</span><span class="n">m</span>

    <span class="k">def</span> <span class="nf">_mom1_sc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">integrate</span><span class="o">.</span><span class="n">quad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mom_integ1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">m</span><span class="p">,)</span><span class="o">+</span><span class="n">args</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_pdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">derivative</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cdf</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">dx</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="n">args</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>

    <span class="c">## Could also define any of these</span>
    <span class="k">def</span> <span class="nf">_logpdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_pdf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_cdf_single</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">integrate</span><span class="o">.</span><span class="n">quad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_pdf</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="n">args</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_cdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cdfvec</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="c">## generic _argcheck, _logcdf, _sf, _logsf, _ppf, _isf, _rvs are defined</span>
    <span class="c">## in rv_generic</span>

    <span class="k">def</span> <span class="nf">pdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Probability density function at x of the given RV.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : array_like</span>
<span class="sd">            quantiles</span>
<span class="sd">        arg1, arg2, arg3,... : array_like</span>
<span class="sd">            The shape parameter(s) for the distribution (see docstring of the</span>
<span class="sd">            instance object for more information)</span>
<span class="sd">        loc : array_like, optional</span>
<span class="sd">            location parameter (default=0)</span>
<span class="sd">        scale : array_like, optional</span>
<span class="sd">            scale parameter (default=1)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pdf : ndarray</span>
<span class="sd">            Probability density function evaluated at x</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">args</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_args</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">scale</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">asarray</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="p">))</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">asarray</span><span class="p">,</span> <span class="n">args</span><span class="p">))</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">((</span><span class="n">x</span><span class="o">-</span><span class="n">loc</span><span class="p">)</span><span class="o">*</span><span class="mf">1.0</span><span class="o">/</span><span class="n">scale</span><span class="p">)</span>
        <span class="n">cond0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_argcheck</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">scale</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">cond1</span> <span class="o">=</span> <span class="p">(</span><span class="n">scale</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">x</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">)</span>
        <span class="n">cond</span> <span class="o">=</span> <span class="n">cond0</span> <span class="o">&amp;</span> <span class="n">cond1</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="p">(</span><span class="n">cond</span><span class="p">),</span> <span class="s">&#39;d&#39;</span><span class="p">)</span>
        <span class="n">putmask</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">cond0</span><span class="p">)</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">badvalue</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">cond</span><span class="p">):</span>
            <span class="n">goodargs</span> <span class="o">=</span> <span class="n">argsreduce</span><span class="p">(</span><span class="n">cond</span><span class="p">,</span> <span class="o">*</span><span class="p">((</span><span class="n">x</span><span class="p">,)</span><span class="o">+</span><span class="n">args</span><span class="o">+</span><span class="p">(</span><span class="n">scale</span><span class="p">,)))</span>
            <span class="n">scale</span><span class="p">,</span> <span class="n">goodargs</span> <span class="o">=</span> <span class="n">goodargs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">goodargs</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">place</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">cond</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pdf</span><span class="p">(</span><span class="o">*</span><span class="n">goodargs</span><span class="p">)</span> <span class="o">/</span> <span class="n">scale</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">output</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">output</span><span class="p">[()]</span>
        <span class="k">return</span> <span class="n">output</span>

    <span class="k">def</span> <span class="nf">logpdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Log of the probability density function at x of the given RV.</span>

<span class="sd">        This uses a more numerically accurate calculation if available.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : array_like</span>
<span class="sd">            quantiles</span>
<span class="sd">        arg1, arg2, arg3,... : array_like</span>
<span class="sd">            The shape parameter(s) for the distribution (see docstring of the</span>
<span class="sd">            instance object for more information)</span>
<span class="sd">        loc : array_like, optional</span>
<span class="sd">            location parameter (default=0)</span>
<span class="sd">        scale : array_like, optional</span>
<span class="sd">            scale parameter (default=1)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        logpdf : array_like</span>
<span class="sd">            Log of the probability density function evaluated at x</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">args</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_args</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">scale</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">asarray</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="p">))</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">asarray</span><span class="p">,</span> <span class="n">args</span><span class="p">))</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">((</span><span class="n">x</span><span class="o">-</span><span class="n">loc</span><span class="p">)</span><span class="o">*</span><span class="mf">1.0</span><span class="o">/</span><span class="n">scale</span><span class="p">)</span>
        <span class="n">cond0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_argcheck</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">scale</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">cond1</span> <span class="o">=</span> <span class="p">(</span><span class="n">scale</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">x</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">)</span>
        <span class="n">cond</span> <span class="o">=</span> <span class="n">cond0</span> <span class="o">&amp;</span> <span class="n">cond1</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">empty</span><span class="p">(</span><span class="n">shape</span><span class="p">(</span><span class="n">cond</span><span class="p">),</span> <span class="s">&#39;d&#39;</span><span class="p">)</span>
        <span class="n">output</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">NINF</span><span class="p">)</span>
        <span class="n">putmask</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">cond0</span><span class="p">)</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">badvalue</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">cond</span><span class="p">):</span>
            <span class="n">goodargs</span> <span class="o">=</span> <span class="n">argsreduce</span><span class="p">(</span><span class="n">cond</span><span class="p">,</span> <span class="o">*</span><span class="p">((</span><span class="n">x</span><span class="p">,)</span><span class="o">+</span><span class="n">args</span><span class="o">+</span><span class="p">(</span><span class="n">scale</span><span class="p">,)))</span>
            <span class="n">scale</span><span class="p">,</span> <span class="n">goodargs</span> <span class="o">=</span> <span class="n">goodargs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">goodargs</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">place</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">cond</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_logpdf</span><span class="p">(</span><span class="o">*</span><span class="n">goodargs</span><span class="p">)</span> <span class="o">-</span> <span class="n">log</span><span class="p">(</span><span class="n">scale</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">output</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">output</span><span class="p">[()]</span>
        <span class="k">return</span> <span class="n">output</span>

    <span class="k">def</span> <span class="nf">cdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Cumulative distribution function of the given RV.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : array_like</span>
<span class="sd">            quantiles</span>
<span class="sd">        arg1, arg2, arg3,... : array_like</span>
<span class="sd">            The shape parameter(s) for the distribution (see docstring of the</span>
<span class="sd">            instance object for more information)</span>
<span class="sd">        loc : array_like, optional</span>
<span class="sd">            location parameter (default=0)</span>
<span class="sd">        scale : array_like, optional</span>
<span class="sd">            scale parameter (default=1)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        cdf : ndarray</span>
<span class="sd">            Cumulative distribution function evaluated at `x`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">args</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_args</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">scale</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">asarray</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="p">))</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">asarray</span><span class="p">,</span> <span class="n">args</span><span class="p">))</span>
        <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">loc</span><span class="p">)</span><span class="o">*</span><span class="mf">1.0</span><span class="o">/</span><span class="n">scale</span>
        <span class="n">cond0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_argcheck</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">scale</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">cond1</span> <span class="o">=</span> <span class="p">(</span><span class="n">scale</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">)</span>
        <span class="n">cond2</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">cond0</span>
        <span class="n">cond</span> <span class="o">=</span> <span class="n">cond0</span> <span class="o">&amp;</span> <span class="n">cond1</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="p">(</span><span class="n">cond</span><span class="p">),</span> <span class="s">&#39;d&#39;</span><span class="p">)</span>
        <span class="n">place</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">cond0</span><span class="p">)</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">badvalue</span><span class="p">)</span>
        <span class="n">place</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">cond2</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">cond</span><span class="p">):</span>  <span class="c"># call only if at least 1 entry</span>
            <span class="n">goodargs</span> <span class="o">=</span> <span class="n">argsreduce</span><span class="p">(</span><span class="n">cond</span><span class="p">,</span> <span class="o">*</span><span class="p">((</span><span class="n">x</span><span class="p">,)</span><span class="o">+</span><span class="n">args</span><span class="p">))</span>
            <span class="n">place</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">cond</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cdf</span><span class="p">(</span><span class="o">*</span><span class="n">goodargs</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">output</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">output</span><span class="p">[()]</span>
        <span class="k">return</span> <span class="n">output</span>

    <span class="k">def</span> <span class="nf">logcdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Log of the cumulative distribution function at x of the given RV.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : array_like</span>
<span class="sd">            quantiles</span>
<span class="sd">        arg1, arg2, arg3,... : array_like</span>
<span class="sd">            The shape parameter(s) for the distribution (see docstring of the</span>
<span class="sd">            instance object for more information)</span>
<span class="sd">        loc : array_like, optional</span>
<span class="sd">            location parameter (default=0)</span>
<span class="sd">        scale : array_like, optional</span>
<span class="sd">            scale parameter (default=1)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        logcdf : array_like</span>
<span class="sd">            Log of the cumulative distribution function evaluated at x</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">args</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_args</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">scale</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">asarray</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="p">))</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">asarray</span><span class="p">,</span> <span class="n">args</span><span class="p">))</span>
        <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">loc</span><span class="p">)</span><span class="o">*</span><span class="mf">1.0</span><span class="o">/</span><span class="n">scale</span>
        <span class="n">cond0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_argcheck</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">scale</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">cond1</span> <span class="o">=</span> <span class="p">(</span><span class="n">scale</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">)</span>
        <span class="n">cond2</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">cond0</span>
        <span class="n">cond</span> <span class="o">=</span> <span class="n">cond0</span> <span class="o">&amp;</span> <span class="n">cond1</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">empty</span><span class="p">(</span><span class="n">shape</span><span class="p">(</span><span class="n">cond</span><span class="p">),</span> <span class="s">&#39;d&#39;</span><span class="p">)</span>
        <span class="n">output</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">NINF</span><span class="p">)</span>
        <span class="n">place</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">cond0</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">cond1</span> <span class="o">==</span> <span class="n">cond1</span><span class="p">)</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">badvalue</span><span class="p">)</span>
        <span class="n">place</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">cond2</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">cond</span><span class="p">):</span>  <span class="c"># call only if at least 1 entry</span>
            <span class="n">goodargs</span> <span class="o">=</span> <span class="n">argsreduce</span><span class="p">(</span><span class="n">cond</span><span class="p">,</span> <span class="o">*</span><span class="p">((</span><span class="n">x</span><span class="p">,)</span><span class="o">+</span><span class="n">args</span><span class="p">))</span>
            <span class="n">place</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">cond</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_logcdf</span><span class="p">(</span><span class="o">*</span><span class="n">goodargs</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">output</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">output</span><span class="p">[()]</span>
        <span class="k">return</span> <span class="n">output</span>

    <span class="k">def</span> <span class="nf">sf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Survival function (1-cdf) at x of the given RV.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : array_like</span>
<span class="sd">            quantiles</span>
<span class="sd">        arg1, arg2, arg3,... : array_like</span>
<span class="sd">            The shape parameter(s) for the distribution (see docstring of the</span>
<span class="sd">            instance object for more information)</span>
<span class="sd">        loc : array_like, optional</span>
<span class="sd">            location parameter (default=0)</span>
<span class="sd">        scale : array_like, optional</span>
<span class="sd">            scale parameter (default=1)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        sf : array_like</span>
<span class="sd">            Survival function evaluated at x</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">args</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_args</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">scale</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">asarray</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="p">))</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">asarray</span><span class="p">,</span> <span class="n">args</span><span class="p">))</span>
        <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">loc</span><span class="p">)</span><span class="o">*</span><span class="mf">1.0</span><span class="o">/</span><span class="n">scale</span>
        <span class="n">cond0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_argcheck</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">scale</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">cond1</span> <span class="o">=</span> <span class="p">(</span><span class="n">scale</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">)</span>
        <span class="n">cond2</span> <span class="o">=</span> <span class="n">cond0</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">x</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">)</span>
        <span class="n">cond</span> <span class="o">=</span> <span class="n">cond0</span> <span class="o">&amp;</span> <span class="n">cond1</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="p">(</span><span class="n">cond</span><span class="p">),</span> <span class="s">&#39;d&#39;</span><span class="p">)</span>
        <span class="n">place</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">cond0</span><span class="p">)</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">badvalue</span><span class="p">)</span>
        <span class="n">place</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">cond2</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">cond</span><span class="p">):</span>
            <span class="n">goodargs</span> <span class="o">=</span> <span class="n">argsreduce</span><span class="p">(</span><span class="n">cond</span><span class="p">,</span> <span class="o">*</span><span class="p">((</span><span class="n">x</span><span class="p">,)</span><span class="o">+</span><span class="n">args</span><span class="p">))</span>
            <span class="n">place</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">cond</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sf</span><span class="p">(</span><span class="o">*</span><span class="n">goodargs</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">output</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">output</span><span class="p">[()]</span>
        <span class="k">return</span> <span class="n">output</span>

    <span class="k">def</span> <span class="nf">logsf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Log of the survival function of the given RV.</span>

<span class="sd">        Returns the log of the &quot;survival function,&quot; defined as (1 - `cdf`),</span>
<span class="sd">        evaluated at `x`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : array_like</span>
<span class="sd">            quantiles</span>
<span class="sd">        arg1, arg2, arg3,... : array_like</span>
<span class="sd">            The shape parameter(s) for the distribution (see docstring of the</span>
<span class="sd">            instance object for more information)</span>
<span class="sd">        loc : array_like, optional</span>
<span class="sd">            location parameter (default=0)</span>
<span class="sd">        scale : array_like, optional</span>
<span class="sd">            scale parameter (default=1)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        logsf : ndarray</span>
<span class="sd">            Log of the survival function evaluated at `x`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">args</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_args</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">scale</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">asarray</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="p">))</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">asarray</span><span class="p">,</span> <span class="n">args</span><span class="p">))</span>
        <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">loc</span><span class="p">)</span><span class="o">*</span><span class="mf">1.0</span><span class="o">/</span><span class="n">scale</span>
        <span class="n">cond0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_argcheck</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">scale</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">cond1</span> <span class="o">=</span> <span class="p">(</span><span class="n">scale</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">)</span>
        <span class="n">cond2</span> <span class="o">=</span> <span class="n">cond0</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">x</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">)</span>
        <span class="n">cond</span> <span class="o">=</span> <span class="n">cond0</span> <span class="o">&amp;</span> <span class="n">cond1</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">empty</span><span class="p">(</span><span class="n">shape</span><span class="p">(</span><span class="n">cond</span><span class="p">),</span> <span class="s">&#39;d&#39;</span><span class="p">)</span>
        <span class="n">output</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">NINF</span><span class="p">)</span>
        <span class="n">place</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">cond0</span><span class="p">)</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">badvalue</span><span class="p">)</span>
        <span class="n">place</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">cond2</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">cond</span><span class="p">):</span>
            <span class="n">goodargs</span> <span class="o">=</span> <span class="n">argsreduce</span><span class="p">(</span><span class="n">cond</span><span class="p">,</span> <span class="o">*</span><span class="p">((</span><span class="n">x</span><span class="p">,)</span><span class="o">+</span><span class="n">args</span><span class="p">))</span>
            <span class="n">place</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">cond</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_logsf</span><span class="p">(</span><span class="o">*</span><span class="n">goodargs</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">output</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">output</span><span class="p">[()]</span>
        <span class="k">return</span> <span class="n">output</span>

    <span class="k">def</span> <span class="nf">ppf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Percent point function (inverse of cdf) at q of the given RV.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        q : array_like</span>
<span class="sd">            lower tail probability</span>
<span class="sd">        arg1, arg2, arg3,... : array_like</span>
<span class="sd">            The shape parameter(s) for the distribution (see docstring of the</span>
<span class="sd">            instance object for more information)</span>
<span class="sd">        loc : array_like, optional</span>
<span class="sd">            location parameter (default=0)</span>
<span class="sd">        scale : array_like, optional</span>
<span class="sd">            scale parameter (default=1)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        x : array_like</span>
<span class="sd">            quantile corresponding to the lower tail probability q.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">args</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_args</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
        <span class="n">q</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">scale</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">asarray</span><span class="p">,</span> <span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="p">))</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">asarray</span><span class="p">,</span> <span class="n">args</span><span class="p">))</span>
        <span class="n">cond0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_argcheck</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">scale</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">loc</span> <span class="o">==</span> <span class="n">loc</span><span class="p">)</span>
        <span class="n">cond1</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;</span> <span class="n">q</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">q</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">cond2</span> <span class="o">=</span> <span class="n">cond0</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">q</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">cond3</span> <span class="o">=</span> <span class="n">cond0</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">q</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">cond</span> <span class="o">=</span> <span class="n">cond0</span> <span class="o">&amp;</span> <span class="n">cond1</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">valarray</span><span class="p">(</span><span class="n">shape</span><span class="p">(</span><span class="n">cond</span><span class="p">),</span> <span class="n">value</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">badvalue</span><span class="p">)</span>

        <span class="n">lower_bound</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span> <span class="o">*</span> <span class="n">scale</span> <span class="o">+</span> <span class="n">loc</span>
        <span class="n">upper_bound</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span> <span class="o">*</span> <span class="n">scale</span> <span class="o">+</span> <span class="n">loc</span>
        <span class="n">place</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">cond2</span><span class="p">,</span> <span class="n">argsreduce</span><span class="p">(</span><span class="n">cond2</span><span class="p">,</span> <span class="n">lower_bound</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">place</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">cond3</span><span class="p">,</span> <span class="n">argsreduce</span><span class="p">(</span><span class="n">cond3</span><span class="p">,</span> <span class="n">upper_bound</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>

        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">cond</span><span class="p">):</span>  <span class="c"># call only if at least 1 entry</span>
            <span class="n">goodargs</span> <span class="o">=</span> <span class="n">argsreduce</span><span class="p">(</span><span class="n">cond</span><span class="p">,</span> <span class="o">*</span><span class="p">((</span><span class="n">q</span><span class="p">,)</span><span class="o">+</span><span class="n">args</span><span class="o">+</span><span class="p">(</span><span class="n">scale</span><span class="p">,</span> <span class="n">loc</span><span class="p">)))</span>
            <span class="n">scale</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">goodargs</span> <span class="o">=</span> <span class="n">goodargs</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="n">goodargs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">goodargs</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">place</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">cond</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ppf</span><span class="p">(</span><span class="o">*</span><span class="n">goodargs</span><span class="p">)</span> <span class="o">*</span> <span class="n">scale</span> <span class="o">+</span> <span class="n">loc</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">output</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">output</span><span class="p">[()]</span>
        <span class="k">return</span> <span class="n">output</span>

    <span class="k">def</span> <span class="nf">isf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Inverse survival function at q of the given RV.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        q : array_like</span>
<span class="sd">            upper tail probability</span>
<span class="sd">        arg1, arg2, arg3,... : array_like</span>
<span class="sd">            The shape parameter(s) for the distribution (see docstring of the</span>
<span class="sd">            instance object for more information)</span>
<span class="sd">        loc : array_like, optional</span>
<span class="sd">            location parameter (default=0)</span>
<span class="sd">        scale : array_like, optional</span>
<span class="sd">            scale parameter (default=1)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        x : ndarray or scalar</span>
<span class="sd">            Quantile corresponding to the upper tail probability q.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">args</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_args</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
        <span class="n">q</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">scale</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">asarray</span><span class="p">,</span> <span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="p">))</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">asarray</span><span class="p">,</span> <span class="n">args</span><span class="p">))</span>
        <span class="n">cond0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_argcheck</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">scale</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">loc</span> <span class="o">==</span> <span class="n">loc</span><span class="p">)</span>
        <span class="n">cond1</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;</span> <span class="n">q</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">q</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">cond2</span> <span class="o">=</span> <span class="n">cond0</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">q</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">cond3</span> <span class="o">=</span> <span class="n">cond0</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">q</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">cond</span> <span class="o">=</span> <span class="n">cond0</span> <span class="o">&amp;</span> <span class="n">cond1</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">valarray</span><span class="p">(</span><span class="n">shape</span><span class="p">(</span><span class="n">cond</span><span class="p">),</span> <span class="n">value</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">badvalue</span><span class="p">)</span>

        <span class="n">lower_bound</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span> <span class="o">*</span> <span class="n">scale</span> <span class="o">+</span> <span class="n">loc</span>
        <span class="n">upper_bound</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span> <span class="o">*</span> <span class="n">scale</span> <span class="o">+</span> <span class="n">loc</span>
        <span class="n">place</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">cond2</span><span class="p">,</span> <span class="n">argsreduce</span><span class="p">(</span><span class="n">cond2</span><span class="p">,</span> <span class="n">lower_bound</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">place</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">cond3</span><span class="p">,</span> <span class="n">argsreduce</span><span class="p">(</span><span class="n">cond3</span><span class="p">,</span> <span class="n">upper_bound</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>

        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">cond</span><span class="p">):</span>
            <span class="n">goodargs</span> <span class="o">=</span> <span class="n">argsreduce</span><span class="p">(</span><span class="n">cond</span><span class="p">,</span> <span class="o">*</span><span class="p">((</span><span class="n">q</span><span class="p">,)</span><span class="o">+</span><span class="n">args</span><span class="o">+</span><span class="p">(</span><span class="n">scale</span><span class="p">,</span> <span class="n">loc</span><span class="p">)))</span>
            <span class="n">scale</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">goodargs</span> <span class="o">=</span> <span class="n">goodargs</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="n">goodargs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">goodargs</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">place</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">cond</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_isf</span><span class="p">(</span><span class="o">*</span><span class="n">goodargs</span><span class="p">)</span> <span class="o">*</span> <span class="n">scale</span> <span class="o">+</span> <span class="n">loc</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">output</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">output</span><span class="p">[()]</span>
        <span class="k">return</span> <span class="n">output</span>

    <span class="k">def</span> <span class="nf">_nnlf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="k">return</span> <span class="o">-</span><span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_logpdf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">nnlf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Return negative loglikelihood function</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This is ``-sum(log pdf(x, theta), axis=0)`` where theta are the</span>
<span class="sd">        parameters (including loc and scale).</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">loc</span> <span class="o">=</span> <span class="n">theta</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">scale</span> <span class="o">=</span> <span class="n">theta</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">args</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">theta</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>
        <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Not enough input arguments.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_argcheck</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="ow">or</span> <span class="n">scale</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">inf</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">((</span><span class="n">x</span><span class="o">-</span><span class="n">loc</span><span class="p">)</span> <span class="o">/</span> <span class="n">scale</span><span class="p">)</span>
        <span class="n">cond0</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">b</span> <span class="o">&lt;=</span> <span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">any</span><span class="p">(</span><span class="n">cond0</span><span class="p">)):</span>
            <span class="k">return</span> <span class="n">inf</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nnlf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">+</span> <span class="n">N</span> <span class="o">*</span> <span class="n">log</span><span class="p">(</span><span class="n">scale</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_penalized_nnlf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39; Return negative loglikelihood function,</span>
<span class="sd">        i.e., - sum (log pdf(x, theta), axis=0)</span>
<span class="sd">           where theta are the parameters (including loc and scale)</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">loc</span> <span class="o">=</span> <span class="n">theta</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">scale</span> <span class="o">=</span> <span class="n">theta</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">args</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">theta</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>
        <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Not enough input arguments.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_argcheck</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="ow">or</span> <span class="n">scale</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">inf</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">((</span><span class="n">x</span><span class="o">-</span><span class="n">loc</span><span class="p">)</span> <span class="o">/</span> <span class="n">scale</span><span class="p">)</span>

        <span class="n">loginf</span> <span class="o">=</span> <span class="n">log</span><span class="p">(</span><span class="n">_XMAX</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isneginf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
            <span class="n">Nbad</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cond0</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">b</span> <span class="o">&lt;=</span> <span class="n">x</span><span class="p">)</span>
            <span class="n">Nbad</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">cond0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">Nbad</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">argsreduce</span><span class="p">(</span><span class="o">~</span><span class="n">cond0</span><span class="p">,</span> <span class="n">x</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nnlf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">+</span> <span class="n">N</span><span class="o">*</span><span class="n">log</span><span class="p">(</span><span class="n">scale</span><span class="p">)</span> <span class="o">+</span> <span class="n">Nbad</span> <span class="o">*</span> <span class="mf">100.0</span> <span class="o">*</span> <span class="n">loginf</span>

    <span class="c"># return starting point for fit (shape arguments + loc + scale)</span>
    <span class="k">def</span> <span class="nf">_fitstart</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">args</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.0</span><span class="p">,)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">numargs</span>
        <span class="k">return</span> <span class="n">args</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_loc_scale</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="c"># Return the (possibly reduced) function to optimize in order to find MLE</span>
    <span class="c">#  estimates for the .fit method</span>
    <span class="k">def</span> <span class="nf">_reduce_func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwds</span><span class="p">):</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
        <span class="n">Nargs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
        <span class="n">fixedn</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">index</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">Nargs</span><span class="p">))</span>
        <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;f</span><span class="si">%d</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Nargs</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)]</span> <span class="o">+</span> <span class="p">[</span><span class="s">&#39;floc&#39;</span><span class="p">,</span> <span class="s">&#39;fscale&#39;</span><span class="p">]</span>
        <span class="n">x0</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">names</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">kwds</span><span class="p">:</span>
                <span class="n">fixedn</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
                <span class="n">args</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwds</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">x0</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">fixedn</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_penalized_nnlf</span>
            <span class="n">restore</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">fixedn</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">index</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s">&quot;All parameters fixed. There is nothing to optimize.&quot;</span><span class="p">)</span>

            <span class="k">def</span> <span class="nf">restore</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>
                <span class="c"># Replace with theta for all numbers not in fixedn</span>
                <span class="c"># This allows the non-fixed values to vary, but</span>
                <span class="c">#  we still call self.nnlf with all parameters.</span>
                <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Nargs</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">n</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">fixedn</span><span class="p">:</span>
                        <span class="n">args</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">theta</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">return</span> <span class="n">args</span>

            <span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
                <span class="n">newtheta</span> <span class="o">=</span> <span class="n">restore</span><span class="p">(</span><span class="n">args</span><span class="p">[:],</span> <span class="n">theta</span><span class="p">)</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_penalized_nnlf</span><span class="p">(</span><span class="n">newtheta</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">x0</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">restore</span><span class="p">,</span> <span class="n">args</span>

    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return MLEs for shape, location, and scale parameters from data.</span>

<span class="sd">        MLE stands for Maximum Likelihood Estimate.  Starting estimates for</span>
<span class="sd">        the fit are given by input arguments; for any arguments not provided</span>
<span class="sd">        with starting estimates, ``self._fitstart(data)`` is called to generate</span>
<span class="sd">        such.</span>

<span class="sd">        One can hold some parameters fixed to specific values by passing in</span>
<span class="sd">        keyword arguments ``f0``, ``f1``, ..., ``fn`` (for shape parameters)</span>
<span class="sd">        and ``floc`` and ``fscale`` (for location and scale parameters,</span>
<span class="sd">        respectively).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : array_like</span>
<span class="sd">            Data to use in calculating the MLEs.</span>
<span class="sd">        args : floats, optional</span>
<span class="sd">            Starting value(s) for any shape-characterizing arguments (those not</span>
<span class="sd">            provided will be determined by a call to ``_fitstart(data)``).</span>
<span class="sd">            No default value.</span>
<span class="sd">        kwds : floats, optional</span>
<span class="sd">            Starting values for the location and scale parameters; no default.</span>
<span class="sd">            Special keyword arguments are recognized as holding certain</span>
<span class="sd">            parameters fixed:</span>

<span class="sd">            f0...fn : hold respective shape parameters fixed.</span>

<span class="sd">            floc : hold location parameter fixed to specified value.</span>

<span class="sd">            fscale : hold scale parameter fixed to specified value.</span>

<span class="sd">            optimizer : The optimizer to use.  The optimizer must take func,</span>
<span class="sd">                        and starting position as the first two arguments,</span>
<span class="sd">                        plus args (for extra arguments to pass to the</span>
<span class="sd">                        function to be optimized) and disp=0 to suppress</span>
<span class="sd">                        output as keyword arguments.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        shape, loc, scale : tuple of floats</span>
<span class="sd">            MLEs for any shape statistics, followed by those for location and</span>
<span class="sd">            scale.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This fit is computed by maximizing a log-likelihood function, with</span>
<span class="sd">        penalty applied for samples outside of range of the distribution. The</span>
<span class="sd">        returned answer is not guaranteed to be the globally optimal MLE, it</span>
<span class="sd">        may only be locally optimal, or the optimization may fail altogether.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Narg</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">Narg</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">numargs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;Too many input arguments.&quot;</span><span class="p">)</span>

        <span class="n">start</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span><span class="o">*</span><span class="mi">2</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">Narg</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">numargs</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="p">(</span><span class="s">&#39;loc&#39;</span> <span class="ow">in</span> <span class="n">kwds</span> <span class="ow">and</span>
                                         <span class="s">&#39;scale&#39;</span> <span class="ow">in</span> <span class="n">kwds</span><span class="p">):</span>
            <span class="c"># get distribution specific starting locations</span>
            <span class="n">start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fitstart</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="n">args</span> <span class="o">+=</span> <span class="n">start</span><span class="p">[</span><span class="n">Narg</span><span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">loc</span> <span class="o">=</span> <span class="n">kwds</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;loc&#39;</span><span class="p">,</span> <span class="n">start</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">scale</span> <span class="o">=</span> <span class="n">kwds</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;scale&#39;</span><span class="p">,</span> <span class="n">start</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">args</span> <span class="o">+=</span> <span class="p">(</span><span class="n">loc</span><span class="p">,</span> <span class="n">scale</span><span class="p">)</span>
        <span class="n">x0</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">restore</span><span class="p">,</span> <span class="n">args</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reduce_func</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwds</span><span class="p">)</span>

        <span class="n">optimizer</span> <span class="o">=</span> <span class="n">kwds</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;optimizer&#39;</span><span class="p">,</span> <span class="n">optimize</span><span class="o">.</span><span class="n">fmin</span><span class="p">)</span>
        <span class="c"># convert string to function in scipy.optimize</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">callable</span><span class="p">(</span><span class="n">optimizer</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">optimizer</span><span class="p">,</span> <span class="n">string_types</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">optimizer</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&#39;fmin_&#39;</span><span class="p">):</span>
                <span class="n">optimizer</span> <span class="o">=</span> <span class="s">&quot;fmin_&quot;</span><span class="o">+</span><span class="n">optimizer</span>
            <span class="k">if</span> <span class="n">optimizer</span> <span class="o">==</span> <span class="s">&#39;fmin_&#39;</span><span class="p">:</span>
                <span class="n">optimizer</span> <span class="o">=</span> <span class="s">&#39;fmin&#39;</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">optimizer</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">optimize</span><span class="p">,</span> <span class="n">optimizer</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%s</span><span class="s"> is not a valid optimizer&quot;</span> <span class="o">%</span> <span class="n">optimizer</span><span class="p">)</span>
        <span class="n">vals</span> <span class="o">=</span> <span class="n">optimizer</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">ravel</span><span class="p">(</span><span class="n">data</span><span class="p">),),</span> <span class="n">disp</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">restore</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">vals</span> <span class="o">=</span> <span class="n">restore</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">vals</span><span class="p">)</span>
        <span class="n">vals</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">vals</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">vals</span>

    <span class="k">def</span> <span class="nf">fit_loc_scale</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Estimate loc and scale parameters from data using 1st and 2nd moments.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : array_like</span>
<span class="sd">            Data to fit.</span>
<span class="sd">        arg1, arg2, arg3,... : array_like</span>
<span class="sd">            The shape parameter(s) for the distribution (see docstring of the</span>
<span class="sd">            instance object for more information).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Lhat : float</span>
<span class="sd">            Estimated location parameter for the data.</span>
<span class="sd">        Shat : float</span>
<span class="sd">            Estimated scale parameter for the data.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mu</span><span class="p">,</span> <span class="n">mu2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="p">{</span><span class="s">&#39;moments&#39;</span><span class="p">:</span> <span class="s">&#39;mv&#39;</span><span class="p">})</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">muhat</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        <span class="n">mu2hat</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">var</span><span class="p">()</span>
        <span class="n">Shat</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">mu2hat</span> <span class="o">/</span> <span class="n">mu2</span><span class="p">)</span>
        <span class="n">Lhat</span> <span class="o">=</span> <span class="n">muhat</span> <span class="o">-</span> <span class="n">Shat</span><span class="o">*</span><span class="n">mu</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">Lhat</span><span class="p">):</span>
            <span class="n">Lhat</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">Shat</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;</span> <span class="n">Shat</span><span class="p">)):</span>
            <span class="n">Shat</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">Lhat</span><span class="p">,</span> <span class="n">Shat</span>

    <span class="nd">@np.deprecate</span>
    <span class="k">def</span> <span class="nf">est_loc_scale</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This function is deprecated, use self.fit_loc_scale(data) instead.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_loc_scale</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_entropy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">integ</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="n">val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pdf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">entr</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

        <span class="c"># upper limit is often inf, so suppress warnings when integrating</span>
        <span class="n">olderr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">seterr</span><span class="p">(</span><span class="n">over</span><span class="o">=</span><span class="s">&#39;ignore&#39;</span><span class="p">)</span>
        <span class="n">h</span> <span class="o">=</span> <span class="n">integrate</span><span class="o">.</span><span class="n">quad</span><span class="p">(</span><span class="n">integ</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">np</span><span class="o">.</span><span class="n">seterr</span><span class="p">(</span><span class="o">**</span><span class="n">olderr</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">h</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">h</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># try with different limits if integration problems</span>
            <span class="n">low</span><span class="p">,</span> <span class="n">upp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ppf</span><span class="p">([</span><span class="mf">1e-10</span><span class="p">,</span> <span class="mf">1.</span> <span class="o">-</span> <span class="mf">1e-10</span><span class="p">],</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">):</span>
                <span class="n">upper</span> <span class="o">=</span> <span class="n">upp</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">upper</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">):</span>
                <span class="n">lower</span> <span class="o">=</span> <span class="n">low</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">lower</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span>
            <span class="k">return</span> <span class="n">integrate</span><span class="o">.</span><span class="n">quad</span><span class="p">(</span><span class="n">integ</span><span class="p">,</span> <span class="n">lower</span><span class="p">,</span> <span class="n">upper</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">entropy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Differential entropy of the RV.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        arg1, arg2, arg3,... : array_like</span>
<span class="sd">            The shape parameter(s) for the distribution (see docstring of the</span>
<span class="sd">            instance object for more information).</span>
<span class="sd">        loc : array_like, optional</span>
<span class="sd">            Location parameter (default=0).</span>
<span class="sd">        scale : array_like, optional</span>
<span class="sd">            Scale parameter (default=1).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">args</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_args</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">asarray</span><span class="p">,</span> <span class="n">args</span><span class="p">))</span>
        <span class="n">cond0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_argcheck</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">scale</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">loc</span> <span class="o">==</span> <span class="n">loc</span><span class="p">)</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="p">(</span><span class="n">cond0</span><span class="p">),</span> <span class="s">&#39;d&#39;</span><span class="p">)</span>
        <span class="n">place</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">cond0</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">badvalue</span><span class="p">)</span>
        <span class="n">goodargs</span> <span class="o">=</span> <span class="n">argsreduce</span><span class="p">(</span><span class="n">cond0</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="c"># np.vectorize doesn&#39;t work when numargs == 0 in numpy 1.5.1</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">numargs</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">place</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">cond0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_entropy</span><span class="p">()</span> <span class="o">+</span> <span class="n">log</span><span class="p">(</span><span class="n">scale</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">place</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">cond0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vecentropy</span><span class="p">(</span><span class="o">*</span><span class="n">goodargs</span><span class="p">)</span> <span class="o">+</span> <span class="n">log</span><span class="p">(</span><span class="n">scale</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">output</span>

    <span class="k">def</span> <span class="nf">expect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(),</span> <span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">lb</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">ub</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
               <span class="n">conditional</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate expected value of a function with respect to the</span>
<span class="sd">        distribution.</span>

<span class="sd">        The expected value of a function ``f(x)`` with respect to a</span>
<span class="sd">        distribution ``dist`` is defined as::</span>

<span class="sd">                    ubound</span>
<span class="sd">            E[x] = Integral(f(x) * dist.pdf(x))</span>
<span class="sd">                    lbound</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        func : callable, optional</span>
<span class="sd">            Function for which integral is calculated. Takes only one argument.</span>
<span class="sd">            The default is the identity mapping f(x) = x.</span>
<span class="sd">        args : tuple, optional</span>
<span class="sd">            Argument (parameters) of the distribution.</span>
<span class="sd">        lb, ub : scalar, optional</span>
<span class="sd">            Lower and upper bound for integration. default is set to the</span>
<span class="sd">            support of the distribution.</span>
<span class="sd">        conditional : bool, optional</span>
<span class="sd">            If True, the integral is corrected by the conditional probability</span>
<span class="sd">            of the integration interval.  The return value is the expectation</span>
<span class="sd">            of the function, conditional on being in the given interval.</span>
<span class="sd">            Default is False.</span>

<span class="sd">        Additional keyword arguments are passed to the integration routine.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        expect : float</span>
<span class="sd">            The calculated expected value.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The integration behavior of this function is inherited from</span>
<span class="sd">        `integrate.quad`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lockwds</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;loc&#39;</span><span class="p">:</span> <span class="n">loc</span><span class="p">,</span>
                   <span class="s">&#39;scale&#39;</span><span class="p">:</span> <span class="n">scale</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_argcheck</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">func</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">fun</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">lockwds</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">fun</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">lockwds</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">lb</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">lb</span> <span class="o">=</span> <span class="n">loc</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span> <span class="o">*</span> <span class="n">scale</span>
        <span class="k">if</span> <span class="n">ub</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">ub</span> <span class="o">=</span> <span class="n">loc</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span> <span class="o">*</span> <span class="n">scale</span>
        <span class="k">if</span> <span class="n">conditional</span><span class="p">:</span>
            <span class="n">invfac</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sf</span><span class="p">(</span><span class="n">lb</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">lockwds</span><span class="p">)</span>
                      <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">sf</span><span class="p">(</span><span class="n">ub</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">lockwds</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">invfac</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="n">kwds</span><span class="p">[</span><span class="s">&#39;args&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">args</span>
        <span class="c"># Silence floating point warnings from integration.</span>
        <span class="n">olderr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">seterr</span><span class="p">(</span><span class="nb">all</span><span class="o">=</span><span class="s">&#39;ignore&#39;</span><span class="p">)</span>
        <span class="n">vals</span> <span class="o">=</span> <span class="n">integrate</span><span class="o">.</span><span class="n">quad</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="n">lb</span><span class="p">,</span> <span class="n">ub</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">invfac</span>
        <span class="n">np</span><span class="o">.</span><span class="n">seterr</span><span class="p">(</span><span class="o">**</span><span class="n">olderr</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">vals</span>


<span class="c">## Handlers for generic case where xk and pk are given</span>
<span class="c">## The _drv prefix probably means discrete random variable.</span>

<span class="k">def</span> <span class="nf">_drv_pmf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xk</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">P</span><span class="p">[</span><span class="n">xk</span><span class="p">]</span>
    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
        <span class="k">return</span> <span class="mf">0.0</span>


<span class="k">def</span> <span class="nf">_drv_cdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xk</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="n">indx</span> <span class="o">=</span> <span class="n">argmax</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">xk</span> <span class="o">&gt;</span> <span class="n">xk</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">F</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">xk</span><span class="p">[</span><span class="n">indx</span><span class="p">]]</span>


<span class="k">def</span> <span class="nf">_drv_ppf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="n">indx</span> <span class="o">=</span> <span class="n">argmax</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">qvals</span> <span class="o">&gt;=</span> <span class="n">q</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Finv</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">qvals</span><span class="p">[</span><span class="n">indx</span><span class="p">]]</span>


<span class="k">def</span> <span class="nf">_drv_nonzero</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="k">return</span> <span class="mi">1</span>


<span class="k">def</span> <span class="nf">_drv_moment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xk</span><span class="o">**</span><span class="n">n</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">pk</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_drv_moment_gen</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">exp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xk</span> <span class="o">*</span> <span class="n">t</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="o">...</span><span class="p">])</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">pk</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_drv2_moment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Non-central moment of discrete distribution.&quot;&quot;&quot;</span>
    <span class="c"># many changes, originally not even a return</span>
    <span class="n">tot</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="n">diff</span> <span class="o">=</span> <span class="mf">1e100</span>
    <span class="c"># pos = self.a</span>
    <span class="n">pos</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">)</span>
    <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="c"># handle cases with infinite support</span>
    <span class="n">ulimit</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span> <span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span> <span class="o">+</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="o">-</span><span class="mi">1000</span><span class="p">))</span><span class="o">/</span><span class="mf">2.0</span><span class="p">)</span>
    <span class="n">llimit</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="o">-</span><span class="mi">1000</span><span class="p">,</span> <span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span> <span class="o">+</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="o">-</span><span class="mi">1000</span><span class="p">))</span><span class="o">/</span><span class="mf">2.0</span><span class="p">)</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">pos</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">)</span> <span class="ow">and</span> <span class="p">((</span><span class="n">pos</span> <span class="o">&lt;=</span> <span class="n">ulimit</span><span class="p">)</span> <span class="ow">or</span>
                               <span class="p">(</span><span class="n">diff</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">moment_tol</span><span class="p">)):</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">pmf</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="c"># use pmf because _pmf does not check support in randint and there</span>
        <span class="c"># might be problems ? with correct self.a, self.b at this stage</span>
        <span class="n">tot</span> <span class="o">+=</span> <span class="n">diff</span>
        <span class="n">pos</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inc</span>
        <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>  <span class="c"># handle case when self.a = -inf</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="mf">1e100</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">inc</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">pos</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">)</span> <span class="ow">and</span> <span class="p">((</span><span class="n">pos</span> <span class="o">&gt;=</span> <span class="n">llimit</span><span class="p">)</span> <span class="ow">or</span>
                                   <span class="p">(</span><span class="n">diff</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">moment_tol</span><span class="p">)):</span>
            <span class="n">diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">pmf</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
            <span class="c"># using pmf instead of _pmf, see above</span>
            <span class="n">tot</span> <span class="o">+=</span> <span class="n">diff</span>
            <span class="n">pos</span> <span class="o">-=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inc</span>
            <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">tot</span>


<span class="k">def</span> <span class="nf">_drv2_ppfsingle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>  <span class="c"># Use basic bisection algorithm</span>
    <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span>
    <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span>
    <span class="k">if</span> <span class="n">isinf</span><span class="p">(</span><span class="n">b</span><span class="p">):</span>            <span class="c"># Be sure ending point is &gt; q</span>
        <span class="n">b</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="mi">100</span><span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
        <span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">b</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">:</span>
                <span class="n">qb</span> <span class="o">=</span> <span class="mf">1.0</span>
                <span class="k">break</span>
            <span class="n">qb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cdf</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">qb</span> <span class="o">&lt;</span> <span class="n">q</span><span class="p">):</span>
                <span class="n">b</span> <span class="o">+=</span> <span class="mi">10</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">break</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">qb</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="k">if</span> <span class="n">isinf</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>    <span class="c"># be sure starting point &lt; q</span>
        <span class="n">a</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="o">-</span><span class="mi">100</span><span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="o">-</span><span class="mi">10</span><span class="p">))</span>
        <span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">a</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">:</span>
                <span class="n">qb</span> <span class="o">=</span> <span class="mf">0.0</span>
                <span class="k">break</span>
            <span class="n">qa</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cdf</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">qa</span> <span class="o">&gt;</span> <span class="n">q</span><span class="p">):</span>
                <span class="n">a</span> <span class="o">-=</span> <span class="mi">10</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">break</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">qa</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cdf</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">qa</span> <span class="o">==</span> <span class="n">q</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">a</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">qb</span> <span class="o">==</span> <span class="n">q</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">b</span>
        <span class="k">if</span> <span class="n">b</span> <span class="o">&lt;=</span> <span class="n">a</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span>
            <span class="c"># testcase: return wrong number at lower index</span>
            <span class="c"># python -c &quot;from scipy.stats import zipf;print zipf.ppf(0.01, 2)&quot; wrong</span>
            <span class="c"># python -c &quot;from scipy.stats import zipf;print zipf.ppf([0.01, 0.61, 0.77, 0.83], 2)&quot;</span>
            <span class="c"># python -c &quot;from scipy.stats import logser;print logser.ppf([0.1, 0.66, 0.86, 0.93], 0.6)&quot;</span>
            <span class="k">if</span> <span class="n">qa</span> <span class="o">&gt;</span> <span class="n">q</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">a</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">b</span>
        <span class="n">c</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">)</span><span class="o">/</span><span class="mf">2.0</span><span class="p">)</span>
        <span class="n">qc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cdf</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">qc</span> <span class="o">&lt;</span> <span class="n">q</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">a</span> <span class="o">!=</span> <span class="n">c</span><span class="p">:</span>
                <span class="n">a</span> <span class="o">=</span> <span class="n">c</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s">&#39;updating stopped, endless loop&#39;</span><span class="p">)</span>
            <span class="n">qa</span> <span class="o">=</span> <span class="n">qc</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">qc</span> <span class="o">&gt;</span> <span class="n">q</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">b</span> <span class="o">!=</span> <span class="n">c</span><span class="p">:</span>
                <span class="n">b</span> <span class="o">=</span> <span class="n">c</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s">&#39;updating stopped, endless loop&#39;</span><span class="p">)</span>
            <span class="n">qb</span> <span class="o">=</span> <span class="n">qc</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">c</span>


<span class="k">def</span> <span class="nf">entropy</span><span class="p">(</span><span class="n">pk</span><span class="p">,</span> <span class="n">qk</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate the entropy of a distribution for given probability values.</span>

<span class="sd">    If only probabilities `pk` are given, the entropy is calculated as</span>
<span class="sd">    ``S = -sum(pk * log(pk), axis=0)``.</span>

<span class="sd">    If `qk` is not None, then compute the Kullback-Leibler divergence</span>
<span class="sd">    ``S = sum(pk * log(pk / qk), axis=0)``.</span>

<span class="sd">    This routine will normalize `pk` and `qk` if they don&#39;t sum to 1.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    pk : sequence</span>
<span class="sd">        Defines the (discrete) distribution. ``pk[i]`` is the (possibly</span>
<span class="sd">        unnormalized) probability of event ``i``.</span>
<span class="sd">    qk : sequence, optional</span>
<span class="sd">        Sequence against which the relative entropy is computed. Should be in</span>
<span class="sd">        the same format as `pk`.</span>
<span class="sd">    base : float, optional</span>
<span class="sd">        The logarithmic base to use, defaults to ``e`` (natural logarithm).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    S : float</span>
<span class="sd">        The calculated entropy.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">pk</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">pk</span><span class="p">)</span>
    <span class="n">pk</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">*</span><span class="n">pk</span> <span class="o">/</span> <span class="nb">sum</span><span class="p">(</span><span class="n">pk</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">qk</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">vec</span> <span class="o">=</span> <span class="n">entr</span><span class="p">(</span><span class="n">pk</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">qk</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">qk</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">qk</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pk</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;qk and pk must have same length.&quot;</span><span class="p">)</span>
        <span class="n">qk</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">*</span><span class="n">qk</span> <span class="o">/</span> <span class="nb">sum</span><span class="p">(</span><span class="n">qk</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">vec</span> <span class="o">=</span> <span class="n">kl_div</span><span class="p">(</span><span class="n">pk</span><span class="p">,</span> <span class="n">qk</span><span class="p">)</span>
    <span class="n">S</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">vec</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">base</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">S</span> <span class="o">/=</span> <span class="n">log</span><span class="p">(</span><span class="n">base</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">S</span>


<span class="c"># Must over-ride one of _pmf or _cdf or pass in</span>
<span class="c">#  x_k, p(x_k) lists in initialization</span>

<span class="k">class</span> <span class="nc">rv_discrete</span><span class="p">(</span><span class="n">rv_generic</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A generic discrete random variable class meant for subclassing.</span>

<span class="sd">    `rv_discrete` is a base class to construct specific distribution classes</span>
<span class="sd">    and instances from for discrete random variables. rv_discrete can be used</span>
<span class="sd">    to construct an arbitrary distribution with defined by a list of support</span>
<span class="sd">    points and the corresponding probabilities.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : float, optional</span>
<span class="sd">        Lower bound of the support of the distribution, default: 0</span>
<span class="sd">    b : float, optional</span>
<span class="sd">        Upper bound of the support of the distribution, default: plus infinity</span>
<span class="sd">    moment_tol : float, optional</span>
<span class="sd">        The tolerance for the generic calculation of moments</span>
<span class="sd">    values : tuple of two array_like</span>
<span class="sd">        (xk, pk) where xk are points (integers) with positive probability pk</span>
<span class="sd">        with sum(pk) = 1</span>
<span class="sd">    inc : integer</span>
<span class="sd">        increment for the support of the distribution, default: 1</span>
<span class="sd">        other values have not been tested</span>
<span class="sd">    badvalue : object, optional</span>
<span class="sd">        The value in (masked) arrays that indicates a value that should be</span>
<span class="sd">        ignored.</span>
<span class="sd">    name : str, optional</span>
<span class="sd">        The name of the instance. This string is used to construct the default</span>
<span class="sd">        example for distributions.</span>
<span class="sd">    longname : str, optional</span>
<span class="sd">        This string is used as part of the first line of the docstring returned</span>
<span class="sd">        when a subclass has no docstring of its own. Note: `longname` exists</span>
<span class="sd">        for backwards compatibility, do not use for new subclasses.</span>
<span class="sd">    shapes : str, optional</span>
<span class="sd">        The shape of the distribution. For example ``&quot;m, n&quot;`` for a</span>
<span class="sd">        distribution that takes two integers as the first two arguments for all</span>
<span class="sd">        its methods.</span>
<span class="sd">    extradoc :  str, optional</span>
<span class="sd">        This string is used as the last part of the docstring returned when a</span>
<span class="sd">        subclass has no docstring of its own. Note: `extradoc` exists for</span>
<span class="sd">        backwards compatibility, do not use for new subclasses.</span>

<span class="sd">    Methods</span>
<span class="sd">    -------</span>
<span class="sd">    ``generic.rvs(&lt;shape(s)&gt;, loc=0, size=1)``</span>
<span class="sd">        random variates</span>

<span class="sd">    ``generic.pmf(x, &lt;shape(s)&gt;, loc=0)``</span>
<span class="sd">        probability mass function</span>

<span class="sd">    ``logpmf(x, &lt;shape(s)&gt;, loc=0)``</span>
<span class="sd">        log of the probability density function</span>

<span class="sd">    ``generic.cdf(x, &lt;shape(s)&gt;, loc=0)``</span>
<span class="sd">        cumulative density function</span>

<span class="sd">    ``generic.logcdf(x, &lt;shape(s)&gt;, loc=0)``</span>
<span class="sd">        log of the cumulative density function</span>

<span class="sd">    ``generic.sf(x, &lt;shape(s)&gt;, loc=0)``</span>
<span class="sd">        survival function (1-cdf --- sometimes more accurate)</span>

<span class="sd">    ``generic.logsf(x, &lt;shape(s)&gt;, loc=0, scale=1)``</span>
<span class="sd">        log of the survival function</span>

<span class="sd">    ``generic.ppf(q, &lt;shape(s)&gt;, loc=0)``</span>
<span class="sd">        percent point function (inverse of cdf --- percentiles)</span>

<span class="sd">    ``generic.isf(q, &lt;shape(s)&gt;, loc=0)``</span>
<span class="sd">        inverse survival function (inverse of sf)</span>

<span class="sd">    ``generic.moment(n, &lt;shape(s)&gt;, loc=0)``</span>
<span class="sd">        non-central n-th moment of the distribution.  May not work for array</span>
<span class="sd">        arguments.</span>

<span class="sd">    ``generic.stats(&lt;shape(s)&gt;, loc=0, moments=&#39;mv&#39;)``</span>
<span class="sd">        mean(&#39;m&#39;, axis=0), variance(&#39;v&#39;), skew(&#39;s&#39;), and/or kurtosis(&#39;k&#39;)</span>

<span class="sd">    ``generic.entropy(&lt;shape(s)&gt;, loc=0)``</span>
<span class="sd">        entropy of the RV</span>

<span class="sd">    ``generic.expect(func=None, args=(), loc=0, lb=None, ub=None, conditional=False)``</span>
<span class="sd">        Expected value of a function with respect to the distribution.</span>
<span class="sd">        Additional kwd arguments passed to integrate.quad</span>

<span class="sd">    ``generic.median(&lt;shape(s)&gt;, loc=0)``</span>
<span class="sd">        Median of the distribution.</span>

<span class="sd">    ``generic.mean(&lt;shape(s)&gt;, loc=0)``</span>
<span class="sd">        Mean of the distribution.</span>

<span class="sd">    ``generic.std(&lt;shape(s)&gt;, loc=0)``</span>
<span class="sd">        Standard deviation of the distribution.</span>

<span class="sd">    ``generic.var(&lt;shape(s)&gt;, loc=0)``</span>
<span class="sd">        Variance of the distribution.</span>

<span class="sd">    ``generic.interval(alpha, &lt;shape(s)&gt;, loc=0)``</span>
<span class="sd">        Interval that with `alpha` percent probability contains a random</span>
<span class="sd">        realization of this distribution.</span>

<span class="sd">    ``generic(&lt;shape(s)&gt;, loc=0)``</span>
<span class="sd">        calling a distribution instance returns a frozen distribution</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>

<span class="sd">    You can construct an arbitrary discrete rv where ``P{X=xk} = pk``</span>
<span class="sd">    by passing to the rv_discrete initialization method (through the</span>
<span class="sd">    values=keyword) a tuple of sequences (xk, pk) which describes only those</span>
<span class="sd">    values of X (xk) that occur with nonzero probability (pk).</span>

<span class="sd">    To create a new discrete distribution, we would do the following::</span>

<span class="sd">        class poisson_gen(rv_discrete):</span>
<span class="sd">            # &quot;Poisson distribution&quot;</span>
<span class="sd">            def _pmf(self, k, mu):</span>
<span class="sd">                ...</span>

<span class="sd">    and create an instance::</span>

<span class="sd">        poisson = poisson_gen(name=&quot;poisson&quot;,</span>
<span class="sd">                              longname=&#39;A Poisson&#39;)</span>

<span class="sd">    The docstring can be created from a template.</span>

<span class="sd">    Alternatively, the object may be called (as a function) to fix the shape</span>
<span class="sd">    and location parameters returning a &quot;frozen&quot; discrete RV object::</span>

<span class="sd">        myrv = generic(&lt;shape(s)&gt;, loc=0)</span>
<span class="sd">            - frozen RV object with the same methods but holding the given</span>
<span class="sd">              shape and location fixed.</span>

<span class="sd">    A note on ``shapes``: subclasses need not specify them explicitly. In this</span>
<span class="sd">    case, the `shapes` will be automatically deduced from the signatures of the</span>
<span class="sd">    overridden methods.</span>
<span class="sd">    If, for some reason, you prefer to avoid relying on introspection, you can</span>
<span class="sd">    specify ``shapes`` explicitly as an argument to the instance constructor.</span>


<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    Custom made discrete distribution:</span>

<span class="sd">    &gt;&gt;&gt; from scipy import stats</span>
<span class="sd">    &gt;&gt;&gt; xk = np.arange(7)</span>
<span class="sd">    &gt;&gt;&gt; pk = (0.1, 0.2, 0.3, 0.1, 0.1, 0.0, 0.2)</span>
<span class="sd">    &gt;&gt;&gt; custm = stats.rv_discrete(name=&#39;custm&#39;, values=(xk, pk))</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; fig, ax = plt.subplots(1, 1)</span>
<span class="sd">    &gt;&gt;&gt; ax.plot(xk, custm.pmf(xk), &#39;ro&#39;, ms=12, mec=&#39;r&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax.vlines(xk, 0, custm.pmf(xk), colors=&#39;r&#39;, lw=4)</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    Random number generation:</span>

<span class="sd">    &gt;&gt;&gt; R = custm.rvs(size=100)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="n">inf</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">badvalue</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="n">moment_tol</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">inc</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">longname</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="n">shapes</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">extradoc</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">rv_discrete</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span>

        <span class="c"># cf generic freeze</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ctor_param</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="n">a</span><span class="o">=</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="n">b</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">badvalue</span><span class="o">=</span><span class="n">badvalue</span><span class="p">,</span>
            <span class="n">moment_tol</span><span class="o">=</span><span class="n">moment_tol</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="n">values</span><span class="p">,</span> <span class="n">inc</span><span class="o">=</span><span class="n">inc</span><span class="p">,</span>
            <span class="n">longname</span><span class="o">=</span><span class="n">longname</span><span class="p">,</span> <span class="n">shapes</span><span class="o">=</span><span class="n">shapes</span><span class="p">,</span> <span class="n">extradoc</span><span class="o">=</span><span class="n">extradoc</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">badvalue</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">badvalue</span> <span class="o">=</span> <span class="n">nan</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="s">&#39;Distribution&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">badvalue</span> <span class="o">=</span> <span class="n">badvalue</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="n">a</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">b</span> <span class="o">=</span> <span class="n">b</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">moment_tol</span> <span class="o">=</span> <span class="n">moment_tol</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inc</span> <span class="o">=</span> <span class="n">inc</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cdfvec</span> <span class="o">=</span> <span class="n">vectorize</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cdf_single</span><span class="p">,</span> <span class="n">otypes</span><span class="o">=</span><span class="s">&#39;d&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">return_integers</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vecentropy</span> <span class="o">=</span> <span class="n">vectorize</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_entropy</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shapes</span> <span class="o">=</span> <span class="n">shapes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extradoc</span> <span class="o">=</span> <span class="n">extradoc</span>

        <span class="k">if</span> <span class="n">values</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">xk</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pk</span> <span class="o">=</span> <span class="n">values</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">return_integers</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">indx</span> <span class="o">=</span> <span class="n">argsort</span><span class="p">(</span><span class="n">ravel</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xk</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">xk</span> <span class="o">=</span> <span class="n">take</span><span class="p">(</span><span class="n">ravel</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xk</span><span class="p">),</span> <span class="n">indx</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pk</span> <span class="o">=</span> <span class="n">take</span><span class="p">(</span><span class="n">ravel</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pk</span><span class="p">),</span> <span class="n">indx</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xk</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xk</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">P</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xk</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pk</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">qvals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pk</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">F</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xk</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">qvals</span><span class="p">))</span>
            <span class="n">decreasing_keys</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">F</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span> <span class="n">reverse</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Finv</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">F</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">decreasing_keys</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ppf</span> <span class="o">=</span> <span class="n">instancemethod</span><span class="p">(</span><span class="n">vectorize</span><span class="p">(</span><span class="n">_drv_ppf</span><span class="p">,</span> <span class="n">otypes</span><span class="o">=</span><span class="s">&#39;d&#39;</span><span class="p">),</span>
                                       <span class="bp">self</span><span class="p">,</span> <span class="n">rv_discrete</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_pmf</span> <span class="o">=</span> <span class="n">instancemethod</span><span class="p">(</span><span class="n">vectorize</span><span class="p">(</span><span class="n">_drv_pmf</span><span class="p">,</span> <span class="n">otypes</span><span class="o">=</span><span class="s">&#39;d&#39;</span><span class="p">),</span>
                                       <span class="bp">self</span><span class="p">,</span> <span class="n">rv_discrete</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cdf</span> <span class="o">=</span> <span class="n">instancemethod</span><span class="p">(</span><span class="n">vectorize</span><span class="p">(</span><span class="n">_drv_cdf</span><span class="p">,</span> <span class="n">otypes</span><span class="o">=</span><span class="s">&#39;d&#39;</span><span class="p">),</span>
                                       <span class="bp">self</span><span class="p">,</span> <span class="n">rv_discrete</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_nonzero</span> <span class="o">=</span> <span class="n">instancemethod</span><span class="p">(</span><span class="n">_drv_nonzero</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">rv_discrete</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">generic_moment</span> <span class="o">=</span> <span class="n">instancemethod</span><span class="p">(</span><span class="n">_drv_moment</span><span class="p">,</span>
                                                 <span class="bp">self</span><span class="p">,</span> <span class="n">rv_discrete</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">moment_gen</span> <span class="o">=</span> <span class="n">instancemethod</span><span class="p">(</span><span class="n">_drv_moment_gen</span><span class="p">,</span>
                                             <span class="bp">self</span><span class="p">,</span> <span class="n">rv_discrete</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_construct_argparser</span><span class="p">(</span><span class="n">meths_to_inspect</span><span class="o">=</span><span class="p">[</span><span class="n">_drv_pmf</span><span class="p">],</span>
                                      <span class="n">locscale_in</span><span class="o">=</span><span class="s">&#39;loc=0&#39;</span><span class="p">,</span>
                                      <span class="c"># scale=1 for discrete RVs</span>
                                      <span class="n">locscale_out</span><span class="o">=</span><span class="s">&#39;loc, 1&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_construct_argparser</span><span class="p">(</span><span class="n">meths_to_inspect</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_pmf</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cdf</span><span class="p">],</span>
                                      <span class="n">locscale_in</span><span class="o">=</span><span class="s">&#39;loc=0&#39;</span><span class="p">,</span>
                                      <span class="c"># scale=1 for discrete RVs</span>
                                      <span class="n">locscale_out</span><span class="o">=</span><span class="s">&#39;loc, 1&#39;</span><span class="p">)</span>

            <span class="c"># nin correction needs to be after we know numargs</span>
            <span class="c"># correct nin for generic moment vectorization</span>
            <span class="n">_vec_generic_moment</span> <span class="o">=</span> <span class="n">vectorize</span><span class="p">(</span><span class="n">_drv2_moment</span><span class="p">,</span> <span class="n">otypes</span><span class="o">=</span><span class="s">&#39;d&#39;</span><span class="p">)</span>
            <span class="n">_vec_generic_moment</span><span class="o">.</span><span class="n">nin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">numargs</span> <span class="o">+</span> <span class="mi">2</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">generic_moment</span> <span class="o">=</span> <span class="n">instancemethod</span><span class="p">(</span><span class="n">_vec_generic_moment</span><span class="p">,</span>
                                                 <span class="bp">self</span><span class="p">,</span> <span class="n">rv_discrete</span><span class="p">)</span>
            <span class="c"># backwards compat.  was removed in 0.14.0, put back but</span>
            <span class="c"># deprecated in 0.14.1:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">vec_generic_moment</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deprecate</span><span class="p">(</span><span class="n">_vec_generic_moment</span><span class="p">,</span>
                                                   <span class="s">&quot;vec_generic_moment&quot;</span><span class="p">,</span>
                                                   <span class="s">&quot;generic_moment&quot;</span><span class="p">)</span>

            <span class="c"># correct nin for ppf vectorization</span>
            <span class="n">_vppf</span> <span class="o">=</span> <span class="n">vectorize</span><span class="p">(</span><span class="n">_drv2_ppfsingle</span><span class="p">,</span> <span class="n">otypes</span><span class="o">=</span><span class="s">&#39;d&#39;</span><span class="p">)</span>
            <span class="n">_vppf</span><span class="o">.</span><span class="n">nin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">numargs</span> <span class="o">+</span> <span class="mi">2</span>  <span class="c"># +1 is for self</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ppfvec</span> <span class="o">=</span> <span class="n">instancemethod</span><span class="p">(</span><span class="n">_vppf</span><span class="p">,</span>
                                          <span class="bp">self</span><span class="p">,</span> <span class="n">rv_discrete</span><span class="p">)</span>

        <span class="c"># now that self.numargs is defined, we can adjust nin</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cdfvec</span><span class="o">.</span><span class="n">nin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">numargs</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="c"># generate docstring for subclass instances</span>
        <span class="k">if</span> <span class="n">longname</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&#39;aeiouAEIOU&#39;</span><span class="p">]:</span>
                <span class="n">hstr</span> <span class="o">=</span> <span class="s">&quot;An &quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">hstr</span> <span class="o">=</span> <span class="s">&quot;A &quot;</span>
            <span class="n">longname</span> <span class="o">=</span> <span class="n">hstr</span> <span class="o">+</span> <span class="n">name</span>

        <span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">optimize</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c"># Skip adding docstrings if interpreter is run with -OO</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__doc__</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_construct_default_doc</span><span class="p">(</span><span class="n">longname</span><span class="o">=</span><span class="n">longname</span><span class="p">,</span>
                                            <span class="n">extradoc</span><span class="o">=</span><span class="n">extradoc</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dct</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">distdiscrete</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_construct_doc</span><span class="p">(</span><span class="n">docdict_discrete</span><span class="p">,</span> <span class="n">dct</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>

            <span class="c">#discrete RV do not have the scale parameter, remove it</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__doc__</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__doc__</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span>
                <span class="s">&#39;</span><span class="se">\n</span><span class="s">    scale : array_like, &#39;</span>
                <span class="s">&#39;optional</span><span class="se">\n</span><span class="s">        scale parameter (default=1)&#39;</span><span class="p">,</span> <span class="s">&#39;&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_construct_default_doc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">longname</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">extradoc</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Construct instance docstring from the rv_discrete template.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">extradoc</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">extradoc</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>
        <span class="k">if</span> <span class="n">extradoc</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\n\n</span><span class="s">&#39;</span><span class="p">):</span>
            <span class="n">extradoc</span> <span class="o">=</span> <span class="n">extradoc</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__doc__</span> <span class="o">=</span> <span class="s">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s">&#39;</span><span class="si">%s</span><span class="s"> discrete random variable.&#39;</span> <span class="o">%</span> <span class="n">longname</span><span class="p">,</span>
                                <span class="s">&#39;</span><span class="se">\n\n</span><span class="si">%(before_notes)s</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">,</span> <span class="n">docheaders</span><span class="p">[</span><span class="s">&#39;notes&#39;</span><span class="p">],</span>
                                <span class="n">extradoc</span><span class="p">,</span> <span class="s">&#39;</span><span class="se">\n</span><span class="si">%(example)s</span><span class="s">&#39;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_construct_doc</span><span class="p">(</span><span class="n">docdict_discrete</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_nonzero</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">floor</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">==</span> <span class="n">k</span>

    <span class="k">def</span> <span class="nf">_pmf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cdf</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cdf</span><span class="p">(</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_logpmf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_pmf</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_cdf_single</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">arange</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">),</span> <span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_pmf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_cdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">floor</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cdfvec</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="c"># generic _logcdf, _sf, _logsf, _ppf, _isf, _rvs defined in rv_generic</span>

    <span class="k">def</span> <span class="nf">rvs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Random variates of given type.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        arg1, arg2, arg3,... : array_like</span>
<span class="sd">            The shape parameter(s) for the distribution (see docstring of the</span>
<span class="sd">            instance object for more information).</span>
<span class="sd">        loc : array_like, optional</span>
<span class="sd">            Location parameter (default=0).</span>
<span class="sd">        size : int or tuple of ints, optional</span>
<span class="sd">            Defining number of random variates (default=1).  Note that `size`</span>
<span class="sd">            has to be given as keyword, not as positional argument.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        rvs : ndarray or scalar</span>
<span class="sd">            Random variates of given `size`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s">&#39;discrete&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">rv_discrete</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">pmf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Probability mass function at k of the given RV.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        k : array_like</span>
<span class="sd">            quantiles</span>
<span class="sd">        arg1, arg2, arg3,... : array_like</span>
<span class="sd">            The shape parameter(s) for the distribution (see docstring of the</span>
<span class="sd">            instance object for more information)</span>
<span class="sd">        loc : array_like, optional</span>
<span class="sd">            Location parameter (default=0).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pmf : array_like</span>
<span class="sd">            Probability mass function evaluated at k</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">args</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_args</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
        <span class="n">k</span><span class="p">,</span> <span class="n">loc</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">asarray</span><span class="p">,</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">loc</span><span class="p">))</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">asarray</span><span class="p">,</span> <span class="n">args</span><span class="p">))</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">((</span><span class="n">k</span><span class="o">-</span><span class="n">loc</span><span class="p">))</span>
        <span class="n">cond0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_argcheck</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="n">cond1</span> <span class="o">=</span> <span class="p">(</span><span class="n">k</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">k</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">)</span> <span class="o">&amp;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nonzero</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="n">cond</span> <span class="o">=</span> <span class="n">cond0</span> <span class="o">&amp;</span> <span class="n">cond1</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="p">(</span><span class="n">cond</span><span class="p">),</span> <span class="s">&#39;d&#39;</span><span class="p">)</span>
        <span class="n">place</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">cond0</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">k</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">badvalue</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">cond</span><span class="p">):</span>
            <span class="n">goodargs</span> <span class="o">=</span> <span class="n">argsreduce</span><span class="p">(</span><span class="n">cond</span><span class="p">,</span> <span class="o">*</span><span class="p">((</span><span class="n">k</span><span class="p">,)</span><span class="o">+</span><span class="n">args</span><span class="p">))</span>
            <span class="n">place</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">cond</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_pmf</span><span class="p">(</span><span class="o">*</span><span class="n">goodargs</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">output</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">output</span><span class="p">[()]</span>
        <span class="k">return</span> <span class="n">output</span>

    <span class="k">def</span> <span class="nf">logpmf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Log of the probability mass function at k of the given RV.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        k : array_like</span>
<span class="sd">            Quantiles.</span>
<span class="sd">        arg1, arg2, arg3,... : array_like</span>
<span class="sd">            The shape parameter(s) for the distribution (see docstring of the</span>
<span class="sd">            instance object for more information).</span>
<span class="sd">        loc : array_like, optional</span>
<span class="sd">            Location parameter. Default is 0.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        logpmf : array_like</span>
<span class="sd">            Log of the probability mass function evaluated at k.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">args</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_args</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
        <span class="n">k</span><span class="p">,</span> <span class="n">loc</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">asarray</span><span class="p">,</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">loc</span><span class="p">))</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">asarray</span><span class="p">,</span> <span class="n">args</span><span class="p">))</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">((</span><span class="n">k</span><span class="o">-</span><span class="n">loc</span><span class="p">))</span>
        <span class="n">cond0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_argcheck</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="n">cond1</span> <span class="o">=</span> <span class="p">(</span><span class="n">k</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">k</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">)</span> <span class="o">&amp;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nonzero</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="n">cond</span> <span class="o">=</span> <span class="n">cond0</span> <span class="o">&amp;</span> <span class="n">cond1</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">empty</span><span class="p">(</span><span class="n">shape</span><span class="p">(</span><span class="n">cond</span><span class="p">),</span> <span class="s">&#39;d&#39;</span><span class="p">)</span>
        <span class="n">output</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">NINF</span><span class="p">)</span>
        <span class="n">place</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">cond0</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">k</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">badvalue</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">cond</span><span class="p">):</span>
            <span class="n">goodargs</span> <span class="o">=</span> <span class="n">argsreduce</span><span class="p">(</span><span class="n">cond</span><span class="p">,</span> <span class="o">*</span><span class="p">((</span><span class="n">k</span><span class="p">,)</span><span class="o">+</span><span class="n">args</span><span class="p">))</span>
            <span class="n">place</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">cond</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_logpmf</span><span class="p">(</span><span class="o">*</span><span class="n">goodargs</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">output</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">output</span><span class="p">[()]</span>
        <span class="k">return</span> <span class="n">output</span>

    <span class="k">def</span> <span class="nf">cdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Cumulative distribution function of the given RV.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        k : array_like, int</span>
<span class="sd">            Quantiles.</span>
<span class="sd">        arg1, arg2, arg3,... : array_like</span>
<span class="sd">            The shape parameter(s) for the distribution (see docstring of the</span>
<span class="sd">            instance object for more information).</span>
<span class="sd">        loc : array_like, optional</span>
<span class="sd">            Location parameter (default=0).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        cdf : ndarray</span>
<span class="sd">            Cumulative distribution function evaluated at `k`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">args</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_args</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
        <span class="n">k</span><span class="p">,</span> <span class="n">loc</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">asarray</span><span class="p">,</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">loc</span><span class="p">))</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">asarray</span><span class="p">,</span> <span class="n">args</span><span class="p">))</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">((</span><span class="n">k</span><span class="o">-</span><span class="n">loc</span><span class="p">))</span>
        <span class="n">cond0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_argcheck</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="n">cond1</span> <span class="o">=</span> <span class="p">(</span><span class="n">k</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">k</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">)</span>
        <span class="n">cond2</span> <span class="o">=</span> <span class="p">(</span><span class="n">k</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">)</span>
        <span class="n">cond</span> <span class="o">=</span> <span class="n">cond0</span> <span class="o">&amp;</span> <span class="n">cond1</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="p">(</span><span class="n">cond</span><span class="p">),</span> <span class="s">&#39;d&#39;</span><span class="p">)</span>
        <span class="n">place</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">cond0</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">k</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">badvalue</span><span class="p">)</span>
        <span class="n">place</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">cond2</span><span class="o">*</span><span class="p">(</span><span class="n">cond0</span> <span class="o">==</span> <span class="n">cond0</span><span class="p">),</span> <span class="mf">1.0</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">cond</span><span class="p">):</span>
            <span class="n">goodargs</span> <span class="o">=</span> <span class="n">argsreduce</span><span class="p">(</span><span class="n">cond</span><span class="p">,</span> <span class="o">*</span><span class="p">((</span><span class="n">k</span><span class="p">,)</span><span class="o">+</span><span class="n">args</span><span class="p">))</span>
            <span class="n">place</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">cond</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cdf</span><span class="p">(</span><span class="o">*</span><span class="n">goodargs</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">output</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">output</span><span class="p">[()]</span>
        <span class="k">return</span> <span class="n">output</span>

    <span class="k">def</span> <span class="nf">logcdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Log of the cumulative distribution function at k of the given RV</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        k : array_like, int</span>
<span class="sd">            Quantiles.</span>
<span class="sd">        arg1, arg2, arg3,... : array_like</span>
<span class="sd">            The shape parameter(s) for the distribution (see docstring of the</span>
<span class="sd">            instance object for more information).</span>
<span class="sd">        loc : array_like, optional</span>
<span class="sd">            Location parameter (default=0).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        logcdf : array_like</span>
<span class="sd">            Log of the cumulative distribution function evaluated at k.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">args</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_args</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
        <span class="n">k</span><span class="p">,</span> <span class="n">loc</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">asarray</span><span class="p">,</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">loc</span><span class="p">))</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">asarray</span><span class="p">,</span> <span class="n">args</span><span class="p">))</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">((</span><span class="n">k</span><span class="o">-</span><span class="n">loc</span><span class="p">))</span>
        <span class="n">cond0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_argcheck</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="n">cond1</span> <span class="o">=</span> <span class="p">(</span><span class="n">k</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">k</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">)</span>
        <span class="n">cond2</span> <span class="o">=</span> <span class="p">(</span><span class="n">k</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">)</span>
        <span class="n">cond</span> <span class="o">=</span> <span class="n">cond0</span> <span class="o">&amp;</span> <span class="n">cond1</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">empty</span><span class="p">(</span><span class="n">shape</span><span class="p">(</span><span class="n">cond</span><span class="p">),</span> <span class="s">&#39;d&#39;</span><span class="p">)</span>
        <span class="n">output</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">NINF</span><span class="p">)</span>
        <span class="n">place</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">cond0</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">k</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">badvalue</span><span class="p">)</span>
        <span class="n">place</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">cond2</span><span class="o">*</span><span class="p">(</span><span class="n">cond0</span> <span class="o">==</span> <span class="n">cond0</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">cond</span><span class="p">):</span>
            <span class="n">goodargs</span> <span class="o">=</span> <span class="n">argsreduce</span><span class="p">(</span><span class="n">cond</span><span class="p">,</span> <span class="o">*</span><span class="p">((</span><span class="n">k</span><span class="p">,)</span><span class="o">+</span><span class="n">args</span><span class="p">))</span>
            <span class="n">place</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">cond</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_logcdf</span><span class="p">(</span><span class="o">*</span><span class="n">goodargs</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">output</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">output</span><span class="p">[()]</span>
        <span class="k">return</span> <span class="n">output</span>

    <span class="k">def</span> <span class="nf">sf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Survival function (1-cdf) at k of the given RV.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        k : array_like</span>
<span class="sd">            Quantiles.</span>
<span class="sd">        arg1, arg2, arg3,... : array_like</span>
<span class="sd">            The shape parameter(s) for the distribution (see docstring of the</span>
<span class="sd">            instance object for more information).</span>
<span class="sd">        loc : array_like, optional</span>
<span class="sd">            Location parameter (default=0).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        sf : array_like</span>
<span class="sd">            Survival function evaluated at k.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">args</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_args</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
        <span class="n">k</span><span class="p">,</span> <span class="n">loc</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">asarray</span><span class="p">,</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">loc</span><span class="p">))</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">asarray</span><span class="p">,</span> <span class="n">args</span><span class="p">))</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">k</span><span class="o">-</span><span class="n">loc</span><span class="p">)</span>
        <span class="n">cond0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_argcheck</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="n">cond1</span> <span class="o">=</span> <span class="p">(</span><span class="n">k</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">k</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">)</span>
        <span class="n">cond2</span> <span class="o">=</span> <span class="p">(</span><span class="n">k</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">cond0</span>
        <span class="n">cond</span> <span class="o">=</span> <span class="n">cond0</span> <span class="o">&amp;</span> <span class="n">cond1</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="p">(</span><span class="n">cond</span><span class="p">),</span> <span class="s">&#39;d&#39;</span><span class="p">)</span>
        <span class="n">place</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">cond0</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">k</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">badvalue</span><span class="p">)</span>
        <span class="n">place</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">cond2</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">cond</span><span class="p">):</span>
            <span class="n">goodargs</span> <span class="o">=</span> <span class="n">argsreduce</span><span class="p">(</span><span class="n">cond</span><span class="p">,</span> <span class="o">*</span><span class="p">((</span><span class="n">k</span><span class="p">,)</span><span class="o">+</span><span class="n">args</span><span class="p">))</span>
            <span class="n">place</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">cond</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sf</span><span class="p">(</span><span class="o">*</span><span class="n">goodargs</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">output</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">output</span><span class="p">[()]</span>
        <span class="k">return</span> <span class="n">output</span>

    <span class="k">def</span> <span class="nf">logsf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Log of the survival function of the given RV.</span>

<span class="sd">        Returns the log of the &quot;survival function,&quot; defined as ``1 - cdf``,</span>
<span class="sd">        evaluated at `k`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        k : array_like</span>
<span class="sd">            Quantiles.</span>
<span class="sd">        arg1, arg2, arg3,... : array_like</span>
<span class="sd">            The shape parameter(s) for the distribution (see docstring of the</span>
<span class="sd">            instance object for more information).</span>
<span class="sd">        loc : array_like, optional</span>
<span class="sd">            Location parameter (default=0).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        logsf : ndarray</span>
<span class="sd">            Log of the survival function evaluated at `k`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">args</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_args</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
        <span class="n">k</span><span class="p">,</span> <span class="n">loc</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">asarray</span><span class="p">,</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">loc</span><span class="p">))</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">asarray</span><span class="p">,</span> <span class="n">args</span><span class="p">))</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">k</span><span class="o">-</span><span class="n">loc</span><span class="p">)</span>
        <span class="n">cond0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_argcheck</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="n">cond1</span> <span class="o">=</span> <span class="p">(</span><span class="n">k</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">k</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">)</span>
        <span class="n">cond2</span> <span class="o">=</span> <span class="p">(</span><span class="n">k</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">cond0</span>
        <span class="n">cond</span> <span class="o">=</span> <span class="n">cond0</span> <span class="o">&amp;</span> <span class="n">cond1</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">empty</span><span class="p">(</span><span class="n">shape</span><span class="p">(</span><span class="n">cond</span><span class="p">),</span> <span class="s">&#39;d&#39;</span><span class="p">)</span>
        <span class="n">output</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">NINF</span><span class="p">)</span>
        <span class="n">place</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">cond0</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">k</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">badvalue</span><span class="p">)</span>
        <span class="n">place</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">cond2</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">cond</span><span class="p">):</span>
            <span class="n">goodargs</span> <span class="o">=</span> <span class="n">argsreduce</span><span class="p">(</span><span class="n">cond</span><span class="p">,</span> <span class="o">*</span><span class="p">((</span><span class="n">k</span><span class="p">,)</span><span class="o">+</span><span class="n">args</span><span class="p">))</span>
            <span class="n">place</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">cond</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_logsf</span><span class="p">(</span><span class="o">*</span><span class="n">goodargs</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">output</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">output</span><span class="p">[()]</span>
        <span class="k">return</span> <span class="n">output</span>

    <span class="k">def</span> <span class="nf">ppf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Percent point function (inverse of cdf) at q of the given RV</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        q : array_like</span>
<span class="sd">            Lower tail probability.</span>
<span class="sd">        arg1, arg2, arg3,... : array_like</span>
<span class="sd">            The shape parameter(s) for the distribution (see docstring of the</span>
<span class="sd">            instance object for more information).</span>
<span class="sd">        loc : array_like, optional</span>
<span class="sd">            Location parameter (default=0).</span>
<span class="sd">        scale : array_like, optional</span>
<span class="sd">            Scale parameter (default=1).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        k : array_like</span>
<span class="sd">            Quantile corresponding to the lower tail probability, q.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">args</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_args</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
        <span class="n">q</span><span class="p">,</span> <span class="n">loc</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">asarray</span><span class="p">,</span> <span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">loc</span><span class="p">))</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">asarray</span><span class="p">,</span> <span class="n">args</span><span class="p">))</span>
        <span class="n">cond0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_argcheck</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">loc</span> <span class="o">==</span> <span class="n">loc</span><span class="p">)</span>
        <span class="n">cond1</span> <span class="o">=</span> <span class="p">(</span><span class="n">q</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">q</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">cond2</span> <span class="o">=</span> <span class="p">(</span><span class="n">q</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">cond0</span>
        <span class="n">cond</span> <span class="o">=</span> <span class="n">cond0</span> <span class="o">&amp;</span> <span class="n">cond1</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">valarray</span><span class="p">(</span><span class="n">shape</span><span class="p">(</span><span class="n">cond</span><span class="p">),</span> <span class="n">value</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">badvalue</span><span class="p">,</span> <span class="n">typecode</span><span class="o">=</span><span class="s">&#39;d&#39;</span><span class="p">)</span>
        <span class="c"># output type &#39;d&#39; to handle nin and inf</span>
        <span class="n">place</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="p">(</span><span class="n">q</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">cond</span> <span class="o">==</span> <span class="n">cond</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">place</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">cond2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">cond</span><span class="p">):</span>
            <span class="n">goodargs</span> <span class="o">=</span> <span class="n">argsreduce</span><span class="p">(</span><span class="n">cond</span><span class="p">,</span> <span class="o">*</span><span class="p">((</span><span class="n">q</span><span class="p">,)</span><span class="o">+</span><span class="n">args</span><span class="o">+</span><span class="p">(</span><span class="n">loc</span><span class="p">,)))</span>
            <span class="n">loc</span><span class="p">,</span> <span class="n">goodargs</span> <span class="o">=</span> <span class="n">goodargs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">goodargs</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">place</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">cond</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ppf</span><span class="p">(</span><span class="o">*</span><span class="n">goodargs</span><span class="p">)</span> <span class="o">+</span> <span class="n">loc</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">output</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">output</span><span class="p">[()]</span>
        <span class="k">return</span> <span class="n">output</span>

    <span class="k">def</span> <span class="nf">isf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Inverse survival function (inverse of `sf`) at q of the given RV.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        q : array_like</span>
<span class="sd">            Upper tail probability.</span>
<span class="sd">        arg1, arg2, arg3,... : array_like</span>
<span class="sd">            The shape parameter(s) for the distribution (see docstring of the</span>
<span class="sd">            instance object for more information).</span>
<span class="sd">        loc : array_like, optional</span>
<span class="sd">            Location parameter (default=0).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        k : ndarray or scalar</span>
<span class="sd">            Quantile corresponding to the upper tail probability, q.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">args</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_args</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
        <span class="n">q</span><span class="p">,</span> <span class="n">loc</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">asarray</span><span class="p">,</span> <span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">loc</span><span class="p">))</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">asarray</span><span class="p">,</span> <span class="n">args</span><span class="p">))</span>
        <span class="n">cond0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_argcheck</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">loc</span> <span class="o">==</span> <span class="n">loc</span><span class="p">)</span>
        <span class="n">cond1</span> <span class="o">=</span> <span class="p">(</span><span class="n">q</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">q</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">cond2</span> <span class="o">=</span> <span class="p">(</span><span class="n">q</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">cond0</span>
        <span class="n">cond</span> <span class="o">=</span> <span class="n">cond0</span> <span class="o">&amp;</span> <span class="n">cond1</span>

        <span class="c"># same problem as with ppf; copied from ppf and changed</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">valarray</span><span class="p">(</span><span class="n">shape</span><span class="p">(</span><span class="n">cond</span><span class="p">),</span> <span class="n">value</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">badvalue</span><span class="p">,</span> <span class="n">typecode</span><span class="o">=</span><span class="s">&#39;d&#39;</span><span class="p">)</span>
        <span class="c"># output type &#39;d&#39; to handle nin and inf</span>
        <span class="n">place</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="p">(</span><span class="n">q</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">cond</span> <span class="o">==</span> <span class="n">cond</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">)</span>
        <span class="n">place</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">cond2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="c"># call place only if at least 1 valid argument</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">cond</span><span class="p">):</span>
            <span class="n">goodargs</span> <span class="o">=</span> <span class="n">argsreduce</span><span class="p">(</span><span class="n">cond</span><span class="p">,</span> <span class="o">*</span><span class="p">((</span><span class="n">q</span><span class="p">,)</span><span class="o">+</span><span class="n">args</span><span class="o">+</span><span class="p">(</span><span class="n">loc</span><span class="p">,)))</span>
            <span class="n">loc</span><span class="p">,</span> <span class="n">goodargs</span> <span class="o">=</span> <span class="n">goodargs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">goodargs</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="c"># PB same as ticket 766</span>
            <span class="n">place</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">cond</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_isf</span><span class="p">(</span><span class="o">*</span><span class="n">goodargs</span><span class="p">)</span> <span class="o">+</span> <span class="n">loc</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">output</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">output</span><span class="p">[()]</span>
        <span class="k">return</span> <span class="n">output</span>

    <span class="k">def</span> <span class="nf">_entropy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;pk&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">entropy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pk</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mu</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="p">{</span><span class="s">&#39;moments&#39;</span><span class="p">:</span> <span class="s">&#39;m&#39;</span><span class="p">}))</span>
            <span class="n">val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pmf</span><span class="p">(</span><span class="n">mu</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
            <span class="n">ent</span> <span class="o">=</span> <span class="n">entr</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
            <span class="n">k</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">term</span> <span class="o">=</span> <span class="mf">1.0</span>
            <span class="k">while</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">term</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">_EPS</span><span class="p">):</span>
                <span class="n">val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pmf</span><span class="p">(</span><span class="n">mu</span><span class="o">+</span><span class="n">k</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
                <span class="n">term</span> <span class="o">=</span> <span class="n">entr</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
                <span class="n">val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pmf</span><span class="p">(</span><span class="n">mu</span><span class="o">-</span><span class="n">k</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
                <span class="n">term</span> <span class="o">+=</span> <span class="n">entr</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
                <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">ent</span> <span class="o">+=</span> <span class="n">term</span>
            <span class="k">return</span> <span class="n">ent</span>

    <span class="k">def</span> <span class="nf">expect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(),</span> <span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">lb</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">ub</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
               <span class="n">conditional</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate expected value of a function with respect to the distribution</span>
<span class="sd">        for discrete distribution</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fn : function (default: identity mapping)</span>
<span class="sd">            Function for which sum is calculated. Takes only one argument.</span>
<span class="sd">        args : tuple</span>
<span class="sd">            argument (parameters) of the distribution</span>
<span class="sd">        lb, ub : numbers, optional</span>
<span class="sd">            lower and upper bound for integration, default is set to the</span>
<span class="sd">            support of the distribution, lb and ub are inclusive (ul&lt;=k&lt;=ub)</span>
<span class="sd">        conditional : bool, optional</span>
<span class="sd">            Default is False.</span>
<span class="sd">            If true then the expectation is corrected by the conditional</span>
<span class="sd">            probability of the integration interval. The return value is the</span>
<span class="sd">            expectation of the function, conditional on being in the given</span>
<span class="sd">            interval (k such that ul&lt;=k&lt;=ub).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        expect : float</span>
<span class="sd">            Expected value.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        * function is not vectorized</span>
<span class="sd">        * accuracy: uses self.moment_tol as stopping criterium</span>
<span class="sd">          for heavy tailed distribution e.g. zipf(4), accuracy for</span>
<span class="sd">          mean, variance in example is only 1e-5,</span>
<span class="sd">          increasing precision (moment_tol) makes zipf very slow</span>
<span class="sd">        * suppnmin=100 internal parameter for minimum number of points to</span>
<span class="sd">          evaluate could be added as keyword parameter, to evaluate functions</span>
<span class="sd">          with non-monotonic shapes, points include integers in (-suppnmin,</span>
<span class="sd">          suppnmin)</span>
<span class="sd">        * uses maxcount=1000 limits the number of points that are evaluated</span>
<span class="sd">          to break loop for infinite sums</span>
<span class="sd">          (a maximum of suppnmin+1000 positive plus suppnmin+1000 negative</span>
<span class="sd">          integers are evaluated)</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c"># moment_tol = 1e-12 # increase compared to self.moment_tol,</span>
        <span class="c"># too slow for only small gain in precision for zipf</span>

        <span class="c"># avoid endless loop with unbound integral, eg. var of zipf(2)</span>
        <span class="n">maxcount</span> <span class="o">=</span> <span class="mi">1000</span>
        <span class="n">suppnmin</span> <span class="o">=</span> <span class="mi">100</span>  <span class="c"># minimum number of points to evaluate (+ and -)</span>

        <span class="k">if</span> <span class="n">func</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">fun</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
                <span class="c"># loc and args from outer scope</span>
                <span class="k">return</span> <span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="n">loc</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_pmf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">fun</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
                <span class="c"># loc and args from outer scope</span>
                <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="n">loc</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_pmf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="c"># used pmf because _pmf does not check support in randint and there</span>
        <span class="c"># might be problems(?) with correct self.a, self.b at this stage maybe</span>
        <span class="c"># not anymore, seems to work now with _pmf</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_argcheck</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>  <span class="c"># (re)generate scalar self.a and self.b</span>
        <span class="k">if</span> <span class="n">lb</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">lb</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lb</span> <span class="o">=</span> <span class="n">lb</span> <span class="o">-</span> <span class="n">loc</span>   <span class="c"># convert bound for standardized distribution</span>
        <span class="k">if</span> <span class="n">ub</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">ub</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ub</span> <span class="o">=</span> <span class="n">ub</span> <span class="o">-</span> <span class="n">loc</span>   <span class="c"># convert bound for standardized distribution</span>
        <span class="k">if</span> <span class="n">conditional</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isposinf</span><span class="p">(</span><span class="n">ub</span><span class="p">)[()]:</span>
                <span class="c"># work around bug: stats.poisson.sf(stats.poisson.b, 2) is nan</span>
                <span class="n">invfac</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">lb</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">invfac</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">lb</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">sf</span><span class="p">(</span><span class="n">ub</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">invfac</span> <span class="o">=</span> <span class="mf">1.0</span>

        <span class="n">tot</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">low</span><span class="p">,</span> <span class="n">upp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ppf</span><span class="p">(</span><span class="mf">0.001</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ppf</span><span class="p">(</span><span class="mf">0.999</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="n">low</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="o">-</span><span class="n">suppnmin</span><span class="p">,</span> <span class="n">low</span><span class="p">),</span> <span class="n">lb</span><span class="p">)</span>
        <span class="n">upp</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">suppnmin</span><span class="p">,</span> <span class="n">upp</span><span class="p">),</span> <span class="n">ub</span><span class="p">)</span>
        <span class="n">supp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">low</span><span class="p">,</span> <span class="n">upp</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">inc</span><span class="p">)</span>  <span class="c"># check limits</span>
        <span class="n">tot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">fun</span><span class="p">(</span><span class="n">supp</span><span class="p">))</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="mf">1e100</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="n">upp</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">inc</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c"># handle cases with infinite support</span>

        <span class="k">while</span> <span class="p">(</span><span class="n">pos</span> <span class="o">&lt;=</span> <span class="n">ub</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">diff</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">moment_tol</span><span class="p">)</span> <span class="ow">and</span> <span class="n">count</span> <span class="o">&lt;=</span> <span class="n">maxcount</span><span class="p">:</span>
            <span class="n">diff</span> <span class="o">=</span> <span class="n">fun</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span>
            <span class="n">tot</span> <span class="o">+=</span> <span class="n">diff</span>
            <span class="n">pos</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inc</span>
            <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>  <span class="c"># handle case when self.a = -inf</span>
            <span class="n">diff</span> <span class="o">=</span> <span class="mf">1e100</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="n">low</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">inc</span>
            <span class="k">while</span> <span class="p">((</span><span class="n">pos</span> <span class="o">&gt;=</span> <span class="n">lb</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">diff</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">moment_tol</span><span class="p">)</span> <span class="ow">and</span>
                   <span class="n">count</span> <span class="o">&lt;=</span> <span class="n">maxcount</span><span class="p">):</span>
                <span class="n">diff</span> <span class="o">=</span> <span class="n">fun</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span>
                <span class="n">tot</span> <span class="o">+=</span> <span class="n">diff</span>
                <span class="n">pos</span> <span class="o">-=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inc</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">count</span> <span class="o">&gt;</span> <span class="n">maxcount</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&#39;expect(): sum did not converge&#39;</span><span class="p">,</span> <span class="ne">RuntimeWarning</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tot</span><span class="o">/</span><span class="n">invfac</span>


<span class="k">def</span> <span class="nf">get_distribution_names</span><span class="p">(</span><span class="n">namespace_pairs</span><span class="p">,</span> <span class="n">rv_base_class</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Collect names of statistical distributions and their generators.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    namespace_pairs : sequence</span>
<span class="sd">        A snapshot of (name, value) pairs in the namespace of a module.</span>
<span class="sd">    rv_base_class : class</span>
<span class="sd">        The base class of random variable generator classes in a module.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    distn_names : list of strings</span>
<span class="sd">        Names of the statistical distributions.</span>
<span class="sd">    distn_gen_names : list of strings</span>
<span class="sd">        Names of the generators of the statistical distributions.</span>
<span class="sd">        Note that these are not simply the names of the statistical</span>
<span class="sd">        distributions, with a _gen suffix added.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">distn_names</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">distn_gen_names</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">namespace_pairs</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&#39;_&#39;</span><span class="p">):</span>
            <span class="k">continue</span>
        <span class="k">if</span> <span class="n">name</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s">&#39;_gen&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">rv_base_class</span><span class="p">):</span>
            <span class="n">distn_gen_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">rv_base_class</span><span class="p">):</span>
            <span class="n">distn_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">distn_names</span><span class="p">,</span> <span class="n">distn_gen_names</span>
</pre></div>




          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2009-2013, Josef Perktold, Skipper Seabold, Jonathan Taylor, statsmodels-developers.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.1.
    </div>
  </body>
</html>