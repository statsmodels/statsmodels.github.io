
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>statsmodels.genmod.generalized_estimating_equations &mdash; statsmodels 0.6.1 documentation</title>
    
    <link rel="stylesheet" href="../../../_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '0.6.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <link rel="shortcut icon" href="../../../_static/statsmodels_hybi_favico.ico"/>
    <link rel="author" title="About these documents" href="../../../about.html" />
    <link rel="top" title="statsmodels 0.6.1 documentation" href="../../../index.html" />
    <link rel="up" title="Module code" href="../../index.html" />
<link rel="stylesheet" href="../../_static/facebox.css" type="text/css" />
<link rel="stylesheet" href="../_static/examples.css" type="text/css" />
<script type="text/javascript" src="../../../_static/scripts.js">
</script>
<script type="text/javascript" src="../../../_static/facebox.js">
</script>

  </head>
  <body role="document">
<div class="headerwrap">
    <div class = "header">
        
        <a href = "../../../index.html">
<img src="../../../_static/statsmodels_hybi_banner.png" alt="Logo"
    style="padding-left: 15px"/></a>
        
    </div>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
<li><a href ="../../../install.html">Install</a></li> &nbsp;|&nbsp;
<li><a href="https://groups.google.com/group/pystatsmodels?hl=en">Support</a></li> &nbsp;|&nbsp;
<li><a href="https://github.com/statsmodels/statsmodels/issues">Bugs</a></li> &nbsp;|&nbsp;
<li><a href="../../../dev/index.html">Develop</a></li> &nbsp;|&nbsp;
<li><a href="../../../examples/index.html">Examples</a></li> &nbsp;|&nbsp;
<li><a href="../../../faq.html">FAQ</a></li> &nbsp;|&nbsp;

          <li class="nav-item nav-item-1"><a href="../../index.html" accesskey="U">Module code</a> |</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            




  <h1>Source code for statsmodels.genmod.generalized_estimating_equations</h1><div class="highlight"><pre>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Procedures for fitting marginal regression models to dependent data</span>
<span class="sd">using Generalized Estimating Equations.</span>

<span class="sd">References</span>
<span class="sd">----------</span>
<span class="sd">KY Liang and S Zeger. &quot;Longitudinal data analysis using</span>
<span class="sd">generalized linear models&quot;. Biometrika (1986) 73 (1): 13-22.</span>

<span class="sd">S Zeger and KY Liang. &quot;Longitudinal Data Analysis for Discrete and</span>
<span class="sd">Continuous Outcomes&quot;. Biometrics Vol. 42, No. 1 (Mar., 1986),</span>
<span class="sd">pp. 121-130</span>

<span class="sd">A Rotnitzky and NP Jewell (1990). &quot;Hypothesis testing of regression</span>
<span class="sd">parameters in semiparametric generalized linear models for cluster</span>
<span class="sd">correlated data&quot;, Biometrika, 77, 485-497.</span>

<span class="sd">Xu Guo and Wei Pan (2002). &quot;Small sample performance of the score</span>
<span class="sd">test in GEE&quot;.</span>
<span class="sd">http://www.sph.umn.edu/faculty1/wp-content/uploads/2012/11/rr2002-013.pdf</span>

<span class="sd">LA Mancl LA, TA DeRouen (2001). A covariance estimator for GEE with</span>
<span class="sd">improved small-sample properties.  Biometrics. 2001 Mar;57(1):126-34.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">statsmodels.compat.python</span> <span class="kn">import</span> <span class="n">iterkeys</span><span class="p">,</span> <span class="nb">range</span><span class="p">,</span> <span class="n">lrange</span><span class="p">,</span> <span class="n">lzip</span><span class="p">,</span> <span class="nb">zip</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">stats</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="kn">as</span> <span class="nn">pd</span>

<span class="kn">from</span> <span class="nn">statsmodels.tools.decorators</span> <span class="kn">import</span> <span class="p">(</span><span class="n">cache_readonly</span><span class="p">,</span>
    <span class="n">resettable_cache</span><span class="p">)</span>
<span class="kn">import</span> <span class="nn">statsmodels.base.model</span> <span class="kn">as</span> <span class="nn">base</span>
<span class="c"># used for wrapper:</span>
<span class="kn">import</span> <span class="nn">statsmodels.regression.linear_model</span> <span class="kn">as</span> <span class="nn">lm</span>
<span class="kn">import</span> <span class="nn">statsmodels.base.wrapper</span> <span class="kn">as</span> <span class="nn">wrap</span>

<span class="kn">from</span> <span class="nn">statsmodels.genmod</span> <span class="kn">import</span> <span class="n">families</span>
<span class="kn">from</span> <span class="nn">statsmodels.genmod.cov_struct</span> <span class="kn">import</span> <span class="p">(</span><span class="n">Independence</span><span class="p">,</span>
                                           <span class="n">GlobalOddsRatio</span><span class="p">,</span>
                                           <span class="n">CovStruct</span><span class="p">)</span>
<span class="kn">import</span> <span class="nn">statsmodels.genmod.families.varfuncs</span> <span class="kn">as</span> <span class="nn">varfuncs</span>
<span class="kn">from</span> <span class="nn">statsmodels.genmod.families.links</span> <span class="kn">import</span> <span class="n">Link</span>

<span class="kn">from</span> <span class="nn">statsmodels.tools.sm_exceptions</span> <span class="kn">import</span> <span class="p">(</span><span class="n">ConvergenceWarning</span><span class="p">,</span>
                                             <span class="n">IterationLimitWarning</span><span class="p">)</span>
<span class="kn">import</span> <span class="nn">warnings</span>


<span class="c"># Workaround for block_diag, not available until scipy version</span>
<span class="c"># 0.11. When the statsmodels scipy dependency moves to version 0.11,</span>
<span class="c"># we can remove this function and use:</span>
<span class="c"># from scipy.sparse import block_diag</span>
<span class="k">def</span> <span class="nf">block_diag</span><span class="p">(</span><span class="n">dblocks</span><span class="p">,</span> <span class="n">format</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>

    <span class="kn">from</span> <span class="nn">scipy.sparse</span> <span class="kn">import</span> <span class="n">bmat</span>

    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dblocks</span><span class="p">)</span>
    <span class="n">blocks</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">b</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">,]</span> <span class="o">*</span> <span class="n">n</span>
        <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">dblocks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">blocks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">bmat</span><span class="p">(</span><span class="n">blocks</span><span class="p">,</span> <span class="n">format</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">ParameterConstraint</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A class for managing linear equality constraints for a parameter</span>
<span class="sd">    vector.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">,</span> <span class="n">exog</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        lhs : ndarray</span>
<span class="sd">           A q x p matrix which is the left hand side of the</span>
<span class="sd">           constraint lhs * param = rhs.  The number of constraints is</span>
<span class="sd">           q &gt;= 1 and p is the dimension of the parameter vector.</span>
<span class="sd">        rhs : ndarray</span>
<span class="sd">          A 1-dimensional vector of length q which is the right hand</span>
<span class="sd">          side of the constraint equation.</span>
<span class="sd">        exog : ndarray</span>
<span class="sd">          The n x p exognenous data for the full model.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c"># In case a row or column vector is passed (patsy linear</span>
        <span class="c"># constraints passes a column vector).</span>
        <span class="n">rhs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">rhs</span><span class="o">.</span><span class="n">squeeze</span><span class="p">())</span>

        <span class="k">if</span> <span class="n">rhs</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;The right hand side of the constraint &quot;</span>
                             <span class="s">&quot;must be a vector.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">rhs</span><span class="p">)</span> <span class="o">!=</span> <span class="n">lhs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;The number of rows of the left hand &quot;</span>
                             <span class="s">&quot;side constraint matrix L must equal &quot;</span>
                             <span class="s">&quot;the length of the right hand side &quot;</span>
                             <span class="s">&quot;constraint vector R.&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">lhs</span> <span class="o">=</span> <span class="n">lhs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rhs</span> <span class="o">=</span> <span class="n">rhs</span>

        <span class="c"># The columns of lhs0 are an orthogonal basis for the</span>
        <span class="c"># orthogonal complement to row(lhs), the columns of lhs1 are</span>
        <span class="c"># an orthogonal basis for row(lhs).  The columns of lhsf =</span>
        <span class="c"># [lhs0, lhs1] are mutually orthogonal.</span>
        <span class="n">lhs_u</span><span class="p">,</span> <span class="n">lhs_s</span><span class="p">,</span> <span class="n">lhs_vt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">lhs</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">full_matrices</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lhs0</span> <span class="o">=</span> <span class="n">lhs_u</span><span class="p">[:,</span> <span class="nb">len</span><span class="p">(</span><span class="n">lhs_s</span><span class="p">):]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lhs1</span> <span class="o">=</span> <span class="n">lhs_u</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="n">lhs_s</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lhsf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">lhs0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lhs1</span><span class="p">))</span>

        <span class="c"># param0 is one solution to the underdetermined system</span>
        <span class="c"># L * param = R.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">param0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lhs1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">lhs_vt</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rhs</span><span class="p">)</span> <span class="o">/</span>
                             <span class="n">lhs_s</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_offset_increment</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">exog</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">param0</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">orig_exog</span> <span class="o">=</span> <span class="n">exog</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">exog_fulltrans</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">exog</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lhsf</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">offset_increment</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a vector that should be added to the offset vector to</span>
<span class="sd">        accommodate the constraint.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        exog : array-like</span>
<span class="sd">           The exogeneous data for the model.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_offset_increment</span>

    <span class="k">def</span> <span class="nf">reduced_exog</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a linearly transformed exog matrix whose columns span</span>
<span class="sd">        the constrained model space.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        exog : array-like</span>
<span class="sd">           The exogeneous data for the model.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">exog_fulltrans</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">lhs0</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>

    <span class="k">def</span> <span class="nf">restore_exog</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the full exog matrix before it was reduced to</span>
<span class="sd">        satisfy the constraint.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">orig_exog</span>

    <span class="k">def</span> <span class="nf">unpack_param</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts the parameter vector `params` from reduced to full</span>
<span class="sd">        coordinates.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">param0</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lhs0</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">unpack_cov</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bcov</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts the covariance matrix `bcov` from reduced to full</span>
<span class="sd">        coordinates.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lhs0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">bcov</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lhs0</span><span class="o">.</span><span class="n">T</span><span class="p">))</span>


<span class="n">_gee_init_doc</span> <span class="o">=</span> <span class="s">&quot;&quot;&quot;</span>
<span class="s">    GEE can be used to fit Generalized Linear Models (GLMs) when the</span>
<span class="s">    data have a grouped structure, and the observations are possibly</span>
<span class="s">    correlated within groups but not between groups.</span>

<span class="s">    Parameters</span>
<span class="s">    ----------</span>
<span class="s">    endog : array-like</span>
<span class="s">        1d array of endogenous values (i.e. responses, outcomes,</span>
<span class="s">        dependent variables, or &#39;Y&#39; values).</span>
<span class="s">    exog : array-like</span>
<span class="s">        2d array of exogeneous values (i.e. covariates, predictors,</span>
<span class="s">        independent variables, regressors, or &#39;X&#39; values). A nobs x k</span>
<span class="s">        array where `nobs` is the number of observations and `k` is</span>
<span class="s">        the number of regressors. An intercept is not included by</span>
<span class="s">        default and should be added by the user. See</span>
<span class="s">        `statsmodels.tools.add_constant`.</span>
<span class="s">    groups : array-like</span>
<span class="s">        A 1d array of length `nobs` containing the group labels.</span>
<span class="s">    time : array-like</span>
<span class="s">        A 2d array of time (or other index) values, used by some</span>
<span class="s">        dependence structures to define similarity relationships among</span>
<span class="s">        observations within a cluster.</span>
<span class="s">    family : family class instance</span>
<span class="si">%(family_doc)s</span><span class="s"></span>
<span class="s">    cov_struct : CovStruct class instance</span>
<span class="s">        The default is Independence.  To specify an exchangeable</span>
<span class="s">        structure use cov_struct = Exchangeable().  See</span>
<span class="s">        statsmodels.genmod.cov_struct.CovStruct for more</span>
<span class="s">        information.</span>
<span class="s">    offset : array-like</span>
<span class="s">        An offset to be included in the fit.  If provided, must be</span>
<span class="s">        an array whose length is the number of rows in exog.</span>
<span class="s">    dep_data : array-like</span>
<span class="s">        Additional data passed to the dependence structure.</span>
<span class="s">    constraint : (ndarray, ndarray)</span>
<span class="s">        If provided, the constraint is a tuple (L, R) such that the</span>
<span class="s">        model parameters are estimated under the constraint L *</span>
<span class="s">        param = R, where L is a q x p matrix and R is a</span>
<span class="s">        q-dimensional vector.  If constraint is provided, a score</span>
<span class="s">        test is performed to compare the constrained model to the</span>
<span class="s">        unconstrained model.</span>
<span class="s">    update_dep : bool</span>
<span class="s">        If true, the dependence parameters are optimized, otherwise</span>
<span class="s">        they are held fixed at their starting values.</span>
<span class="s">    </span><span class="si">%(extra_params)s</span><span class="s"></span>

<span class="s">    See Also</span>
<span class="s">    --------</span>
<span class="s">    statsmodels.genmod.families.family</span>
<span class="s">    :ref:`families`</span>
<span class="s">    :ref:`links`</span>

<span class="s">    Notes</span>
<span class="s">    -----</span>
<span class="s">    Only the following combinations make sense for family and link ::</span>

<span class="s">                   + ident log logit probit cloglog pow opow nbinom loglog logc</span>
<span class="s">      Gaussian     |   x    x                        x</span>
<span class="s">      inv Gaussian |   x    x                        x</span>
<span class="s">      binomial     |   x    x    x     x       x     x    x           x      x</span>
<span class="s">      Poission     |   x    x                        x</span>
<span class="s">      neg binomial |   x    x                        x          x</span>
<span class="s">      gamma        |   x    x                        x</span>

<span class="s">    Not all of these link functions are currently available.</span>

<span class="s">    Endog and exog are references so that if the data they refer</span>
<span class="s">    to are already arrays and these arrays are changed, endog and</span>
<span class="s">    exog will change.</span>

<span class="s">    The &quot;robust&quot; covariance type is the standard &quot;sandwich estimator&quot;</span>
<span class="s">    (e.g. Liang and Zeger (1986)).  It is the default here and in most</span>
<span class="s">    other packages.  The &quot;naive&quot; estimator gives smaller standard</span>
<span class="s">    errors, but is only correct if the working correlation structure</span>
<span class="s">    is correctly specified.  The &quot;bias reduced&quot; estimator of Mancl and</span>
<span class="s">    DeRouen (Biometrics, 2001) reduces the downard bias of the robust</span>
<span class="s">    estimator.</span>

<span class="s">    Examples</span>
<span class="s">    --------</span>
<span class="s">    </span><span class="si">%(example)s</span><span class="s"></span>
<span class="s">&quot;&quot;&quot;</span>

<span class="n">_gee_family_doc</span> <span class="o">=</span> <span class="s">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s">        The default is Gaussian.  To specify the binomial</span>
<span class="s">        distribution use `family=sm.family.Binomial()`. Each family</span>
<span class="s">        can take a link instance as an argument.  See</span>
<span class="s">        statsmodels.family.family for more information.&quot;&quot;&quot;</span>

<span class="n">_gee_ordinal_family_doc</span> <span class="o">=</span> <span class="s">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s">        The only family supported is `Binomial`.  The default `Logit`</span>
<span class="s">        link may be replaced with `probit` if desired.&quot;&quot;&quot;</span>

<span class="n">_gee_nominal_family_doc</span> <span class="o">=</span> <span class="s">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s">        The default value `None` uses a multinomial logit family</span>
<span class="s">        specifically designed for use with GEE.  Setting this</span>
<span class="s">        argument to a non-default value is not currently supported.&quot;&quot;&quot;</span>

<span class="n">_gee_fit_doc</span> <span class="o">=</span> <span class="s">&quot;&quot;&quot;</span>
<span class="s">    Fits a marginal regression model using generalized estimating</span>
<span class="s">    equations (GEE).</span>

<span class="s">    Parameters</span>
<span class="s">    ----------</span>
<span class="s">    maxiter : integer</span>
<span class="s">        The maximum number of iterations</span>
<span class="s">    ctol : float</span>
<span class="s">        The convergence criterion for stopping the Gauss-Seidel</span>
<span class="s">        iterations</span>
<span class="s">    start_params : array-like</span>
<span class="s">        A vector of starting values for the regression</span>
<span class="s">        coefficients.  If None, a default is chosen.</span>
<span class="s">    params_niter : integer</span>
<span class="s">        The number of Gauss-Seidel updates of the mean structure</span>
<span class="s">        parameters that take place prior to each update of the</span>
<span class="s">        dependence structure.</span>
<span class="s">    first_dep_update : integer</span>
<span class="s">        No dependence structure updates occur before this</span>
<span class="s">        iteration number.</span>
<span class="s">    cov_type : string</span>
<span class="s">        One of &quot;robust&quot;, &quot;naive&quot;, or &quot;bias_reduced&quot;.</span>

<span class="s">    Returns</span>
<span class="s">    -------</span>
<span class="s">    An instance of the GEEResults class or subclass</span>

<span class="s">    Notes</span>
<span class="s">    -----</span>
<span class="s">    If convergence difficulties occur, increase the values of</span>
<span class="s">    `first_dep_update` and/or `params_niter`.  Setting</span>
<span class="s">    `first_dep_update` to a greater value (e.g. ~10-20) causes the</span>
<span class="s">    algorithm to move close to the GLM solution before attempting</span>
<span class="s">    to identify the dependence structure.</span>

<span class="s">    For the Gaussian family, there is no benefit to setting</span>
<span class="s">    `params_niter` to a value greater than 1, since the mean</span>
<span class="s">    structure parameters converge in one step.</span>
<span class="s">&quot;&quot;&quot;</span>

<span class="n">_gee_results_doc</span> <span class="o">=</span> <span class="s">&quot;&quot;&quot;</span>
<span class="s">    Returns</span>
<span class="s">    -------</span>
<span class="s">    **Attributes**</span>

<span class="s">    cov_params_default : ndarray</span>
<span class="s">        default covariance of the parameter estimates. Is chosen among one</span>
<span class="s">        of the following three based on `cov_type`</span>
<span class="s">    cov_robust : ndarray</span>
<span class="s">        covariance of the parameter estimates that is robust</span>
<span class="s">    cov_naive : ndarray</span>
<span class="s">        covariance of the parameter estimates that is not robust to</span>
<span class="s">        correlation or variance misspecification</span>
<span class="s">    cov_robust_bc : ndarray</span>
<span class="s">        covariance of the parameter estimates that is robust and bias</span>
<span class="s">        reduced</span>
<span class="s">    converged : bool</span>
<span class="s">        indicator for convergence of the optimization.</span>
<span class="s">        True if the norm of the score is smaller than a threshold</span>
<span class="s">    cov_type : string</span>
<span class="s">        string indicating whether a &quot;robust&quot;, &quot;naive&quot; or &quot;bias_reduced&quot;</span>
<span class="s">        covariance is used as default</span>
<span class="s">    fit_history : dict</span>
<span class="s">        Contains information about the iterations.</span>
<span class="s">    fittedvalues : array</span>
<span class="s">        Linear predicted values for the fitted model.</span>
<span class="s">        dot(exog, params)</span>
<span class="s">    model : class instance</span>
<span class="s">        Pointer to GEE model instance that called `fit`.</span>
<span class="s">    normalized_cov_params : array</span>
<span class="s">        See GEE docstring</span>
<span class="s">    params : array</span>
<span class="s">        The coefficients of the fitted model.  Note that</span>
<span class="s">        interpretation of the coefficients often depends on the</span>
<span class="s">        distribution family and the data.</span>
<span class="s">    scale : float</span>
<span class="s">        The estimate of the scale / dispersion for the model fit.</span>
<span class="s">        See GEE.fit for more information.</span>
<span class="s">    score_norm : float</span>
<span class="s">        norm of the score at the end of the iterative estimation.</span>
<span class="s">    bse : array</span>
<span class="s">        The standard errors of the fitted GEE parameters.</span>
<span class="s">&quot;&quot;&quot;</span>

<span class="n">_gee_example</span> <span class="o">=</span> <span class="s">&quot;&quot;&quot;</span>
<span class="s">    Logistic regression with autoregressive working dependence:</span>

<span class="s">    &gt;&gt;&gt; import statsmodels.api as sm</span>
<span class="s">    &gt;&gt;&gt; family = sm.families.Binomial()</span>
<span class="s">    &gt;&gt;&gt; va = sm.cov_struct.Autoregressive()</span>
<span class="s">    &gt;&gt;&gt; model = sm.GEE(endog, exog, group, family=family, cov_struct=va)</span>
<span class="s">    &gt;&gt;&gt; result = model.fit()</span>
<span class="s">    &gt;&gt;&gt; print result.summary()</span>

<span class="s">    Use formulas to fit a Poisson GLM with independent working</span>
<span class="s">    dependence:</span>

<span class="s">    &gt;&gt;&gt; import statsmodels.api as sm</span>
<span class="s">    &gt;&gt;&gt; fam = sm.families.Poisson()</span>
<span class="s">    &gt;&gt;&gt; ind = sm.cov_struct.Independence()</span>
<span class="s">    &gt;&gt;&gt; model = sm.GEE.from_formula(&quot;y ~ age + trt + base&quot;, &quot;subject&quot;,</span>
<span class="s">                                 data, cov_struct=ind, family=fam)</span>
<span class="s">    &gt;&gt;&gt; result = model.fit()</span>
<span class="s">    &gt;&gt;&gt; print result.summary()</span>

<span class="s">    Equivalent, using the formula API:</span>

<span class="s">    &gt;&gt;&gt; import statsmodels.api as sm</span>
<span class="s">    &gt;&gt;&gt; import statsmodels.formula.api as smf</span>
<span class="s">    &gt;&gt;&gt; fam = sm.families.Poisson()</span>
<span class="s">    &gt;&gt;&gt; ind = sm.cov_struct.Independence()</span>
<span class="s">    &gt;&gt;&gt; model = smf.gee(&quot;y ~ age + trt + base&quot;, &quot;subject&quot;,</span>
<span class="s">                    data, cov_struct=ind, family=fam)</span>
<span class="s">    &gt;&gt;&gt; result = model.fit()</span>
<span class="s">    &gt;&gt;&gt; print result.summary()</span>
<span class="s">&quot;&quot;&quot;</span>

<span class="n">_gee_ordinal_example</span> <span class="o">=</span> <span class="s">&quot;&quot;&quot;</span>
<span class="s">    Fit an ordinal regression model using GEE, with &quot;global</span>
<span class="s">    odds ratio&quot; dependence:</span>

<span class="s">    &gt;&gt;&gt; import statsmodels.api as sm</span>
<span class="s">    &gt;&gt;&gt; gor = sm.cov_struct.GlobalOddsRatio(&quot;ordinal&quot;)</span>
<span class="s">    &gt;&gt;&gt; model = sm.OrdinalGEE(endog, exog, groups, cov_struct=gor)</span>
<span class="s">    &gt;&gt;&gt; result = model.fit()</span>
<span class="s">    &gt;&gt;&gt; print result.summary()</span>

<span class="s">    Using formulas:</span>

<span class="s">    &gt;&gt;&gt; import statsmodels.formula.api as smf</span>
<span class="s">    &gt;&gt;&gt; model = smf.ordinal_gee(&quot;y ~ x1 + x2&quot;, groups, data,</span>
<span class="s">                                    cov_struct=gor)</span>
<span class="s">    &gt;&gt;&gt; result = model.fit()</span>
<span class="s">    &gt;&gt;&gt; print result.summary()</span>
<span class="s">&quot;&quot;&quot;</span>

<span class="n">_gee_nominal_example</span> <span class="o">=</span> <span class="s">&quot;&quot;&quot;</span>
<span class="s">    Fit a nominal regression model using GEE:</span>

<span class="s">    &gt;&gt;&gt; import statsmodels.api as sm</span>
<span class="s">    &gt;&gt;&gt; import statsmodels.formula.api as smf</span>
<span class="s">    &gt;&gt;&gt; gor = sm.cov_struct.GlobalOddsRatio(&quot;nominal&quot;)</span>
<span class="s">    &gt;&gt;&gt; model = sm.NominalGEE(endog, exog, groups, cov_struct=gor)</span>
<span class="s">    &gt;&gt;&gt; result = model.fit()</span>
<span class="s">    &gt;&gt;&gt; print result.summary()</span>

<span class="s">    Using formulas:</span>

<span class="s">    &gt;&gt;&gt; import statsmodels.api as sm</span>
<span class="s">    &gt;&gt;&gt; model = sm.NominalGEE.from_formula(&quot;y ~ x1 + x2&quot;, groups,</span>
<span class="s">                     data, cov_struct=gor)</span>
<span class="s">    &gt;&gt;&gt; result = model.fit()</span>
<span class="s">    &gt;&gt;&gt; print result.summary()</span>

<span class="s">    Using the formula API:</span>

<span class="s">    &gt;&gt;&gt; import statsmodels.formula.api as smf</span>
<span class="s">    &gt;&gt;&gt; model = smf.nominal_gee(&quot;y ~ x1 + x2&quot;, groups, data,</span>
<span class="s">                                cov_struct=gor)</span>
<span class="s">    &gt;&gt;&gt; result = model.fit()</span>
<span class="s">    &gt;&gt;&gt; print result.summary()</span>
<span class="s">&quot;&quot;&quot;</span>


<div class="viewcode-block" id="GEE"><a class="viewcode-back" href="../../../generated/statsmodels.genmod.generalized_estimating_equations.GEE.html#statsmodels.genmod.generalized_estimating_equations.GEE">[docs]</a><span class="k">class</span> <span class="nc">GEE</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>

    <span class="n">__doc__</span> <span class="o">=</span> <span class="p">(</span>
        <span class="s">&quot;    Estimation of marginal regression models using Generalized</span><span class="se">\n</span><span class="s">&quot;</span>
        <span class="s">&quot;    Estimating Equations (GEE).</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">+</span> <span class="n">_gee_init_doc</span> <span class="o">%</span>
        <span class="p">{</span><span class="s">&#39;extra_params&#39;</span><span class="p">:</span> <span class="n">base</span><span class="o">.</span><span class="n">_missing_param_doc</span><span class="p">,</span>
         <span class="s">&#39;family_doc&#39;</span><span class="p">:</span> <span class="n">_gee_family_doc</span><span class="p">,</span>
         <span class="s">&#39;example&#39;</span><span class="p">:</span> <span class="n">_gee_example</span><span class="p">})</span>

    <span class="n">cached_means</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">endog</span><span class="p">,</span> <span class="n">exog</span><span class="p">,</span> <span class="n">groups</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">family</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="n">cov_struct</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">missing</span><span class="o">=</span><span class="s">&#39;none&#39;</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="n">exposure</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">dep_data</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">constraint</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="n">update_dep</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">missing</span> <span class="o">=</span> <span class="n">missing</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dep_data</span> <span class="o">=</span> <span class="n">dep_data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">constraint</span> <span class="o">=</span> <span class="n">constraint</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_dep</span> <span class="o">=</span> <span class="n">update_dep</span>

        <span class="n">groups</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">groups</span><span class="p">)</span> <span class="c"># in case groups is pandas</span>
        <span class="c"># Pass groups, time, offset, and dep_data so they are</span>
        <span class="c"># processed for missing data along with endog and exog.</span>
        <span class="c"># Calling super creates self.exog, self.endog, etc. as</span>
        <span class="c"># ndarrays and the original exog, endog, etc. are</span>
        <span class="c"># self.data.endog, etc.</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">GEE</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">endog</span><span class="p">,</span> <span class="n">exog</span><span class="p">,</span> <span class="n">groups</span><span class="o">=</span><span class="n">groups</span><span class="p">,</span>
                                  <span class="n">time</span><span class="o">=</span><span class="n">time</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">,</span>
                                  <span class="n">exposure</span><span class="o">=</span><span class="n">exposure</span><span class="p">,</span>
                                  <span class="n">dep_data</span><span class="o">=</span><span class="n">dep_data</span><span class="p">,</span> <span class="n">missing</span><span class="o">=</span><span class="n">missing</span><span class="p">,</span>
                                  <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_init_keys</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="s">&quot;update_dep&quot;</span><span class="p">,</span> <span class="s">&quot;constraint&quot;</span><span class="p">,</span> <span class="s">&quot;family&quot;</span><span class="p">,</span>
                                <span class="s">&quot;cov_struct&quot;</span><span class="p">])</span>

        <span class="c"># Handle the family argument</span>
        <span class="k">if</span> <span class="n">family</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">family</span> <span class="o">=</span> <span class="n">families</span><span class="o">.</span><span class="n">Gaussian</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">family</span><span class="o">.</span><span class="n">__class__</span><span class="p">,</span> <span class="n">families</span><span class="o">.</span><span class="n">Family</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;GEE: `family` must be a genmod &quot;</span>
                                 <span class="s">&quot;family instance&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">family</span> <span class="o">=</span> <span class="n">family</span>

        <span class="c"># Handle the cov_struct argument</span>
        <span class="k">if</span> <span class="n">cov_struct</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">cov_struct</span> <span class="o">=</span> <span class="n">Independence</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">cov_struct</span><span class="o">.</span><span class="n">__class__</span><span class="p">,</span> <span class="n">CovStruct</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;GEE: `cov_struct` must be a genmod &quot;</span>
                                 <span class="s">&quot;cov_struct instance&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">cov_struct</span> <span class="o">=</span> <span class="n">cov_struct</span>

        <span class="c"># Handle the offset and exposure</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_offset_exposure</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endog</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">offset</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_offset_exposure</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">offset</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">offset</span> <span class="o">=</span> <span class="n">offset</span>
        <span class="k">if</span> <span class="n">exposure</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">family</span><span class="o">.</span><span class="n">link</span><span class="p">,</span> <span class="n">families</span><span class="o">.</span><span class="n">links</span><span class="o">.</span><span class="n">Log</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;exposure can only be used with the log link function&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_offset_exposure</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">exposure</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">exposure</span> <span class="o">=</span> <span class="n">exposure</span>

        <span class="c"># Handle the constraint</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">constraint</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">if</span> <span class="n">constraint</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">constraint</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;GEE: `constraint` must be a 2-tuple.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">constraint</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exog</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;GEE: the left hand side of the &quot;</span>
                   <span class="s">&quot;constraint must have the same number of columns &quot;</span>
                   <span class="s">&quot;as the exog matrix.&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">constraint</span> <span class="o">=</span> <span class="n">ParameterConstraint</span><span class="p">(</span><span class="n">constraint</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                                  <span class="n">constraint</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                                                  <span class="bp">self</span><span class="o">.</span><span class="n">exog</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_offset_exposure</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">constraint</span><span class="o">.</span><span class="n">offset_increment</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">exog</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">constraint</span><span class="o">.</span><span class="n">reduced_exog</span><span class="p">()</span>

        <span class="c"># Convert the data to the internal representation, which is a</span>
        <span class="c"># list of arrays, corresponding to the clusters.</span>
        <span class="n">group_labels</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">groups</span><span class="p">))</span>
        <span class="n">group_indices</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="n">s</span><span class="p">,</span> <span class="p">[])</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">group_labels</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endog</span><span class="p">)):</span>
            <span class="n">group_indices</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">groups</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">iterkeys</span><span class="p">(</span><span class="n">group_indices</span><span class="p">):</span>
            <span class="n">group_indices</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">group_indices</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">group_indices</span> <span class="o">=</span> <span class="n">group_indices</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">group_labels</span> <span class="o">=</span> <span class="n">group_labels</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">endog_li</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cluster_list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endog</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">exog_li</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cluster_list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exog</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">num_group</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endog_li</span><span class="p">)</span>

        <span class="c"># Time defaults to a 1d grid with equal spacing</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">[:,</span><span class="bp">None</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">time_li</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cluster_list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">time_li</span> <span class="o">=</span> \
                <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)[:,</span> <span class="bp">None</span><span class="p">]</span>
                 <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">endog_li</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time_li</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">offset_li</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cluster_list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_offset_exposure</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">constraint</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">constraint</span><span class="o">.</span><span class="n">exog_fulltrans_li</span> <span class="o">=</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">cluster_list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">constraint</span><span class="o">.</span><span class="n">exog_fulltrans</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">family</span> <span class="o">=</span> <span class="n">family</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">cov_struct</span><span class="o">.</span><span class="n">initialize</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="c"># Total sample size</span>
        <span class="n">group_ns</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">endog_li</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">group_ns</span><span class="p">)</span>
        <span class="c"># The following are column based, not on rank see #1928</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">df_model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exog</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>  <span class="c"># assumes constant</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">df_resid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">exog</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="c"># mean_deriv is the derivative of E[endog|exog] with respect</span>
        <span class="c"># to params</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c"># This custom mean_deriv is currently only used for the</span>
            <span class="c"># multinomial logit model</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mean_deriv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">family</span><span class="o">.</span><span class="n">link</span><span class="o">.</span><span class="n">mean_deriv</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="c"># Otherwise it can be obtained easily from inverse_deriv</span>
            <span class="n">mean_deriv_lpr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">family</span><span class="o">.</span><span class="n">link</span><span class="o">.</span><span class="n">inverse_deriv</span>

            <span class="k">def</span> <span class="nf">mean_deriv</span><span class="p">(</span><span class="n">exog</span><span class="p">,</span> <span class="n">lpr</span><span class="p">):</span>
                <span class="n">dmat</span> <span class="o">=</span> <span class="n">exog</span> <span class="o">*</span> <span class="n">mean_deriv_lpr</span><span class="p">(</span><span class="n">lpr</span><span class="p">)[:,</span> <span class="bp">None</span><span class="p">]</span>
                <span class="k">return</span> <span class="n">dmat</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">mean_deriv</span> <span class="o">=</span> <span class="n">mean_deriv</span>

        <span class="c"># mean_deriv_exog is the derivative of E[endog|exog] with</span>
        <span class="c"># respect to exog</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c"># This custom mean_deriv_exog is currently only used for</span>
            <span class="c"># the multinomial logit model</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mean_deriv_exog</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">family</span><span class="o">.</span><span class="n">link</span><span class="o">.</span><span class="n">mean_deriv_exog</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="c"># Otherwise it can be obtained easily from inverse_deriv</span>
            <span class="n">mean_deriv_lpr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">family</span><span class="o">.</span><span class="n">link</span><span class="o">.</span><span class="n">inverse_deriv</span>

            <span class="k">def</span> <span class="nf">mean_deriv_exog</span><span class="p">(</span><span class="n">exog</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
                <span class="n">lpr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">exog</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>
                <span class="n">dmat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">mean_deriv_lpr</span><span class="p">(</span><span class="n">lpr</span><span class="p">),</span> <span class="n">params</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">dmat</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">mean_deriv_exog</span> <span class="o">=</span> <span class="n">mean_deriv_exog</span>

        <span class="c"># Skip the covariance updates if all groups have a single</span>
        <span class="c"># observation (reduces to fitting a GLM).</span>
        <span class="n">maxgroup</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">endog_li</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">maxgroup</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update_dep</span> <span class="o">=</span> <span class="bp">False</span>

    <span class="c"># Override to allow groups and time to be passed as variable</span>
    <span class="c"># names.</span>
    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="GEE.from_formula"><a class="viewcode-back" href="../../../generated/statsmodels.genmod.generalized_estimating_equations.GEE.from_formula.html#statsmodels.genmod.generalized_estimating_equations.GEE.from_formula">[docs]</a>    <span class="k">def</span> <span class="nf">from_formula</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">formula</span><span class="p">,</span> <span class="n">groups</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">subset</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                     <span class="n">time</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">exposure</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                     <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a GEE model instance from a formula and dataframe.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        formula : str or generic Formula object</span>
<span class="sd">            The formula specifying the model</span>
<span class="sd">        groups : array-like or string</span>
<span class="sd">            Array of grouping labels.  If a string, this is the name</span>
<span class="sd">            of a variable in `data` that contains the grouping labels.</span>
<span class="sd">        data : array-like</span>
<span class="sd">            The data for the model.</span>
<span class="sd">        subset : array-like</span>
<span class="sd">            An array-like object of booleans, integers, or index</span>
<span class="sd">            values that indicate the subset of the data to used when</span>
<span class="sd">            fitting the model.</span>
<span class="sd">        time : array-like or string</span>
<span class="sd">            The time values, used for dependence structures involving</span>
<span class="sd">            distances between observations.  If a string, this is the</span>
<span class="sd">            name of a variable in `data` that contains the time</span>
<span class="sd">            values.</span>
<span class="sd">        offset : array-like or string</span>
<span class="sd">            The offset values, added to the linear predictor.  If a</span>
<span class="sd">            string, this is the name of a variable in `data` that</span>
<span class="sd">            contains the offset values.</span>
<span class="sd">        exposure : array-like or string</span>
<span class="sd">            The exposure values, only used if the link function is the</span>
<span class="sd">            logarithm function, in which case the log of `exposure`</span>
<span class="sd">            is added to the offset (if any).  If a string, this is the</span>
<span class="sd">            name of a variable in `data` that contains the offset</span>
<span class="sd">            values.</span>
<span class="sd">        %(missing_param_doc)s</span>
<span class="sd">        args : extra arguments</span>
<span class="sd">            These are passed to the model</span>
<span class="sd">        kwargs : extra keyword arguments</span>
<span class="sd">            These are passed to the model with one exception. The</span>
<span class="sd">            ``eval_env`` keyword is passed to patsy. It can be either a</span>
<span class="sd">            :class:`patsy:patsy.EvalEnvironment` object or an integer</span>
<span class="sd">            indicating the depth of the namespace to use. For example, the</span>
<span class="sd">            default ``eval_env=0`` uses the calling namespace. If you wish</span>
<span class="sd">            to use a &quot;clean&quot; environment set ``eval_env=-1``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        model : GEE model instance</span>

<span class="sd">        Notes</span>
<span class="sd">        ------</span>
<span class="sd">        `data` must define __getitem__ with the keys in the formula</span>
<span class="sd">        terms args and kwargs are passed on to the model</span>
<span class="sd">        instantiation. E.g., a numpy structured or rec array, a</span>
<span class="sd">        dictionary, or a pandas DataFrame.</span>

<span class="sd">        This method currently does not correctly handle missing</span>
<span class="sd">        values, so missing values should be explicitly dropped from</span>
<span class="sd">        the DataFrame before calling this method.</span>
<span class="sd">        &quot;&quot;&quot;</span> <span class="o">%</span> <span class="p">{</span><span class="s">&#39;missing_param_doc&#39;</span> <span class="p">:</span> <span class="n">base</span><span class="o">.</span><span class="n">_missing_param_doc</span><span class="p">}</span>


        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">groups</span><span class="p">)</span> <span class="o">==</span> <span class="nb">str</span><span class="p">:</span>
            <span class="n">groups</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">groups</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">time</span><span class="p">)</span> <span class="o">==</span> <span class="nb">str</span><span class="p">:</span>
            <span class="n">time</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">time</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">offset</span><span class="p">)</span> <span class="o">==</span> <span class="nb">str</span><span class="p">:</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">offset</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">exposure</span><span class="p">)</span> <span class="o">==</span> <span class="nb">str</span><span class="p">:</span>
            <span class="n">exposure</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">exposure</span><span class="p">]</span>

        <span class="n">model</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">GEE</span><span class="p">,</span> <span class="n">cls</span><span class="p">)</span><span class="o">.</span><span class="n">from_formula</span><span class="p">(</span><span class="n">formula</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">subset</span><span class="p">,</span>
                                             <span class="n">groups</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="n">time</span><span class="p">,</span>
                                             <span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">,</span>
                                             <span class="n">exposure</span><span class="o">=</span><span class="n">exposure</span><span class="p">,</span>
                                             <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">model</span>
</div>
<div class="viewcode-block" id="GEE.cluster_list"><a class="viewcode-back" href="../../../generated/statsmodels.genmod.generalized_estimating_equations.GEE.cluster_list.html#statsmodels.genmod.generalized_estimating_equations.GEE.cluster_list">[docs]</a>    <span class="k">def</span> <span class="nf">cluster_list</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">array</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns `array` split into subarrays corresponding to the</span>
<span class="sd">        cluster structure.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">array</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">array</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">group_indices</span><span class="p">[</span><span class="n">k</span><span class="p">]])</span>
                    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">group_labels</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">array</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">group_indices</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="p">:])</span>
                    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">group_labels</span><span class="p">]</span>
</div>
<div class="viewcode-block" id="GEE.estimate_scale"><a class="viewcode-back" href="../../../generated/statsmodels.genmod.generalized_estimating_equations.GEE.estimate_scale.html#statsmodels.genmod.generalized_estimating_equations.GEE.estimate_scale">[docs]</a>    <span class="k">def</span> <span class="nf">estimate_scale</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an estimate of the scale parameter `phi` at the</span>
<span class="sd">        current parameter value.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">endog</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">endog_li</span>
        <span class="n">exog</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exog_li</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">offset_li</span>

        <span class="n">cached_means</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cached_means</span>

        <span class="n">nobs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span>
        <span class="n">exog_dim</span> <span class="o">=</span> <span class="n">exog</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">varfunc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">family</span><span class="o">.</span><span class="n">variance</span>

        <span class="n">scale</span> <span class="o">=</span> <span class="mf">0.</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_group</span><span class="p">):</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">endog</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">expval</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">cached_means</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

            <span class="n">sdev</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">varfunc</span><span class="p">(</span><span class="n">expval</span><span class="p">))</span>
            <span class="n">resid</span> <span class="o">=</span> <span class="p">(</span><span class="n">endog</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">offset</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">expval</span><span class="p">)</span> <span class="o">/</span> <span class="n">sdev</span>

            <span class="n">scale</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">resid</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

        <span class="n">scale</span> <span class="o">/=</span> <span class="p">(</span><span class="n">nobs</span> <span class="o">-</span> <span class="n">exog_dim</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">scale</span>
</div>
    <span class="k">def</span> <span class="nf">_update_mean_params</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        update : array-like</span>
<span class="sd">            The update vector such that params + update is the next</span>
<span class="sd">            iterate when solving the score equations.</span>
<span class="sd">        score : array-like</span>
<span class="sd">            The current value of the score equations, not</span>
<span class="sd">            incorporating the scale parameter.  If desired,</span>
<span class="sd">            multiply this vector by the scale parameter to</span>
<span class="sd">            incorporate the scale.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">endog</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">endog_li</span>
        <span class="n">exog</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exog_li</span>

        <span class="n">cached_means</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cached_means</span>

        <span class="n">varfunc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">family</span><span class="o">.</span><span class="n">variance</span>

        <span class="n">bmat</span><span class="p">,</span> <span class="n">score</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_group</span><span class="p">):</span>

            <span class="n">expval</span><span class="p">,</span> <span class="n">lpr</span> <span class="o">=</span> <span class="n">cached_means</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">resid</span> <span class="o">=</span> <span class="n">endog</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">expval</span>
            <span class="n">dmat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mean_deriv</span><span class="p">(</span><span class="n">exog</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">lpr</span><span class="p">)</span>
            <span class="n">sdev</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">varfunc</span><span class="p">(</span><span class="n">expval</span><span class="p">))</span>

            <span class="n">rslt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cov_struct</span><span class="o">.</span><span class="n">covariance_matrix_solve</span><span class="p">(</span><span class="n">expval</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span>
                                                <span class="n">sdev</span><span class="p">,</span> <span class="p">(</span><span class="n">dmat</span><span class="p">,</span> <span class="n">resid</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">rslt</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span>
            <span class="n">vinv_d</span><span class="p">,</span> <span class="n">vinv_resid</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">rslt</span><span class="p">)</span>

            <span class="n">bmat</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">dmat</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">vinv_d</span><span class="p">)</span>
            <span class="n">score</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">dmat</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">vinv_resid</span><span class="p">)</span>

        <span class="n">update</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">bmat</span><span class="p">,</span> <span class="n">score</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_fit_history</span><span class="p">[</span><span class="s">&quot;cov_adjust&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cov_struct</span><span class="o">.</span><span class="n">cov_adjust</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">update</span><span class="p">,</span> <span class="n">score</span>

<div class="viewcode-block" id="GEE.update_cached_means"><a class="viewcode-back" href="../../../generated/statsmodels.genmod.generalized_estimating_equations.GEE.update_cached_means.html#statsmodels.genmod.generalized_estimating_equations.GEE.update_cached_means">[docs]</a>    <span class="k">def</span> <span class="nf">update_cached_means</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mean_params</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        cached_means should always contain the most recent calculation</span>
<span class="sd">        of the group-wise mean vectors.  This function should be</span>
<span class="sd">        called every time the regression parameters are changed, to</span>
<span class="sd">        keep the cached means up to date.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">endog</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">endog_li</span>
        <span class="n">exog</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exog_li</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">offset_li</span>

        <span class="n">linkinv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">family</span><span class="o">.</span><span class="n">link</span><span class="o">.</span><span class="n">inverse</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">cached_means</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_group</span><span class="p">):</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">endog</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">lpr</span> <span class="o">=</span> <span class="n">offset</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">exog</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">mean_params</span><span class="p">)</span>
            <span class="n">expval</span> <span class="o">=</span> <span class="n">linkinv</span><span class="p">(</span><span class="n">lpr</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">cached_means</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">expval</span><span class="p">,</span> <span class="n">lpr</span><span class="p">))</span>
</div>
    <span class="k">def</span> <span class="nf">_covmat</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the sampling covariance matrix of the regression</span>
<span class="sd">        parameters and related quantities.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        cov_robust : array-like</span>
<span class="sd">           The robust, or sandwich estimate of the covariance, which</span>
<span class="sd">           is meaningful even if the working covariance structure is</span>
<span class="sd">           incorrectly specified.</span>
<span class="sd">        cov_naive : array-like</span>
<span class="sd">           The model-based estimate of the covariance, which is</span>
<span class="sd">           meaningful if the covariance structure is correctly</span>
<span class="sd">           specified.</span>
<span class="sd">        cov_robust_bc : array-like</span>
<span class="sd">           The &quot;bias corrected&quot; robust covariance of Mancl and</span>
<span class="sd">           DeRouen.</span>
<span class="sd">        cmat : array-like</span>
<span class="sd">           The center matrix of the sandwich expression, used in</span>
<span class="sd">           obtaining score test results.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">endog</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">endog_li</span>
        <span class="n">exog</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exog_li</span>

        <span class="n">varfunc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">family</span><span class="o">.</span><span class="n">variance</span>
        <span class="n">cached_means</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cached_means</span>

        <span class="c"># Calculate the naive (model-based) and robust (sandwich)</span>
        <span class="c"># covariances.</span>
        <span class="n">bmat</span><span class="p">,</span> <span class="n">cmat</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_group</span><span class="p">):</span>

            <span class="n">expval</span><span class="p">,</span> <span class="n">lpr</span> <span class="o">=</span> <span class="n">cached_means</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">resid</span> <span class="o">=</span> <span class="n">endog</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">expval</span>
            <span class="n">dmat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mean_deriv</span><span class="p">(</span><span class="n">exog</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">lpr</span><span class="p">)</span>
            <span class="n">sdev</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">varfunc</span><span class="p">(</span><span class="n">expval</span><span class="p">))</span>

            <span class="n">rslt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cov_struct</span><span class="o">.</span><span class="n">covariance_matrix_solve</span><span class="p">(</span><span class="n">expval</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span>
                                                <span class="n">sdev</span><span class="p">,</span> <span class="p">(</span><span class="n">dmat</span><span class="p">,</span> <span class="n">resid</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">rslt</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span>
            <span class="n">vinv_d</span><span class="p">,</span> <span class="n">vinv_resid</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">rslt</span><span class="p">)</span>

            <span class="n">bmat</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">dmat</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">vinv_d</span><span class="p">)</span>
            <span class="n">dvinv_resid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">dmat</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">vinv_resid</span><span class="p">)</span>
            <span class="n">cmat</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">dvinv_resid</span><span class="p">,</span> <span class="n">dvinv_resid</span><span class="p">)</span>

        <span class="n">scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">estimate_scale</span><span class="p">()</span>

        <span class="n">bmati</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">bmat</span><span class="p">)</span>
        <span class="n">cov_naive</span> <span class="o">=</span> <span class="n">bmati</span> <span class="o">*</span> <span class="n">scale</span>
        <span class="n">cov_robust</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">bmati</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">cmat</span><span class="p">,</span> <span class="n">bmati</span><span class="p">))</span>

        <span class="c"># Calculate the bias-corrected sandwich estimate of Mancl and</span>
        <span class="c"># DeRouen (requires cov_naive so cannot be calculated</span>
        <span class="c"># in the previous loop).</span>
        <span class="n">bcm</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_group</span><span class="p">):</span>

            <span class="n">expval</span><span class="p">,</span> <span class="n">lpr</span> <span class="o">=</span> <span class="n">cached_means</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">resid</span> <span class="o">=</span> <span class="n">endog</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">expval</span>
            <span class="n">dmat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mean_deriv</span><span class="p">(</span><span class="n">exog</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">lpr</span><span class="p">)</span>
            <span class="n">sdev</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">varfunc</span><span class="p">(</span><span class="n">expval</span><span class="p">))</span>

            <span class="n">rslt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cov_struct</span><span class="o">.</span><span class="n">covariance_matrix_solve</span><span class="p">(</span><span class="n">expval</span><span class="p">,</span>
                                                  <span class="n">i</span><span class="p">,</span> <span class="n">sdev</span><span class="p">,</span> <span class="p">(</span><span class="n">dmat</span><span class="p">,))</span>
            <span class="k">if</span> <span class="n">rslt</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span>
            <span class="n">vinv_d</span> <span class="o">=</span> <span class="n">rslt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">vinv_d</span> <span class="o">/=</span> <span class="n">scale</span>

            <span class="n">hmat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vinv_d</span><span class="p">,</span> <span class="n">cov_naive</span><span class="p">)</span>
            <span class="n">hmat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">hmat</span><span class="p">,</span> <span class="n">dmat</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

            <span class="n">aresid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">resid</span><span class="p">))</span> <span class="o">-</span> <span class="n">hmat</span><span class="p">,</span> <span class="n">resid</span><span class="p">)</span>
            <span class="n">rslt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cov_struct</span><span class="o">.</span><span class="n">covariance_matrix_solve</span><span class="p">(</span><span class="n">expval</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span>
                                                     <span class="n">sdev</span><span class="p">,</span> <span class="p">(</span><span class="n">aresid</span><span class="p">,))</span>
            <span class="k">if</span> <span class="n">rslt</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span>
            <span class="n">srt</span> <span class="o">=</span> <span class="n">rslt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">srt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">dmat</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">srt</span><span class="p">)</span> <span class="o">/</span> <span class="n">scale</span>
            <span class="n">bcm</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">srt</span><span class="p">,</span> <span class="n">srt</span><span class="p">)</span>

        <span class="n">cov_robust_bc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">cov_naive</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">bcm</span><span class="p">,</span> <span class="n">cov_naive</span><span class="p">))</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">cov_robust</span><span class="p">,</span> <span class="n">cov_naive</span><span class="p">,</span> <span class="n">cov_robust_bc</span><span class="p">,</span> <span class="n">cmat</span><span class="p">)</span>

<div class="viewcode-block" id="GEE.predict"><a class="viewcode-back" href="../../../generated/statsmodels.genmod.generalized_estimating_equations.GEE.predict.html#statsmodels.genmod.generalized_estimating_equations.GEE.predict">[docs]</a>    <span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">exog</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                <span class="n">exposure</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">linear</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return predicted values for a marginal regression model fit</span>
<span class="sd">        using GEE.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array-like</span>
<span class="sd">            Parameters / coefficients of a marginal regression model.</span>
<span class="sd">        exog : array-like, optional</span>
<span class="sd">            Design / exogenous data. If exog is None, model exog is</span>
<span class="sd">            used.</span>
<span class="sd">        offset : array-like, optional</span>
<span class="sd">            Offset for exog if provided.  If offset is None, model</span>
<span class="sd">            offset is used.</span>
<span class="sd">        exposure : array-like, optional</span>
<span class="sd">            Exposure for exog, if exposure is None, model exposure is</span>
<span class="sd">            used.  Only allowed if link function is the logarithm.</span>
<span class="sd">        linear : bool</span>
<span class="sd">            If True, returns the linear predicted values.  If False,</span>
<span class="sd">            returns the value of the inverse of the model&#39;s link</span>
<span class="sd">            function at the linear predicted values.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        An array of fitted values</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Using log(V) as the offset is equivalent to using V as the</span>
<span class="sd">        exposure.  If exposure U and offset V are both provided, then</span>
<span class="sd">        log(U) + V is added to the linear predictor.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c"># TODO: many paths through this, not well covered in tests</span>

        <span class="k">if</span> <span class="n">exposure</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">family</span><span class="o">.</span><span class="n">link</span><span class="p">,</span> <span class="n">families</span><span class="o">.</span><span class="n">links</span><span class="o">.</span><span class="n">Log</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;exposure can only be used with the log link function&quot;</span><span class="p">)</span>

        <span class="c"># This is the combined offset and exposure</span>
        <span class="n">_offset</span> <span class="o">=</span> <span class="mf">0.</span>

        <span class="c"># Using model exog</span>
        <span class="k">if</span> <span class="n">exog</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">exog</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exog</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">family</span><span class="o">.</span><span class="n">link</span><span class="p">,</span> <span class="n">families</span><span class="o">.</span><span class="n">links</span><span class="o">.</span><span class="n">Log</span><span class="p">):</span>
                <span class="c"># Don&#39;t need to worry about exposure</span>
                <span class="k">if</span> <span class="n">offset</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">_offset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_offset_exposure</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">_offset</span> <span class="o">=</span> <span class="n">offset</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">offset</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">exposure</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">_offset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_offset_exposure</span>
                <span class="k">elif</span> <span class="n">offset</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">exposure</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">_offset</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">exposure</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&quot;offset&quot;</span><span class="p">):</span>
                        <span class="n">_offset</span> <span class="o">=</span> <span class="n">_offset</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">offset</span>
                <span class="k">elif</span> <span class="n">offset</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">exposure</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">_offset</span> <span class="o">=</span> <span class="n">offset</span>
                    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&quot;exposure&quot;</span><span class="p">):</span>
                        <span class="n">_offset</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exposure</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">_offset</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">exposure</span><span class="p">)</span>

        <span class="c"># exog is provided: this is simpler than above because we</span>
        <span class="c"># never use model exog or exposure if exog is provided.</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">offset</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">_offset</span> <span class="o">+=</span> <span class="n">offset</span>
            <span class="k">if</span> <span class="n">exposure</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">_offset</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">exposure</span><span class="p">)</span>

        <span class="n">lin_pred</span> <span class="o">=</span> <span class="n">_offset</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">exog</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">linear</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">family</span><span class="o">.</span><span class="n">link</span><span class="o">.</span><span class="n">inverse</span><span class="p">(</span><span class="n">lin_pred</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">lin_pred</span>
</div>
    <span class="k">def</span> <span class="nf">_starting_params</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a starting value for the mean parameters and a list of</span>
<span class="sd">        variable names.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">dm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exog</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="c"># For categorical models, use independence cov_struct to get</span>
        <span class="c"># starting values.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cov_struct</span><span class="p">,</span> <span class="n">GlobalOddsRatio</span><span class="p">):</span>

            <span class="n">ind</span> <span class="o">=</span> <span class="n">Independence</span><span class="p">()</span>
            <span class="n">md</span> <span class="o">=</span> <span class="n">GEE</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endog</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">exog</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">groups</span><span class="p">,</span>
                     <span class="n">time</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">,</span> <span class="n">family</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">family</span><span class="p">,</span>
                     <span class="n">offset</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">offset</span><span class="p">,</span> <span class="n">exposure</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">exposure</span><span class="p">)</span>
            <span class="n">mdf</span> <span class="o">=</span> <span class="n">md</span><span class="o">.</span><span class="n">fit</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">mdf</span><span class="o">.</span><span class="n">params</span>

        <span class="c"># TODO: use GLM to get Poisson starting values</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">dm</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

<div class="viewcode-block" id="GEE.fit"><a class="viewcode-back" href="../../../generated/statsmodels.genmod.generalized_estimating_equations.GEE.fit.html#statsmodels.genmod.generalized_estimating_equations.GEE.fit">[docs]</a>    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="mi">60</span><span class="p">,</span> <span class="n">ctol</span><span class="o">=</span><span class="mf">1e-6</span><span class="p">,</span> <span class="n">start_params</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
            <span class="n">params_niter</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">first_dep_update</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="n">cov_type</span><span class="o">=</span><span class="s">&#39;robust&#39;</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_fit_history</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;params&#39;</span><span class="p">:</span> <span class="p">[],</span>
                             <span class="s">&#39;score&#39;</span><span class="p">:</span> <span class="p">[],</span>
                             <span class="s">&#39;dep_params&#39;</span><span class="p">:</span> <span class="p">[],</span>
                             <span class="s">&#39;cov_adjust&#39;</span><span class="p">:</span> <span class="p">[]}</span>

        <span class="k">if</span> <span class="n">start_params</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">mean_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_starting_params</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mean_params</span> <span class="o">=</span> <span class="n">start_params</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">update_cached_means</span><span class="p">(</span><span class="n">mean_params</span><span class="p">)</span>

        <span class="n">del_params</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.</span>
        <span class="n">num_assoc_updates</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">itr</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">maxiter</span><span class="p">):</span>

            <span class="n">update</span><span class="p">,</span> <span class="n">score</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_update_mean_params</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">update</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;Singular matrix encountered in GEE update&quot;</span><span class="p">,</span>
                              <span class="n">ConvergenceWarning</span><span class="p">)</span>
                <span class="k">break</span>
            <span class="n">mean_params</span> <span class="o">+=</span> <span class="n">update</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update_cached_means</span><span class="p">(</span><span class="n">mean_params</span><span class="p">)</span>

            <span class="c"># L2 norm of the change in mean structure parameters at</span>
            <span class="c"># this iteration.</span>
            <span class="n">del_params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">score</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_fit_history</span><span class="p">[</span><span class="s">&#39;params&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mean_params</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_fit_history</span><span class="p">[</span><span class="s">&#39;score&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">score</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_fit_history</span><span class="p">[</span><span class="s">&#39;dep_params&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cov_struct</span><span class="o">.</span><span class="n">dep_params</span><span class="p">)</span>

            <span class="c"># Don&#39;t exit until the association parameters have been</span>
            <span class="c"># updated at least once.</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">del_params</span> <span class="o">&lt;</span> <span class="n">ctol</span> <span class="ow">and</span>
                <span class="p">(</span><span class="n">num_assoc_updates</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">update_dep</span> <span class="o">==</span> <span class="bp">False</span><span class="p">)):</span>
                <span class="k">break</span>

            <span class="c"># Update the dependence structure</span>
            <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">update_dep</span> <span class="ow">and</span> <span class="p">(</span><span class="n">itr</span> <span class="o">%</span> <span class="n">params_niter</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
                <span class="ow">and</span> <span class="p">(</span><span class="n">itr</span> <span class="o">&gt;=</span> <span class="n">first_dep_update</span><span class="p">)):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_update_assoc</span><span class="p">(</span><span class="n">mean_params</span><span class="p">)</span>
                <span class="n">num_assoc_updates</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">del_params</span> <span class="o">&gt;=</span> <span class="n">ctol</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;Iteration limit reached prior to convergence&quot;</span><span class="p">,</span>
                          <span class="n">IterationLimitWarning</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">mean_params</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;Unable to estimate GEE parameters.&quot;</span><span class="p">,</span>
                          <span class="n">ConvergenceWarning</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">None</span>

        <span class="n">bcov</span><span class="p">,</span> <span class="n">ncov</span><span class="p">,</span> <span class="n">bc_cov</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_covmat</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">bcov</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;Estimated covariance structure for GEE &quot;</span>
                          <span class="s">&quot;estimates is singular&quot;</span><span class="p">,</span> <span class="n">ConvergenceWarning</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">None</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">constraint</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">mean_params</span><span class="p">,</span> <span class="n">bcov</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_handle_constraint</span><span class="p">(</span><span class="n">mean_params</span><span class="p">,</span> <span class="n">bcov</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">mean_params</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;Unable to estimate constrained GEE &quot;</span>
                              <span class="s">&quot;parameters.&quot;</span><span class="p">,</span> <span class="n">ConvergenceWarning</span><span class="p">)</span>
                <span class="k">return</span> <span class="bp">None</span>

        <span class="n">scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">estimate_scale</span><span class="p">()</span>

        <span class="c">#kwargs to add to results instance, need to be available in __init__</span>
        <span class="n">res_kwds</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">cov_type</span> <span class="o">=</span> <span class="n">cov_type</span><span class="p">,</span>
                        <span class="n">cov_robust</span> <span class="o">=</span> <span class="n">bcov</span><span class="p">,</span>
                        <span class="n">cov_naive</span> <span class="o">=</span> <span class="n">ncov</span><span class="p">,</span>
                        <span class="n">cov_robust_bc</span> <span class="o">=</span> <span class="n">bc_cov</span><span class="p">)</span>

        <span class="c"># The superclass constructor will multiply the covariance</span>
        <span class="c"># matrix argument bcov by scale, which we don&#39;t want, so we</span>
        <span class="c"># divide bcov by the scale parameter here</span>
        <span class="n">results</span> <span class="o">=</span> <span class="n">GEEResults</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mean_params</span><span class="p">,</span> <span class="n">bcov</span> <span class="o">/</span> <span class="n">scale</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span>
                             <span class="n">cov_type</span><span class="o">=</span><span class="n">cov_type</span><span class="p">,</span> <span class="n">use_t</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                             <span class="n">attr_kwds</span><span class="o">=</span><span class="n">res_kwds</span><span class="p">)</span>

        <span class="c"># attributes not needed during results__init__</span>
        <span class="n">results</span><span class="o">.</span><span class="n">fit_history</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fit_history</span>
        <span class="nb">delattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&quot;_fit_history&quot;</span><span class="p">)</span>
        <span class="n">results</span><span class="o">.</span><span class="n">score_norm</span> <span class="o">=</span> <span class="n">del_params</span>
        <span class="n">results</span><span class="o">.</span><span class="n">converged</span> <span class="o">=</span> <span class="p">(</span><span class="n">del_params</span> <span class="o">&lt;</span> <span class="n">ctol</span><span class="p">)</span>
        <span class="n">results</span><span class="o">.</span><span class="n">cov_struct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cov_struct</span>
        <span class="n">results</span><span class="o">.</span><span class="n">params_niter</span> <span class="o">=</span> <span class="n">params_niter</span>
        <span class="n">results</span><span class="o">.</span><span class="n">first_dep_update</span> <span class="o">=</span> <span class="n">first_dep_update</span>
        <span class="n">results</span><span class="o">.</span><span class="n">ctol</span> <span class="o">=</span> <span class="n">ctol</span>
        <span class="n">results</span><span class="o">.</span><span class="n">maxiter</span> <span class="o">=</span> <span class="n">maxiter</span>

        <span class="c"># These will be copied over to subclasses when upgrading.</span>
        <span class="n">results</span><span class="o">.</span><span class="n">_props</span> <span class="o">=</span> <span class="p">[</span><span class="s">&quot;cov_type&quot;</span><span class="p">,</span> <span class="s">&quot;use_t&quot;</span><span class="p">,</span>
                          <span class="s">&quot;cov_params_default&quot;</span><span class="p">,</span> <span class="s">&quot;cov_robust&quot;</span><span class="p">,</span>
                          <span class="s">&quot;cov_naive&quot;</span><span class="p">,</span> <span class="s">&quot;cov_robust_bc&quot;</span><span class="p">,</span>
                           <span class="s">&quot;fit_history&quot;</span><span class="p">,</span>
                          <span class="s">&quot;score_norm&quot;</span><span class="p">,</span> <span class="s">&quot;converged&quot;</span><span class="p">,</span> <span class="s">&quot;cov_struct&quot;</span><span class="p">,</span>
                          <span class="s">&quot;params_niter&quot;</span><span class="p">,</span> <span class="s">&quot;first_dep_update&quot;</span><span class="p">,</span> <span class="s">&quot;ctol&quot;</span><span class="p">,</span>
                          <span class="s">&quot;maxiter&quot;</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">GEEResultsWrapper</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>
</div>
    <span class="n">fit</span><span class="o">.</span><span class="n">__doc__</span> <span class="o">=</span> <span class="n">_gee_fit_doc</span>

    <span class="k">def</span> <span class="nf">_handle_constraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mean_params</span><span class="p">,</span> <span class="n">bcov</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Expand the parameter estimate `mean_params` and covariance matrix</span>
<span class="sd">        `bcov` to the coordinate system of the unconstrained model.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mean_params : array-like</span>
<span class="sd">            A parameter vector estimate for the reduced model.</span>
<span class="sd">        bcov : array-like</span>
<span class="sd">            The covariance matrix of mean_params.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        mean_params : array-like</span>
<span class="sd">            The input parameter vector mean_params, expanded to the</span>
<span class="sd">            coordinate system of the full model</span>
<span class="sd">        bcov : array-like</span>
<span class="sd">            The input covariance matrix bcov, expanded to the</span>
<span class="sd">            coordinate system of the full model</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c"># The number of variables in the full model</span>
        <span class="n">red_p</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">mean_params</span><span class="p">)</span>
        <span class="n">full_p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">constraint</span><span class="o">.</span><span class="n">lhs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">mean_params0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">mean_params</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">full_p</span> <span class="o">-</span> <span class="n">red_p</span><span class="p">)]</span>

        <span class="c"># Get the score vector under the full model.</span>
        <span class="n">save_exog_li</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exog_li</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">exog_li</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">constraint</span><span class="o">.</span><span class="n">exog_fulltrans_li</span>
        <span class="kn">import</span> <span class="nn">copy</span>
        <span class="n">save_cached_means</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cached_means</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_cached_means</span><span class="p">(</span><span class="n">mean_params0</span><span class="p">)</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">score</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_update_mean_params</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">score</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;Singular matrix encountered in GEE score test&quot;</span><span class="p">,</span>
                          <span class="n">ConvergenceWarning</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span>

        <span class="n">_</span><span class="p">,</span> <span class="n">ncov1</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">cmat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_covmat</span><span class="p">()</span>
        <span class="n">scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">estimate_scale</span><span class="p">()</span>
        <span class="n">cmat</span> <span class="o">=</span> <span class="n">cmat</span> <span class="o">/</span> <span class="n">scale</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">score2</span> <span class="o">=</span> <span class="n">score</span><span class="p">[</span><span class="n">red_p</span><span class="p">:]</span> <span class="o">/</span> <span class="n">scale</span>

        <span class="n">amat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">ncov1</span><span class="p">)</span>

        <span class="n">bmat_11</span> <span class="o">=</span> <span class="n">cmat</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">red_p</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">red_p</span><span class="p">]</span>
        <span class="n">bmat_22</span> <span class="o">=</span> <span class="n">cmat</span><span class="p">[</span><span class="n">red_p</span><span class="p">:,</span> <span class="n">red_p</span><span class="p">:]</span>
        <span class="n">bmat_12</span> <span class="o">=</span> <span class="n">cmat</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">red_p</span><span class="p">,</span> <span class="n">red_p</span><span class="p">:]</span>
        <span class="n">amat_11</span> <span class="o">=</span> <span class="n">amat</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">red_p</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">red_p</span><span class="p">]</span>
        <span class="n">amat_12</span> <span class="o">=</span> <span class="n">amat</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">red_p</span><span class="p">,</span> <span class="n">red_p</span><span class="p">:]</span>

        <span class="n">score_cov</span> <span class="o">=</span> <span class="n">bmat_22</span> <span class="o">-</span> \
            <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">amat_12</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">amat_11</span><span class="p">,</span> <span class="n">bmat_12</span><span class="p">))</span>
        <span class="n">score_cov</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">bmat_12</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">amat_11</span><span class="p">,</span> <span class="n">amat_12</span><span class="p">))</span>
        <span class="n">score_cov</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">amat_12</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
                            <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">amat_11</span><span class="p">,</span> <span class="n">bmat_11</span><span class="p">),</span>
                                   <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">amat_11</span><span class="p">,</span> <span class="n">amat_12</span><span class="p">)))</span>

        <span class="kn">from</span> <span class="nn">scipy.stats.distributions</span> <span class="kn">import</span> <span class="n">chi2</span>
        <span class="n">score_statistic</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">score2</span><span class="p">,</span>
                                 <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">score_cov</span><span class="p">,</span> <span class="n">score2</span><span class="p">))</span>
        <span class="n">score_df</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">score2</span><span class="p">)</span>
        <span class="n">score_pvalue</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">chi2</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">score_statistic</span><span class="p">,</span> <span class="n">score_df</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">score_test_results</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;statistic&quot;</span><span class="p">:</span> <span class="n">score_statistic</span><span class="p">,</span>
                                   <span class="s">&quot;df&quot;</span><span class="p">:</span> <span class="n">score_df</span><span class="p">,</span>
                                   <span class="s">&quot;p-value&quot;</span><span class="p">:</span> <span class="n">score_pvalue</span><span class="p">}</span>

        <span class="n">mean_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">constraint</span><span class="o">.</span><span class="n">unpack_param</span><span class="p">(</span><span class="n">mean_params</span><span class="p">)</span>
        <span class="n">bcov</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">constraint</span><span class="o">.</span><span class="n">unpack_cov</span><span class="p">(</span><span class="n">bcov</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">exog_li</span> <span class="o">=</span> <span class="n">save_exog_li</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cached_means</span> <span class="o">=</span> <span class="n">save_cached_means</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">exog</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">constraint</span><span class="o">.</span><span class="n">restore_exog</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">mean_params</span><span class="p">,</span> <span class="n">bcov</span>

    <span class="k">def</span> <span class="nf">_update_assoc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update the association parameters</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">cov_struct</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_derivative_exog</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">exog</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">transform</span><span class="o">=</span><span class="s">&#39;dydx&#39;</span><span class="p">,</span>
            <span class="n">dummy_idx</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">count_idx</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For computing marginal effects returns dF(XB) / dX where F(.) is</span>
<span class="sd">        the predicted probabilities</span>

<span class="sd">        transform can be &#39;dydx&#39;, &#39;dyex&#39;, &#39;eydx&#39;, or &#39;eyex&#39;.</span>

<span class="sd">        Not all of these make sense in the presence of discrete regressors,</span>
<span class="sd">        but checks are done in the results in get_margeff.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c">#note, this form should be appropriate for</span>
        <span class="c">## group 1 probit, logit, logistic, cloglog, heckprob, xtprobit</span>
        <span class="k">if</span> <span class="n">exog</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">exog</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exog</span>
        <span class="n">margeff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mean_deriv_exog</span><span class="p">(</span><span class="n">exog</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>
<span class="c">#        lpr = np.dot(exog, params)</span>
<span class="c">#        margeff = (self.mean_deriv(exog, lpr) / exog) * params</span>
<span class="c">#        margeff = np.dot(self.pdf(np.dot(exog, params))[:, None],</span>
<span class="c">#                                                          params[None,:])</span>

        <span class="k">if</span> <span class="s">&#39;ex&#39;</span> <span class="ow">in</span> <span class="n">transform</span><span class="p">:</span>
            <span class="n">margeff</span> <span class="o">*=</span> <span class="n">exog</span>
        <span class="k">if</span> <span class="s">&#39;ey&#39;</span> <span class="ow">in</span> <span class="n">transform</span><span class="p">:</span>
            <span class="n">margeff</span> <span class="o">/=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">exog</span><span class="p">)[:,</span> <span class="bp">None</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">count_idx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">statsmodels.discrete.discrete_margins</span> <span class="kn">import</span> <span class="p">(</span>
                    <span class="n">_get_count_effects</span><span class="p">)</span>
            <span class="n">margeff</span> <span class="o">=</span> <span class="n">_get_count_effects</span><span class="p">(</span><span class="n">margeff</span><span class="p">,</span> <span class="n">exog</span><span class="p">,</span> <span class="n">count_idx</span><span class="p">,</span> <span class="n">transform</span><span class="p">,</span>
                    <span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dummy_idx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">statsmodels.discrete.discrete_margins</span> <span class="kn">import</span> <span class="p">(</span>
                    <span class="n">_get_dummy_effects</span><span class="p">)</span>
            <span class="n">margeff</span> <span class="o">=</span> <span class="n">_get_dummy_effects</span><span class="p">(</span><span class="n">margeff</span><span class="p">,</span> <span class="n">exog</span><span class="p">,</span> <span class="n">dummy_idx</span><span class="p">,</span> <span class="n">transform</span><span class="p">,</span>
                    <span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">margeff</span>

</div>
<div class="viewcode-block" id="GEEResults"><a class="viewcode-back" href="../../../generated/statsmodels.genmod.generalized_estimating_equations.GEEResults.html#statsmodels.genmod.generalized_estimating_equations.GEEResults">[docs]</a><span class="k">class</span> <span class="nc">GEEResults</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="n">LikelihoodModelResults</span><span class="p">):</span>

    <span class="n">__doc__</span> <span class="o">=</span> <span class="p">(</span>
        <span class="s">&quot;This class summarizes the fit of a marginal regression model using GEE.</span><span class="se">\n</span><span class="s">&quot;</span>
        <span class="o">+</span> <span class="n">_gee_results_doc</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">cov_params</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span>
                 <span class="n">cov_type</span><span class="o">=</span><span class="s">&#39;robust&#39;</span><span class="p">,</span> <span class="n">use_t</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">GEEResults</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span>
                <span class="n">normalized_cov_params</span><span class="o">=</span><span class="n">cov_params</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">)</span>

        <span class="c"># not added by super</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">df_resid</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">df_resid</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">df_model</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">df_model</span>

        <span class="n">attr_kwds</span> <span class="o">=</span> <span class="n">kwds</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;attr_kwds&#39;</span><span class="p">,</span> <span class="p">{})</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">attr_kwds</span><span class="p">)</span>

        <span class="c"># we don&#39;t do this if the cov_type has already been set</span>
        <span class="c"># subclasses can set it through attr_kwds</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;cov_type&#39;</span><span class="p">)</span> <span class="ow">and</span>
                <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;cov_params_default&#39;</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cov_type</span> <span class="o">=</span> <span class="n">cov_type</span> <span class="c"># keep alias</span>
            <span class="n">covariance_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cov_type</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
            <span class="n">allowed_covariances</span> <span class="o">=</span> <span class="p">[</span><span class="s">&quot;robust&quot;</span><span class="p">,</span> <span class="s">&quot;naive&quot;</span><span class="p">,</span> <span class="s">&quot;bias_reduced&quot;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">covariance_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">allowed_covariances</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s">&quot;GEE: `cov_type` must be one of &quot;</span> <span class="o">+</span>\
                    <span class="s">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">allowed_covariances</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">cov_type</span> <span class="o">==</span> <span class="s">&quot;robust&quot;</span><span class="p">:</span>
                <span class="n">cov</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cov_robust</span>
            <span class="k">elif</span> <span class="n">cov_type</span> <span class="o">==</span> <span class="s">&quot;naive&quot;</span><span class="p">:</span>
                <span class="n">cov</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cov_naive</span>
            <span class="k">elif</span> <span class="n">cov_type</span> <span class="o">==</span> <span class="s">&quot;bias_reduced&quot;</span><span class="p">:</span>
                <span class="n">cov</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cov_robust_bc</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">cov_params_default</span> <span class="o">=</span> <span class="n">cov</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cov_type</span> <span class="o">!=</span> <span class="n">cov_type</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;cov_type in argument is different from &#39;</span>
                                 <span class="s">&#39;already attached cov_type&#39;</span><span class="p">)</span>


<div class="viewcode-block" id="GEEResults.standard_errors"><a class="viewcode-back" href="../../../generated/statsmodels.genmod.generalized_estimating_equations.GEEResults.standard_errors.html#statsmodels.genmod.generalized_estimating_equations.GEEResults.standard_errors">[docs]</a>    <span class="k">def</span> <span class="nf">standard_errors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cov_type</span><span class="o">=</span><span class="s">&quot;robust&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This is a convenience function that returns the standard</span>
<span class="sd">        errors for any covariance type.  The value of `bse` is the</span>
<span class="sd">        standard errors for whichever covariance type is specified as</span>
<span class="sd">        an argument to `fit` (defaults to &quot;robust&quot;).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cov_type : string</span>
<span class="sd">            One of &quot;robust&quot;, &quot;naive&quot;, or &quot;bias_reduced&quot;.  Determines</span>
<span class="sd">            the covariance used to compute standard errors.  Defaults</span>
<span class="sd">            to &quot;robust&quot;.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c"># Check covariance_type</span>
        <span class="n">covariance_type</span> <span class="o">=</span> <span class="n">cov_type</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="n">allowed_covariances</span> <span class="o">=</span> <span class="p">[</span><span class="s">&quot;robust&quot;</span><span class="p">,</span> <span class="s">&quot;naive&quot;</span><span class="p">,</span> <span class="s">&quot;bias_reduced&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">covariance_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">allowed_covariances</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s">&quot;GEE: `covariance_type` must be one of &quot;</span> <span class="o">+</span>\
                <span class="s">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">allowed_covariances</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">covariance_type</span> <span class="o">==</span> <span class="s">&quot;robust&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cov_robust</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">covariance_type</span> <span class="o">==</span> <span class="s">&quot;naive&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cov_naive</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">covariance_type</span> <span class="o">==</span> <span class="s">&quot;bias_reduced&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cov_robust_bc</span><span class="p">))</span>

    <span class="c"># Need to override to allow for different covariance types.</span></div>
    <span class="nd">@cache_readonly</span>
<div class="viewcode-block" id="GEEResults.bse"><a class="viewcode-back" href="../../../generated/statsmodels.genmod.generalized_estimating_equations.GEEResults.bse.html#statsmodels.genmod.generalized_estimating_equations.GEEResults.bse">[docs]</a>    <span class="k">def</span> <span class="nf">bse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">standard_errors</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cov_type</span><span class="p">)</span>
</div>
    <span class="nd">@cache_readonly</span>
<div class="viewcode-block" id="GEEResults.resid"><a class="viewcode-back" href="../../../generated/statsmodels.genmod.generalized_estimating_equations.GEEResults.resid.html#statsmodels.genmod.generalized_estimating_equations.GEEResults.resid">[docs]</a>    <span class="k">def</span> <span class="nf">resid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the residuals, the endogeneous data minus the fitted</span>
<span class="sd">        values from the model.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">endog</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">fittedvalues</span>
</div>
    <span class="nd">@cache_readonly</span>
<div class="viewcode-block" id="GEEResults.resid_split"><a class="viewcode-back" href="../../../generated/statsmodels.genmod.generalized_estimating_equations.GEEResults.resid_split.html#statsmodels.genmod.generalized_estimating_equations.GEEResults.resid_split">[docs]</a>    <span class="k">def</span> <span class="nf">resid_split</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the residuals, the endogeneous data minus the fitted</span>
<span class="sd">        values from the model.  The residuals are returned as a list</span>
<span class="sd">        of arrays containing the residuals for each cluster.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sresid</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">group_labels</span><span class="p">:</span>
            <span class="n">ii</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">group_indices</span><span class="p">[</span><span class="n">v</span><span class="p">]</span>
            <span class="n">sresid</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">resid</span><span class="p">[</span><span class="n">ii</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">sresid</span>
</div>
    <span class="nd">@cache_readonly</span>
<div class="viewcode-block" id="GEEResults.resid_centered"><a class="viewcode-back" href="../../../generated/statsmodels.genmod.generalized_estimating_equations.GEEResults.resid_centered.html#statsmodels.genmod.generalized_estimating_equations.GEEResults.resid_centered">[docs]</a>    <span class="k">def</span> <span class="nf">resid_centered</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the residuals centered within each group.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cresid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">resid</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">group_labels</span><span class="p">:</span>
            <span class="n">ii</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">group_indices</span><span class="p">[</span><span class="n">v</span><span class="p">]</span>
            <span class="n">cresid</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">-=</span> <span class="n">cresid</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">cresid</span>
</div>
    <span class="nd">@cache_readonly</span>
<div class="viewcode-block" id="GEEResults.resid_centered_split"><a class="viewcode-back" href="../../../generated/statsmodels.genmod.generalized_estimating_equations.GEEResults.resid_centered_split.html#statsmodels.genmod.generalized_estimating_equations.GEEResults.resid_centered_split">[docs]</a>    <span class="k">def</span> <span class="nf">resid_centered_split</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the residuals centered within each group.  The</span>
<span class="sd">        residuals are returned as a list of arrays containing the</span>
<span class="sd">        centered residuals for each cluster.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sresid</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">group_labels</span><span class="p">:</span>
            <span class="n">ii</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">group_indices</span><span class="p">[</span><span class="n">v</span><span class="p">]</span>
            <span class="n">sresid</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">centered_resid</span><span class="p">[</span><span class="n">ii</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">sresid</span>


    <span class="c"># FIXME: alias to be removed, temporary backwards compatibility</span></div>
    <span class="n">split_resid</span> <span class="o">=</span> <span class="n">resid_split</span>
    <span class="n">centered_resid</span> <span class="o">=</span> <span class="n">resid_centered</span>
    <span class="n">split_centered_resid</span> <span class="o">=</span> <span class="n">resid_centered_split</span>


    <span class="nd">@cache_readonly</span>
<div class="viewcode-block" id="GEEResults.fittedvalues"><a class="viewcode-back" href="../../../generated/statsmodels.genmod.generalized_estimating_equations.GEEResults.fittedvalues.html#statsmodels.genmod.generalized_estimating_equations.GEEResults.fittedvalues">[docs]</a>    <span class="k">def</span> <span class="nf">fittedvalues</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the fitted values from the model.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">family</span><span class="o">.</span><span class="n">link</span><span class="o">.</span><span class="n">inverse</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">exog</span><span class="p">,</span>
                                                     <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">))</span>
</div>
<div class="viewcode-block" id="GEEResults.conf_int"><a class="viewcode-back" href="../../../generated/statsmodels.genmod.generalized_estimating_equations.GEEResults.conf_int.html#statsmodels.genmod.generalized_estimating_equations.GEEResults.conf_int">[docs]</a>    <span class="k">def</span> <span class="nf">conf_int</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=.</span><span class="mo">05</span><span class="p">,</span> <span class="n">cols</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">cov_type</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns confidence intervals for the fitted parameters.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        alpha : float, optional</span>
<span class="sd">             The `alpha` level for the confidence interval.  i.e., The</span>
<span class="sd">             default `alpha` = .05 returns a 95% confidence interval.</span>
<span class="sd">        cols : array-like, optional</span>
<span class="sd">             `cols` specifies which confidence intervals to return</span>
<span class="sd">        cov_type : string</span>
<span class="sd">             The covariance type used for computing standard errors;</span>
<span class="sd">             must be one of &#39;robust&#39;, &#39;naive&#39;, and &#39;bias reduced&#39;.</span>
<span class="sd">             See `GEE` for details.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The confidence interval is based on the Gaussian distribution.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># super doesn&#39;t allow to specify cov_type and method is not</span>
        <span class="c"># implemented,</span>
        <span class="c"># FIXME: remove this method here</span>
        <span class="k">if</span> <span class="n">cov_type</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">bse</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bse</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">bse</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">standard_errors</span><span class="p">(</span><span class="n">cov_type</span><span class="o">=</span><span class="n">cov_type</span><span class="p">)</span>
        <span class="n">params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span>
        <span class="n">dist</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span>
        <span class="n">q</span> <span class="o">=</span> <span class="n">dist</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">alpha</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">cols</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">lower</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span> <span class="o">-</span> <span class="n">q</span> <span class="o">*</span> <span class="n">bse</span>
            <span class="n">upper</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span> <span class="o">+</span> <span class="n">q</span> <span class="o">*</span> <span class="n">bse</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cols</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">cols</span><span class="p">)</span>
            <span class="n">lower</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="n">cols</span><span class="p">]</span> <span class="o">-</span> <span class="n">q</span> <span class="o">*</span> <span class="n">bse</span><span class="p">[</span><span class="n">cols</span><span class="p">]</span>
            <span class="n">upper</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="n">cols</span><span class="p">]</span> <span class="o">+</span> <span class="n">q</span> <span class="o">*</span> <span class="n">bse</span><span class="p">[</span><span class="n">cols</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">lzip</span><span class="p">(</span><span class="n">lower</span><span class="p">,</span> <span class="n">upper</span><span class="p">))</span>
</div>
<div class="viewcode-block" id="GEEResults.summary"><a class="viewcode-back" href="../../../generated/statsmodels.genmod.generalized_estimating_equations.GEEResults.summary.html#statsmodels.genmod.generalized_estimating_equations.GEEResults.summary">[docs]</a>    <span class="k">def</span> <span class="nf">summary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">yname</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">xname</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=.</span><span class="mo">05</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Summarize the GEE regression results</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        yname : string, optional</span>
<span class="sd">            Default is `y`</span>
<span class="sd">        xname : list of strings, optional</span>
<span class="sd">            Default is `var_##` for ## in p the number of regressors</span>
<span class="sd">        title : string, optional</span>
<span class="sd">            Title for the top table. If not None, then this replaces</span>
<span class="sd">            the default title</span>
<span class="sd">        alpha : float</span>
<span class="sd">            significance level for the confidence intervals</span>
<span class="sd">        cov_type : string</span>
<span class="sd">            The covariance type used to compute the standard errors;</span>
<span class="sd">            one of &#39;robust&#39; (the usual robust sandwich-type covariance</span>
<span class="sd">            estimate), &#39;naive&#39; (ignores dependence), and &#39;bias</span>
<span class="sd">            reduced&#39; (the Mancl/DeRouen estimate).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        smry : Summary instance</span>
<span class="sd">            this holds the summary tables and text, which can be</span>
<span class="sd">            printed or converted to various output formats.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        statsmodels.iolib.summary.Summary : class to hold summary</span>
<span class="sd">            results</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">top_left</span> <span class="o">=</span> <span class="p">[(</span><span class="s">&#39;Dep. Variable:&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">),</span>
                    <span class="p">(</span><span class="s">&#39;Model:&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">),</span>
                    <span class="p">(</span><span class="s">&#39;Method:&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s">&#39;Generalized&#39;</span><span class="p">]),</span>
                    <span class="p">(</span><span class="s">&#39;&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s">&#39;Estimating Equations&#39;</span><span class="p">]),</span>
                    <span class="p">(</span><span class="s">&#39;Family:&#39;</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">family</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">]),</span>
                    <span class="p">(</span><span class="s">&#39;Dependence structure:&#39;</span><span class="p">,</span>
                     <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">cov_struct</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">]),</span>
                    <span class="p">(</span><span class="s">&#39;Date:&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">),</span>
                    <span class="p">(</span><span class="s">&#39;Covariance type: &#39;</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">cov_type</span><span class="p">,])</span>
                   <span class="p">]</span>

        <span class="n">NY</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">endog_li</span><span class="p">]</span>

        <span class="n">top_right</span> <span class="o">=</span> <span class="p">[(</span><span class="s">&#39;No. Observations:&#39;</span><span class="p">,</span> <span class="p">[</span><span class="nb">sum</span><span class="p">(</span><span class="n">NY</span><span class="p">)]),</span>
                     <span class="p">(</span><span class="s">&#39;No. clusters:&#39;</span><span class="p">,</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">endog_li</span><span class="p">)]),</span>
                     <span class="p">(</span><span class="s">&#39;Min. cluster size:&#39;</span><span class="p">,</span> <span class="p">[</span><span class="nb">min</span><span class="p">(</span><span class="n">NY</span><span class="p">)]),</span>
                     <span class="p">(</span><span class="s">&#39;Max. cluster size:&#39;</span><span class="p">,</span> <span class="p">[</span><span class="nb">max</span><span class="p">(</span><span class="n">NY</span><span class="p">)]),</span>
                     <span class="p">(</span><span class="s">&#39;Mean cluster size:&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s">&quot;</span><span class="si">%.1f</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">NY</span><span class="p">)]),</span>
                     <span class="p">(</span><span class="s">&#39;Num. iterations:&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s">&#39;</span><span class="si">%d</span><span class="s">&#39;</span> <span class="o">%</span>
                           <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fit_history</span><span class="p">[</span><span class="s">&#39;params&#39;</span><span class="p">])]),</span>
                     <span class="p">(</span><span class="s">&#39;Scale:&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s">&quot;</span><span class="si">%.3f</span><span class="s">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">]),</span>
                     <span class="p">(</span><span class="s">&#39;Time:&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">),</span>
                 <span class="p">]</span>

        <span class="c"># The skew of the residuals</span>
        <span class="n">skew1</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">skew</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">resid</span><span class="p">)</span>
        <span class="n">kurt1</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">kurtosis</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">resid</span><span class="p">)</span>
        <span class="n">skew2</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">skew</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">centered_resid</span><span class="p">)</span>
        <span class="n">kurt2</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">kurtosis</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">centered_resid</span><span class="p">)</span>

        <span class="n">diagn_left</span> <span class="o">=</span> <span class="p">[(</span><span class="s">&#39;Skew:&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s">&quot;</span><span class="si">%12.4f</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">skew1</span><span class="p">]),</span>
                      <span class="p">(</span><span class="s">&#39;Centered skew:&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s">&quot;</span><span class="si">%12.4f</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">skew2</span><span class="p">])]</span>

        <span class="n">diagn_right</span> <span class="o">=</span> <span class="p">[(</span><span class="s">&#39;Kurtosis:&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s">&quot;</span><span class="si">%12.4f</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">kurt1</span><span class="p">]),</span>
                       <span class="p">(</span><span class="s">&#39;Centered kurtosis:&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s">&quot;</span><span class="si">%12.4f</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">kurt2</span><span class="p">])</span>
                   <span class="p">]</span>

        <span class="k">if</span> <span class="n">title</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">title</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span> <span class="o">+</span> <span class="s">&#39; &#39;</span> <span class="o">+</span>\
                    <span class="s">&quot;Regression Results&quot;</span>

        <span class="c"># Override the dataframe names if xname is provided as an</span>
        <span class="c"># argument.</span>
        <span class="k">if</span> <span class="n">xname</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">xna</span> <span class="o">=</span> <span class="n">xname</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">xna</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">exog_names</span>

        <span class="c"># Create summary table instance</span>
        <span class="kn">from</span> <span class="nn">statsmodels.iolib.summary</span> <span class="kn">import</span> <span class="n">Summary</span>
        <span class="n">smry</span> <span class="o">=</span> <span class="n">Summary</span><span class="p">()</span>
        <span class="n">smry</span><span class="o">.</span><span class="n">add_table_2cols</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gleft</span><span class="o">=</span><span class="n">top_left</span><span class="p">,</span> <span class="n">gright</span><span class="o">=</span><span class="n">top_right</span><span class="p">,</span>
                             <span class="n">yname</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">endog_names</span><span class="p">,</span> <span class="n">xname</span><span class="o">=</span><span class="n">xna</span><span class="p">,</span>
                             <span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">)</span>
        <span class="n">smry</span><span class="o">.</span><span class="n">add_table_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">yname</span><span class="o">=</span><span class="n">yname</span><span class="p">,</span> <span class="n">xname</span><span class="o">=</span><span class="n">xna</span><span class="p">,</span>
                              <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">use_t</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
        <span class="n">smry</span><span class="o">.</span><span class="n">add_table_2cols</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gleft</span><span class="o">=</span><span class="n">diagn_left</span><span class="p">,</span>
                             <span class="n">gright</span><span class="o">=</span><span class="n">diagn_right</span><span class="p">,</span> <span class="n">yname</span><span class="o">=</span><span class="n">yname</span><span class="p">,</span>
                             <span class="n">xname</span><span class="o">=</span><span class="n">xna</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s">&quot;&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">smry</span>
</div>
<div class="viewcode-block" id="GEEResults.plot_isotropic_dependence"><a class="viewcode-back" href="../../../generated/statsmodels.genmod.generalized_estimating_equations.GEEResults.plot_isotropic_dependence.html#statsmodels.genmod.generalized_estimating_equations.GEEResults.plot_isotropic_dependence">[docs]</a>    <span class="k">def</span> <span class="nf">plot_isotropic_dependence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">xpoints</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
                                  <span class="n">min_n</span><span class="o">=</span><span class="mi">50</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a plot of the pairwise products of within-group</span>
<span class="sd">        residuals against the corresponding time differences.  This</span>
<span class="sd">        plot can be used to assess the possible form of an isotropic</span>
<span class="sd">        covariance structure.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ax : Matplotlib axes instance</span>
<span class="sd">            An axes on which to draw the graph.  If None, new</span>
<span class="sd">            figure and axes objects are created</span>
<span class="sd">        xpoints : scalar or array-like</span>
<span class="sd">            If scalar, the number of points equally spaced points on</span>
<span class="sd">            the time difference axis used to define bins for</span>
<span class="sd">            calculating local means.  If an array, the specific points</span>
<span class="sd">            that define the bins.</span>
<span class="sd">        min_n : integer</span>
<span class="sd">            The minimum sample size in a bin for the mean residual</span>
<span class="sd">            product to be included on the plot.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="kn">from</span> <span class="nn">statsmodels.graphics</span> <span class="kn">import</span> <span class="n">utils</span> <span class="k">as</span> <span class="n">gutils</span>

        <span class="n">resid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">cluster_list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">resid</span><span class="p">)</span>
        <span class="n">time</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">cluster_list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">time</span><span class="p">)</span>

        <span class="c"># All within-group pairwise time distances (xdt) and the</span>
        <span class="c"># corresponding products of scaled residuals (xre).</span>
        <span class="n">xre</span><span class="p">,</span> <span class="n">xdt</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">re</span><span class="p">,</span> <span class="n">ti</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">resid</span><span class="p">,</span> <span class="n">time</span><span class="p">):</span>
            <span class="n">ix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tril_indices</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">re</span> <span class="o">=</span> <span class="n">re</span><span class="p">[</span><span class="n">ix</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">*</span> <span class="n">re</span><span class="p">[</span><span class="n">ix</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="o">**</span><span class="mi">2</span>
            <span class="n">xre</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">re</span><span class="p">)</span>
            <span class="n">dists</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(((</span><span class="n">ti</span><span class="p">[</span><span class="n">ix</span><span class="p">[</span><span class="mi">0</span><span class="p">],:]</span> <span class="o">-</span> <span class="n">ti</span><span class="p">[</span><span class="n">ix</span><span class="p">[</span><span class="mi">1</span><span class="p">],:])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
            <span class="n">xdt</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dists</span><span class="p">)</span>

        <span class="n">xre</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">xre</span><span class="p">)</span>
        <span class="n">xdt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">xdt</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">gutils</span><span class="o">.</span><span class="n">create_mpl_ax</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">get_figure</span><span class="p">()</span>

        <span class="c"># Convert to a correlation</span>
        <span class="n">ii</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">(</span><span class="n">xdt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">v0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">xre</span><span class="p">[</span><span class="n">ii</span><span class="p">])</span>
        <span class="n">xre</span> <span class="o">/=</span> <span class="n">v0</span>

        <span class="c"># Use the simple average to smooth, since fancier smoothers</span>
        <span class="c"># that trim and downweight outliers give biased results (we</span>
        <span class="c"># need the actual mean of a skewed distribution).</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">xpoints</span><span class="p">):</span>
            <span class="n">xpoints</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">xdt</span><span class="p">),</span> <span class="n">xpoints</span><span class="p">)</span>
        <span class="n">dg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">digitize</span><span class="p">(</span><span class="n">xdt</span><span class="p">,</span> <span class="n">xpoints</span><span class="p">)</span>
        <span class="n">dgu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">dg</span><span class="p">)</span>
        <span class="n">hist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dg</span><span class="o">==</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">dgu</span><span class="p">])</span>
        <span class="n">ii</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">(</span><span class="n">hist</span> <span class="o">&gt;=</span> <span class="n">min_n</span><span class="p">)</span>
        <span class="n">dgu</span> <span class="o">=</span> <span class="n">dgu</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span>
        <span class="n">dgy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">xre</span><span class="p">[</span><span class="n">dg</span><span class="o">==</span><span class="n">k</span><span class="p">])</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">dgu</span><span class="p">])</span>
        <span class="n">dgx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">xdt</span><span class="p">[</span><span class="n">dg</span><span class="o">==</span><span class="n">k</span><span class="p">])</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">dgu</span><span class="p">])</span>

        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">dgx</span><span class="p">,</span> <span class="n">dgy</span><span class="p">,</span> <span class="s">&#39;-&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s">&#39;orange&#39;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s">&quot;Time difference&quot;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s">&quot;Product of scaled residuals&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">fig</span>
</div>
<div class="viewcode-block" id="GEEResults.sensitivity_params"><a class="viewcode-back" href="../../../generated/statsmodels.genmod.generalized_estimating_equations.GEEResults.sensitivity_params.html#statsmodels.genmod.generalized_estimating_equations.GEEResults.sensitivity_params">[docs]</a>    <span class="k">def</span> <span class="nf">sensitivity_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dep_params_first</span><span class="p">,</span>
                           <span class="n">dep_params_last</span><span class="p">,</span> <span class="n">num_steps</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Refits the GEE model using a sequence of values for the</span>
<span class="sd">        dependence parameters.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dep_params_first : array-like</span>
<span class="sd">            The first dep_params in the sequence</span>
<span class="sd">        dep_params_last : array-like</span>
<span class="sd">            The last dep_params in the sequence</span>
<span class="sd">        num_steps : int</span>
<span class="sd">            The number of dep_params in the sequence</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        results : array-like</span>
<span class="sd">            The GEEResults objects resulting from the fits.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span>

        <span class="kn">import</span> <span class="nn">copy</span>
        <span class="n">cov_struct</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">cov_struct</span><span class="p">)</span>

        <span class="c"># We are fixing the dependence structure in each run.</span>
        <span class="n">update_dep</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">update_dep</span>
        <span class="n">model</span><span class="o">.</span><span class="n">update_dep</span> <span class="o">=</span> <span class="bp">False</span>

        <span class="n">dep_params</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">num_steps</span><span class="p">):</span>

            <span class="n">dp</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">dep_params_last</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="n">dep_params_first</span>
            <span class="n">dep_params</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dp</span><span class="p">)</span>

            <span class="n">model</span><span class="o">.</span><span class="n">cov_struct</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">cov_struct</span><span class="p">)</span>
            <span class="n">model</span><span class="o">.</span><span class="n">cov_struct</span><span class="o">.</span><span class="n">dep_params</span> <span class="o">=</span> <span class="n">dp</span>
            <span class="n">rslt</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">start_params</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">,</span>
                             <span class="n">ctol</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ctol</span><span class="p">,</span>
                             <span class="n">params_niter</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">params_niter</span><span class="p">,</span>
                             <span class="n">first_dep_update</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">first_dep_update</span><span class="p">,</span>
                             <span class="n">cov_type</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cov_type</span><span class="p">)</span>
            <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rslt</span><span class="p">)</span>

        <span class="n">model</span><span class="o">.</span><span class="n">update_dep</span> <span class="o">=</span> <span class="n">update_dep</span>

        <span class="k">return</span> <span class="n">results</span>

    <span class="c"># FIXME: alias to be removed, temporary backwards compatibility</span></div>
    <span class="n">params_sensitivity</span> <span class="o">=</span> <span class="n">sensitivity_params</span>

</div>
<span class="k">class</span> <span class="nc">GEEResultsWrapper</span><span class="p">(</span><span class="n">lm</span><span class="o">.</span><span class="n">RegressionResultsWrapper</span><span class="p">):</span>
    <span class="n">_attrs</span> <span class="o">=</span> <span class="p">{</span>
              <span class="s">&#39;centered_resid&#39;</span> <span class="p">:</span> <span class="s">&#39;rows&#39;</span><span class="p">,</span>
              <span class="p">}</span>
    <span class="n">_wrap_attrs</span> <span class="o">=</span> <span class="n">wrap</span><span class="o">.</span><span class="n">union_dicts</span><span class="p">(</span><span class="n">lm</span><span class="o">.</span><span class="n">RegressionResultsWrapper</span><span class="o">.</span><span class="n">_wrap_attrs</span><span class="p">,</span>
                                   <span class="n">_attrs</span><span class="p">)</span>
<span class="n">wrap</span><span class="o">.</span><span class="n">populate_wrapper</span><span class="p">(</span><span class="n">GEEResultsWrapper</span><span class="p">,</span> <span class="n">GEEResults</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">OrdinalGEE</span><span class="p">(</span><span class="n">GEE</span><span class="p">):</span>

    <span class="n">__doc__</span> <span class="o">=</span> <span class="p">(</span>
        <span class="s">&quot;    Estimation of ordinal response marginal regression models</span><span class="se">\n</span><span class="s">&quot;</span>
        <span class="s">&quot;    using Generalized Estimating Equations (GEE).</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">+</span>
        <span class="n">_gee_init_doc</span> <span class="o">%</span> <span class="p">{</span><span class="s">&#39;extra_params&#39;</span><span class="p">:</span> <span class="n">base</span><span class="o">.</span><span class="n">_missing_param_doc</span><span class="p">,</span>
                         <span class="s">&#39;family_doc&#39;</span><span class="p">:</span> <span class="n">_gee_ordinal_family_doc</span><span class="p">,</span>
                         <span class="s">&#39;example&#39;</span><span class="p">:</span> <span class="n">_gee_ordinal_example</span><span class="p">})</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">endog</span><span class="p">,</span> <span class="n">exog</span><span class="p">,</span> <span class="n">groups</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">family</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                       <span class="n">cov_struct</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">missing</span><span class="o">=</span><span class="s">&#39;none&#39;</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                       <span class="n">dep_data</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">constraint</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">family</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">family</span> <span class="o">=</span> <span class="n">families</span><span class="o">.</span><span class="n">Binomial</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">family</span><span class="p">,</span> <span class="n">families</span><span class="o">.</span><span class="n">Binomial</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;ordinal GEE must use a Binomial family&quot;</span><span class="p">)</span>

        <span class="n">endog</span><span class="p">,</span> <span class="n">exog</span><span class="p">,</span> <span class="n">groups</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">offset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">setup_ordinal</span><span class="p">(</span><span class="n">endog</span><span class="p">,</span>
                                       <span class="n">exog</span><span class="p">,</span> <span class="n">groups</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">offset</span><span class="p">)</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">OrdinalGEE</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">endog</span><span class="p">,</span> <span class="n">exog</span><span class="p">,</span> <span class="n">groups</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span>
                                         <span class="n">family</span><span class="p">,</span> <span class="n">cov_struct</span><span class="p">,</span> <span class="n">missing</span><span class="p">,</span>
                                         <span class="n">offset</span><span class="p">,</span> <span class="n">dep_data</span><span class="p">,</span> <span class="n">constraint</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">setup_ordinal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">endog</span><span class="p">,</span> <span class="n">exog</span><span class="p">,</span> <span class="n">groups</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">offset</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Restructure ordinal data as binary indicators so that they can</span>
<span class="sd">        be analysed using Generalized Estimating Equations.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">endog_orig</span> <span class="o">=</span> <span class="n">endog</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">exog_orig</span> <span class="o">=</span> <span class="n">exog</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">groups_orig</span> <span class="o">=</span> <span class="n">groups</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">offset</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">offset_orig</span> <span class="o">=</span> <span class="n">offset</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">offset_orig</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">endog</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">time</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">time_orig</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">time_orig</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="n">time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">endog</span><span class="p">),</span><span class="mi">1</span><span class="p">))</span>

        <span class="n">exog</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">exog</span><span class="p">)</span>
        <span class="n">endog</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">endog</span><span class="p">)</span>
        <span class="n">groups</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">groups</span><span class="p">)</span>
        <span class="n">time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">offset</span><span class="p">)</span>

        <span class="c"># The unique outcomes, except the greatest one.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">endog_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">endog</span><span class="p">)</span>
        <span class="n">endog_cuts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">endog_values</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">ncut</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">endog_cuts</span><span class="p">)</span>

        <span class="n">nrows</span> <span class="o">=</span> <span class="n">ncut</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">endog</span><span class="p">)</span>
        <span class="n">exog_out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nrows</span><span class="p">,</span> <span class="n">exog</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
                            <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">endog_out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nrows</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">intercepts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nrows</span><span class="p">,</span> <span class="n">ncut</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">groups_out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nrows</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">groups</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">time_out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nrows</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
                            <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">offset_out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nrows</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

        <span class="n">jrow</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">zipper</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="n">exog</span><span class="p">,</span> <span class="n">endog</span><span class="p">,</span> <span class="n">groups</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">offset</span><span class="p">)</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">exog_row</span><span class="p">,</span> <span class="n">endog_value</span><span class="p">,</span> <span class="n">group_value</span><span class="p">,</span> <span class="n">time_value</span><span class="p">,</span>
             <span class="n">offset_value</span><span class="p">)</span> <span class="ow">in</span> <span class="n">zipper</span><span class="p">:</span>

            <span class="c"># Loop over thresholds for the indicators</span>
            <span class="k">for</span> <span class="n">thresh_ix</span><span class="p">,</span> <span class="n">thresh</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">endog_cuts</span><span class="p">):</span>

                <span class="n">exog_out</span><span class="p">[</span><span class="n">jrow</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">exog_row</span>
                <span class="n">endog_out</span><span class="p">[</span><span class="n">jrow</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">endog_value</span> <span class="o">&gt;</span> <span class="n">thresh</span><span class="p">))</span>
                <span class="n">intercepts</span><span class="p">[</span><span class="n">jrow</span><span class="p">,</span> <span class="n">thresh_ix</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">groups_out</span><span class="p">[</span><span class="n">jrow</span><span class="p">]</span> <span class="o">=</span> <span class="n">group_value</span>
                <span class="n">time_out</span><span class="p">[</span><span class="n">jrow</span><span class="p">]</span> <span class="o">=</span> <span class="n">time_value</span>
                <span class="n">offset_out</span><span class="p">[</span><span class="n">jrow</span><span class="p">]</span> <span class="o">=</span> <span class="n">offset_value</span>
                <span class="n">jrow</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="n">exog_out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">intercepts</span><span class="p">,</span> <span class="n">exog_out</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c"># exog column names, including intercepts</span>
        <span class="n">xnames</span> <span class="o">=</span> <span class="p">[</span><span class="s">&quot;I(y&gt;</span><span class="si">%.1f</span><span class="s">)&quot;</span> <span class="o">%</span> <span class="n">v</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">endog_cuts</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exog_orig</span><span class="p">)</span> <span class="o">==</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
            <span class="n">xnames</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exog_orig</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">xnames</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="s">&quot;x</span><span class="si">%d</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">exog</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)])</span>
        <span class="n">exog_out</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">exog_out</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">xnames</span><span class="p">)</span>

        <span class="c"># Preserve the endog name if there is one</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endog_orig</span><span class="p">)</span> <span class="o">==</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">:</span>
            <span class="n">endog_out</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">endog_out</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">endog_orig</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">endog_out</span><span class="p">,</span> <span class="n">exog_out</span><span class="p">,</span> <span class="n">groups_out</span><span class="p">,</span> <span class="n">time_out</span><span class="p">,</span> <span class="n">offset_out</span>

    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="mi">60</span><span class="p">,</span> <span class="n">ctol</span><span class="o">=</span><span class="mf">1e-6</span><span class="p">,</span> <span class="n">start_params</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
            <span class="n">params_niter</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">first_dep_update</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="n">cov_type</span><span class="o">=</span><span class="s">&#39;robust&#39;</span><span class="p">):</span>

        <span class="n">rslt</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">OrdinalGEE</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">maxiter</span><span class="p">,</span> <span class="n">ctol</span><span class="p">,</span> <span class="n">start_params</span><span class="p">,</span>
                                           <span class="n">params_niter</span><span class="p">,</span> <span class="n">first_dep_update</span><span class="p">,</span>
                                           <span class="n">cov_type</span><span class="o">=</span><span class="n">cov_type</span><span class="p">)</span>

        <span class="n">rslt</span> <span class="o">=</span> <span class="n">rslt</span><span class="o">.</span><span class="n">_results</span>   <span class="c"># use unwrapped instance</span>
        <span class="n">res_kwds</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(((</span><span class="n">k</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">rslt</span><span class="p">,</span> <span class="n">k</span><span class="p">))</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">rslt</span><span class="o">.</span><span class="n">_props</span><span class="p">))</span>
        <span class="c"># Convert the GEEResults to an OrdinalGEEResults</span>
        <span class="n">ord_rslt</span> <span class="o">=</span> <span class="n">OrdinalGEEResults</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rslt</span><span class="o">.</span><span class="n">params</span><span class="p">,</span>
                                     <span class="n">rslt</span><span class="o">.</span><span class="n">cov_params</span><span class="p">()</span> <span class="o">/</span> <span class="n">rslt</span><span class="o">.</span><span class="n">scale</span><span class="p">,</span>
                                     <span class="n">rslt</span><span class="o">.</span><span class="n">scale</span><span class="p">,</span>
                                     <span class="n">cov_type</span><span class="o">=</span><span class="n">cov_type</span><span class="p">,</span>
                                     <span class="n">attr_kwds</span><span class="o">=</span><span class="n">res_kwds</span><span class="p">)</span>
        <span class="c">#for k in rslt._props:</span>
        <span class="c">#    setattr(ord_rslt, k, getattr(rslt, k))</span>

        <span class="k">return</span> <span class="n">OrdinalGEEResultsWrapper</span><span class="p">(</span><span class="n">ord_rslt</span><span class="p">)</span>

    <span class="n">fit</span><span class="o">.</span><span class="n">__doc__</span> <span class="o">=</span> <span class="n">_gee_fit_doc</span>


<span class="k">class</span> <span class="nc">OrdinalGEEResults</span><span class="p">(</span><span class="n">GEEResults</span><span class="p">):</span>

    <span class="n">__doc__</span> <span class="o">=</span> <span class="p">(</span>
        <span class="s">&quot;This class summarizes the fit of a marginal regression model&quot;</span>
        <span class="s">&quot;for an ordinal response using GEE.</span><span class="se">\n</span><span class="s">&quot;</span>
        <span class="o">+</span> <span class="n">_gee_results_doc</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">plot_distribution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">exog_values</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the fitted probabilities of endog in an ordinal model,</span>
<span class="sd">        for specifed values of the predictors.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ax : Matplotlib axes instance</span>
<span class="sd">            An axes on which to draw the graph.  If None, new</span>
<span class="sd">            figure and axes objects are created</span>
<span class="sd">        exog_values : array-like</span>
<span class="sd">            A list of dictionaries, with each dictionary mapping</span>
<span class="sd">            variable names to values at which the variable is held</span>
<span class="sd">            fixed.  The values P(endog=y | exog) are plotted for all</span>
<span class="sd">            possible values of y, at the given exog value.  Variables</span>
<span class="sd">            not included in a dictionary are held fixed at the mean</span>
<span class="sd">            value.</span>

<span class="sd">        Example:</span>
<span class="sd">        --------</span>
<span class="sd">        We have a model with covariates &#39;age&#39; and &#39;sex&#39;, and wish to</span>
<span class="sd">        plot the probabilities P(endog=y | exog) for males (sex=0) and</span>
<span class="sd">        for females (sex=1), as separate paths on the plot.  Since</span>
<span class="sd">        &#39;age&#39; is not included below in the map, it is held fixed at</span>
<span class="sd">        its mean value.</span>

<span class="sd">        &gt;&gt; ev = [{&quot;sex&quot;: 1}, {&quot;sex&quot;: 0}]</span>
<span class="sd">        &gt;&gt; rslt.distribution_plot(exog_values=ev)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="kn">from</span> <span class="nn">statsmodels.graphics</span> <span class="kn">import</span> <span class="n">utils</span> <span class="k">as</span> <span class="n">gutils</span>

        <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">gutils</span><span class="o">.</span><span class="n">create_mpl_ax</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">get_figure</span><span class="p">()</span>

        <span class="c"># If no covariate patterns are specified, create one with all</span>
        <span class="c"># variables set to their mean values.</span>
        <span class="k">if</span> <span class="n">exog_values</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">exog_values</span> <span class="o">=</span> <span class="p">[{},]</span>

        <span class="n">exog_means</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">exog</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">ix_icept</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">exog_names</span><span class="p">)</span> <span class="k">if</span>
                    <span class="n">x</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&quot;I(&quot;</span><span class="p">)]</span>

        <span class="k">for</span> <span class="n">ev</span> <span class="ow">in</span> <span class="n">exog_values</span><span class="p">:</span>

            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">ev</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">exog_names</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%s</span><span class="s"> is not a variable in the model&quot;</span>
                                     <span class="o">%</span> <span class="n">k</span><span class="p">)</span>

            <span class="c"># Get the fitted probability for each level, at the given</span>
            <span class="c"># covariate values.</span>
            <span class="n">pr</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">ix_icept</span><span class="p">:</span>

                <span class="n">xp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>
                <span class="n">xp</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">vn</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">exog_names</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ix_icept</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="c"># User-specified value</span>
                    <span class="k">if</span> <span class="n">vn</span> <span class="ow">in</span> <span class="n">ev</span><span class="p">:</span>
                        <span class="n">xp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">ev</span><span class="p">[</span><span class="n">vn</span><span class="p">]</span>
                    <span class="c"># Mean value</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">xp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">exog_means</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

                <span class="n">p</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">xp</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">)))</span>
                <span class="n">pr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>

            <span class="n">pr</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">pr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">pr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">pr</span><span class="p">)</span>
            <span class="n">prd</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">pr</span><span class="p">)</span>

            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">endog_values</span><span class="p">,</span> <span class="n">prd</span><span class="p">,</span> <span class="s">&#39;o-&#39;</span><span class="p">)</span>

        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s">&quot;Response value&quot;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s">&quot;Probability&quot;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">fig</span>

<span class="k">class</span> <span class="nc">OrdinalGEEResultsWrapper</span><span class="p">(</span><span class="n">GEEResultsWrapper</span><span class="p">):</span>
    <span class="k">pass</span>
<span class="n">wrap</span><span class="o">.</span><span class="n">populate_wrapper</span><span class="p">(</span><span class="n">OrdinalGEEResultsWrapper</span><span class="p">,</span> <span class="n">OrdinalGEEResults</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">NominalGEE</span><span class="p">(</span><span class="n">GEE</span><span class="p">):</span>

    <span class="n">__doc__</span> <span class="o">=</span> <span class="p">(</span>
        <span class="s">&quot;    Estimation of nominal response marginal regression models</span><span class="se">\n</span><span class="s">&quot;</span>
        <span class="s">&quot;    using Generalized Estimating Equations (GEE).</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">+</span>
        <span class="n">_gee_init_doc</span> <span class="o">%</span> <span class="p">{</span><span class="s">&#39;extra_params&#39;</span><span class="p">:</span> <span class="n">base</span><span class="o">.</span><span class="n">_missing_param_doc</span><span class="p">,</span>
                         <span class="s">&#39;family_doc&#39;</span><span class="p">:</span> <span class="n">_gee_nominal_family_doc</span><span class="p">,</span>
                         <span class="s">&#39;example&#39;</span><span class="p">:</span> <span class="n">_gee_nominal_example</span><span class="p">})</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">endog</span><span class="p">,</span> <span class="n">exog</span><span class="p">,</span> <span class="n">groups</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">family</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                       <span class="n">cov_struct</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">missing</span><span class="o">=</span><span class="s">&#39;none&#39;</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                       <span class="n">dep_data</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">constraint</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>

        <span class="n">endog</span><span class="p">,</span> <span class="n">exog</span><span class="p">,</span> <span class="n">groups</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">offset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">setup_nominal</span><span class="p">(</span><span class="n">endog</span><span class="p">,</span>
                                       <span class="n">exog</span><span class="p">,</span> <span class="n">groups</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">offset</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">family</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">family</span> <span class="o">=</span> <span class="n">_Multinomial</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ncut</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">NominalGEE</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">endog</span><span class="p">,</span> <span class="n">exog</span><span class="p">,</span> <span class="n">groups</span><span class="p">,</span>
                 <span class="n">time</span><span class="p">,</span> <span class="n">family</span><span class="p">,</span> <span class="n">cov_struct</span><span class="p">,</span> <span class="n">missing</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">dep_data</span><span class="p">,</span>
                 <span class="n">constraint</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">setup_nominal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">endog</span><span class="p">,</span> <span class="n">exog</span><span class="p">,</span> <span class="n">groups</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">offset</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Restructure nominal data as binary indicators so that they can</span>
<span class="sd">        be analysed using Generalized Estimating Equations.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">endog_orig</span> <span class="o">=</span> <span class="n">endog</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">exog_orig</span> <span class="o">=</span> <span class="n">exog</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">groups_orig</span> <span class="o">=</span> <span class="n">groups</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">offset</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">offset_orig</span> <span class="o">=</span> <span class="n">offset</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">offset_orig</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">endog</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">time</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">time_orig</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">time_orig</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="n">time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">endog</span><span class="p">),</span><span class="mi">1</span><span class="p">))</span>

        <span class="n">exog</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">exog</span><span class="p">)</span>
        <span class="n">endog</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">endog</span><span class="p">)</span>
        <span class="n">groups</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">groups</span><span class="p">)</span>
        <span class="n">time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">offset</span><span class="p">)</span>

        <span class="c"># The unique outcomes, except the greatest one.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">endog_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">endog</span><span class="p">)</span>
        <span class="n">endog_cuts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">endog_values</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">ncut</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">endog_cuts</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ncut</span> <span class="o">=</span> <span class="n">ncut</span>

        <span class="n">nrows</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">endog_cuts</span><span class="p">)</span> <span class="o">*</span> <span class="n">exog</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">ncols</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">endog_cuts</span><span class="p">)</span> <span class="o">*</span> <span class="n">exog</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">exog_out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nrows</span><span class="p">,</span> <span class="n">ncols</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">endog_out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nrows</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">groups_out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nrows</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">time_out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nrows</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
                        <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">offset_out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nrows</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

        <span class="n">jrow</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">zipper</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="n">exog</span><span class="p">,</span> <span class="n">endog</span><span class="p">,</span> <span class="n">groups</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">offset</span><span class="p">)</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">exog_row</span><span class="p">,</span> <span class="n">endog_value</span><span class="p">,</span> <span class="n">group_value</span><span class="p">,</span> <span class="n">time_value</span><span class="p">,</span>
             <span class="n">offset_value</span><span class="p">)</span> <span class="ow">in</span> <span class="n">zipper</span><span class="p">:</span>

            <span class="c"># Loop over thresholds for the indicators</span>
            <span class="k">for</span> <span class="n">thresh_ix</span><span class="p">,</span> <span class="n">thresh</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">endog_cuts</span><span class="p">):</span>

                <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">endog_cuts</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
                <span class="n">u</span><span class="p">[</span><span class="n">thresh_ix</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">exog_out</span><span class="p">[</span><span class="n">jrow</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">exog_row</span><span class="p">)</span>
                <span class="n">endog_out</span><span class="p">[</span><span class="n">jrow</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">endog_value</span> <span class="o">==</span> <span class="n">thresh</span><span class="p">))</span>
                <span class="n">groups_out</span><span class="p">[</span><span class="n">jrow</span><span class="p">]</span> <span class="o">=</span> <span class="n">group_value</span>
                <span class="n">time_out</span><span class="p">[</span><span class="n">jrow</span><span class="p">]</span> <span class="o">=</span> <span class="n">time_value</span>
                <span class="n">offset_out</span><span class="p">[</span><span class="n">jrow</span><span class="p">]</span> <span class="o">=</span> <span class="n">offset_value</span>
                <span class="n">jrow</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c"># exog names</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exog_orig</span><span class="p">)</span> <span class="o">==</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
            <span class="n">xnames_in</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exog_orig</span><span class="o">.</span><span class="n">columns</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">xnames_in</span> <span class="o">=</span> <span class="p">[</span><span class="s">&quot;x</span><span class="si">%d</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">exog</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
        <span class="n">xnames</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">tr</span> <span class="ow">in</span> <span class="n">endog_cuts</span><span class="p">:</span>
            <span class="n">xnames</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="s">&quot;</span><span class="si">%s</span><span class="s">[</span><span class="si">%.1f</span><span class="s">]&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">tr</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">xnames_in</span><span class="p">])</span>
        <span class="n">exog_out</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">exog_out</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">xnames</span><span class="p">)</span>
        <span class="n">exog_out</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">exog_out</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">xnames</span><span class="p">)</span>

        <span class="c"># Preserve endog name if there is one</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endog_orig</span><span class="p">)</span> <span class="o">==</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">:</span>
            <span class="n">endog_out</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">endog_out</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">endog_orig</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">endog_out</span><span class="p">,</span> <span class="n">exog_out</span><span class="p">,</span> <span class="n">groups_out</span><span class="p">,</span> <span class="n">time_out</span><span class="p">,</span> <span class="n">offset_out</span>

    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="mi">60</span><span class="p">,</span> <span class="n">ctol</span><span class="o">=</span><span class="mf">1e-6</span><span class="p">,</span> <span class="n">start_params</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
            <span class="n">params_niter</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">first_dep_update</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="n">cov_type</span><span class="o">=</span><span class="s">&#39;robust&#39;</span><span class="p">):</span>

        <span class="n">rslt</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">NominalGEE</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">maxiter</span><span class="p">,</span> <span class="n">ctol</span><span class="p">,</span> <span class="n">start_params</span><span class="p">,</span>
                                           <span class="n">params_niter</span><span class="p">,</span> <span class="n">first_dep_update</span><span class="p">,</span>
                                           <span class="n">cov_type</span><span class="o">=</span><span class="n">cov_type</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">rslt</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;GEE updates did not converge&quot;</span><span class="p">,</span>
                          <span class="n">ConvergenceWarning</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">None</span>

        <span class="n">rslt</span> <span class="o">=</span> <span class="n">rslt</span><span class="o">.</span><span class="n">_results</span>   <span class="c"># use unwrapped instance</span>
        <span class="n">res_kwds</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(((</span><span class="n">k</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">rslt</span><span class="p">,</span> <span class="n">k</span><span class="p">))</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">rslt</span><span class="o">.</span><span class="n">_props</span><span class="p">))</span>
        <span class="c"># Convert the GEEResults to a NominalGEEResults</span>
        <span class="n">nom_rslt</span> <span class="o">=</span> <span class="n">NominalGEEResults</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rslt</span><span class="o">.</span><span class="n">params</span><span class="p">,</span>
                                     <span class="n">rslt</span><span class="o">.</span><span class="n">cov_params</span><span class="p">()</span> <span class="o">/</span> <span class="n">rslt</span><span class="o">.</span><span class="n">scale</span><span class="p">,</span>
                                     <span class="n">rslt</span><span class="o">.</span><span class="n">scale</span><span class="p">,</span>
                                     <span class="n">cov_type</span><span class="o">=</span><span class="n">cov_type</span><span class="p">,</span>
                                     <span class="n">attr_kwds</span><span class="o">=</span><span class="n">res_kwds</span><span class="p">)</span>
        <span class="c">#for k in rslt._props:</span>
        <span class="c">#    setattr(nom_rslt, k, getattr(rslt, k))</span>

        <span class="k">return</span> <span class="n">NominalGEEResultsWrapper</span><span class="p">(</span><span class="n">nom_rslt</span><span class="p">)</span>

    <span class="n">fit</span><span class="o">.</span><span class="n">__doc__</span> <span class="o">=</span> <span class="n">_gee_fit_doc</span>

<span class="k">class</span> <span class="nc">NominalGEEResults</span><span class="p">(</span><span class="n">GEEResults</span><span class="p">):</span>

    <span class="n">__doc__</span> <span class="o">=</span> <span class="p">(</span>
        <span class="s">&quot;This class summarizes the fit of a marginal regression model&quot;</span>
        <span class="s">&quot;for a nominal response using GEE.</span><span class="se">\n</span><span class="s">&quot;</span>
        <span class="o">+</span> <span class="n">_gee_results_doc</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">plot_distribution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">exog_values</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the fitted probabilities of endog in an nominal model,</span>
<span class="sd">        for specifed values of the predictors.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ax : Matplotlib axes instance</span>
<span class="sd">            An axes on which to draw the graph.  If None, new</span>
<span class="sd">            figure and axes objects are created</span>
<span class="sd">        exog_values : array-like</span>
<span class="sd">            A list of dictionaries, with each dictionary mapping</span>
<span class="sd">            variable names to values at which the variable is held</span>
<span class="sd">            fixed.  The values P(endog=y | exog) are plotted for all</span>
<span class="sd">            possible values of y, at the given exog value.  Variables</span>
<span class="sd">            not included in a dictionary are held fixed at the mean</span>
<span class="sd">            value.</span>

<span class="sd">        Example:</span>
<span class="sd">        --------</span>
<span class="sd">        We have a model with covariates &#39;age&#39; and &#39;sex&#39;, and wish to</span>
<span class="sd">        plot the probabilities P(endog=y | exog) for males (sex=0) and</span>
<span class="sd">        for females (sex=1), as separate paths on the plot.  Since</span>
<span class="sd">        &#39;age&#39; is not included below in the map, it is held fixed at</span>
<span class="sd">        its mean value.</span>

<span class="sd">        &gt;&gt;&gt; ex = [{&quot;sex&quot;: 1}, {&quot;sex&quot;: 0}]</span>
<span class="sd">        &gt;&gt;&gt; rslt.distribution_plot(exog_values=ex)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="kn">from</span> <span class="nn">statsmodels.graphics</span> <span class="kn">import</span> <span class="n">utils</span> <span class="k">as</span> <span class="n">gutils</span>

        <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">gutils</span><span class="o">.</span><span class="n">create_mpl_ax</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">get_figure</span><span class="p">()</span>

        <span class="c"># If no covariate patterns are specified, create one with all</span>
        <span class="c"># variables set to their mean values.</span>
        <span class="k">if</span> <span class="n">exog_values</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">exog_values</span> <span class="o">=</span> <span class="p">[{},]</span>

        <span class="n">link</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">family</span><span class="o">.</span><span class="n">link</span><span class="o">.</span><span class="n">inverse</span>
        <span class="n">ncut</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">family</span><span class="o">.</span><span class="n">ncut</span>

        <span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">exog</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">ncut</span>
        <span class="n">exog_means</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">exog</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">:</span><span class="n">k</span><span class="p">]</span>
        <span class="n">exog_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">exog_names</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">k</span><span class="p">]</span>
        <span class="n">exog_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&quot;[&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">exog_names</span><span class="p">]</span>

        <span class="n">params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">,</span>
                            <span class="p">(</span><span class="n">ncut</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">)</span> <span class="o">/</span> <span class="n">ncut</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">ev</span> <span class="ow">in</span> <span class="n">exog_values</span><span class="p">:</span>

            <span class="n">exog</span> <span class="o">=</span> <span class="n">exog_means</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">ev</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">exog_names</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%s</span><span class="s"> is not a variable in the model&quot;</span>
                                     <span class="o">%</span> <span class="n">k</span><span class="p">)</span>

                <span class="n">ii</span> <span class="o">=</span> <span class="n">exog_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                <span class="n">exog</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">ev</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>

            <span class="n">lpr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">exog</span><span class="p">)</span>
            <span class="n">pr</span> <span class="o">=</span> <span class="n">link</span><span class="p">(</span><span class="n">lpr</span><span class="p">)</span>
            <span class="n">pr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">pr</span><span class="p">,</span> <span class="mi">1</span><span class="o">-</span><span class="n">pr</span><span class="o">.</span><span class="n">sum</span><span class="p">()]</span>

            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">endog_values</span><span class="p">,</span> <span class="n">pr</span><span class="p">,</span> <span class="s">&#39;o-&#39;</span><span class="p">)</span>

        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s">&quot;Response value&quot;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s">&quot;Probability&quot;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">endog_values</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xticklabels</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">endog_values</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">fig</span>

<span class="k">class</span> <span class="nc">NominalGEEResultsWrapper</span><span class="p">(</span><span class="n">GEEResultsWrapper</span><span class="p">):</span>
    <span class="k">pass</span>
<span class="n">wrap</span><span class="o">.</span><span class="n">populate_wrapper</span><span class="p">(</span><span class="n">NominalGEEResultsWrapper</span><span class="p">,</span> <span class="n">NominalGEEResults</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">_MultinomialLogit</span><span class="p">(</span><span class="n">Link</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The multinomial logit transform, only for use with GEE.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The data are assumed coded as binary indicators, where each</span>
<span class="sd">    observed multinomial value y is coded as I(y == S[0]), ..., I(y ==</span>
<span class="sd">    S[-1]), where S is the set of possible response labels, excluding</span>
<span class="sd">    the largest one.  Thererefore functions in this class should only</span>
<span class="sd">    be called using vector argument whose length is a multiple of |S|</span>
<span class="sd">    = ncut, which is an argument to be provided when initializing the</span>
<span class="sd">    class.</span>

<span class="sd">    call and derivative use a private method _clean to trim p by 1e-10</span>
<span class="sd">    so that p is in (0, 1)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ncut</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ncut</span> <span class="o">=</span> <span class="n">ncut</span>

    <span class="k">def</span> <span class="nf">inverse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lpr</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Inverse of the multinomial logit transform, which gives the</span>
<span class="sd">        expected values of the data as a function of the linear</span>
<span class="sd">        predictors.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        lpr : array-like (length must be divisible by `ncut`)</span>
<span class="sd">            The linear predictors</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        prob : array</span>
<span class="sd">            Probabilities, or expected values</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">expval</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">lpr</span><span class="p">)</span>

        <span class="n">denom</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">expval</span><span class="p">,</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">expval</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncut</span><span class="p">,</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">ncut</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">denom</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">denom</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ncut</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">))</span>

        <span class="n">prob</span> <span class="o">=</span> <span class="n">expval</span> <span class="o">/</span> <span class="n">denom</span>

        <span class="k">return</span> <span class="n">prob</span>

    <span class="k">def</span> <span class="nf">mean_deriv</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exog</span><span class="p">,</span> <span class="n">lpr</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Derivative of the expected endog with respect to param.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        exog : array-like</span>
<span class="sd">           The exogeneous data at which the derivative is computed,</span>
<span class="sd">           number of rows must be a multiple of `ncut`.</span>
<span class="sd">        lpr : array-like</span>
<span class="sd">           The linear predictor values, length must be multiple of</span>
<span class="sd">           `ncut`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        The value of the derivative of the expected endog with respect</span>
<span class="sd">        to param</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">expval</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">lpr</span><span class="p">)</span>

        <span class="n">expval_m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">expval</span><span class="p">,</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">expval</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncut</span><span class="p">,</span>
                                       <span class="bp">self</span><span class="o">.</span><span class="n">ncut</span><span class="p">))</span>

        <span class="n">denom</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">expval_m</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">denom</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">denom</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ncut</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">))</span>

        <span class="n">dmat</span> <span class="o">=</span> <span class="n">expval</span><span class="p">[:,</span> <span class="bp">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">exog</span> <span class="o">/</span> <span class="n">denom</span><span class="p">[:,</span> <span class="bp">None</span><span class="p">]</span>

        <span class="n">ones</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ncut</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">cmat</span> <span class="o">=</span> <span class="n">block_diag</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">ones</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">expval_m</span><span class="p">],</span> <span class="s">&quot;csr&quot;</span><span class="p">)</span>
        <span class="n">rmat</span> <span class="o">=</span> <span class="n">cmat</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">exog</span><span class="p">)</span>
        <span class="n">dmat</span> <span class="o">-=</span> <span class="n">expval</span><span class="p">[:,</span> <span class="bp">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">rmat</span> <span class="o">/</span> <span class="n">denom</span><span class="p">[:,</span> <span class="bp">None</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span>

        <span class="k">return</span> <span class="n">dmat</span>

    <span class="c"># Minimally tested</span>
    <span class="k">def</span> <span class="nf">mean_deriv_exog</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exog</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Derivative of the expected endog with respect to exog for the</span>
<span class="sd">        multinomial model, used in analyzing marginal effects.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        exog : array-like</span>
<span class="sd">           The exogeneous data at which the derivative is computed,</span>
<span class="sd">           number of rows must be a multiple of `ncut`.</span>
<span class="sd">        lpr : array-like</span>
<span class="sd">           The linear predictor values, length must be multiple of</span>
<span class="sd">           `ncut`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        The value of the derivative of the expected endog with respect</span>
<span class="sd">        to exog.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">lpr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">exog</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>
        <span class="n">expval</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">lpr</span><span class="p">)</span>

        <span class="n">expval_m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">expval</span><span class="p">,</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">expval</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncut</span><span class="p">,</span>
                                       <span class="bp">self</span><span class="o">.</span><span class="n">ncut</span><span class="p">))</span>

        <span class="n">denom</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">expval_m</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">denom</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">denom</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ncut</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">))</span>

        <span class="n">bmat0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">exog</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">params</span><span class="p">)</span>

        <span class="c"># Masking matrix</span>
        <span class="n">qmat</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ncut</span><span class="p">):</span>
            <span class="n">ee</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ncut</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="n">ee</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">qmat</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">ee</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncut</span><span class="p">)))</span>
        <span class="n">qmat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">qmat</span><span class="p">)</span>
        <span class="n">qmat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">exog</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">ncut</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span> <span class="n">qmat</span><span class="p">)</span>
        <span class="n">bmat</span> <span class="o">=</span> <span class="n">bmat0</span> <span class="o">*</span> <span class="n">qmat</span>

        <span class="n">dmat</span> <span class="o">=</span> <span class="n">expval</span><span class="p">[:,</span> <span class="bp">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">bmat</span> <span class="o">/</span> <span class="n">denom</span><span class="p">[:,</span> <span class="bp">None</span><span class="p">]</span>

        <span class="n">expval_mb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">expval_m</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">ncut</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span>
        <span class="n">expval_mb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">expval_mb</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncut</span><span class="p">)))</span>

        <span class="n">dmat</span> <span class="o">-=</span> <span class="n">expval</span><span class="p">[:,</span> <span class="bp">None</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">bmat</span> <span class="o">*</span> <span class="n">expval_mb</span><span class="p">)</span> <span class="o">/</span> <span class="n">denom</span><span class="p">[:,</span> <span class="bp">None</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span>

        <span class="k">return</span> <span class="n">dmat</span>


<span class="k">class</span> <span class="nc">_Multinomial</span><span class="p">(</span><span class="n">families</span><span class="o">.</span><span class="n">Family</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Pseudo-link function for fitting nominal multinomial models with</span>
<span class="sd">    GEE.  Not for use outside the GEE class.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">links</span> <span class="o">=</span> <span class="p">[</span><span class="n">_MultinomialLogit</span><span class="p">,]</span>
    <span class="n">variance</span> <span class="o">=</span> <span class="n">varfuncs</span><span class="o">.</span><span class="n">binary</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nlevels</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nlevels : integer</span>
<span class="sd">            The number of distinct categories for the multinomial</span>
<span class="sd">            distribution.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initialize</span><span class="p">(</span><span class="n">nlevels</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nlevels</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ncut</span> <span class="o">=</span> <span class="n">nlevels</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">link</span> <span class="o">=</span> <span class="n">_MultinomialLogit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ncut</span><span class="p">)</span>




<span class="kn">from</span> <span class="nn">statsmodels.discrete.discrete_margins</span> <span class="kn">import</span> \
    <span class="n">_get_margeff_exog</span><span class="p">,</span> <span class="n">_get_const_index</span><span class="p">,</span> <span class="n">_check_margeff_args</span><span class="p">,</span> \
    <span class="n">_effects_at</span><span class="p">,</span> <span class="n">margeff_cov_with_se</span><span class="p">,</span> <span class="n">_check_at_is_all</span><span class="p">,</span> \
    <span class="n">_transform_names</span><span class="p">,</span> \
    <span class="n">_check_discrete_args</span><span class="p">,</span> <span class="n">_get_dummy_index</span><span class="p">,</span> <span class="n">_get_count_index</span>



<div class="viewcode-block" id="GEEMargins"><a class="viewcode-back" href="../../../generated/statsmodels.genmod.generalized_estimating_equations.GEEMargins.html#statsmodels.genmod.generalized_estimating_equations.GEEMargins">[docs]</a><span class="k">class</span> <span class="nc">GEEMargins</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Estimate the marginal effects of a model fit using generalized</span>
<span class="sd">    estimating equations.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    results : GEEResults instance</span>
<span class="sd">        The results instance of a fitted discrete choice model</span>
<span class="sd">    args : tuple</span>
<span class="sd">        Args are passed to `get_margeff`. This is the same as</span>
<span class="sd">        results.get_margeff. See there for more information.</span>
<span class="sd">    kwargs : dict</span>
<span class="sd">        Keyword args are passed to `get_margeff`. This is the same as</span>
<span class="sd">        results.get_margeff. See there for more information.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">results</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">=</span><span class="p">{}):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span> <span class="o">=</span> <span class="n">resettable_cache</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">results</span> <span class="o">=</span> <span class="n">results</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">get_margeff</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span> <span class="o">=</span> <span class="n">resettable_cache</span><span class="p">()</span>

    <span class="nd">@cache_readonly</span>
<div class="viewcode-block" id="GEEMargins.tvalues"><a class="viewcode-back" href="../../../generated/statsmodels.genmod.generalized_estimating_equations.GEEMargins.tvalues.html#statsmodels.genmod.generalized_estimating_equations.GEEMargins.tvalues">[docs]</a>    <span class="k">def</span> <span class="nf">tvalues</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">_check_at_is_all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">margeff_options</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">margeff</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">margeff_se</span>
</div>
<div class="viewcode-block" id="GEEMargins.summary_frame"><a class="viewcode-back" href="../../../generated/statsmodels.genmod.generalized_estimating_equations.GEEMargins.summary_frame.html#statsmodels.genmod.generalized_estimating_equations.GEEMargins.summary_frame">[docs]</a>    <span class="k">def</span> <span class="nf">summary_frame</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=.</span><span class="mo">05</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a DataFrame summarizing the marginal effects.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        alpha : float</span>
<span class="sd">            Number between 0 and 1. The confidence intervals have the</span>
<span class="sd">            probability 1-alpha.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        frame : DataFrames</span>
<span class="sd">            A DataFrame summarizing the marginal effects.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_check_at_is_all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">margeff_options</span><span class="p">)</span>
        <span class="kn">from</span> <span class="nn">pandas</span> <span class="kn">import</span> <span class="n">DataFrame</span>
        <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="n">_transform_names</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">margeff_options</span><span class="p">[</span><span class="s">&#39;method&#39;</span><span class="p">]],</span>
                                  <span class="s">&#39;Std. Err.&#39;</span><span class="p">,</span> <span class="s">&#39;z&#39;</span><span class="p">,</span> <span class="s">&#39;Pr(&gt;|z|)&#39;</span><span class="p">,</span>
                                  <span class="s">&#39;Conf. Int. Low&#39;</span><span class="p">,</span> <span class="s">&#39;Cont. Int. Hi.&#39;</span><span class="p">]</span>
        <span class="n">ind</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">exog</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="c"># True if not a constant</span>
        <span class="n">exog_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">exog_names</span>
        <span class="n">var_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">name</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">exog_names</span><span class="p">)</span> <span class="k">if</span> <span class="n">ind</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
        <span class="n">table</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">margeff</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">margeff_se</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tvalues</span><span class="p">,</span>
                                 <span class="bp">self</span><span class="o">.</span><span class="n">pvalues</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">conf_int</span><span class="p">(</span><span class="n">alpha</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">DataFrame</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">names</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">var_names</span><span class="p">)</span>
</div>
    <span class="nd">@cache_readonly</span>
<div class="viewcode-block" id="GEEMargins.pvalues"><a class="viewcode-back" href="../../../generated/statsmodels.genmod.generalized_estimating_equations.GEEMargins.pvalues.html#statsmodels.genmod.generalized_estimating_equations.GEEMargins.pvalues">[docs]</a>    <span class="k">def</span> <span class="nf">pvalues</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">_check_at_is_all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">margeff_options</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">sf</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tvalues</span><span class="p">))</span> <span class="o">*</span> <span class="mi">2</span>
</div>
<div class="viewcode-block" id="GEEMargins.conf_int"><a class="viewcode-back" href="../../../generated/statsmodels.genmod.generalized_estimating_equations.GEEMargins.conf_int.html#statsmodels.genmod.generalized_estimating_equations.GEEMargins.conf_int">[docs]</a>    <span class="k">def</span> <span class="nf">conf_int</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=.</span><span class="mo">05</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the confidence intervals of the marginal effects</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        alpha : float</span>
<span class="sd">            Number between 0 and 1. The confidence intervals have the</span>
<span class="sd">            probability 1-alpha.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        conf_int : ndarray</span>
<span class="sd">            An array with lower, upper confidence intervals for the marginal</span>
<span class="sd">            effects.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_check_at_is_all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">margeff_options</span><span class="p">)</span>
        <span class="n">me_se</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">margeff_se</span>
        <span class="n">q</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">alpha</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">lower</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">margeff</span> <span class="o">-</span> <span class="n">q</span> <span class="o">*</span> <span class="n">me_se</span>
        <span class="n">upper</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">margeff</span> <span class="o">+</span> <span class="n">q</span> <span class="o">*</span> <span class="n">me_se</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">lzip</span><span class="p">(</span><span class="n">lower</span><span class="p">,</span> <span class="n">upper</span><span class="p">))</span>
</div>
<div class="viewcode-block" id="GEEMargins.summary"><a class="viewcode-back" href="../../../generated/statsmodels.genmod.generalized_estimating_equations.GEEMargins.summary.html#statsmodels.genmod.generalized_estimating_equations.GEEMargins.summary">[docs]</a>    <span class="k">def</span> <span class="nf">summary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=.</span><span class="mo">05</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a summary table for marginal effects</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        alpha : float</span>
<span class="sd">            Number between 0 and 1. The confidence intervals have the</span>
<span class="sd">            probability 1-alpha.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Summary : SummaryTable</span>
<span class="sd">            A SummaryTable instance</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_check_at_is_all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">margeff_options</span><span class="p">)</span>
        <span class="n">results</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">results</span>
        <span class="n">model</span> <span class="o">=</span> <span class="n">results</span><span class="o">.</span><span class="n">model</span>
        <span class="n">title</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span> <span class="o">+</span> <span class="s">&quot; Marginal Effects&quot;</span>
        <span class="n">method</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">margeff_options</span><span class="p">[</span><span class="s">&#39;method&#39;</span><span class="p">]</span>
        <span class="n">top_left</span> <span class="o">=</span> <span class="p">[(</span><span class="s">&#39;Dep. Variable:&#39;</span><span class="p">,</span> <span class="p">[</span><span class="n">model</span><span class="o">.</span><span class="n">endog_names</span><span class="p">]),</span>
                <span class="p">(</span><span class="s">&#39;Method:&#39;</span><span class="p">,</span> <span class="p">[</span><span class="n">method</span><span class="p">]),</span>
                <span class="p">(</span><span class="s">&#39;At:&#39;</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">margeff_options</span><span class="p">[</span><span class="s">&#39;at&#39;</span><span class="p">]]),]</span>

        <span class="kn">from</span> <span class="nn">statsmodels.iolib.summary</span> <span class="kn">import</span> <span class="p">(</span><span class="n">Summary</span><span class="p">,</span> <span class="n">summary_params</span><span class="p">,</span>
                                                <span class="n">table_extend</span><span class="p">)</span>
        <span class="n">exog_names</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">exog_names</span><span class="p">[:]</span> <span class="c"># copy</span>
        <span class="n">smry</span> <span class="o">=</span> <span class="n">Summary</span><span class="p">()</span>

        <span class="c"># sigh, we really need to hold on to this in _data...</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">const_idx</span> <span class="o">=</span> <span class="n">_get_const_index</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">exog</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">const_idx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">exog_names</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">const_idx</span><span class="p">)</span>

        <span class="n">J</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="s">&quot;J&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">J</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">yname</span><span class="p">,</span> <span class="n">yname_list</span> <span class="o">=</span> <span class="n">results</span><span class="o">.</span><span class="n">_get_endog_name</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">endog_names</span><span class="p">,</span>
                                                <span class="bp">None</span><span class="p">,</span> <span class="nb">all</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">yname</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">endog_names</span>
            <span class="n">yname_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">yname</span><span class="p">]</span>

        <span class="n">smry</span><span class="o">.</span><span class="n">add_table_2cols</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gleft</span><span class="o">=</span><span class="n">top_left</span><span class="p">,</span> <span class="n">gright</span><span class="o">=</span><span class="p">[],</span>
                <span class="n">yname</span><span class="o">=</span><span class="n">yname</span><span class="p">,</span> <span class="n">xname</span><span class="o">=</span><span class="n">exog_names</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">)</span>

        <span class="c">#NOTE: add_table_params is not general enough yet for margeff</span>
        <span class="c"># could use a refactor with getattr instead of hard-coded params</span>
        <span class="c"># tvalues etc.</span>
        <span class="n">table</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">conf_int</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">conf_int</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>
        <span class="n">margeff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">margeff</span>
        <span class="n">margeff_se</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">margeff_se</span>
        <span class="n">tvalues</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tvalues</span>
        <span class="n">pvalues</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pvalues</span>
        <span class="k">if</span> <span class="n">J</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">eq</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">J</span><span class="p">):</span>
                <span class="n">restup</span> <span class="o">=</span> <span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="n">margeff</span><span class="p">[:,</span> <span class="n">eq</span><span class="p">],</span> <span class="n">margeff_se</span><span class="p">[:,</span> <span class="n">eq</span><span class="p">],</span>
                          <span class="n">tvalues</span><span class="p">[:,</span> <span class="n">eq</span><span class="p">],</span> <span class="n">pvalues</span><span class="p">[:,</span> <span class="n">eq</span><span class="p">],</span> <span class="n">conf_int</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">eq</span><span class="p">])</span>
                <span class="n">tble</span> <span class="o">=</span> <span class="n">summary_params</span><span class="p">(</span><span class="n">restup</span><span class="p">,</span> <span class="n">yname</span><span class="o">=</span><span class="n">yname_list</span><span class="p">[</span><span class="n">eq</span><span class="p">],</span>
                              <span class="n">xname</span><span class="o">=</span><span class="n">exog_names</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">use_t</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                              <span class="n">skip_header</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
                <span class="n">tble</span><span class="o">.</span><span class="n">title</span> <span class="o">=</span> <span class="n">yname_list</span><span class="p">[</span><span class="n">eq</span><span class="p">]</span>
                <span class="c"># overwrite coef with method name</span>
                <span class="n">header</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;&#39;</span><span class="p">,</span> <span class="n">_transform_names</span><span class="p">[</span><span class="n">method</span><span class="p">],</span> <span class="s">&#39;std err&#39;</span><span class="p">,</span> <span class="s">&#39;z&#39;</span><span class="p">,</span>
                        <span class="s">&#39;P&gt;|z|&#39;</span><span class="p">,</span> <span class="s">&#39;[</span><span class="si">%3.1f%%</span><span class="s"> Conf. Int.]&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="mi">100</span><span class="o">-</span><span class="n">alpha</span><span class="o">*</span><span class="mi">100</span><span class="p">)]</span>
                <span class="n">tble</span><span class="o">.</span><span class="n">insert_header_row</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">header</span><span class="p">)</span>
                <span class="c">#from IPython.core.debugger import Pdb; Pdb().set_trace()</span>
                <span class="n">table</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tble</span><span class="p">)</span>

            <span class="n">table</span> <span class="o">=</span> <span class="n">table_extend</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">keep_headers</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">restup</span> <span class="o">=</span> <span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="n">margeff</span><span class="p">,</span> <span class="n">margeff_se</span><span class="p">,</span> <span class="n">tvalues</span><span class="p">,</span> <span class="n">pvalues</span><span class="p">,</span> <span class="n">conf_int</span><span class="p">)</span>
            <span class="n">table</span> <span class="o">=</span> <span class="n">summary_params</span><span class="p">(</span><span class="n">restup</span><span class="p">,</span> <span class="n">yname</span><span class="o">=</span><span class="n">yname</span><span class="p">,</span> <span class="n">xname</span><span class="o">=</span><span class="n">exog_names</span><span class="p">,</span>
                    <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">use_t</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">skip_header</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
            <span class="n">header</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;&#39;</span><span class="p">,</span> <span class="n">_transform_names</span><span class="p">[</span><span class="n">method</span><span class="p">],</span> <span class="s">&#39;std err&#39;</span><span class="p">,</span> <span class="s">&#39;z&#39;</span><span class="p">,</span>
                        <span class="s">&#39;P&gt;|z|&#39;</span><span class="p">,</span> <span class="s">&#39;[</span><span class="si">%3.1f%%</span><span class="s"> Conf. Int.]&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="mi">100</span><span class="o">-</span><span class="n">alpha</span><span class="o">*</span><span class="mi">100</span><span class="p">)]</span>
            <span class="n">table</span><span class="o">.</span><span class="n">insert_header_row</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">header</span><span class="p">)</span>

        <span class="n">smry</span><span class="o">.</span><span class="n">tables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">table</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">smry</span>
</div>
<div class="viewcode-block" id="GEEMargins.get_margeff"><a class="viewcode-back" href="../../../generated/statsmodels.genmod.generalized_estimating_equations.GEEMargins.get_margeff.html#statsmodels.genmod.generalized_estimating_equations.GEEMargins.get_margeff">[docs]</a>    <span class="k">def</span> <span class="nf">get_margeff</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">at</span><span class="o">=</span><span class="s">&#39;overall&#39;</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s">&#39;dydx&#39;</span><span class="p">,</span> <span class="n">atexog</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                          <span class="n">dummy</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get marginal effects of the fitted model.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        at : str, optional</span>
<span class="sd">            Options are:</span>

<span class="sd">            - &#39;overall&#39;, The average of the marginal effects at each</span>
<span class="sd">              observation.</span>
<span class="sd">            - &#39;mean&#39;, The marginal effects at the mean of each regressor.</span>
<span class="sd">            - &#39;median&#39;, The marginal effects at the median of each regressor.</span>
<span class="sd">            - &#39;zero&#39;, The marginal effects at zero for each regressor.</span>
<span class="sd">            - &#39;all&#39;, The marginal effects at each observation. If `at` is all</span>
<span class="sd">              only margeff will be available.</span>

<span class="sd">            Note that if `exog` is specified, then marginal effects for all</span>
<span class="sd">            variables not specified by `exog` are calculated using the `at`</span>
<span class="sd">            option.</span>
<span class="sd">        method : str, optional</span>
<span class="sd">            Options are:</span>

<span class="sd">            - &#39;dydx&#39; - dy/dx - No transformation is made and marginal effects</span>
<span class="sd">              are returned.  This is the default.</span>
<span class="sd">            - &#39;eyex&#39; - estimate elasticities of variables in `exog` --</span>
<span class="sd">              d(lny)/d(lnx)</span>
<span class="sd">            - &#39;dyex&#39; - estimate semielasticity -- dy/d(lnx)</span>
<span class="sd">            - &#39;eydx&#39; - estimate semeilasticity -- d(lny)/dx</span>

<span class="sd">            Note that tranformations are done after each observation is</span>
<span class="sd">            calculated.  Semi-elasticities for binary variables are computed</span>
<span class="sd">            using the midpoint method. &#39;dyex&#39; and &#39;eyex&#39; do not make sense</span>
<span class="sd">            for discrete variables.</span>
<span class="sd">        atexog : array-like, optional</span>
<span class="sd">            Optionally, you can provide the exogenous variables over which to</span>
<span class="sd">            get the marginal effects.  This should be a dictionary with the key</span>
<span class="sd">            as the zero-indexed column number and the value of the dictionary.</span>
<span class="sd">            Default is None for all independent variables less the constant.</span>
<span class="sd">        dummy : bool, optional</span>
<span class="sd">            If False, treats binary variables (if present) as continuous.  This</span>
<span class="sd">            is the default.  Else if True, treats binary variables as</span>
<span class="sd">            changing from 0 to 1.  Note that any variable that is either 0 or 1</span>
<span class="sd">            is treated as binary.  Each binary variable is treated separately</span>
<span class="sd">            for now.</span>
<span class="sd">        count : bool, optional</span>
<span class="sd">            If False, treats count variables (if present) as continuous.  This</span>
<span class="sd">            is the default.  Else if True, the marginal effect is the</span>
<span class="sd">            change in probabilities when each observation is increased by one.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        effects : ndarray</span>
<span class="sd">            the marginal effect corresponding to the input options</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        When using after Poisson, returns the expected number of events</span>
<span class="sd">        per period, assuming that the model is loglinear.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_reset</span><span class="p">()</span> <span class="c"># always reset the cache when this is called</span>
        <span class="c">#TODO: if at is not all or overall, we can also put atexog values</span>
        <span class="c"># in summary table head</span>
        <span class="n">method</span> <span class="o">=</span> <span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="n">at</span> <span class="o">=</span> <span class="n">at</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="n">_check_margeff_args</span><span class="p">(</span><span class="n">at</span><span class="p">,</span> <span class="n">method</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">margeff_options</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">at</span><span class="o">=</span><span class="n">at</span><span class="p">)</span>
        <span class="n">results</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">results</span>
        <span class="n">model</span> <span class="o">=</span> <span class="n">results</span><span class="o">.</span><span class="n">model</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">results</span><span class="o">.</span><span class="n">params</span>
        <span class="n">exog</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">exog</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="c"># copy because values are changed</span>
        <span class="n">effects_idx</span><span class="p">,</span> <span class="n">const_idx</span> <span class="o">=</span> <span class="n">_get_const_index</span><span class="p">(</span><span class="n">exog</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">dummy</span><span class="p">:</span>
            <span class="n">_check_discrete_args</span><span class="p">(</span><span class="n">at</span><span class="p">,</span> <span class="n">method</span><span class="p">)</span>
            <span class="n">dummy_idx</span><span class="p">,</span> <span class="n">dummy</span> <span class="o">=</span> <span class="n">_get_dummy_index</span><span class="p">(</span><span class="n">exog</span><span class="p">,</span> <span class="n">const_idx</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dummy_idx</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="k">if</span> <span class="n">count</span><span class="p">:</span>
            <span class="n">_check_discrete_args</span><span class="p">(</span><span class="n">at</span><span class="p">,</span> <span class="n">method</span><span class="p">)</span>
            <span class="n">count_idx</span><span class="p">,</span> <span class="n">count</span> <span class="o">=</span> <span class="n">_get_count_index</span><span class="p">(</span><span class="n">exog</span><span class="p">,</span> <span class="n">const_idx</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">count_idx</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="c"># get the exogenous variables</span>
        <span class="n">exog</span> <span class="o">=</span> <span class="n">_get_margeff_exog</span><span class="p">(</span><span class="n">exog</span><span class="p">,</span> <span class="n">at</span><span class="p">,</span> <span class="n">atexog</span><span class="p">,</span> <span class="n">effects_idx</span><span class="p">)</span>

        <span class="c"># get base marginal effects, handled by sub-classes</span>
        <span class="n">effects</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">_derivative_exog</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">exog</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span>
                                                    <span class="n">dummy_idx</span><span class="p">,</span> <span class="n">count_idx</span><span class="p">)</span>

        <span class="n">J</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="s">&#39;J&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">effects_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">effects_idx</span><span class="p">,</span> <span class="n">J</span><span class="p">)</span> <span class="c"># adjust for multi-equation.</span>

        <span class="n">effects</span> <span class="o">=</span> <span class="n">_effects_at</span><span class="p">(</span><span class="n">effects</span><span class="p">,</span> <span class="n">at</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">at</span> <span class="o">==</span> <span class="s">&#39;all&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">J</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">K</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">K</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">effects_idx</span><span class="p">)</span> <span class="c"># subtract constant</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">margeff</span> <span class="o">=</span> <span class="n">effects</span><span class="p">[:,</span> <span class="n">effects_idx</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">K</span><span class="p">,</span> <span class="n">J</span><span class="p">,</span>
                                                                <span class="n">order</span><span class="o">=</span><span class="s">&#39;F&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">margeff</span> <span class="o">=</span> <span class="n">effects</span><span class="p">[:,</span> <span class="n">effects_idx</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># Set standard error of the marginal effects by Delta method.</span>
            <span class="n">margeff_cov</span><span class="p">,</span> <span class="n">margeff_se</span> <span class="o">=</span> <span class="n">margeff_cov_with_se</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">exog</span><span class="p">,</span>
                                                <span class="n">results</span><span class="o">.</span><span class="n">cov_params</span><span class="p">(),</span> <span class="n">at</span><span class="p">,</span>
                                                <span class="n">model</span><span class="o">.</span><span class="n">_derivative_exog</span><span class="p">,</span>
                                                <span class="n">dummy_idx</span><span class="p">,</span> <span class="n">count_idx</span><span class="p">,</span>
                                                <span class="n">method</span><span class="p">,</span> <span class="n">J</span><span class="p">)</span>

            <span class="c"># reshape for multi-equation</span>
            <span class="k">if</span> <span class="n">J</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">K</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">K</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">effects_idx</span><span class="p">)</span> <span class="c"># subtract constant</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">margeff</span> <span class="o">=</span> <span class="n">effects</span><span class="p">[</span><span class="n">effects_idx</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="n">J</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s">&#39;F&#39;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">margeff_se</span> <span class="o">=</span> <span class="n">margeff_se</span><span class="p">[</span><span class="n">effects_idx</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="n">J</span><span class="p">,</span>
                                                                  <span class="n">order</span><span class="o">=</span><span class="s">&#39;F&#39;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">margeff_cov</span> <span class="o">=</span> <span class="n">margeff_cov</span><span class="p">[</span><span class="n">effects_idx</span><span class="p">][:,</span> <span class="n">effects_idx</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c"># don&#39;t care about at constant</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">margeff_cov</span> <span class="o">=</span> <span class="n">margeff_cov</span><span class="p">[</span><span class="n">effects_idx</span><span class="p">][:,</span> <span class="n">effects_idx</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">margeff_se</span> <span class="o">=</span> <span class="n">margeff_se</span><span class="p">[</span><span class="n">effects_idx</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">margeff</span> <span class="o">=</span> <span class="n">effects</span><span class="p">[</span><span class="n">effects_idx</span><span class="p">]</span></div></div>
</pre></div>




          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2009-2013, Josef Perktold, Skipper Seabold, Jonathan Taylor, statsmodels-developers.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.1.
    </div>
  </body>
</html>