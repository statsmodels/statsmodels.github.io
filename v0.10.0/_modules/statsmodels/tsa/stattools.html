

<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>statsmodels.tsa.stattools &#8212; statsmodels v0.10.0 documentation</title>
    <link rel="stylesheet" href="../../../_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../_static/language_data.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="shortcut icon" href="../../../_static/statsmodels_hybi_favico.ico"/>
    <link rel="author" title="About these documents" href="../../../about.html" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
<link rel="stylesheet" href="../../../_static/examples.css" type="text/css" />
<link rel="stylesheet" href="../../../_static/facebox.css" type="text/css" />
<script type="text/javascript" src="../../../_static/scripts.js">
</script>
<script type="text/javascript" src="../../../_static/facebox.js">
</script>
<script type="text/javascript">
$.facebox.settings.closeImage = "../../../_static/closelabel.png"
$.facebox.settings.loadingImage = "../../../_static/loading.gif"
</script>

<script>
$(document).ready(function() {
  $.getJSON("../../../../versions.json", function(versions) {
    var dropdown = document.createElement("div");
    dropdown.className = "dropdown";
    var button = document.createElement("button");
    button.className = "dropbtn";
    button.innerHTML = "Other Versions";
    var content = document.createElement("div");
    content.className = "dropdown-content";
    dropdown.appendChild(button);
    dropdown.appendChild(content);
    $(".header").prepend(dropdown);
    for (var i = 0; i < versions.length; i++) {
      if (versions[i].substring(0, 1) == "v") {
        versions[i] = [versions[i], versions[i].substring(1)];
      } else {
        versions[i] = [versions[i], versions[i]];
      };
    };
    for (var i = 0; i < versions.length; i++) {
      var a = document.createElement("a");
      a.innerHTML = versions[i][1];
      a.href = "../../../../" + versions[i][0] + "/index.html";
      a.title = versions[i][1];
      $(".dropdown-content").append(a);
    };
  });
});
</script>


  </head><body>
<div class="headerwrap">
    <div class = "header">
        
        <a href = "../../../index.html">
<img src="../../../_static/statsmodels_hybi_banner.png" alt="Logo"
    style="padding-left: 15px"/></a>
        
    </div>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
<li><a href ="../../../install.html">Install</a></li> &nbsp;|&nbsp;
<li><a href="https://groups.google.com/forum/?hl=en#!forum/pystatsmodels">Support</a></li> &nbsp;|&nbsp;
<li><a href="https://github.com/statsmodels/statsmodels/issues">Bugs</a></li> &nbsp;|&nbsp;
<li><a href="../../../dev/index.html">Develop</a></li> &nbsp;|&nbsp;
<li><a href="../../../examples/index.html">Examples</a></li> &nbsp;|&nbsp;
<li><a href="../../../faq.html">FAQ</a></li> &nbsp;|&nbsp;

          <li class="nav-item nav-item-1"><a href="../../index.html" accesskey="U">Module code</a> |</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            




  <h1>Source code for statsmodels.tsa.stattools</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Statistical tools for time series analysis</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">division</span>
<span class="kn">from</span> <span class="nn">statsmodels.compat.python</span> <span class="k">import</span> <span class="p">(</span><span class="n">iteritems</span><span class="p">,</span> <span class="nb">range</span><span class="p">,</span> <span class="n">lrange</span><span class="p">,</span> <span class="n">string_types</span><span class="p">,</span>
                                       <span class="n">lzip</span><span class="p">,</span> <span class="nb">zip</span><span class="p">,</span> <span class="n">long</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">statsmodels.compat.numpy</span> <span class="k">import</span> <span class="n">lstsq</span>
<span class="kn">from</span> <span class="nn">statsmodels.compat.scipy</span> <span class="k">import</span> <span class="n">_next_regular</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">from</span> <span class="nn">numpy.linalg</span> <span class="k">import</span> <span class="n">LinAlgError</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="k">import</span> <span class="n">stats</span>

<span class="kn">from</span> <span class="nn">statsmodels.regression.linear_model</span> <span class="k">import</span> <span class="n">OLS</span><span class="p">,</span> <span class="n">yule_walker</span>
<span class="kn">from</span> <span class="nn">statsmodels.tools.sm_exceptions</span> <span class="k">import</span> <span class="p">(</span><span class="n">InterpolationWarning</span><span class="p">,</span>
                                             <span class="n">MissingDataError</span><span class="p">,</span>
                                             <span class="n">CollinearityWarning</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">statsmodels.tools.tools</span> <span class="k">import</span> <span class="n">add_constant</span><span class="p">,</span> <span class="n">Bunch</span>
<span class="kn">from</span> <span class="nn">statsmodels.tsa._bds</span> <span class="k">import</span> <span class="n">bds</span>
<span class="kn">from</span> <span class="nn">statsmodels.tsa.adfvalues</span> <span class="k">import</span> <span class="n">mackinnonp</span><span class="p">,</span> <span class="n">mackinnoncrit</span>
<span class="kn">from</span> <span class="nn">statsmodels.tsa.arima_model</span> <span class="k">import</span> <span class="n">ARMA</span>
<span class="kn">from</span> <span class="nn">statsmodels.tsa.tsatools</span> <span class="k">import</span> <span class="n">lagmat</span><span class="p">,</span> <span class="n">lagmat2ds</span><span class="p">,</span> <span class="n">add_trend</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;acovf&#39;</span><span class="p">,</span> <span class="s1">&#39;acf&#39;</span><span class="p">,</span> <span class="s1">&#39;pacf&#39;</span><span class="p">,</span> <span class="s1">&#39;pacf_yw&#39;</span><span class="p">,</span> <span class="s1">&#39;pacf_ols&#39;</span><span class="p">,</span> <span class="s1">&#39;ccovf&#39;</span><span class="p">,</span> <span class="s1">&#39;ccf&#39;</span><span class="p">,</span>
           <span class="s1">&#39;periodogram&#39;</span><span class="p">,</span> <span class="s1">&#39;q_stat&#39;</span><span class="p">,</span> <span class="s1">&#39;coint&#39;</span><span class="p">,</span> <span class="s1">&#39;arma_order_select_ic&#39;</span><span class="p">,</span>
           <span class="s1">&#39;adfuller&#39;</span><span class="p">,</span> <span class="s1">&#39;kpss&#39;</span><span class="p">,</span> <span class="s1">&#39;bds&#39;</span><span class="p">,</span> <span class="s1">&#39;pacf_burg&#39;</span><span class="p">,</span> <span class="s1">&#39;innovations_algo&#39;</span><span class="p">,</span>
           <span class="s1">&#39;innovations_filter&#39;</span><span class="p">,</span> <span class="s1">&#39;levinson_durbin_pacf&#39;</span><span class="p">,</span> <span class="s1">&#39;levinson_durbin&#39;</span><span class="p">]</span>

<span class="n">SQRTEPS</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span><span class="p">)</span>


<span class="c1">#NOTE: now in two places to avoid circular import</span>
<span class="c1">#TODO: I like the bunch pattern for this too.</span>
<span class="k">class</span> <span class="nc">ResultsStore</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_str</span>  <span class="c1"># pylint: disable=E1101</span>


<span class="k">def</span> <span class="nf">_autolag</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">endog</span><span class="p">,</span> <span class="n">exog</span><span class="p">,</span> <span class="n">startlag</span><span class="p">,</span> <span class="n">maxlag</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">modargs</span><span class="o">=</span><span class="p">(),</span>
             <span class="n">fitargs</span><span class="o">=</span><span class="p">(),</span> <span class="n">regresults</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the results for the lag length that maximizes the info criterion.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mod : Model class</span>
<span class="sd">        Model estimator class</span>
<span class="sd">    endog : array-like</span>
<span class="sd">        nobs array containing endogenous variable</span>
<span class="sd">    exog : array-like</span>
<span class="sd">        nobs by (startlag + maxlag) array containing lags and possibly other</span>
<span class="sd">        variables</span>
<span class="sd">    startlag : int</span>
<span class="sd">        The first zero-indexed column to hold a lag.  See Notes.</span>
<span class="sd">    maxlag : int</span>
<span class="sd">        The highest lag order for lag length selection.</span>
<span class="sd">    method : {&#39;aic&#39;, &#39;bic&#39;, &#39;t-stat&#39;}</span>
<span class="sd">        aic - Akaike Information Criterion</span>
<span class="sd">        bic - Bayes Information Criterion</span>
<span class="sd">        t-stat - Based on last lag</span>
<span class="sd">    modargs : tuple, optional</span>
<span class="sd">        args to pass to model.  See notes.</span>
<span class="sd">    fitargs : tuple, optional</span>
<span class="sd">        args to pass to fit.  See notes.</span>
<span class="sd">    regresults : bool, optional</span>
<span class="sd">        Flag indicating to return optional return results</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    icbest : float</span>
<span class="sd">        Best information criteria.</span>
<span class="sd">    bestlag : int</span>
<span class="sd">        The lag length that maximizes the information criterion.</span>
<span class="sd">    results : dict, optional</span>
<span class="sd">        Dictionary containing all estimation results</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Does estimation like mod(endog, exog[:,:i], *modargs).fit(*fitargs)</span>
<span class="sd">    where i goes from lagstart to lagstart+maxlag+1.  Therefore, lags are</span>
<span class="sd">    assumed to be in contiguous columns from low to high lag length with</span>
<span class="sd">    the highest lag in the last column.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#TODO: can tcol be replaced by maxlag + 2?</span>
    <span class="c1">#TODO: This could be changed to laggedRHS and exog keyword arguments if</span>
    <span class="c1">#    this will be more general.</span>

    <span class="n">results</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">method</span> <span class="o">=</span> <span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">lag</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">startlag</span><span class="p">,</span> <span class="n">startlag</span> <span class="o">+</span> <span class="n">maxlag</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">mod_instance</span> <span class="o">=</span> <span class="n">mod</span><span class="p">(</span><span class="n">endog</span><span class="p">,</span> <span class="n">exog</span><span class="p">[:,</span> <span class="p">:</span><span class="n">lag</span><span class="p">],</span> <span class="o">*</span><span class="n">modargs</span><span class="p">)</span>
        <span class="n">results</span><span class="p">[</span><span class="n">lag</span><span class="p">]</span> <span class="o">=</span> <span class="n">mod_instance</span><span class="o">.</span><span class="n">fit</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;aic&quot;</span><span class="p">:</span>
        <span class="n">icbest</span><span class="p">,</span> <span class="n">bestlag</span> <span class="o">=</span> <span class="nb">min</span><span class="p">((</span><span class="n">v</span><span class="o">.</span><span class="n">aic</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">iteritems</span><span class="p">(</span><span class="n">results</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;bic&quot;</span><span class="p">:</span>
        <span class="n">icbest</span><span class="p">,</span> <span class="n">bestlag</span> <span class="o">=</span> <span class="nb">min</span><span class="p">((</span><span class="n">v</span><span class="o">.</span><span class="n">bic</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">iteritems</span><span class="p">(</span><span class="n">results</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;t-stat&quot;</span><span class="p">:</span>
        <span class="c1">#stop = stats.norm.ppf(.95)</span>
        <span class="n">stop</span> <span class="o">=</span> <span class="mf">1.6448536269514722</span>
        <span class="k">for</span> <span class="n">lag</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">startlag</span> <span class="o">+</span> <span class="n">maxlag</span><span class="p">,</span> <span class="n">startlag</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">icbest</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="n">lag</span><span class="p">]</span><span class="o">.</span><span class="n">tvalues</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">icbest</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">stop</span><span class="p">:</span>
                <span class="n">bestlag</span> <span class="o">=</span> <span class="n">lag</span>
                <span class="n">icbest</span> <span class="o">=</span> <span class="n">icbest</span>
                <span class="k">break</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Information Criterion </span><span class="si">%s</span><span class="s2"> not understood.&quot;</span><span class="p">)</span> <span class="o">%</span> <span class="n">method</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">regresults</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">icbest</span><span class="p">,</span> <span class="n">bestlag</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">icbest</span><span class="p">,</span> <span class="n">bestlag</span><span class="p">,</span> <span class="n">results</span>


<span class="c1">#this needs to be converted to a class like HetGoldfeldQuandt,</span>
<span class="c1"># 3 different returns are a mess</span>
<span class="c1"># See:</span>
<span class="c1">#Ng and Perron(2001), Lag length selection and the construction of unit root</span>
<span class="c1">#tests with good size and power, Econometrica, Vol 69 (6) pp 1519-1554</span>
<span class="c1">#TODO: include drift keyword, only valid with regression == &quot;c&quot;</span>
<span class="c1"># just changes the distribution of the test statistic to a t distribution</span>
<span class="c1">#TODO: autolag is untested</span>
<div class="viewcode-block" id="adfuller"><a class="viewcode-back" href="../../../generated/statsmodels.tsa.stattools.adfuller.html#statsmodels.tsa.stattools.adfuller">[docs]</a><span class="k">def</span> <span class="nf">adfuller</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">maxlag</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">regression</span><span class="o">=</span><span class="s2">&quot;c&quot;</span><span class="p">,</span> <span class="n">autolag</span><span class="o">=</span><span class="s1">&#39;AIC&#39;</span><span class="p">,</span>
             <span class="n">store</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">regresults</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Augmented Dickey-Fuller unit root test</span>

<span class="sd">    The Augmented Dickey-Fuller test can be used to test for a unit root in a</span>
<span class="sd">    univariate process in the presence of serial correlation.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : array_like, 1d</span>
<span class="sd">        data series</span>
<span class="sd">    maxlag : int</span>
<span class="sd">        Maximum lag which is included in test, default 12*(nobs/100)^{1/4}</span>
<span class="sd">    regression : {&#39;c&#39;,&#39;ct&#39;,&#39;ctt&#39;,&#39;nc&#39;}</span>
<span class="sd">        Constant and trend order to include in regression</span>

<span class="sd">        * &#39;c&#39; : constant only (default)</span>
<span class="sd">        * &#39;ct&#39; : constant and trend</span>
<span class="sd">        * &#39;ctt&#39; : constant, and linear and quadratic trend</span>
<span class="sd">        * &#39;nc&#39; : no constant, no trend</span>
<span class="sd">    autolag : {&#39;AIC&#39;, &#39;BIC&#39;, &#39;t-stat&#39;, None}</span>
<span class="sd">        * if None, then maxlag lags are used</span>
<span class="sd">        * if &#39;AIC&#39; (default) or &#39;BIC&#39;, then the number of lags is chosen</span>
<span class="sd">          to minimize the corresponding information criterion</span>
<span class="sd">        * &#39;t-stat&#39; based choice of maxlag.  Starts with maxlag and drops a</span>
<span class="sd">          lag until the t-statistic on the last lag length is significant</span>
<span class="sd">          using a 5%-sized test</span>
<span class="sd">    store : bool</span>
<span class="sd">        If True, then a result instance is returned additionally to</span>
<span class="sd">        the adf statistic. Default is False</span>
<span class="sd">    regresults : bool, optional</span>
<span class="sd">        If True, the full regression results are returned. Default is False</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    adf : float</span>
<span class="sd">        Test statistic</span>
<span class="sd">    pvalue : float</span>
<span class="sd">        MacKinnon&#39;s approximate p-value based on MacKinnon (1994, 2010)</span>
<span class="sd">    usedlag : int</span>
<span class="sd">        Number of lags used</span>
<span class="sd">    nobs : int</span>
<span class="sd">        Number of observations used for the ADF regression and calculation of</span>
<span class="sd">        the critical values</span>
<span class="sd">    critical values : dict</span>
<span class="sd">        Critical values for the test statistic at the 1 %, 5 %, and 10 %</span>
<span class="sd">        levels. Based on MacKinnon (2010)</span>
<span class="sd">    icbest : float</span>
<span class="sd">        The maximized information criterion if autolag is not None.</span>
<span class="sd">    resstore : ResultStore, optional</span>
<span class="sd">        A dummy class with results attached as attributes</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The null hypothesis of the Augmented Dickey-Fuller is that there is a unit</span>
<span class="sd">    root, with the alternative that there is no unit root. If the pvalue is</span>
<span class="sd">    above a critical size, then we cannot reject that there is a unit root.</span>

<span class="sd">    The p-values are obtained through regression surface approximation from</span>
<span class="sd">    MacKinnon 1994, but using the updated 2010 tables. If the p-value is close</span>
<span class="sd">    to significant, then the critical values should be used to judge whether</span>
<span class="sd">    to reject the null.</span>

<span class="sd">    The autolag option and maxlag for it are described in Greene.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    See example notebook</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [*] W. Green.  &quot;Econometric Analysis,&quot; 5th ed., Pearson, 2003.</span>

<span class="sd">    .. [*] Hamilton, J.D.  &quot;Time Series Analysis&quot;.  Princeton, 1994.</span>

<span class="sd">    .. [*] MacKinnon, J.G. 1994.  &quot;Approximate asymptotic distribution functions for</span>
<span class="sd">        unit-root and cointegration tests.  `Journal of Business and Economic</span>
<span class="sd">        Statistics` 12, 167-76.</span>

<span class="sd">    .. [*] MacKinnon, J.G. 2010. &quot;Critical Values for Cointegration Tests.&quot;  Queen&#39;s</span>
<span class="sd">        University, Dept of Economics, Working Papers.  Available at</span>
<span class="sd">        http://ideas.repec.org/p/qed/wpaper/1227.html</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">regresults</span><span class="p">:</span>
        <span class="n">store</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="n">trenddict</span> <span class="o">=</span> <span class="p">{</span><span class="kc">None</span><span class="p">:</span> <span class="s1">&#39;nc&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="s1">&#39;ct&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="s1">&#39;ctt&#39;</span><span class="p">}</span>
    <span class="k">if</span> <span class="n">regression</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">regression</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">long</span><span class="p">)):</span>
        <span class="n">regression</span> <span class="o">=</span> <span class="n">trenddict</span><span class="p">[</span><span class="n">regression</span><span class="p">]</span>
    <span class="n">regression</span> <span class="o">=</span> <span class="n">regression</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">regression</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;nc&#39;</span><span class="p">,</span> <span class="s1">&#39;ct&#39;</span><span class="p">,</span> <span class="s1">&#39;ctt&#39;</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;regression option </span><span class="si">%s</span><span class="s2"> not understood&quot;</span><span class="p">)</span> <span class="o">%</span> <span class="n">regression</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">nobs</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">ntrend</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">regression</span><span class="p">)</span> <span class="k">if</span> <span class="n">regression</span> <span class="o">!=</span> <span class="s1">&#39;nc&#39;</span> <span class="k">else</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">maxlag</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># from Greene referencing Schwert 1989</span>
        <span class="n">maxlag</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="mf">12.</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">nobs</span> <span class="o">/</span> <span class="mf">100.</span><span class="p">,</span> <span class="mi">1</span> <span class="o">/</span> <span class="mf">4.</span><span class="p">)))</span>
        <span class="c1"># -1 for the diff</span>
        <span class="n">maxlag</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">nobs</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">ntrend</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">maxlag</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">maxlag</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;sample size is too short to use selected &#39;</span>
                             <span class="s1">&#39;regression component&#39;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">maxlag</span> <span class="o">&gt;</span> <span class="n">nobs</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">ntrend</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;maxlag must be less than (nobs/2 - 1 - ntrend) &#39;</span>
                         <span class="s1">&#39;where n trend is the number of included &#39;</span>
                         <span class="s1">&#39;deterministic regressors&#39;</span><span class="p">)</span>
    <span class="n">xdiff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">xdall</span> <span class="o">=</span> <span class="n">lagmat</span><span class="p">(</span><span class="n">xdiff</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">],</span> <span class="n">maxlag</span><span class="p">,</span> <span class="n">trim</span><span class="o">=</span><span class="s1">&#39;both&#39;</span><span class="p">,</span> <span class="n">original</span><span class="o">=</span><span class="s1">&#39;in&#39;</span><span class="p">)</span>
    <span class="n">nobs</span> <span class="o">=</span> <span class="n">xdall</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">xdall</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="n">nobs</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># replace 0 xdiff with level of x</span>
    <span class="n">xdshort</span> <span class="o">=</span> <span class="n">xdiff</span><span class="p">[</span><span class="o">-</span><span class="n">nobs</span><span class="p">:]</span>

    <span class="k">if</span> <span class="n">store</span><span class="p">:</span>
        <span class="n">resstore</span> <span class="o">=</span> <span class="n">ResultsStore</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">autolag</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">regression</span> <span class="o">!=</span> <span class="s1">&#39;nc&#39;</span><span class="p">:</span>
            <span class="n">fullRHS</span> <span class="o">=</span> <span class="n">add_trend</span><span class="p">(</span><span class="n">xdall</span><span class="p">,</span> <span class="n">regression</span><span class="p">,</span> <span class="n">prepend</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fullRHS</span> <span class="o">=</span> <span class="n">xdall</span>
        <span class="n">startlag</span> <span class="o">=</span> <span class="n">fullRHS</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">xdall</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="c1"># 1 for level</span>
        <span class="c1"># search for lag length with smallest information criteria</span>
        <span class="c1"># Note: use the same number of observations to have comparable IC</span>
        <span class="c1"># aic and bic: smaller is better</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">regresults</span><span class="p">:</span>
            <span class="n">icbest</span><span class="p">,</span> <span class="n">bestlag</span> <span class="o">=</span> <span class="n">_autolag</span><span class="p">(</span><span class="n">OLS</span><span class="p">,</span> <span class="n">xdshort</span><span class="p">,</span> <span class="n">fullRHS</span><span class="p">,</span> <span class="n">startlag</span><span class="p">,</span>
                                       <span class="n">maxlag</span><span class="p">,</span> <span class="n">autolag</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">icbest</span><span class="p">,</span> <span class="n">bestlag</span><span class="p">,</span> <span class="n">alres</span> <span class="o">=</span> <span class="n">_autolag</span><span class="p">(</span><span class="n">OLS</span><span class="p">,</span> <span class="n">xdshort</span><span class="p">,</span> <span class="n">fullRHS</span><span class="p">,</span> <span class="n">startlag</span><span class="p">,</span>
                                              <span class="n">maxlag</span><span class="p">,</span> <span class="n">autolag</span><span class="p">,</span>
                                              <span class="n">regresults</span><span class="o">=</span><span class="n">regresults</span><span class="p">)</span>
            <span class="n">resstore</span><span class="o">.</span><span class="n">autolag_results</span> <span class="o">=</span> <span class="n">alres</span>

        <span class="n">bestlag</span> <span class="o">-=</span> <span class="n">startlag</span>  <span class="c1"># convert to lag not column index</span>

        <span class="c1"># rerun ols with best autolag</span>
        <span class="n">xdall</span> <span class="o">=</span> <span class="n">lagmat</span><span class="p">(</span><span class="n">xdiff</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">],</span> <span class="n">bestlag</span><span class="p">,</span> <span class="n">trim</span><span class="o">=</span><span class="s1">&#39;both&#39;</span><span class="p">,</span> <span class="n">original</span><span class="o">=</span><span class="s1">&#39;in&#39;</span><span class="p">)</span>
        <span class="n">nobs</span> <span class="o">=</span> <span class="n">xdall</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">xdall</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="n">nobs</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># replace 0 xdiff with level of x</span>
        <span class="n">xdshort</span> <span class="o">=</span> <span class="n">xdiff</span><span class="p">[</span><span class="o">-</span><span class="n">nobs</span><span class="p">:]</span>
        <span class="n">usedlag</span> <span class="o">=</span> <span class="n">bestlag</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">usedlag</span> <span class="o">=</span> <span class="n">maxlag</span>
        <span class="n">icbest</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">regression</span> <span class="o">!=</span> <span class="s1">&#39;nc&#39;</span><span class="p">:</span>
        <span class="n">resols</span> <span class="o">=</span> <span class="n">OLS</span><span class="p">(</span><span class="n">xdshort</span><span class="p">,</span> <span class="n">add_trend</span><span class="p">(</span><span class="n">xdall</span><span class="p">[:,</span> <span class="p">:</span><span class="n">usedlag</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span>
                     <span class="n">regression</span><span class="p">))</span><span class="o">.</span><span class="n">fit</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">resols</span> <span class="o">=</span> <span class="n">OLS</span><span class="p">(</span><span class="n">xdshort</span><span class="p">,</span> <span class="n">xdall</span><span class="p">[:,</span> <span class="p">:</span><span class="n">usedlag</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">fit</span><span class="p">()</span>

    <span class="n">adfstat</span> <span class="o">=</span> <span class="n">resols</span><span class="o">.</span><span class="n">tvalues</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="c1">#    adfstat = (resols.params[0]-1.0)/resols.bse[0]</span>
    <span class="c1"># the &quot;asymptotically correct&quot; z statistic is obtained as</span>
    <span class="c1"># nobs/(1-np.sum(resols.params[1:-(trendorder+1)])) (resols.params[0] - 1)</span>
    <span class="c1"># I think this is the statistic that is used for series that are integrated</span>
    <span class="c1"># for orders higher than I(1), ie., not ADF but cointegration tests.</span>

    <span class="c1"># Get approx p-value and critical values</span>
    <span class="n">pvalue</span> <span class="o">=</span> <span class="n">mackinnonp</span><span class="p">(</span><span class="n">adfstat</span><span class="p">,</span> <span class="n">regression</span><span class="o">=</span><span class="n">regression</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">critvalues</span> <span class="o">=</span> <span class="n">mackinnoncrit</span><span class="p">(</span><span class="n">N</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">regression</span><span class="o">=</span><span class="n">regression</span><span class="p">,</span> <span class="n">nobs</span><span class="o">=</span><span class="n">nobs</span><span class="p">)</span>
    <span class="n">critvalues</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;1%&quot;</span> <span class="p">:</span> <span class="n">critvalues</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s2">&quot;5%&quot;</span> <span class="p">:</span> <span class="n">critvalues</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                  <span class="s2">&quot;10%&quot;</span> <span class="p">:</span> <span class="n">critvalues</span><span class="p">[</span><span class="mi">2</span><span class="p">]}</span>
    <span class="k">if</span> <span class="n">store</span><span class="p">:</span>
        <span class="n">resstore</span><span class="o">.</span><span class="n">resols</span> <span class="o">=</span> <span class="n">resols</span>
        <span class="n">resstore</span><span class="o">.</span><span class="n">maxlag</span> <span class="o">=</span> <span class="n">maxlag</span>
        <span class="n">resstore</span><span class="o">.</span><span class="n">usedlag</span> <span class="o">=</span> <span class="n">usedlag</span>
        <span class="n">resstore</span><span class="o">.</span><span class="n">adfstat</span> <span class="o">=</span> <span class="n">adfstat</span>
        <span class="n">resstore</span><span class="o">.</span><span class="n">critvalues</span> <span class="o">=</span> <span class="n">critvalues</span>
        <span class="n">resstore</span><span class="o">.</span><span class="n">nobs</span> <span class="o">=</span> <span class="n">nobs</span>
        <span class="n">resstore</span><span class="o">.</span><span class="n">H0</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;The coefficient on the lagged level equals 1 - &quot;</span>
                       <span class="s2">&quot;unit root&quot;</span><span class="p">)</span>
        <span class="n">resstore</span><span class="o">.</span><span class="n">HA</span> <span class="o">=</span> <span class="s2">&quot;The coefficient on the lagged level &lt; 1 - stationary&quot;</span>
        <span class="n">resstore</span><span class="o">.</span><span class="n">icbest</span> <span class="o">=</span> <span class="n">icbest</span>
        <span class="n">resstore</span><span class="o">.</span><span class="n">_str</span> <span class="o">=</span> <span class="s1">&#39;Augmented Dickey-Fuller Test Results&#39;</span>
        <span class="k">return</span> <span class="n">adfstat</span><span class="p">,</span> <span class="n">pvalue</span><span class="p">,</span> <span class="n">critvalues</span><span class="p">,</span> <span class="n">resstore</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">autolag</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">adfstat</span><span class="p">,</span> <span class="n">pvalue</span><span class="p">,</span> <span class="n">usedlag</span><span class="p">,</span> <span class="n">nobs</span><span class="p">,</span> <span class="n">critvalues</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">adfstat</span><span class="p">,</span> <span class="n">pvalue</span><span class="p">,</span> <span class="n">usedlag</span><span class="p">,</span> <span class="n">nobs</span><span class="p">,</span> <span class="n">critvalues</span><span class="p">,</span> <span class="n">icbest</span></div>


<div class="viewcode-block" id="acovf"><a class="viewcode-back" href="../../../generated/statsmodels.tsa.stattools.acovf.html#statsmodels.tsa.stattools.acovf">[docs]</a><span class="k">def</span> <span class="nf">acovf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">unbiased</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">demean</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">fft</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">missing</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">,</span> <span class="n">nlag</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Autocovariance for 1D</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : array</span>
<span class="sd">        Time series data. Must be 1d.</span>
<span class="sd">    unbiased : bool</span>
<span class="sd">        If True, then denominators is n-k, otherwise n</span>
<span class="sd">    demean : bool</span>
<span class="sd">        If True, then subtract the mean x from each element of x</span>
<span class="sd">    fft : bool</span>
<span class="sd">        If True, use FFT convolution.  This method should be preferred</span>
<span class="sd">        for long time series.</span>
<span class="sd">    missing : str</span>
<span class="sd">        A string in [&#39;none&#39;, &#39;raise&#39;, &#39;conservative&#39;, &#39;drop&#39;] specifying how</span>
<span class="sd">        the NaNs are to be treated.</span>
<span class="sd">    nlag : {int, None}</span>
<span class="sd">        Limit the number of autocovariances returned.  Size of returned</span>
<span class="sd">        array is nlag + 1.  Setting nlag when fft is False uses a simple,</span>
<span class="sd">        direct estimator of the autocovariances that only computes the first</span>
<span class="sd">        nlag + 1 values. This can be much faster when the time series is long</span>
<span class="sd">        and only a small number of autocovariances are needed.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    acovf : array</span>
<span class="sd">        autocovariance function</span>

<span class="sd">    References</span>
<span class="sd">    -----------</span>
<span class="sd">    .. [*] Parzen, E., 1963. On spectral analysis with missing observations</span>
<span class="sd">           and amplitude modulation. Sankhya: The Indian Journal of</span>
<span class="sd">           Statistics, Series A, pp.383-392.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">fft</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="kn">import</span> <span class="nn">warnings</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;fft=True will become the default in a future version of &#39;</span> \
              <span class="s1">&#39;statsmodels. To suppress this warning, explicitly set &#39;</span> \
              <span class="s1">&#39;fft=False.&#39;</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="ne">FutureWarning</span><span class="p">)</span>
        <span class="n">fft</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;x must be 1d. Got </span><span class="si">%d</span><span class="s2"> dims.&quot;</span> <span class="o">%</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>

    <span class="n">missing</span> <span class="o">=</span> <span class="n">missing</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">missing</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;none&#39;</span><span class="p">,</span> <span class="s1">&#39;raise&#39;</span><span class="p">,</span> <span class="s1">&#39;conservative&#39;</span><span class="p">,</span> <span class="s1">&#39;drop&#39;</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;missing option </span><span class="si">%s</span><span class="s2"> not understood&quot;</span> <span class="o">%</span> <span class="n">missing</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">missing</span> <span class="o">==</span> <span class="s1">&#39;none&#39;</span><span class="p">:</span>
        <span class="n">deal_with_masked</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">deal_with_masked</span> <span class="o">=</span> <span class="n">has_missing</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">deal_with_masked</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">missing</span> <span class="o">==</span> <span class="s1">&#39;raise&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">MissingDataError</span><span class="p">(</span><span class="s2">&quot;NaNs were encountered in the data&quot;</span><span class="p">)</span>
        <span class="n">notmask_bool</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  <span class="c1"># bool</span>
        <span class="k">if</span> <span class="n">missing</span> <span class="o">==</span> <span class="s1">&#39;conservative&#39;</span><span class="p">:</span>
            <span class="c1"># Must copy for thread safety</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">x</span><span class="p">[</span><span class="o">~</span><span class="n">notmask_bool</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># &#39;drop&#39;</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">notmask_bool</span><span class="p">]</span>  <span class="c1"># copies non-missing</span>
        <span class="n">notmask_int</span> <span class="o">=</span> <span class="n">notmask_bool</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>  <span class="c1"># int</span>

    <span class="k">if</span> <span class="n">demean</span> <span class="ow">and</span> <span class="n">deal_with_masked</span><span class="p">:</span>
        <span class="c1"># whether &#39;drop&#39; or &#39;conservative&#39;:</span>
        <span class="n">xo</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">x</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="n">notmask_int</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">missing</span> <span class="o">==</span> <span class="s1">&#39;conservative&#39;</span><span class="p">:</span>
            <span class="n">xo</span><span class="p">[</span><span class="o">~</span><span class="n">notmask_bool</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">elif</span> <span class="n">demean</span><span class="p">:</span>
        <span class="n">xo</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">x</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">xo</span> <span class="o">=</span> <span class="n">x</span>

    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">lag_len</span> <span class="o">=</span> <span class="n">nlag</span>
    <span class="k">if</span> <span class="n">nlag</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">lag_len</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">elif</span> <span class="n">nlag</span> <span class="o">&gt;</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;nlag must be smaller than nobs - 1&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">fft</span> <span class="ow">and</span> <span class="n">nlag</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">acov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">lag_len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">acov</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">xo</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">xo</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">lag_len</span><span class="p">):</span>
            <span class="n">acov</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">xo</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">xo</span><span class="p">[:</span><span class="o">-</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)])</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">deal_with_masked</span> <span class="ow">or</span> <span class="n">missing</span> <span class="o">==</span> <span class="s1">&#39;drop&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">unbiased</span><span class="p">:</span>
                <span class="n">acov</span> <span class="o">/=</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">lag_len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">acov</span> <span class="o">/=</span> <span class="n">n</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">unbiased</span><span class="p">:</span>
                <span class="n">divisor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">lag_len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
                <span class="n">divisor</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">notmask_int</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">lag_len</span><span class="p">):</span>
                    <span class="n">divisor</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">notmask_int</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">notmask_int</span><span class="p">[:</span><span class="o">-</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)])</span>
                <span class="n">divisor</span><span class="p">[</span><span class="n">divisor</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">acov</span> <span class="o">/=</span> <span class="n">divisor</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># biased, missing data but npt &#39;drop&#39;</span>
                <span class="n">acov</span> <span class="o">/=</span> <span class="n">notmask_int</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">acov</span>

    <span class="k">if</span> <span class="n">unbiased</span> <span class="ow">and</span> <span class="n">deal_with_masked</span> <span class="ow">and</span> <span class="n">missing</span> <span class="o">==</span> <span class="s1">&#39;conservative&#39;</span><span class="p">:</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">correlate</span><span class="p">(</span><span class="n">notmask_int</span><span class="p">,</span> <span class="n">notmask_int</span><span class="p">,</span> <span class="s1">&#39;full&#39;</span><span class="p">)</span>
        <span class="n">d</span><span class="p">[</span><span class="n">d</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">elif</span> <span class="n">unbiased</span><span class="p">:</span>
        <span class="n">xi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">xi</span><span class="p">,</span> <span class="n">xi</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
    <span class="k">elif</span> <span class="n">deal_with_masked</span><span class="p">:</span>  <span class="c1"># biased and NaNs given and (&#39;drop&#39; or &#39;conservative&#39;)</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">notmask_int</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>  <span class="c1"># biased and no NaNs or missing==&#39;none&#39;</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">n</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">fft</span><span class="p">:</span>
        <span class="n">nobs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">xo</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">_next_regular</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">nobs</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">Frf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">xo</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">)</span>
        <span class="n">acov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifft</span><span class="p">(</span><span class="n">Frf</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conjugate</span><span class="p">(</span><span class="n">Frf</span><span class="p">))[:</span><span class="n">nobs</span><span class="p">]</span> <span class="o">/</span> <span class="n">d</span><span class="p">[</span><span class="n">nobs</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:]</span>
        <span class="n">acov</span> <span class="o">=</span> <span class="n">acov</span><span class="o">.</span><span class="n">real</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">acov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">correlate</span><span class="p">(</span><span class="n">xo</span><span class="p">,</span> <span class="n">xo</span><span class="p">,</span> <span class="s1">&#39;full&#39;</span><span class="p">)[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:]</span> <span class="o">/</span> <span class="n">d</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:]</span>

    <span class="k">if</span> <span class="n">nlag</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Copy to allow gc of full array rather than view</span>
        <span class="k">return</span> <span class="n">acov</span><span class="p">[:</span><span class="n">lag_len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">acov</span></div>


<div class="viewcode-block" id="q_stat"><a class="viewcode-back" href="../../../generated/statsmodels.tsa.stattools.q_stat.html#statsmodels.tsa.stattools.q_stat">[docs]</a><span class="k">def</span> <span class="nf">q_stat</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">nobs</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s2">&quot;ljungbox&quot;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return&#39;s Ljung-Box Q Statistic</span>

<span class="sd">    x : array-like</span>
<span class="sd">        Array of autocorrelation coefficients.  Can be obtained from acf.</span>
<span class="sd">    nobs : int</span>
<span class="sd">        Number of observations in the entire sample (ie., not just the length</span>
<span class="sd">        of the autocorrelation function results.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    q-stat : array</span>
<span class="sd">        Ljung-Box Q-statistic for autocorrelation parameters</span>
<span class="sd">    p-value : array</span>
<span class="sd">        P-value of the Q statistic</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Written to be used with acf.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">type</span> <span class="o">==</span> <span class="s2">&quot;ljungbox&quot;</span><span class="p">:</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="p">(</span><span class="n">nobs</span> <span class="o">*</span> <span class="p">(</span><span class="n">nobs</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span>
               <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">((</span><span class="mf">1.</span> <span class="o">/</span> <span class="p">(</span><span class="n">nobs</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span> <span class="o">*</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
    <span class="n">chi2</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">chi2</span><span class="o">.</span><span class="n">sf</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">ret</span><span class="p">,</span> <span class="n">chi2</span></div>


<span class="c1">#NOTE: Changed unbiased to False</span>
<span class="c1">#see for example</span>
<span class="c1"># http://www.itl.nist.gov/div898/handbook/eda/section3/autocopl.htm</span>
<div class="viewcode-block" id="acf"><a class="viewcode-back" href="../../../generated/statsmodels.tsa.stattools.acf.html#statsmodels.tsa.stattools.acf">[docs]</a><span class="k">def</span> <span class="nf">acf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">unbiased</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">nlags</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span> <span class="n">qstat</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fft</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">missing</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Autocorrelation function for 1d arrays.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : array</span>
<span class="sd">       Time series data</span>
<span class="sd">    unbiased : bool</span>
<span class="sd">       If True, then denominators for autocovariance are n-k, otherwise n</span>
<span class="sd">    nlags: int, optional</span>
<span class="sd">        Number of lags to return autocorrelation for.</span>
<span class="sd">    qstat : bool, optional</span>
<span class="sd">        If True, returns the Ljung-Box q statistic for each autocorrelation</span>
<span class="sd">        coefficient.  See q_stat for more information.</span>
<span class="sd">    fft : bool, optional</span>
<span class="sd">        If True, computes the ACF via FFT.</span>
<span class="sd">    alpha : scalar, optional</span>
<span class="sd">        If a number is given, the confidence intervals for the given level are</span>
<span class="sd">        returned. For instance if alpha=.05, 95 % confidence intervals are</span>
<span class="sd">        returned where the standard deviation is computed according to</span>
<span class="sd">        Bartlett\&#39;s formula.</span>
<span class="sd">    missing : str, optional</span>
<span class="sd">        A string in [&#39;none&#39;, &#39;raise&#39;, &#39;conservative&#39;, &#39;drop&#39;] specifying how the NaNs</span>
<span class="sd">        are to be treated.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    acf : array</span>
<span class="sd">        autocorrelation function</span>
<span class="sd">    confint : array, optional</span>
<span class="sd">        Confidence intervals for the ACF. Returned if alpha is not None.</span>
<span class="sd">    qstat : array, optional</span>
<span class="sd">        The Ljung-Box Q-Statistic.  Returned if q_stat is True.</span>
<span class="sd">    pvalues : array, optional</span>
<span class="sd">        The p-values associated with the Q-statistics.  Returned if q_stat is</span>
<span class="sd">        True.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The acf at lag 0 (ie., 1) is returned.</span>

<span class="sd">    For very long time series it is recommended to use fft convolution instead.</span>
<span class="sd">    When fft is False uses a simple, direct estimator of the autocovariances</span>
<span class="sd">    that only computes the first nlag + 1 values. This can be much faster when</span>
<span class="sd">    the time series is long and only a small number of autocovariances are</span>
<span class="sd">    needed.</span>

<span class="sd">    If unbiased is true, the denominator for the autocovariance is adjusted</span>
<span class="sd">    but the autocorrelation is not an unbiased estimator.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [*] Parzen, E., 1963. On spectral analysis with missing observations</span>
<span class="sd">       and amplitude modulation. Sankhya: The Indian Journal of</span>
<span class="sd">       Statistics, Series A, pp.383-392.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">fft</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="kn">import</span> <span class="nn">warnings</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;fft=True will become the default in a future version of &#39;</span> \
              <span class="s1">&#39;statsmodels. To suppress this warning, explicitly set &#39;</span> \
              <span class="s1">&#39;fft=False.&#39;</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="ne">FutureWarning</span><span class="p">)</span>
        <span class="n">fft</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="n">nobs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  <span class="c1"># should this shrink for missing=&#39;drop&#39; and NaNs in x?</span>
    <span class="n">avf</span> <span class="o">=</span> <span class="n">acovf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">unbiased</span><span class="o">=</span><span class="n">unbiased</span><span class="p">,</span> <span class="n">demean</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">fft</span><span class="o">=</span><span class="n">fft</span><span class="p">,</span> <span class="n">missing</span><span class="o">=</span><span class="n">missing</span><span class="p">)</span>
    <span class="n">acf</span> <span class="o">=</span> <span class="n">avf</span><span class="p">[:</span><span class="n">nlags</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">avf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">qstat</span> <span class="ow">or</span> <span class="n">alpha</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">acf</span>
    <span class="k">if</span> <span class="n">alpha</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">varacf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">nlags</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">nobs</span>
        <span class="n">varacf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">varacf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span> <span class="o">/</span> <span class="n">nobs</span>
        <span class="n">varacf</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span> <span class="o">*=</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">acf</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">interval</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">alpha</span> <span class="o">/</span> <span class="mf">2.</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">varacf</span><span class="p">)</span>
        <span class="n">confint</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lzip</span><span class="p">(</span><span class="n">acf</span> <span class="o">-</span> <span class="n">interval</span><span class="p">,</span> <span class="n">acf</span> <span class="o">+</span> <span class="n">interval</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">qstat</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">acf</span><span class="p">,</span> <span class="n">confint</span>
    <span class="k">if</span> <span class="n">qstat</span><span class="p">:</span>
        <span class="n">qstat</span><span class="p">,</span> <span class="n">pvalue</span> <span class="o">=</span> <span class="n">q_stat</span><span class="p">(</span><span class="n">acf</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">nobs</span><span class="o">=</span><span class="n">nobs</span><span class="p">)</span>  <span class="c1"># drop lag 0</span>
        <span class="k">if</span> <span class="n">alpha</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">acf</span><span class="p">,</span> <span class="n">confint</span><span class="p">,</span> <span class="n">qstat</span><span class="p">,</span> <span class="n">pvalue</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">acf</span><span class="p">,</span> <span class="n">qstat</span><span class="p">,</span> <span class="n">pvalue</span></div>


<div class="viewcode-block" id="pacf_yw"><a class="viewcode-back" href="../../../generated/statsmodels.tsa.stattools.pacf_yw.html#statsmodels.tsa.stattools.pacf_yw">[docs]</a><span class="k">def</span> <span class="nf">pacf_yw</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">nlags</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;unbiased&#39;</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Partial autocorrelation estimated with non-recursive yule_walker</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : 1d array</span>
<span class="sd">        observations of time series for which pacf is calculated</span>
<span class="sd">    nlags : int</span>
<span class="sd">        largest lag for which pacf is returned</span>
<span class="sd">    method : &#39;unbiased&#39; (default) or &#39;mle&#39;</span>
<span class="sd">        method for the autocovariance calculations in yule walker</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    pacf : 1d array</span>
<span class="sd">        partial autocorrelations, maxlag+1 elements</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    statsmodels.tsa.stattools.pacf</span>
<span class="sd">    statsmodels.tsa.stattools.pacf_burg</span>
<span class="sd">    statsmodels.tsa.stattools.pacf_ols</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This solves yule_walker for each desired lag and contains</span>
<span class="sd">    currently duplicate calculations.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">pacf</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nlags</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">pacf</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">yule_walker</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pacf</span><span class="p">)</span></div>


<div class="viewcode-block" id="pacf_burg"><a class="viewcode-back" href="../../../generated/statsmodels.tsa.stattools.pacf_burg.html#statsmodels.tsa.stattools.pacf_burg">[docs]</a><span class="k">def</span> <span class="nf">pacf_burg</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">nlags</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">demean</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Burg&#39;s partial autocorrelation estimator</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : array-like</span>
<span class="sd">        Observations of time series for which pacf is calculated</span>
<span class="sd">    nlags : int, optional</span>
<span class="sd">        Number of lags to compute the partial autocorrelations.  If omitted,</span>
<span class="sd">        uses the smaller of 10(log10(nobs)) or nobs - 1</span>
<span class="sd">    demean : bool, optional</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    pacf : ndarray</span>
<span class="sd">        Partial autocorrelations for lags 0, 1, ..., nlag</span>
<span class="sd">    sigma2 : ndarray</span>
<span class="sd">        Residual variance estimates where the value in position m is the</span>
<span class="sd">        residual variance in an AR model that includes m lags</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    statsmodels.tsa.stattools.pacf</span>
<span class="sd">    statsmodels.tsa.stattools.pacf_yw</span>
<span class="sd">    statsmodels.tsa.stattools.pacf_ols</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [*] Brockwell, P.J. and Davis, R.A., 2016. Introduction to time series</span>
<span class="sd">        and forecasting. Springer.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;x must be 1-d or squeezable to 1-d.&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">demean</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">x</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
    <span class="n">nobs</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">nlags</span> <span class="k">if</span> <span class="n">nlags</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">min</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="mi">10</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">nobs</span><span class="p">)),</span> <span class="n">nobs</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">p</span> <span class="o">&gt;</span> <span class="n">nobs</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;nlags must be smaller than nobs - 1&#39;</span><span class="p">)</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">x</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">pacf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">x</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">x</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">d</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">u</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
    <span class="n">pacf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">/</span> <span class="n">d</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">u</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">last_u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
    <span class="n">last_v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
        <span class="n">last_u</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">u</span>
        <span class="n">last_v</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">v</span>
        <span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">last_u</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">pacf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">last_v</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">last_v</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">pacf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">last_u</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">d</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">pacf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">u</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="n">pacf</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">/</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">sigma2</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">pacf</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">d</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.</span> <span class="o">*</span> <span class="p">(</span><span class="n">nobs</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">p</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span>
    <span class="n">pacf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># Insert the 0 lag partial autocorrel</span>

    <span class="k">return</span> <span class="n">pacf</span><span class="p">,</span> <span class="n">sigma2</span></div>


<div class="viewcode-block" id="pacf_ols"><a class="viewcode-back" href="../../../generated/statsmodels.tsa.stattools.pacf_ols.html#statsmodels.tsa.stattools.pacf_ols">[docs]</a><span class="k">def</span> <span class="nf">pacf_ols</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">nlags</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span> <span class="n">efficient</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">unbiased</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate partial autocorrelations via OLS</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : 1d array</span>
<span class="sd">        observations of time series for which pacf is calculated</span>
<span class="sd">    nlags : int</span>
<span class="sd">        Number of lags for which pacf is returned.  Lag 0 is not returned.</span>
<span class="sd">    efficient : bool, optional</span>
<span class="sd">        If true, uses the maximum number of available observations to compute</span>
<span class="sd">        each partial autocorrelation. If not, uses the same number of</span>
<span class="sd">        observations to compute all pacf values.</span>
<span class="sd">    unbiased : bool, optional</span>
<span class="sd">        Adjust each partial autocorrelation by n / (n - lag)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    pacf : 1d array</span>
<span class="sd">        partial autocorrelations, (maxlag,) array corresponding to lags</span>
<span class="sd">        0, 1, ..., maxlag</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This solves a separate OLS estimation for each desired lag using method in</span>
<span class="sd">    [1]_. Setting efficient to True has two effects. First, it uses</span>
<span class="sd">    `nobs - lag` observations of estimate each pacf.  Second, it re-estimates</span>
<span class="sd">    the mean in each regression. If efficient is False, then the data are first</span>
<span class="sd">    demeaned, and then `nobs - maxlag` observations are used to estimate each</span>
<span class="sd">    partial autocorrelation.</span>

<span class="sd">    The inefficient estimator appears to have better finite sample properties.</span>
<span class="sd">    This option should only be used in time series that are covariance</span>
<span class="sd">    stationary.</span>

<span class="sd">    OLS estimation of the pacf does not guarantee that all pacf values are</span>
<span class="sd">    between -1 and 1.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    statsmodels.tsa.stattools.pacf</span>
<span class="sd">    statsmodels.tsa.stattools.pacf_yw</span>
<span class="sd">    statsmodels.tsa.stattools.pacf_burg</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Box, G. E., Jenkins, G. M., Reinsel, G. C., &amp; Ljung, G. M. (2015).</span>
<span class="sd">       Time series analysis: forecasting and control. John Wiley &amp; Sons, p. 66</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">pacf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">nlags</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">pacf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;x must be squeezable to a 1-d array&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">efficient</span><span class="p">:</span>
        <span class="n">xlags</span><span class="p">,</span> <span class="n">x0</span> <span class="o">=</span> <span class="n">lagmat</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">nlags</span><span class="p">,</span> <span class="n">original</span><span class="o">=</span><span class="s1">&#39;sep&#39;</span><span class="p">)</span>
        <span class="n">xlags</span> <span class="o">=</span> <span class="n">add_constant</span><span class="p">(</span><span class="n">xlags</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nlags</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">params</span> <span class="o">=</span> <span class="n">lstsq</span><span class="p">(</span><span class="n">xlags</span><span class="p">[</span><span class="n">k</span><span class="p">:,</span> <span class="p">:</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">x0</span><span class="p">[</span><span class="n">k</span><span class="p">:],</span> <span class="n">rcond</span><span class="o">=</span><span class="kc">None</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">pacf</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="c1"># Create a single set of lags for multivariate OLS</span>
        <span class="n">xlags</span><span class="p">,</span> <span class="n">x0</span> <span class="o">=</span> <span class="n">lagmat</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">nlags</span><span class="p">,</span> <span class="n">original</span><span class="o">=</span><span class="s1">&#39;sep&#39;</span><span class="p">,</span> <span class="n">trim</span><span class="o">=</span><span class="s1">&#39;both&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nlags</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">params</span> <span class="o">=</span> <span class="n">lstsq</span><span class="p">(</span><span class="n">xlags</span><span class="p">[:,</span> <span class="p">:</span><span class="n">k</span><span class="p">],</span> <span class="n">x0</span><span class="p">,</span> <span class="n">rcond</span><span class="o">=</span><span class="kc">None</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="c1"># Last coefficient corresponds to PACF value (see [1])</span>
            <span class="n">pacf</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">unbiased</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">pacf</span> <span class="o">*=</span> <span class="n">n</span> <span class="o">/</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nlags</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">pacf</span></div>


<div class="viewcode-block" id="pacf"><a class="viewcode-back" href="../../../generated/statsmodels.tsa.stattools.pacf.html#statsmodels.tsa.stattools.pacf">[docs]</a><span class="k">def</span> <span class="nf">pacf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">nlags</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;ywunbiased&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Partial autocorrelation estimated</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : 1d array</span>
<span class="sd">        observations of time series for which pacf is calculated</span>
<span class="sd">    nlags : int</span>
<span class="sd">        largest lag for which the pacf is returned</span>
<span class="sd">    method : str</span>
<span class="sd">        specifies which method for the calculations to use:</span>

<span class="sd">        - &#39;yw&#39; or &#39;ywunbiased&#39; : Yule-Walker with bias correction in</span>
<span class="sd">          denominator for acovf. Default.</span>
<span class="sd">        - &#39;ywm&#39; or &#39;ywmle&#39; : Yule-Walker without bias correction</span>
<span class="sd">        - &#39;ols&#39; : regression of time series on lags of it and on constant</span>
<span class="sd">        - &#39;ols-inefficient&#39; : regression of time series on lags using a single</span>
<span class="sd">          common sample to estimate all pacf coefficients</span>
<span class="sd">        - &#39;ols-unbiased&#39; : regression of time series on lags with a bias</span>
<span class="sd">          adjustment</span>
<span class="sd">        - &#39;ld&#39; or &#39;ldunbiased&#39; : Levinson-Durbin recursion with bias correction</span>
<span class="sd">        - &#39;ldb&#39; or &#39;ldbiased&#39; : Levinson-Durbin recursion without bias</span>
<span class="sd">          correction</span>

<span class="sd">    alpha : float, optional</span>
<span class="sd">        If a number is given, the confidence intervals for the given level are</span>
<span class="sd">        returned. For instance if alpha=.05, 95 % confidence intervals are</span>
<span class="sd">        returned where the standard deviation is computed according to</span>
<span class="sd">        1/sqrt(len(x))</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    pacf : 1d array</span>
<span class="sd">        partial autocorrelations, nlags elements, including lag zero</span>
<span class="sd">    confint : array, optional</span>
<span class="sd">        Confidence intervals for the PACF. Returned if confint is not None.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    statsmodels.tsa.stattools.acf</span>
<span class="sd">    statsmodels.tsa.stattools.pacf_yw</span>
<span class="sd">    statsmodels.tsa.stattools.pacf_burg</span>
<span class="sd">    statsmodels.tsa.stattools.pacf_ols</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Based on simulation evidence across a range of low-order ARMA models,</span>
<span class="sd">    the best methods based on root MSE are Yule-Walker (MLW), Levinson-Durbin</span>
<span class="sd">    (MLE) and Burg, respectively. The estimators with the lowest bias included</span>
<span class="sd">    included these three in addition to OLS and OLS-unbiased.</span>

<span class="sd">    Yule-Walker (unbiased) and Levinson-Durbin (unbiased) performed</span>
<span class="sd">    consistently worse than the other options.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">method</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;ols&#39;</span><span class="p">,</span> <span class="s1">&#39;ols-inefficient&#39;</span><span class="p">,</span> <span class="s1">&#39;ols-unbiased&#39;</span><span class="p">):</span>
        <span class="n">efficient</span> <span class="o">=</span> <span class="s1">&#39;inefficient&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">method</span>
        <span class="n">unbiased</span> <span class="o">=</span> <span class="s1">&#39;unbiased&#39;</span> <span class="ow">in</span> <span class="n">method</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">pacf_ols</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">nlags</span><span class="o">=</span><span class="n">nlags</span><span class="p">,</span> <span class="n">efficient</span><span class="o">=</span><span class="n">efficient</span><span class="p">,</span> <span class="n">unbiased</span><span class="o">=</span><span class="n">unbiased</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;yw&#39;</span><span class="p">,</span> <span class="s1">&#39;ywu&#39;</span><span class="p">,</span> <span class="s1">&#39;ywunbiased&#39;</span><span class="p">,</span> <span class="s1">&#39;yw_unbiased&#39;</span><span class="p">):</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">pacf_yw</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">nlags</span><span class="o">=</span><span class="n">nlags</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;unbiased&#39;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;ywm&#39;</span><span class="p">,</span> <span class="s1">&#39;ywmle&#39;</span><span class="p">,</span> <span class="s1">&#39;yw_mle&#39;</span><span class="p">):</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">pacf_yw</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">nlags</span><span class="o">=</span><span class="n">nlags</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;mle&#39;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;ld&#39;</span><span class="p">,</span> <span class="s1">&#39;ldu&#39;</span><span class="p">,</span> <span class="s1">&#39;ldunbiased&#39;</span><span class="p">,</span> <span class="s1">&#39;ld_unbiased&#39;</span><span class="p">):</span>
        <span class="n">acv</span> <span class="o">=</span> <span class="n">acovf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">unbiased</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">fft</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">ld_</span> <span class="o">=</span> <span class="n">levinson_durbin</span><span class="p">(</span><span class="n">acv</span><span class="p">,</span> <span class="n">nlags</span><span class="o">=</span><span class="n">nlags</span><span class="p">,</span> <span class="n">isacov</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">ld_</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="c1"># inconsistent naming with ywmle</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;ldb&#39;</span><span class="p">,</span> <span class="s1">&#39;ldbiased&#39;</span><span class="p">,</span> <span class="s1">&#39;ld_biased&#39;</span><span class="p">):</span>
        <span class="n">acv</span> <span class="o">=</span> <span class="n">acovf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">unbiased</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fft</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">ld_</span> <span class="o">=</span> <span class="n">levinson_durbin</span><span class="p">(</span><span class="n">acv</span><span class="p">,</span> <span class="n">nlags</span><span class="o">=</span><span class="n">nlags</span><span class="p">,</span> <span class="n">isacov</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">ld_</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;method not available&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">alpha</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">varacf</span> <span class="o">=</span> <span class="mf">1.</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="c1"># for all lags &gt;=1</span>
        <span class="n">interval</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="mf">1.</span> <span class="o">-</span> <span class="n">alpha</span> <span class="o">/</span> <span class="mf">2.</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">varacf</span><span class="p">)</span>
        <span class="n">confint</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lzip</span><span class="p">(</span><span class="n">ret</span> <span class="o">-</span> <span class="n">interval</span><span class="p">,</span> <span class="n">ret</span> <span class="o">+</span> <span class="n">interval</span><span class="p">))</span>
        <span class="n">confint</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># fix confidence interval for lag 0 to varpacf=0</span>
        <span class="k">return</span> <span class="n">ret</span><span class="p">,</span> <span class="n">confint</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ret</span></div>


<div class="viewcode-block" id="ccovf"><a class="viewcode-back" href="../../../generated/statsmodels.tsa.stattools.ccovf.html#statsmodels.tsa.stattools.ccovf">[docs]</a><span class="k">def</span> <span class="nf">ccovf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">unbiased</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">demean</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; crosscovariance for 1D</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x, y : arrays</span>
<span class="sd">       time series data</span>
<span class="sd">    unbiased : boolean</span>
<span class="sd">       if True, then denominators is n-k, otherwise n</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ccovf : array</span>
<span class="sd">        autocovariance function</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This uses np.correlate which does full convolution. For very long time</span>
<span class="sd">    series it is recommended to use fft convolution instead.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">demean</span><span class="p">:</span>
        <span class="n">xo</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">x</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        <span class="n">yo</span> <span class="o">=</span> <span class="n">y</span> <span class="o">-</span> <span class="n">y</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">xo</span> <span class="o">=</span> <span class="n">x</span>
        <span class="n">yo</span> <span class="o">=</span> <span class="n">y</span>
    <span class="k">if</span> <span class="n">unbiased</span><span class="p">:</span>
        <span class="n">xi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">correlate</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">xi</span><span class="p">,</span> <span class="s1">&#39;full&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">n</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">correlate</span><span class="p">(</span><span class="n">xo</span><span class="p">,</span> <span class="n">yo</span><span class="p">,</span> <span class="s1">&#39;full&#39;</span><span class="p">)</span> <span class="o">/</span> <span class="n">d</span><span class="p">)[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:]</span></div>


<div class="viewcode-block" id="ccf"><a class="viewcode-back" href="../../../generated/statsmodels.tsa.stattools.ccf.html#statsmodels.tsa.stattools.ccf">[docs]</a><span class="k">def</span> <span class="nf">ccf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">unbiased</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;cross-correlation function for 1d</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x, y : arrays</span>
<span class="sd">       time series data</span>
<span class="sd">    unbiased : boolean</span>
<span class="sd">       if True, then denominators for autocovariance is n-k, otherwise n</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ccf : array</span>
<span class="sd">        cross-correlation function of x and y</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This is based np.correlate which does full convolution. For very long time</span>
<span class="sd">    series it is recommended to use fft convolution instead.</span>

<span class="sd">    If unbiased is true, the denominator for the autocovariance is adjusted</span>
<span class="sd">    but the autocorrelation is not an unbiased estimtor.</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">cvf</span> <span class="o">=</span> <span class="n">ccovf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">unbiased</span><span class="o">=</span><span class="n">unbiased</span><span class="p">,</span> <span class="n">demean</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">cvf</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">y</span><span class="p">))</span></div>


<div class="viewcode-block" id="periodogram"><a class="viewcode-back" href="../../../generated/statsmodels.tsa.stattools.periodogram.html#statsmodels.tsa.stattools.periodogram">[docs]</a><span class="k">def</span> <span class="nf">periodogram</span><span class="p">(</span><span class="n">X</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the periodogram for the natural frequency of X</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    X : array-like</span>
<span class="sd">        Array for which the periodogram is desired.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    pgram : array</span>
<span class="sd">        1./len(X) * np.abs(np.fft.fft(X))**2</span>


<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [*] Brockwell, P.J. and Davis, R.A., 2016. Introduction to time series</span>
<span class="sd">        and forecasting. Springer.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
    <span class="c1"># if kernel == &quot;bartlett&quot;:</span>
    <span class="c1">#    w = 1 - np.arange(M+1.)/M   #JP removed integer division</span>

    <span class="n">pergr</span> <span class="o">=</span> <span class="mf">1.</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">X</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">pergr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.</span>  <span class="c1"># what are the implications of this?</span>
    <span class="k">return</span> <span class="n">pergr</span></div>


<span class="c1"># moved from sandbox.tsa.examples.try_ld_nitime, via nitime</span>
<span class="c1"># TODO: check what to return, for testing and trying out returns everything</span>
<div class="viewcode-block" id="levinson_durbin"><a class="viewcode-back" href="../../../generated/statsmodels.tsa.stattools.levinson_durbin.html#statsmodels.tsa.stattools.levinson_durbin">[docs]</a><span class="k">def</span> <span class="nf">levinson_durbin</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">nlags</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">isacov</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Levinson-Durbin recursion for autoregressive processes</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    s : array_like</span>
<span class="sd">        If isacov is False, then this is the time series. If iasacov is true</span>
<span class="sd">        then this is interpreted as autocovariance starting with lag 0</span>
<span class="sd">    nlags : integer</span>
<span class="sd">        largest lag to include in recursion or order of the autoregressive</span>
<span class="sd">        process</span>
<span class="sd">    isacov : boolean</span>
<span class="sd">        flag to indicate whether the first argument, s, contains the</span>
<span class="sd">        autocovariances or the data series.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    sigma_v : float</span>
<span class="sd">        estimate of the error variance ?</span>
<span class="sd">    arcoefs : ndarray</span>
<span class="sd">        estimate of the autoregressive coefficients for a model including nlags</span>
<span class="sd">    pacf : ndarray</span>
<span class="sd">        partial autocorrelation function</span>
<span class="sd">    sigma : ndarray</span>
<span class="sd">        entire sigma array from intermediate result, last value is sigma_v</span>
<span class="sd">    phi : ndarray</span>
<span class="sd">        entire phi array from intermediate result, last column contains</span>
<span class="sd">        autoregressive coefficients for AR(nlags)</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This function returns currently all results, but maybe we drop sigma and</span>
<span class="sd">    phi from the returns.</span>

<span class="sd">    If this function is called with the time series (isacov=False), then the</span>
<span class="sd">    sample autocovariance function is calculated with the default options</span>
<span class="sd">    (biased, no fft).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
    <span class="n">order</span> <span class="o">=</span> <span class="n">nlags</span>

    <span class="k">if</span> <span class="n">isacov</span><span class="p">:</span>
        <span class="n">sxx_m</span> <span class="o">=</span> <span class="n">s</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">sxx_m</span> <span class="o">=</span> <span class="n">acovf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">fft</span><span class="o">=</span><span class="kc">False</span><span class="p">)[:</span><span class="n">order</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>  <span class="c1"># not tested</span>

    <span class="n">phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">order</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">order</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="s1">&#39;d&#39;</span><span class="p">)</span>
    <span class="n">sig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">order</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="c1"># initial points for the recursion</span>
    <span class="n">phi</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">sxx_m</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">sxx_m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">sig</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">sxx_m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">phi</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">sxx_m</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">order</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">phi</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">sxx_m</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">phi</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                                       <span class="n">sxx_m</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">k</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span> <span class="o">/</span> <span class="n">sig</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
            <span class="n">phi</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">phi</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">phi</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">phi</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">sig</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">sig</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">phi</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

    <span class="n">sigma_v</span> <span class="o">=</span> <span class="n">sig</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">arcoefs</span> <span class="o">=</span> <span class="n">phi</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">pacf_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">pacf_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span>
    <span class="k">return</span> <span class="n">sigma_v</span><span class="p">,</span> <span class="n">arcoefs</span><span class="p">,</span> <span class="n">pacf_</span><span class="p">,</span> <span class="n">sig</span><span class="p">,</span> <span class="n">phi</span>  <span class="c1"># return everything</span></div>


<div class="viewcode-block" id="levinson_durbin_pacf"><a class="viewcode-back" href="../../../generated/statsmodels.tsa.stattools.levinson_durbin_pacf.html#statsmodels.tsa.stattools.levinson_durbin_pacf">[docs]</a><span class="k">def</span> <span class="nf">levinson_durbin_pacf</span><span class="p">(</span><span class="n">pacf</span><span class="p">,</span> <span class="n">nlags</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Levinson-Durbin algorithm that returns the acf and ar coefficients</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    pacf : array-like</span>
<span class="sd">        Partial autocorrelation array for lags 0, 1, ... p</span>
<span class="sd">    nlags : int, optional</span>
<span class="sd">        Number of lags in the AR model.  If omitted, returns coefficients from</span>
<span class="sd">        an AR(p) and the first p autocorrelations</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    arcoefs : ndarray</span>
<span class="sd">        AR coefficients computed from the partial autocorrelations</span>
<span class="sd">    acf : ndarray</span>
<span class="sd">        acf computed from the partial autocorrelations. Array returned contains</span>
<span class="sd">        the autocorelations corresponding to lags 0, 1, ..., p</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [*] Brockwell, P.J. and Davis, R.A., 2016. Introduction to time series</span>
<span class="sd">        and forecasting. Springer.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">pacf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">pacf</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">pacf</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;pacf must be 1-d or squeezable to 1-d.&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">pacf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The first entry of the pacf corresponds to lags 0 &#39;</span>
                         <span class="s1">&#39;and so must be 1.&#39;</span><span class="p">)</span>
    <span class="n">pacf</span> <span class="o">=</span> <span class="n">pacf</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">pacf</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">nlags</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">nlags</span> <span class="o">&gt;</span> <span class="n">n</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Must provide at least as many values from the &#39;</span>
                             <span class="s1">&#39;pacf as the number of lags.&#39;</span><span class="p">)</span>
        <span class="n">pacf</span> <span class="o">=</span> <span class="n">pacf</span><span class="p">[:</span><span class="n">nlags</span><span class="p">]</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">pacf</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">acf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">acf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">pacf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">nu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumprod</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">pacf</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">arcoefs</span> <span class="o">=</span> <span class="n">pacf</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="n">prev</span> <span class="o">=</span> <span class="n">arcoefs</span><span class="p">[:</span><span class="o">-</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">i</span><span class="p">)]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">arcoefs</span><span class="p">[:</span><span class="o">-</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">i</span><span class="p">)]</span> <span class="o">=</span> <span class="n">prev</span> <span class="o">-</span> <span class="n">arcoefs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">prev</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">acf</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">arcoefs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">nu</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">prev</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">acf</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">i</span><span class="p">)][::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">acf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">arcoefs</span><span class="p">,</span> <span class="n">acf</span></div>


<div class="viewcode-block" id="innovations_algo"><a class="viewcode-back" href="../../../generated/statsmodels.tsa.stattools.innovations_algo.html#statsmodels.tsa.stattools.innovations_algo">[docs]</a><span class="k">def</span> <span class="nf">innovations_algo</span><span class="p">(</span><span class="n">acov</span><span class="p">,</span> <span class="n">nobs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Innovations algorithm to convert autocovariances to MA parameters</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    acov : array-like</span>
<span class="sd">        Array containing autocovariances including lag 0</span>
<span class="sd">    nobs : int, optional</span>
<span class="sd">        Number of periods to run the algorithm.  If not provided, nobs is</span>
<span class="sd">        equal to the length of acovf</span>
<span class="sd">    rtol : float, optional</span>
<span class="sd">        Tolerance used to check for convergence. Default value is 0 which will</span>
<span class="sd">        never prematurely end the algorithm. Checks after 10 iterations and</span>
<span class="sd">        stops if sigma2[i] - sigma2[i - 10] &lt; rtol * sigma2[0]. When the</span>
<span class="sd">        stopping condition is met, the remaining values in theta and sigma2</span>
<span class="sd">        are forward filled using the value of the final iteration.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    theta : ndarray</span>
<span class="sd">        Innovation coefficients of MA representation. Array is (nobs, q) where</span>
<span class="sd">        q is the largest index of a non-zero autocovariance. theta</span>
<span class="sd">        corresponds to the first q columns of the coefficient matrix in the</span>
<span class="sd">        common description of the innovation algorithm.</span>
<span class="sd">    sigma2 : ndarray</span>
<span class="sd">        The prediction error variance (nobs,).</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import statsmodels.api as sm</span>
<span class="sd">    &gt;&gt;&gt; data = sm.datasets.macrodata.load_pandas()</span>
<span class="sd">    &gt;&gt;&gt; rgdpg = data.data[&#39;realgdp&#39;].pct_change().dropna()</span>
<span class="sd">    &gt;&gt;&gt; acov = sm.tsa.acovf(rgdpg)</span>
<span class="sd">    &gt;&gt;&gt; nobs = activity.shape[0]</span>
<span class="sd">    &gt;&gt;&gt; theta, sigma2  = innovations_algo(acov[:4], nobs=nobs)</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    innovations_filter</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [*] Brockwell, P.J. and Davis, R.A., 2016. Introduction to time series</span>
<span class="sd">        and forecasting. Springer.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">acov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">acov</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">acov</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;acov must be 1-d or squeezable to 1-d.&#39;</span><span class="p">)</span>
    <span class="n">rtol</span> <span class="o">=</span> <span class="mf">0.0</span> <span class="k">if</span> <span class="n">rtol</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">rtol</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rtol</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;rtol must be a non-negative float or None.&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">nobs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="p">(</span><span class="n">nobs</span> <span class="o">!=</span> <span class="nb">int</span><span class="p">(</span><span class="n">nobs</span><span class="p">)</span> <span class="ow">or</span> <span class="n">nobs</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;nobs must be a positive integer&#39;</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">acov</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">nobs</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">int</span><span class="p">(</span><span class="n">nobs</span><span class="p">)</span>
    <span class="n">max_lag</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">acov</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)))</span>

    <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">acov</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="c1"># Retain only the relevant columns of theta</span>
    <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">max_lag</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">max_lag</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">i</span><span class="p">):</span>
            <span class="n">sub</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">max_lag</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">k</span><span class="p">):</span>
                <span class="n">sub</span> <span class="o">+=</span> <span class="n">theta</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span> <span class="o">-</span> <span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">theta</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span> <span class="o">-</span> <span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">v</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="n">theta</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span> <span class="o">-</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span> <span class="o">/</span> <span class="n">v</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">acov</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">k</span><span class="p">]</span> <span class="o">-</span> <span class="n">sub</span><span class="p">)</span>
        <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">acov</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">max_lag</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">i</span><span class="p">):</span>
            <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-=</span> <span class="n">theta</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span> <span class="o">-</span> <span class="n">j</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">v</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
        <span class="c1"># Break if v has converged</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">10</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">10</span><span class="p">]</span> <span class="o">-</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">rtol</span><span class="p">:</span>
                <span class="c1"># Forward fill all remaining values</span>
                <span class="n">v</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">theta</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">theta</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">break</span>

    <span class="n">theta</span> <span class="o">=</span> <span class="n">theta</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:]</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">v</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">theta</span><span class="p">,</span> <span class="n">v</span></div>


<div class="viewcode-block" id="innovations_filter"><a class="viewcode-back" href="../../../generated/statsmodels.tsa.stattools.innovations_filter.html#statsmodels.tsa.stattools.innovations_filter">[docs]</a><span class="k">def</span> <span class="nf">innovations_filter</span><span class="p">(</span><span class="n">endog</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Filter observations using the innovations algorithm</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    endog : array-like</span>
<span class="sd">        The time series to filter (nobs,). Should be demeaned if not mean 0.</span>
<span class="sd">    theta : ndarray</span>
<span class="sd">        Innovation coefficients of MA representation. Array must be (nobs, q)</span>
<span class="sd">        where q order of the MA.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    resid : ndarray</span>
<span class="sd">        Array of filtered innovations</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import statsmodels.api as sm</span>
<span class="sd">    &gt;&gt;&gt; data = sm.datasets.macrodata.load_pandas()</span>
<span class="sd">    &gt;&gt;&gt; rgdpg = data.data[&#39;realgdp&#39;].pct_change().dropna()</span>
<span class="sd">    &gt;&gt;&gt; acov = sm.tsa.acovf(rgdpg)</span>
<span class="sd">    &gt;&gt;&gt; nobs = activity.shape[0]</span>
<span class="sd">    &gt;&gt;&gt; theta, sigma2  = innovations_algo(acov[:4], nobs=nobs)</span>
<span class="sd">    &gt;&gt;&gt; resid = innovations_filter(rgdpg, theta)</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    innovations_algo</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [*] Brockwell, P.J. and Davis, R.A., 2016. Introduction to time series</span>
<span class="sd">        and forecasting. Springer.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">orig_endog</span> <span class="o">=</span> <span class="n">endog</span>
    <span class="n">endog</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">endog</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">endog</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;endog must be 1-d or squeezable to 1-d.&#39;</span><span class="p">)</span>
    <span class="n">nobs</span> <span class="o">=</span> <span class="n">endog</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">n_theta</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="n">theta</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">if</span> <span class="n">nobs</span> <span class="o">!=</span> <span class="n">n_theta</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;theta must be (nobs, q) where q is the moder order&#39;</span><span class="p">)</span>
    <span class="n">is_pandas</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">orig_endog</span><span class="p">,</span> <span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">is_pandas</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">orig_endog</span><span class="o">.</span><span class="n">index</span><span class="p">)</span> <span class="o">!=</span> <span class="n">nobs</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;If endog is a Series or DataFrame, the index must &#39;</span> \
                  <span class="s1">&#39;correspond to the number of time series observations.&#39;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">nobs</span><span class="p">)</span>
    <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">endog</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nobs</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">k</span><span class="p">:</span>
            <span class="n">hat</span> <span class="o">=</span> <span class="p">(</span><span class="n">theta</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">u</span><span class="p">[:</span><span class="n">i</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">hat</span> <span class="o">=</span> <span class="p">(</span><span class="n">theta</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">k</span><span class="p">:</span><span class="n">i</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">endog</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">hat</span>
    <span class="k">if</span> <span class="n">is_pandas</span><span class="p">:</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">orig_endog</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
    <span class="k">return</span> <span class="n">u</span></div>


<div class="viewcode-block" id="grangercausalitytests"><a class="viewcode-back" href="../../../generated/statsmodels.tsa.stattools.grangercausalitytests.html#statsmodels.tsa.stattools.grangercausalitytests">[docs]</a><span class="k">def</span> <span class="nf">grangercausalitytests</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">maxlag</span><span class="p">,</span> <span class="n">addconst</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;four tests for granger non causality of 2 timeseries</span>

<span class="sd">    all four tests give similar results</span>
<span class="sd">    `params_ftest` and `ssr_ftest` are equivalent based on F test which is</span>
<span class="sd">    identical to lmtest:grangertest in R</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : array, 2d</span>
<span class="sd">        data for test whether the time series in the second column Granger</span>
<span class="sd">        causes the time series in the first column</span>
<span class="sd">    maxlag : integer</span>
<span class="sd">        the Granger causality test results are calculated for all lags up to</span>
<span class="sd">        maxlag</span>
<span class="sd">    verbose : bool</span>
<span class="sd">        print results if true</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    results : dictionary</span>
<span class="sd">        all test results, dictionary keys are the number of lags. For each</span>
<span class="sd">        lag the values are a tuple, with the first element a dictionary with</span>
<span class="sd">        teststatistic, pvalues, degrees of freedom, the second element are</span>
<span class="sd">        the OLS estimation results for the restricted model, the unrestricted</span>
<span class="sd">        model and the restriction (contrast) matrix for the parameter f_test.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    TODO: convert to class and attach results properly</span>

<span class="sd">    The Null hypothesis for grangercausalitytests is that the time series in</span>
<span class="sd">    the second column, x2, does NOT Granger cause the time series in the first</span>
<span class="sd">    column, x1. Grange causality means that past values of x2 have a</span>
<span class="sd">    statistically significant effect on the current value of x1, taking past</span>
<span class="sd">    values of x1 into account as regressors. We reject the null hypothesis</span>
<span class="sd">    that x2 does not Granger cause x1 if the pvalues are below a desired size</span>
<span class="sd">    of the test.</span>

<span class="sd">    The null hypothesis for all four test is that the coefficients</span>
<span class="sd">    corresponding to past values of the second time series are zero.</span>

<span class="sd">    &#39;params_ftest&#39;, &#39;ssr_ftest&#39; are based on F distribution</span>

<span class="sd">    &#39;ssr_chi2test&#39;, &#39;lrtest&#39; are based on chi-square distribution</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    http://en.wikipedia.org/wiki/Granger_causality</span>
<span class="sd">    Greene: Econometric Analysis</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">scipy</span> <span class="k">import</span> <span class="n">stats</span>

    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">maxlag</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="n">addconst</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Insufficient observations. Maximum allowable &quot;</span>
                         <span class="s2">&quot;lag is </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">int</span><span class="p">((</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="nb">int</span><span class="p">(</span><span class="n">addconst</span><span class="p">))</span> <span class="o">/</span>
                                                 <span class="mi">3</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>

    <span class="n">resli</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">for</span> <span class="n">mlg</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">maxlag</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Granger Causality&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;number of lags (no zero)&#39;</span><span class="p">,</span> <span class="n">mlg</span><span class="p">)</span>
        <span class="n">mxlg</span> <span class="o">=</span> <span class="n">mlg</span>

        <span class="c1"># create lagmat of both time series</span>
        <span class="n">dta</span> <span class="o">=</span> <span class="n">lagmat2ds</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">mxlg</span><span class="p">,</span> <span class="n">trim</span><span class="o">=</span><span class="s1">&#39;both&#39;</span><span class="p">,</span> <span class="n">dropex</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1">#add constant</span>
        <span class="k">if</span> <span class="n">addconst</span><span class="p">:</span>
            <span class="n">dtaown</span> <span class="o">=</span> <span class="n">add_constant</span><span class="p">(</span><span class="n">dta</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:(</span><span class="n">mxlg</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)],</span> <span class="n">prepend</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">dtajoint</span> <span class="o">=</span> <span class="n">add_constant</span><span class="p">(</span><span class="n">dta</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:],</span> <span class="n">prepend</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Not Implemented&#39;</span><span class="p">)</span>
            <span class="c1">#dtaown = dta[:, 1:mxlg]</span>
            <span class="c1">#dtajoint = dta[:, 1:]</span>

        <span class="c1"># Run ols on both models without and with lags of second variable</span>
        <span class="n">res2down</span> <span class="o">=</span> <span class="n">OLS</span><span class="p">(</span><span class="n">dta</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">dtaown</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">()</span>
        <span class="n">res2djoint</span> <span class="o">=</span> <span class="n">OLS</span><span class="p">(</span><span class="n">dta</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">dtajoint</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">()</span>

        <span class="c1">#print results</span>
        <span class="c1">#for ssr based tests see:</span>
        <span class="c1">#http://support.sas.com/rnd/app/examples/ets/granger/index.htm</span>
        <span class="c1">#the other tests are made-up</span>

        <span class="c1"># Granger Causality test using ssr (F statistic)</span>
        <span class="n">fgc1</span> <span class="o">=</span> <span class="p">((</span><span class="n">res2down</span><span class="o">.</span><span class="n">ssr</span> <span class="o">-</span> <span class="n">res2djoint</span><span class="o">.</span><span class="n">ssr</span><span class="p">)</span> <span class="o">/</span>
                <span class="n">res2djoint</span><span class="o">.</span><span class="n">ssr</span> <span class="o">/</span> <span class="n">mxlg</span> <span class="o">*</span> <span class="n">res2djoint</span><span class="o">.</span><span class="n">df_resid</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;ssr based F test:         F=</span><span class="si">%-8.4f</span><span class="s1">, p=</span><span class="si">%-8.4f</span><span class="s1">, df_denom=</span><span class="si">%d</span><span class="s1">,&#39;</span>
                   <span class="s1">&#39; df_num=</span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">fgc1</span><span class="p">,</span>
                                    <span class="n">stats</span><span class="o">.</span><span class="n">f</span><span class="o">.</span><span class="n">sf</span><span class="p">(</span><span class="n">fgc1</span><span class="p">,</span> <span class="n">mxlg</span><span class="p">,</span>
                                               <span class="n">res2djoint</span><span class="o">.</span><span class="n">df_resid</span><span class="p">),</span>
                                    <span class="n">res2djoint</span><span class="o">.</span><span class="n">df_resid</span><span class="p">,</span> <span class="n">mxlg</span><span class="p">))</span>
        <span class="n">result</span><span class="p">[</span><span class="s1">&#39;ssr_ftest&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">fgc1</span><span class="p">,</span>
                               <span class="n">stats</span><span class="o">.</span><span class="n">f</span><span class="o">.</span><span class="n">sf</span><span class="p">(</span><span class="n">fgc1</span><span class="p">,</span> <span class="n">mxlg</span><span class="p">,</span> <span class="n">res2djoint</span><span class="o">.</span><span class="n">df_resid</span><span class="p">),</span>
                               <span class="n">res2djoint</span><span class="o">.</span><span class="n">df_resid</span><span class="p">,</span> <span class="n">mxlg</span><span class="p">)</span>

        <span class="c1"># Granger Causality test using ssr (ch2 statistic)</span>
        <span class="n">fgc2</span> <span class="o">=</span> <span class="n">res2down</span><span class="o">.</span><span class="n">nobs</span> <span class="o">*</span> <span class="p">(</span><span class="n">res2down</span><span class="o">.</span><span class="n">ssr</span> <span class="o">-</span> <span class="n">res2djoint</span><span class="o">.</span><span class="n">ssr</span><span class="p">)</span> <span class="o">/</span> <span class="n">res2djoint</span><span class="o">.</span><span class="n">ssr</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;ssr based chi2 test:   chi2=</span><span class="si">%-8.4f</span><span class="s1">, p=</span><span class="si">%-8.4f</span><span class="s1">, &#39;</span>
                   <span class="s1">&#39;df=</span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">fgc2</span><span class="p">,</span> <span class="n">stats</span><span class="o">.</span><span class="n">chi2</span><span class="o">.</span><span class="n">sf</span><span class="p">(</span><span class="n">fgc2</span><span class="p">,</span> <span class="n">mxlg</span><span class="p">),</span> <span class="n">mxlg</span><span class="p">))</span>
        <span class="n">result</span><span class="p">[</span><span class="s1">&#39;ssr_chi2test&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">fgc2</span><span class="p">,</span> <span class="n">stats</span><span class="o">.</span><span class="n">chi2</span><span class="o">.</span><span class="n">sf</span><span class="p">(</span><span class="n">fgc2</span><span class="p">,</span> <span class="n">mxlg</span><span class="p">),</span> <span class="n">mxlg</span><span class="p">)</span>

        <span class="c1">#likelihood ratio test pvalue:</span>
        <span class="n">lr</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">res2down</span><span class="o">.</span><span class="n">llf</span> <span class="o">-</span> <span class="n">res2djoint</span><span class="o">.</span><span class="n">llf</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;likelihood ratio test: chi2=</span><span class="si">%-8.4f</span><span class="s1">, p=</span><span class="si">%-8.4f</span><span class="s1">, df=</span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span>
                   <span class="p">(</span><span class="n">lr</span><span class="p">,</span> <span class="n">stats</span><span class="o">.</span><span class="n">chi2</span><span class="o">.</span><span class="n">sf</span><span class="p">(</span><span class="n">lr</span><span class="p">,</span> <span class="n">mxlg</span><span class="p">),</span> <span class="n">mxlg</span><span class="p">))</span>
        <span class="n">result</span><span class="p">[</span><span class="s1">&#39;lrtest&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">lr</span><span class="p">,</span> <span class="n">stats</span><span class="o">.</span><span class="n">chi2</span><span class="o">.</span><span class="n">sf</span><span class="p">(</span><span class="n">lr</span><span class="p">,</span> <span class="n">mxlg</span><span class="p">),</span> <span class="n">mxlg</span><span class="p">)</span>

        <span class="c1"># F test that all lag coefficients of exog are zero</span>
        <span class="n">rconstr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">mxlg</span><span class="p">,</span> <span class="n">mxlg</span><span class="p">)),</span>
                                   <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">mxlg</span><span class="p">,</span> <span class="n">mxlg</span><span class="p">),</span>
                                   <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">mxlg</span><span class="p">,</span> <span class="mi">1</span><span class="p">))))</span>
        <span class="n">ftres</span> <span class="o">=</span> <span class="n">res2djoint</span><span class="o">.</span><span class="n">f_test</span><span class="p">(</span><span class="n">rconstr</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;parameter F test:         F=</span><span class="si">%-8.4f</span><span class="s1">, p=</span><span class="si">%-8.4f</span><span class="s1">, df_denom=</span><span class="si">%d</span><span class="s1">,&#39;</span>
                   <span class="s1">&#39; df_num=</span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">ftres</span><span class="o">.</span><span class="n">fvalue</span><span class="p">,</span> <span class="n">ftres</span><span class="o">.</span><span class="n">pvalue</span><span class="p">,</span> <span class="n">ftres</span><span class="o">.</span><span class="n">df_denom</span><span class="p">,</span>
                                    <span class="n">ftres</span><span class="o">.</span><span class="n">df_num</span><span class="p">))</span>
        <span class="n">result</span><span class="p">[</span><span class="s1">&#39;params_ftest&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">ftres</span><span class="o">.</span><span class="n">fvalue</span><span class="p">)[()],</span>
                                  <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">ftres</span><span class="o">.</span><span class="n">pvalue</span><span class="p">)[()],</span>
                                  <span class="n">ftres</span><span class="o">.</span><span class="n">df_denom</span><span class="p">,</span> <span class="n">ftres</span><span class="o">.</span><span class="n">df_num</span><span class="p">)</span>

        <span class="n">resli</span><span class="p">[</span><span class="n">mxlg</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="p">[</span><span class="n">res2down</span><span class="p">,</span> <span class="n">res2djoint</span><span class="p">,</span> <span class="n">rconstr</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">resli</span></div>


<div class="viewcode-block" id="coint"><a class="viewcode-back" href="../../../generated/statsmodels.tsa.stattools.coint.html#statsmodels.tsa.stattools.coint">[docs]</a><span class="k">def</span> <span class="nf">coint</span><span class="p">(</span><span class="n">y0</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">trend</span><span class="o">=</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;aeg&#39;</span><span class="p">,</span> <span class="n">maxlag</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">autolag</span><span class="o">=</span><span class="s1">&#39;aic&#39;</span><span class="p">,</span>
          <span class="n">return_results</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Test for no-cointegration of a univariate equation</span>

<span class="sd">    The null hypothesis is no cointegration. Variables in y0 and y1 are</span>
<span class="sd">    assumed to be integrated of order 1, I(1).</span>

<span class="sd">    This uses the augmented Engle-Granger two-step cointegration test.</span>
<span class="sd">    Constant or trend is included in 1st stage regression, i.e. in</span>
<span class="sd">    cointegrating equation.</span>

<span class="sd">    **Warning:** The autolag default has changed compared to statsmodels 0.8.</span>
<span class="sd">    In 0.8 autolag was always None, no the keyword is used and defaults to</span>
<span class="sd">    &#39;aic&#39;. Use `autolag=None` to avoid the lag search.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    y1 : array_like, 1d</span>
<span class="sd">        first element in cointegrating vector</span>
<span class="sd">    y2 : array_like</span>
<span class="sd">        remaining elements in cointegrating vector</span>
<span class="sd">    trend : str {&#39;c&#39;, &#39;ct&#39;}</span>
<span class="sd">        trend term included in regression for cointegrating equation</span>

<span class="sd">        * &#39;c&#39; : constant</span>
<span class="sd">        * &#39;ct&#39; : constant and linear trend</span>
<span class="sd">        * also available quadratic trend &#39;ctt&#39;, and no constant &#39;nc&#39;</span>

<span class="sd">    method : string</span>
<span class="sd">        currently only &#39;aeg&#39; for augmented Engle-Granger test is available.</span>
<span class="sd">        default might change.</span>
<span class="sd">    maxlag : None or int</span>
<span class="sd">        keyword for `adfuller`, largest or given number of lags</span>
<span class="sd">    autolag : string</span>
<span class="sd">        keyword for `adfuller`, lag selection criterion.</span>

<span class="sd">        * if None, then maxlag lags are used without lag search</span>
<span class="sd">        * if &#39;AIC&#39; (default) or &#39;BIC&#39;, then the number of lags is chosen</span>
<span class="sd">          to minimize the corresponding information criterion</span>
<span class="sd">        * &#39;t-stat&#39; based choice of maxlag.  Starts with maxlag and drops a</span>
<span class="sd">          lag until the t-statistic on the last lag length is significant</span>
<span class="sd">          using a 5%-sized test</span>

<span class="sd">    return_results : bool</span>
<span class="sd">        for future compatibility, currently only tuple available.</span>
<span class="sd">        If True, then a results instance is returned. Otherwise, a tuple</span>
<span class="sd">        with the test outcome is returned.</span>
<span class="sd">        Set `return_results=False` to avoid future changes in return.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    coint_t : float</span>
<span class="sd">        t-statistic of unit-root test on residuals</span>
<span class="sd">    pvalue : float</span>
<span class="sd">        MacKinnon&#39;s approximate, asymptotic p-value based on MacKinnon (1994)</span>
<span class="sd">    crit_value : dict</span>
<span class="sd">        Critical values for the test statistic at the 1 %, 5 %, and 10 %</span>
<span class="sd">        levels based on regression curve. This depends on the number of</span>
<span class="sd">        observations.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The Null hypothesis is that there is no cointegration, the alternative</span>
<span class="sd">    hypothesis is that there is cointegrating relationship. If the pvalue is</span>
<span class="sd">    small, below a critical size, then we can reject the hypothesis that there</span>
<span class="sd">    is no cointegrating relationship.</span>

<span class="sd">    P-values and critical values are obtained through regression surface</span>
<span class="sd">    approximation from MacKinnon 1994 and 2010.</span>

<span class="sd">    If the two series are almost perfectly collinear, then computing the</span>
<span class="sd">    test is numerically unstable. However, the two series will be cointegrated</span>
<span class="sd">    under the maintained assumption that they are integrated. In this case</span>
<span class="sd">    the t-statistic will be set to -inf and the pvalue to zero.</span>

<span class="sd">    TODO: We could handle gaps in data by dropping rows with nans in the</span>
<span class="sd">    auxiliary regressions. Not implemented yet, currently assumes no nans</span>
<span class="sd">    and no gaps in time series.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    MacKinnon, J.G. 1994  &quot;Approximate Asymptotic Distribution Functions for</span>
<span class="sd">        Unit-Root and Cointegration Tests.&quot; Journal of Business &amp; Economics</span>
<span class="sd">        Statistics, 12.2, 167-76.</span>
<span class="sd">    MacKinnon, J.G. 2010.  &quot;Critical Values for Cointegration Tests.&quot;</span>
<span class="sd">        Queen&#39;s University, Dept of Economics Working Papers 1227.</span>
<span class="sd">        http://ideas.repec.org/p/qed/wpaper/1227.html</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">trend</span> <span class="o">=</span> <span class="n">trend</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">trend</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;nc&#39;</span><span class="p">,</span> <span class="s1">&#39;ct&#39;</span><span class="p">,</span> <span class="s1">&#39;ctt&#39;</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;trend option </span><span class="si">%s</span><span class="s2"> not understood&quot;</span> <span class="o">%</span> <span class="n">trend</span><span class="p">)</span>
    <span class="n">y0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">y0</span><span class="p">)</span>
    <span class="n">y1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">y1</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">y1</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">y1</span> <span class="o">=</span> <span class="n">y1</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span>
    <span class="n">nobs</span><span class="p">,</span> <span class="n">k_vars</span> <span class="o">=</span> <span class="n">y1</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">k_vars</span> <span class="o">+=</span> <span class="mi">1</span>   <span class="c1"># add 1 for y0</span>

    <span class="k">if</span> <span class="n">trend</span> <span class="o">==</span> <span class="s1">&#39;nc&#39;</span><span class="p">:</span>
        <span class="n">xx</span> <span class="o">=</span> <span class="n">y1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">xx</span> <span class="o">=</span> <span class="n">add_trend</span><span class="p">(</span><span class="n">y1</span><span class="p">,</span> <span class="n">trend</span><span class="o">=</span><span class="n">trend</span><span class="p">,</span> <span class="n">prepend</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="n">res_co</span> <span class="o">=</span> <span class="n">OLS</span><span class="p">(</span><span class="n">y0</span><span class="p">,</span> <span class="n">xx</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">res_co</span><span class="o">.</span><span class="n">rsquared</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="o">-</span> <span class="mi">100</span> <span class="o">*</span> <span class="n">SQRTEPS</span><span class="p">:</span>
        <span class="n">res_adf</span> <span class="o">=</span> <span class="n">adfuller</span><span class="p">(</span><span class="n">res_co</span><span class="o">.</span><span class="n">resid</span><span class="p">,</span> <span class="n">maxlag</span><span class="o">=</span><span class="n">maxlag</span><span class="p">,</span> <span class="n">autolag</span><span class="o">=</span><span class="n">autolag</span><span class="p">,</span>
                           <span class="n">regression</span><span class="o">=</span><span class="s1">&#39;nc&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="kn">import</span> <span class="nn">warnings</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;y0 and y1 are (almost) perfectly colinear.&quot;</span>
                      <span class="s2">&quot;Cointegration test is not reliable in this case.&quot;</span><span class="p">,</span>
                      <span class="n">CollinearityWarning</span><span class="p">)</span>
        <span class="c1"># Edge case where series are too similar</span>
        <span class="n">res_adf</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,)</span>

    <span class="c1"># no constant or trend, see egranger in Stata and MacKinnon</span>
    <span class="k">if</span> <span class="n">trend</span> <span class="o">==</span> <span class="s1">&#39;nc&#39;</span><span class="p">:</span>
        <span class="n">crit</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span>  <span class="c1"># 2010 critical values not available</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">crit</span> <span class="o">=</span> <span class="n">mackinnoncrit</span><span class="p">(</span><span class="n">N</span><span class="o">=</span><span class="n">k_vars</span><span class="p">,</span> <span class="n">regression</span><span class="o">=</span><span class="n">trend</span><span class="p">,</span> <span class="n">nobs</span><span class="o">=</span><span class="n">nobs</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="c1">#  nobs - 1, the -1 is to match egranger in Stata, I don&#39;t know why.</span>
        <span class="c1">#  TODO: check nobs or df = nobs - k</span>

    <span class="n">pval_asy</span> <span class="o">=</span> <span class="n">mackinnonp</span><span class="p">(</span><span class="n">res_adf</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">regression</span><span class="o">=</span><span class="n">trend</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="n">k_vars</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">res_adf</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pval_asy</span><span class="p">,</span> <span class="n">crit</span></div>


<span class="k">def</span> <span class="nf">_safe_arma_fit</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">model_kw</span><span class="p">,</span> <span class="n">trend</span><span class="p">,</span> <span class="n">fit_kw</span><span class="p">,</span> <span class="n">start_params</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ARMA</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">,</span> <span class="o">**</span><span class="n">model_kw</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">disp</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">trend</span><span class="o">=</span><span class="n">trend</span><span class="p">,</span>
                                                    <span class="n">start_params</span><span class="o">=</span><span class="n">start_params</span><span class="p">,</span>
                                                    <span class="o">**</span><span class="n">fit_kw</span><span class="p">)</span>
    <span class="k">except</span> <span class="n">LinAlgError</span><span class="p">:</span>
        <span class="c1"># SVD convergence failure on badly misspecified models</span>
        <span class="k">return</span>

    <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">error</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">start_params</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># don&#39;t recurse again</span>
            <span class="c1"># user supplied start_params only get one chance</span>
            <span class="k">return</span>
        <span class="c1"># try a little harder, should be handled in fit really</span>
        <span class="k">elif</span> <span class="p">(</span><span class="s1">&#39;initial&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">error</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">or</span> <span class="s1">&#39;initial&#39;</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">error</span><span class="p">)):</span>
            <span class="n">start_params</span> <span class="o">=</span> <span class="p">[</span><span class="o">.</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="nb">sum</span><span class="p">(</span><span class="n">order</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">trend</span> <span class="o">==</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span>
                <span class="n">start_params</span> <span class="o">=</span> <span class="p">[</span><span class="o">.</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">start_params</span>
            <span class="k">return</span> <span class="n">_safe_arma_fit</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">model_kw</span><span class="p">,</span> <span class="n">trend</span><span class="p">,</span> <span class="n">fit_kw</span><span class="p">,</span>
                                  <span class="n">start_params</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span>
    <span class="k">except</span><span class="p">:</span>  <span class="c1"># no idea what happened</span>
        <span class="k">return</span>


<div class="viewcode-block" id="arma_order_select_ic"><a class="viewcode-back" href="../../../generated/statsmodels.tsa.stattools.arma_order_select_ic.html#statsmodels.tsa.stattools.arma_order_select_ic">[docs]</a><span class="k">def</span> <span class="nf">arma_order_select_ic</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">max_ar</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">max_ma</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">ic</span><span class="o">=</span><span class="s1">&#39;bic&#39;</span><span class="p">,</span> <span class="n">trend</span><span class="o">=</span><span class="s1">&#39;c&#39;</span><span class="p">,</span>
                         <span class="n">model_kw</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fit_kw</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns information criteria for many ARMA models</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    y : array-like</span>
<span class="sd">        Time-series data</span>
<span class="sd">    max_ar : int</span>
<span class="sd">        Maximum number of AR lags to use. Default 4.</span>
<span class="sd">    max_ma : int</span>
<span class="sd">        Maximum number of MA lags to use. Default 2.</span>
<span class="sd">    ic : str, list</span>
<span class="sd">        Information criteria to report. Either a single string or a list</span>
<span class="sd">        of different criteria is possible.</span>
<span class="sd">    trend : str</span>
<span class="sd">        The trend to use when fitting the ARMA models.</span>
<span class="sd">    model_kw : dict</span>
<span class="sd">        Keyword arguments to be passed to the ``ARMA`` model</span>
<span class="sd">    fit_kw : dict</span>
<span class="sd">        Keyword arguments to be passed to ``ARMA.fit``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    obj : Results object</span>
<span class="sd">        Each ic is an attribute with a DataFrame for the results. The AR order</span>
<span class="sd">        used is the row index. The ma order used is the column index. The</span>
<span class="sd">        minimum orders are available as ``ic_min_order``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    &gt;&gt;&gt; from statsmodels.tsa.arima_process import arma_generate_sample</span>
<span class="sd">    &gt;&gt;&gt; import statsmodels.api as sm</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>

<span class="sd">    &gt;&gt;&gt; arparams = np.array([.75, -.25])</span>
<span class="sd">    &gt;&gt;&gt; maparams = np.array([.65, .35])</span>
<span class="sd">    &gt;&gt;&gt; arparams = np.r_[1, -arparams]</span>
<span class="sd">    &gt;&gt;&gt; maparam = np.r_[1, maparams]</span>
<span class="sd">    &gt;&gt;&gt; nobs = 250</span>
<span class="sd">    &gt;&gt;&gt; np.random.seed(2014)</span>
<span class="sd">    &gt;&gt;&gt; y = arma_generate_sample(arparams, maparams, nobs)</span>
<span class="sd">    &gt;&gt;&gt; res = sm.tsa.arma_order_select_ic(y, ic=[&#39;aic&#39;, &#39;bic&#39;], trend=&#39;nc&#39;)</span>
<span class="sd">    &gt;&gt;&gt; res.aic_min_order</span>
<span class="sd">    &gt;&gt;&gt; res.bic_min_order</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This method can be used to tentatively identify the order of an ARMA</span>
<span class="sd">    process, provided that the time series is stationary and invertible. This</span>
<span class="sd">    function computes the full exact MLE estimate of each model and can be,</span>
<span class="sd">    therefore a little slow. An implementation using approximate estimates</span>
<span class="sd">    will be provided in the future. In the meantime, consider passing</span>
<span class="sd">    {method : &#39;css&#39;} to fit_kw.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">pandas</span> <span class="k">import</span> <span class="n">DataFrame</span>

    <span class="n">ar_range</span> <span class="o">=</span> <span class="n">lrange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">max_ar</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">ma_range</span> <span class="o">=</span> <span class="n">lrange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">max_ma</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ic</span><span class="p">,</span> <span class="n">string_types</span><span class="p">):</span>
        <span class="n">ic</span> <span class="o">=</span> <span class="p">[</span><span class="n">ic</span><span class="p">]</span>
    <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ic</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Need a list or a tuple for ic if not a string.&quot;</span><span class="p">)</span>

    <span class="n">results</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">ic</span><span class="p">),</span> <span class="n">max_ar</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">max_ma</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">model_kw</span> <span class="o">=</span> <span class="p">{}</span> <span class="k">if</span> <span class="n">model_kw</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">model_kw</span>
    <span class="n">fit_kw</span> <span class="o">=</span> <span class="p">{}</span> <span class="k">if</span> <span class="n">fit_kw</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">fit_kw</span>
    <span class="n">y_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">ar</span> <span class="ow">in</span> <span class="n">ar_range</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">ma</span> <span class="ow">in</span> <span class="n">ma_range</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ar</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">ma</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">trend</span> <span class="o">==</span> <span class="s1">&#39;nc&#39;</span><span class="p">:</span>
                <span class="n">results</span><span class="p">[:,</span> <span class="n">ar</span><span class="p">,</span> <span class="n">ma</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="k">continue</span>

            <span class="n">mod</span> <span class="o">=</span> <span class="n">_safe_arma_fit</span><span class="p">(</span><span class="n">y_arr</span><span class="p">,</span> <span class="p">(</span><span class="n">ar</span><span class="p">,</span> <span class="n">ma</span><span class="p">),</span> <span class="n">model_kw</span><span class="p">,</span> <span class="n">trend</span><span class="p">,</span> <span class="n">fit_kw</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">mod</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">results</span><span class="p">[:,</span> <span class="n">ar</span><span class="p">,</span> <span class="n">ma</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="k">continue</span>

            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">criteria</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ic</span><span class="p">):</span>
                <span class="n">results</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">ar</span><span class="p">,</span> <span class="n">ma</span><span class="p">]</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">criteria</span><span class="p">)</span>

    <span class="n">dfs</span> <span class="o">=</span> <span class="p">[</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">ma_range</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">ar_range</span><span class="p">)</span> <span class="k">for</span> <span class="n">res</span> <span class="ow">in</span> <span class="n">results</span><span class="p">]</span>

    <span class="n">res</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">ic</span><span class="p">,</span> <span class="n">dfs</span><span class="p">))</span>

    <span class="c1"># add the minimums to the results dict</span>
    <span class="n">min_res</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">result</span> <span class="ow">in</span> <span class="n">iteritems</span><span class="p">(</span><span class="n">res</span><span class="p">):</span>
        <span class="n">mins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">min</span><span class="p">()</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">==</span> <span class="n">result</span><span class="p">)</span>
        <span class="n">min_res</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">i</span> <span class="o">+</span> <span class="s1">&#39;_min_order&#39;</span><span class="p">:</span> <span class="p">(</span><span class="n">mins</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">mins</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">])})</span>
    <span class="n">res</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">min_res</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">Bunch</span><span class="p">(</span><span class="o">**</span><span class="n">res</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">has_missing</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns True if &#39;data&#39; contains missing entries, otherwise False</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>


<div class="viewcode-block" id="kpss"><a class="viewcode-back" href="../../../generated/statsmodels.tsa.stattools.kpss.html#statsmodels.tsa.stattools.kpss">[docs]</a><span class="k">def</span> <span class="nf">kpss</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">regression</span><span class="o">=</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="n">lags</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">store</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Kwiatkowski-Phillips-Schmidt-Shin test for stationarity.</span>

<span class="sd">    Computes the Kwiatkowski-Phillips-Schmidt-Shin (KPSS) test for the null</span>
<span class="sd">    hypothesis that x is level or trend stationary.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : array_like, 1d</span>
<span class="sd">        Data series</span>
<span class="sd">    regression : str{&#39;c&#39;, &#39;ct&#39;}</span>
<span class="sd">        Indicates the null hypothesis for the KPSS test</span>
<span class="sd">        * &#39;c&#39; : The data is stationary around a constant (default)</span>
<span class="sd">        * &#39;ct&#39; : The data is stationary around a trend</span>
<span class="sd">    lags : {None, str, int}, optional</span>
<span class="sd">        Indicates the number of lags to be used. If None (default), lags is</span>
<span class="sd">        calculated using the legacy method. If &#39;auto&#39;, lags is calculated</span>
<span class="sd">        using the data-dependent method of Hobijn et al. (1998). See also</span>
<span class="sd">        Andrews (1991), Newey &amp; West (1994), and Schwert (1989). If set to</span>
<span class="sd">        &#39;legacy&#39;,  uses int(12 * (n / 100)**(1 / 4)) , as outlined in</span>
<span class="sd">        Schwert (1989).</span>
<span class="sd">    store : bool</span>
<span class="sd">        If True, then a result instance is returned additionally to</span>
<span class="sd">        the KPSS statistic (default is False).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    kpss_stat : float</span>
<span class="sd">        The KPSS test statistic</span>
<span class="sd">    p_value : float</span>
<span class="sd">        The p-value of the test. The p-value is interpolated from</span>
<span class="sd">        Table 1 in Kwiatkowski et al. (1992), and a boundary point</span>
<span class="sd">        is returned if the test statistic is outside the table of</span>
<span class="sd">        critical values, that is, if the p-value is outside the</span>
<span class="sd">        interval (0.01, 0.1).</span>
<span class="sd">    lags : int</span>
<span class="sd">        The truncation lag parameter</span>
<span class="sd">    crit : dict</span>
<span class="sd">        The critical values at 10%, 5%, 2.5% and 1%. Based on</span>
<span class="sd">        Kwiatkowski et al. (1992).</span>
<span class="sd">    resstore : (optional) instance of ResultStore</span>
<span class="sd">        An instance of a dummy class with results attached as attributes</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    To estimate sigma^2 the Newey-West estimator is used. If lags is None,</span>
<span class="sd">    the truncation lag parameter is set to int(12 * (n / 100) ** (1 / 4)),</span>
<span class="sd">    as outlined in Schwert (1989). The p-values are interpolated from</span>
<span class="sd">    Table 1 of Kwiatkowski et al. (1992). If the computed statistic is</span>
<span class="sd">    outside the table of critical values, then a warning message is</span>
<span class="sd">    generated.</span>

<span class="sd">    Missing values are not handled.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    Andrews, D.W.K. (1991). Heteroskedasticity and autocorrelation consistent</span>
<span class="sd">    covariance matrix estimation. Econometrica, 59: 817-858.</span>

<span class="sd">    Hobijn, B., Frances, B.H., &amp; Ooms, M. (2004). Generalizations of the</span>
<span class="sd">    KPSS-test for stationarity. Statistica Neerlandica, 52: 483-502.</span>

<span class="sd">    Kwiatkowski, D., Phillips, P.C.B., Schmidt, P., &amp; Shin, Y. (1992). Testing</span>
<span class="sd">    the null hypothesis of stationarity against the alternative of a unit root.</span>
<span class="sd">    Journal of Econometrics, 54: 159-178.</span>

<span class="sd">    Newey, W.K., &amp; West, K.D. (1994). Automatic lag selection in covariance</span>
<span class="sd">    matrix estimation. Review of Economic Studies, 61: 631-653.</span>

<span class="sd">    Schwert, G. W. (1989). Tests for unit roots: A Monte Carlo investigation.</span>
<span class="sd">    Journal of Business and Economic Statistics, 7 (2): 147-159.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">warnings</span> <span class="k">import</span> <span class="n">warn</span>

    <span class="n">nobs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">hypo</span> <span class="o">=</span> <span class="n">regression</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>

    <span class="c1"># if m is not one, n != m * n</span>
    <span class="k">if</span> <span class="n">nobs</span> <span class="o">!=</span> <span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;x of shape </span><span class="si">{0}</span><span class="s2"> not understood&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">hypo</span> <span class="o">==</span> <span class="s1">&#39;ct&#39;</span><span class="p">:</span>
        <span class="c1"># p. 162 Kwiatkowski et al. (1992): y_t = beta * t + r_t + e_t,</span>
        <span class="c1"># where beta is the trend, r_t a random walk and e_t a stationary</span>
        <span class="c1"># error term.</span>
        <span class="n">resids</span> <span class="o">=</span> <span class="n">OLS</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">add_constant</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nobs</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span><span class="o">.</span><span class="n">fit</span><span class="p">()</span><span class="o">.</span><span class="n">resid</span>
        <span class="n">crit</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.119</span><span class="p">,</span> <span class="mf">0.146</span><span class="p">,</span> <span class="mf">0.176</span><span class="p">,</span> <span class="mf">0.216</span><span class="p">]</span>
    <span class="k">elif</span> <span class="n">hypo</span> <span class="o">==</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span>
        <span class="c1"># special case of the model above, where beta = 0 (so the null</span>
        <span class="c1"># hypothesis is that the data is stationary around r_0).</span>
        <span class="n">resids</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">x</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        <span class="n">crit</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.347</span><span class="p">,</span> <span class="mf">0.463</span><span class="p">,</span> <span class="mf">0.574</span><span class="p">,</span> <span class="mf">0.739</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;hypothesis &#39;</span><span class="si">{0}</span><span class="s2">&#39; not understood&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">hypo</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">lags</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">lags</span> <span class="o">=</span> <span class="s1">&#39;legacy&#39;</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;The behavior of using lags=None will change in the next &#39;</span> \
              <span class="s1">&#39;release. Currently lags=None is the same as &#39;</span> \
              <span class="s1">&#39;lags=</span><span class="se">\&#39;</span><span class="s1">legacy</span><span class="se">\&#39;</span><span class="s1">, and so a sample-size lag length is used. &#39;</span> \
              <span class="s1">&#39;After the next release, the default will change to be the &#39;</span> \
              <span class="s1">&#39;same as lags=</span><span class="se">\&#39;</span><span class="s1">auto</span><span class="se">\&#39;</span><span class="s1"> which uses an automatic lag length &#39;</span> \
              <span class="s1">&#39;selection method. To silence this warning, either use &#39;</span> \
              <span class="s1">&#39;</span><span class="se">\&#39;</span><span class="s1">auto</span><span class="se">\&#39;</span><span class="s1"> or </span><span class="se">\&#39;</span><span class="s1">legacy</span><span class="se">\&#39;</span><span class="s1">&#39;</span>
        <span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="ne">DeprecationWarning</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">lags</span> <span class="o">==</span> <span class="s1">&#39;legacy&#39;</span><span class="p">:</span>
        <span class="n">lags</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="mf">12.</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">nobs</span> <span class="o">/</span> <span class="mf">100.</span><span class="p">,</span> <span class="mi">1</span> <span class="o">/</span> <span class="mf">4.</span><span class="p">)))</span>
    <span class="k">elif</span> <span class="n">lags</span> <span class="o">==</span> <span class="s1">&#39;auto&#39;</span><span class="p">:</span>
        <span class="c1"># autolag method of Hobijn et al. (1998)</span>
        <span class="n">lags</span> <span class="o">=</span> <span class="n">_kpss_autolag</span><span class="p">(</span><span class="n">resids</span><span class="p">,</span> <span class="n">nobs</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">lags</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">lags</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">lags</span> <span class="o">&gt;</span> <span class="n">nobs</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;lags (</span><span class="si">{}</span><span class="s2">) must be &lt;= number of observations (</span><span class="si">{}</span><span class="s2">)&quot;</span>
                         <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">lags</span><span class="p">,</span> <span class="n">nobs</span><span class="p">))</span>

    <span class="n">pvals</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.10</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.025</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">]</span>

    <span class="n">eta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">resids</span><span class="o">.</span><span class="n">cumsum</span><span class="p">()</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">nobs</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>  <span class="c1"># eq. 11, p. 165</span>
    <span class="n">s_hat</span> <span class="o">=</span> <span class="n">_sigma_est_kpss</span><span class="p">(</span><span class="n">resids</span><span class="p">,</span> <span class="n">nobs</span><span class="p">,</span> <span class="n">lags</span><span class="p">)</span>

    <span class="n">kpss_stat</span> <span class="o">=</span> <span class="n">eta</span> <span class="o">/</span> <span class="n">s_hat</span>
    <span class="n">p_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">kpss_stat</span><span class="p">,</span> <span class="n">crit</span><span class="p">,</span> <span class="n">pvals</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">p_value</span> <span class="o">==</span> <span class="n">pvals</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="n">warn</span><span class="p">(</span><span class="s2">&quot;p-value is smaller than the indicated p-value&quot;</span><span class="p">,</span> <span class="n">InterpolationWarning</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">p_value</span> <span class="o">==</span> <span class="n">pvals</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="n">warn</span><span class="p">(</span><span class="s2">&quot;p-value is greater than the indicated p-value&quot;</span><span class="p">,</span> <span class="n">InterpolationWarning</span><span class="p">)</span>

    <span class="n">crit_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;10%&#39;</span><span class="p">:</span> <span class="n">crit</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;5%&#39;</span><span class="p">:</span> <span class="n">crit</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;2.5%&#39;</span><span class="p">:</span> <span class="n">crit</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;1%&#39;</span><span class="p">:</span> <span class="n">crit</span><span class="p">[</span><span class="mi">3</span><span class="p">]}</span>

    <span class="k">if</span> <span class="n">store</span><span class="p">:</span>
        <span class="n">rstore</span> <span class="o">=</span> <span class="n">ResultsStore</span><span class="p">()</span>
        <span class="n">rstore</span><span class="o">.</span><span class="n">lags</span> <span class="o">=</span> <span class="n">lags</span>
        <span class="n">rstore</span><span class="o">.</span><span class="n">nobs</span> <span class="o">=</span> <span class="n">nobs</span>

        <span class="n">stationary_type</span> <span class="o">=</span> <span class="s2">&quot;level&quot;</span> <span class="k">if</span> <span class="n">hypo</span> <span class="o">==</span> <span class="s1">&#39;c&#39;</span> <span class="k">else</span> <span class="s2">&quot;trend&quot;</span>
        <span class="n">rstore</span><span class="o">.</span><span class="n">H0</span> <span class="o">=</span> <span class="s2">&quot;The series is </span><span class="si">{0}</span><span class="s2"> stationary&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">stationary_type</span><span class="p">)</span>
        <span class="n">rstore</span><span class="o">.</span><span class="n">HA</span> <span class="o">=</span> <span class="s2">&quot;The series is not </span><span class="si">{0}</span><span class="s2"> stationary&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">stationary_type</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">kpss_stat</span><span class="p">,</span> <span class="n">p_value</span><span class="p">,</span> <span class="n">crit_dict</span><span class="p">,</span> <span class="n">rstore</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">kpss_stat</span><span class="p">,</span> <span class="n">p_value</span><span class="p">,</span> <span class="n">lags</span><span class="p">,</span> <span class="n">crit_dict</span></div>


<span class="k">def</span> <span class="nf">_sigma_est_kpss</span><span class="p">(</span><span class="n">resids</span><span class="p">,</span> <span class="n">nobs</span><span class="p">,</span> <span class="n">lags</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes equation 10, p. 164 of Kwiatkowski et al. (1992). This is the</span>
<span class="sd">    consistent estimator for the variance.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">s_hat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">resids</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">lags</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">resids_prod</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">resids</span><span class="p">[</span><span class="n">i</span><span class="p">:],</span> <span class="n">resids</span><span class="p">[:</span><span class="n">nobs</span> <span class="o">-</span> <span class="n">i</span><span class="p">])</span>
        <span class="n">s_hat</span> <span class="o">+=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">resids_prod</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.</span> <span class="o">-</span> <span class="p">(</span><span class="n">i</span> <span class="o">/</span> <span class="p">(</span><span class="n">lags</span> <span class="o">+</span> <span class="mf">1.</span><span class="p">)))</span>
    <span class="k">return</span> <span class="n">s_hat</span> <span class="o">/</span> <span class="n">nobs</span>


<span class="k">def</span> <span class="nf">_kpss_autolag</span><span class="p">(</span><span class="n">resids</span><span class="p">,</span> <span class="n">nobs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the number of lags for covariance matrix estimation in KPSS test</span>
<span class="sd">    using method of Hobijn et al (1998). See also Andrews (1991), Newey &amp; West</span>
<span class="sd">    (1994), and Schwert (1989). Assumes Bartlett / Newey-West kernel.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">covlags</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">nobs</span><span class="p">,</span> <span class="mf">2.</span> <span class="o">/</span> <span class="mf">9.</span><span class="p">))</span>
    <span class="n">s0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">resids</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">nobs</span>
    <span class="n">s1</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">covlags</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">resids_prod</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">resids</span><span class="p">[</span><span class="n">i</span><span class="p">:],</span> <span class="n">resids</span><span class="p">[:</span><span class="n">nobs</span> <span class="o">-</span> <span class="n">i</span><span class="p">])</span>
        <span class="n">resids_prod</span> <span class="o">/=</span> <span class="p">(</span><span class="n">nobs</span> <span class="o">/</span> <span class="mf">2.</span><span class="p">)</span>
        <span class="n">s0</span> <span class="o">+=</span> <span class="n">resids_prod</span>
        <span class="n">s1</span> <span class="o">+=</span> <span class="n">i</span> <span class="o">*</span> <span class="n">resids_prod</span>
    <span class="n">s_hat</span> <span class="o">=</span> <span class="n">s1</span> <span class="o">/</span> <span class="n">s0</span>
    <span class="n">pwr</span> <span class="o">=</span> <span class="mf">1.</span> <span class="o">/</span> <span class="mf">3.</span>
    <span class="n">gamma_hat</span> <span class="o">=</span> <span class="mf">1.1447</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">s_hat</span> <span class="o">*</span> <span class="n">s_hat</span><span class="p">,</span> <span class="n">pwr</span><span class="p">)</span>
    <span class="n">autolags</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">([</span><span class="n">nobs</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">gamma_hat</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">nobs</span><span class="p">,</span> <span class="n">pwr</span><span class="p">))])</span>
    <span class="k">return</span> <span class="n">autolags</span>
</pre></div>




          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2009-2018, Josef Perktold, Skipper Seabold, Jonathan Taylor, statsmodels-developers.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.1.2.
    </div>
  </body>
</html>