

<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>statsmodels.tsa.statespace.tools &#8212; statsmodels v0.10.0 documentation</title>
    <link rel="stylesheet" href="../../../../_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/graphviz.css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../../../" src="../../../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../../_static/language_data.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="shortcut icon" href="../../../../_static/statsmodels_hybi_favico.ico"/>
    <link rel="author" title="About these documents" href="../../../../about.html" />
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
<link rel="stylesheet" href="../../../../_static/examples.css" type="text/css" />
<link rel="stylesheet" href="../../../../_static/facebox.css" type="text/css" />
<script type="text/javascript" src="../../../../_static/scripts.js">
</script>
<script type="text/javascript" src="../../../../_static/facebox.js">
</script>
<script type="text/javascript">
$.facebox.settings.closeImage = "../../../../_static/closelabel.png"
$.facebox.settings.loadingImage = "../../../../_static/loading.gif"
</script>

<script>
$(document).ready(function() {
  $.getJSON("../../../../../versions.json", function(versions) {
    var dropdown = document.createElement("div");
    dropdown.className = "dropdown";
    var button = document.createElement("button");
    button.className = "dropbtn";
    button.innerHTML = "Other Versions";
    var content = document.createElement("div");
    content.className = "dropdown-content";
    dropdown.appendChild(button);
    dropdown.appendChild(content);
    $(".header").prepend(dropdown);
    for (var i = 0; i < versions.length; i++) {
      if (versions[i].substring(0, 1) == "v") {
        versions[i] = [versions[i], versions[i].substring(1)];
      } else {
        versions[i] = [versions[i], versions[i]];
      };
    };
    for (var i = 0; i < versions.length; i++) {
      var a = document.createElement("a");
      a.innerHTML = versions[i][1];
      a.href = "../../../../../" + versions[i][0] + "/index.html";
      a.title = versions[i][1];
      $(".dropdown-content").append(a);
    };
  });
});
</script>


  </head><body>
<div class="headerwrap">
    <div class = "header">
        
        <a href = "../../../../index.html">
<img src="../../../../_static/statsmodels_hybi_banner.png" alt="Logo"
    style="padding-left: 15px"/></a>
        
    </div>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
<li><a href ="../../../../install.html">Install</a></li> &nbsp;|&nbsp;
<li><a href="https://groups.google.com/forum/?hl=en#!forum/pystatsmodels">Support</a></li> &nbsp;|&nbsp;
<li><a href="https://github.com/statsmodels/statsmodels/issues">Bugs</a></li> &nbsp;|&nbsp;
<li><a href="../../../../dev/index.html">Develop</a></li> &nbsp;|&nbsp;
<li><a href="../../../../examples/index.html">Examples</a></li> &nbsp;|&nbsp;
<li><a href="../../../../faq.html">FAQ</a></li> &nbsp;|&nbsp;

          <li class="nav-item nav-item-1"><a href="../../../index.html" accesskey="U">Module code</a> |</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            




  <h1>Source code for statsmodels.tsa.statespace.tools</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Statespace Tools</span>

<span class="sd">Author: Chad Fulton</span>
<span class="sd">License: Simplified-BSD</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">division</span><span class="p">,</span> <span class="n">absolute_import</span><span class="p">,</span> <span class="n">print_function</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="k">import</span> <span class="n">solve_sylvester</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>

<span class="kn">from</span> <span class="nn">statsmodels.tools.data</span> <span class="k">import</span> <span class="n">_is_using_pandas</span>
<span class="kn">from</span> <span class="nn">scipy.linalg.blas</span> <span class="k">import</span> <span class="n">find_best_blas_type</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="p">(</span><span class="n">_initialization</span><span class="p">,</span> <span class="n">_representation</span><span class="p">,</span> <span class="n">_kalman_filter</span><span class="p">,</span>
               <span class="n">_kalman_smoother</span><span class="p">,</span> <span class="n">_simulation_smoother</span><span class="p">,</span> <span class="n">_tools</span><span class="p">)</span>


<span class="n">compatibility_mode</span> <span class="o">=</span> <span class="kc">False</span>
<span class="n">has_trmm</span> <span class="o">=</span> <span class="kc">True</span>
<span class="n">prefix_dtype_map</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;s&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">complex64</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">complex128</span>
<span class="p">}</span>
<span class="n">prefix_initialization_map</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;s&#39;</span><span class="p">:</span> <span class="n">_initialization</span><span class="o">.</span><span class="n">sInitialization</span><span class="p">,</span>
    <span class="s1">&#39;d&#39;</span><span class="p">:</span> <span class="n">_initialization</span><span class="o">.</span><span class="n">dInitialization</span><span class="p">,</span>
    <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="n">_initialization</span><span class="o">.</span><span class="n">cInitialization</span><span class="p">,</span>
    <span class="s1">&#39;z&#39;</span><span class="p">:</span> <span class="n">_initialization</span><span class="o">.</span><span class="n">zInitialization</span>
<span class="p">}</span>
<span class="n">prefix_statespace_map</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;s&#39;</span><span class="p">:</span> <span class="n">_representation</span><span class="o">.</span><span class="n">sStatespace</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">:</span> <span class="n">_representation</span><span class="o">.</span><span class="n">dStatespace</span><span class="p">,</span>
    <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="n">_representation</span><span class="o">.</span><span class="n">cStatespace</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">:</span> <span class="n">_representation</span><span class="o">.</span><span class="n">zStatespace</span>
<span class="p">}</span>
<span class="n">prefix_kalman_filter_map</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;s&#39;</span><span class="p">:</span> <span class="n">_kalman_filter</span><span class="o">.</span><span class="n">sKalmanFilter</span><span class="p">,</span>
    <span class="s1">&#39;d&#39;</span><span class="p">:</span> <span class="n">_kalman_filter</span><span class="o">.</span><span class="n">dKalmanFilter</span><span class="p">,</span>
    <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="n">_kalman_filter</span><span class="o">.</span><span class="n">cKalmanFilter</span><span class="p">,</span>
    <span class="s1">&#39;z&#39;</span><span class="p">:</span> <span class="n">_kalman_filter</span><span class="o">.</span><span class="n">zKalmanFilter</span>
<span class="p">}</span>
<span class="n">prefix_kalman_smoother_map</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;s&#39;</span><span class="p">:</span> <span class="n">_kalman_smoother</span><span class="o">.</span><span class="n">sKalmanSmoother</span><span class="p">,</span>
    <span class="s1">&#39;d&#39;</span><span class="p">:</span> <span class="n">_kalman_smoother</span><span class="o">.</span><span class="n">dKalmanSmoother</span><span class="p">,</span>
    <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="n">_kalman_smoother</span><span class="o">.</span><span class="n">cKalmanSmoother</span><span class="p">,</span>
    <span class="s1">&#39;z&#39;</span><span class="p">:</span> <span class="n">_kalman_smoother</span><span class="o">.</span><span class="n">zKalmanSmoother</span>
<span class="p">}</span>
<span class="n">prefix_simulation_smoother_map</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;s&#39;</span><span class="p">:</span> <span class="n">_simulation_smoother</span><span class="o">.</span><span class="n">sSimulationSmoother</span><span class="p">,</span>
    <span class="s1">&#39;d&#39;</span><span class="p">:</span> <span class="n">_simulation_smoother</span><span class="o">.</span><span class="n">dSimulationSmoother</span><span class="p">,</span>
    <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="n">_simulation_smoother</span><span class="o">.</span><span class="n">cSimulationSmoother</span><span class="p">,</span>
    <span class="s1">&#39;z&#39;</span><span class="p">:</span> <span class="n">_simulation_smoother</span><span class="o">.</span><span class="n">zSimulationSmoother</span>
<span class="p">}</span>
<span class="n">prefix_pacf_map</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;s&#39;</span><span class="p">:</span> <span class="n">_tools</span><span class="o">.</span><span class="n">_scompute_coefficients_from_multivariate_pacf</span><span class="p">,</span>
    <span class="s1">&#39;d&#39;</span><span class="p">:</span> <span class="n">_tools</span><span class="o">.</span><span class="n">_dcompute_coefficients_from_multivariate_pacf</span><span class="p">,</span>
    <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="n">_tools</span><span class="o">.</span><span class="n">_ccompute_coefficients_from_multivariate_pacf</span><span class="p">,</span>
    <span class="s1">&#39;z&#39;</span><span class="p">:</span> <span class="n">_tools</span><span class="o">.</span><span class="n">_zcompute_coefficients_from_multivariate_pacf</span>
<span class="p">}</span>
<span class="n">prefix_sv_map</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;s&#39;</span><span class="p">:</span> <span class="n">_tools</span><span class="o">.</span><span class="n">_sconstrain_sv_less_than_one</span><span class="p">,</span>
    <span class="s1">&#39;d&#39;</span><span class="p">:</span> <span class="n">_tools</span><span class="o">.</span><span class="n">_dconstrain_sv_less_than_one</span><span class="p">,</span>
    <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="n">_tools</span><span class="o">.</span><span class="n">_cconstrain_sv_less_than_one</span><span class="p">,</span>
    <span class="s1">&#39;z&#39;</span><span class="p">:</span> <span class="n">_tools</span><span class="o">.</span><span class="n">_zconstrain_sv_less_than_one</span>
<span class="p">}</span>
<span class="n">prefix_reorder_missing_matrix_map</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;s&#39;</span><span class="p">:</span> <span class="n">_tools</span><span class="o">.</span><span class="n">sreorder_missing_matrix</span><span class="p">,</span>
    <span class="s1">&#39;d&#39;</span><span class="p">:</span> <span class="n">_tools</span><span class="o">.</span><span class="n">dreorder_missing_matrix</span><span class="p">,</span>
    <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="n">_tools</span><span class="o">.</span><span class="n">creorder_missing_matrix</span><span class="p">,</span>
    <span class="s1">&#39;z&#39;</span><span class="p">:</span> <span class="n">_tools</span><span class="o">.</span><span class="n">zreorder_missing_matrix</span>
<span class="p">}</span>
<span class="n">prefix_reorder_missing_vector_map</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;s&#39;</span><span class="p">:</span> <span class="n">_tools</span><span class="o">.</span><span class="n">sreorder_missing_vector</span><span class="p">,</span>
    <span class="s1">&#39;d&#39;</span><span class="p">:</span> <span class="n">_tools</span><span class="o">.</span><span class="n">dreorder_missing_vector</span><span class="p">,</span>
    <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="n">_tools</span><span class="o">.</span><span class="n">creorder_missing_vector</span><span class="p">,</span>
    <span class="s1">&#39;z&#39;</span><span class="p">:</span> <span class="n">_tools</span><span class="o">.</span><span class="n">zreorder_missing_vector</span>
<span class="p">}</span>
<span class="n">prefix_copy_missing_matrix_map</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;s&#39;</span><span class="p">:</span> <span class="n">_tools</span><span class="o">.</span><span class="n">scopy_missing_matrix</span><span class="p">,</span>
    <span class="s1">&#39;d&#39;</span><span class="p">:</span> <span class="n">_tools</span><span class="o">.</span><span class="n">dcopy_missing_matrix</span><span class="p">,</span>
    <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="n">_tools</span><span class="o">.</span><span class="n">ccopy_missing_matrix</span><span class="p">,</span>
    <span class="s1">&#39;z&#39;</span><span class="p">:</span> <span class="n">_tools</span><span class="o">.</span><span class="n">zcopy_missing_matrix</span>
<span class="p">}</span>
<span class="n">prefix_copy_missing_vector_map</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;s&#39;</span><span class="p">:</span> <span class="n">_tools</span><span class="o">.</span><span class="n">scopy_missing_vector</span><span class="p">,</span>
    <span class="s1">&#39;d&#39;</span><span class="p">:</span> <span class="n">_tools</span><span class="o">.</span><span class="n">dcopy_missing_vector</span><span class="p">,</span>
    <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="n">_tools</span><span class="o">.</span><span class="n">ccopy_missing_vector</span><span class="p">,</span>
    <span class="s1">&#39;z&#39;</span><span class="p">:</span> <span class="n">_tools</span><span class="o">.</span><span class="n">zcopy_missing_vector</span>
<span class="p">}</span>
<span class="n">prefix_copy_index_matrix_map</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;s&#39;</span><span class="p">:</span> <span class="n">_tools</span><span class="o">.</span><span class="n">scopy_index_matrix</span><span class="p">,</span>
    <span class="s1">&#39;d&#39;</span><span class="p">:</span> <span class="n">_tools</span><span class="o">.</span><span class="n">dcopy_index_matrix</span><span class="p">,</span>
    <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="n">_tools</span><span class="o">.</span><span class="n">ccopy_index_matrix</span><span class="p">,</span>
    <span class="s1">&#39;z&#39;</span><span class="p">:</span> <span class="n">_tools</span><span class="o">.</span><span class="n">zcopy_index_matrix</span>
<span class="p">}</span>
<span class="n">prefix_copy_index_vector_map</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;s&#39;</span><span class="p">:</span> <span class="n">_tools</span><span class="o">.</span><span class="n">scopy_index_vector</span><span class="p">,</span>
    <span class="s1">&#39;d&#39;</span><span class="p">:</span> <span class="n">_tools</span><span class="o">.</span><span class="n">dcopy_index_vector</span><span class="p">,</span>
    <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="n">_tools</span><span class="o">.</span><span class="n">ccopy_index_vector</span><span class="p">,</span>
    <span class="s1">&#39;z&#39;</span><span class="p">:</span> <span class="n">_tools</span><span class="o">.</span><span class="n">zcopy_index_vector</span>
<span class="p">}</span>


<span class="k">def</span> <span class="nf">set_mode</span><span class="p">(</span><span class="n">compatibility</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">compatibility</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Compatibility mode is only available in&#39;</span>
                                  <span class="s1">&#39; statsmodels &lt;= 0.9&#39;</span><span class="p">)</span>


<div class="viewcode-block" id="companion_matrix"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.tools.companion_matrix.html#statsmodels.tsa.statespace.tools.companion_matrix">[docs]</a><span class="k">def</span> <span class="nf">companion_matrix</span><span class="p">(</span><span class="n">polynomial</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a companion matrix</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    polynomial : array_like or list</span>
<span class="sd">        If an iterable, interpreted as the coefficients of the polynomial from</span>
<span class="sd">        which to form the companion matrix. Polynomial coefficients are in</span>
<span class="sd">        order of increasing degree, and may be either scalars (as in an AR(p)</span>
<span class="sd">        model) or coefficient matrices (as in a VAR(p) model). If an integer,</span>
<span class="sd">        it is interpereted as the size of a companion matrix of a scalar</span>
<span class="sd">        polynomial, where the polynomial coefficients are initialized to zeros.</span>
<span class="sd">        If a matrix polynomial is passed, :math:`C_0` may be set to the scalar</span>
<span class="sd">        value 1 to indicate an identity matrix (doing so will improve the speed</span>
<span class="sd">        of the companion matrix creation).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    companion_matrix : array</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Given coefficients of a lag polynomial of the form:</span>

<span class="sd">    .. math::</span>

<span class="sd">        c(L) = c_0 + c_1 L + \dots + c_p L^p</span>

<span class="sd">    returns a matrix of the form</span>

<span class="sd">    .. math::</span>
<span class="sd">        \begin{bmatrix}</span>
<span class="sd">            \phi_1 &amp; 1      &amp; 0 &amp; \cdots &amp; 0 \\</span>
<span class="sd">            \phi_2 &amp; 0      &amp; 1 &amp;        &amp; 0 \\</span>
<span class="sd">            \vdots &amp;        &amp;   &amp; \ddots &amp; 0 \\</span>
<span class="sd">                   &amp;        &amp;   &amp;        &amp; 1 \\</span>
<span class="sd">            \phi_n &amp; 0      &amp; 0 &amp; \cdots &amp; 0 \\</span>
<span class="sd">        \end{bmatrix}</span>

<span class="sd">    where some or all of the :math:`\phi_i` may be non-zero (if `polynomial` is</span>
<span class="sd">    None, then all are equal to zero).</span>

<span class="sd">    If the coefficients provided are scalars :math:`(c_0, c_1, \dots, c_p)`,</span>
<span class="sd">    then the companion matrix is an :math:`n \times n` matrix formed with the</span>
<span class="sd">    elements in the first column defined as</span>
<span class="sd">    :math:`\phi_i = -\frac{c_i}{c_0}, i \in 1, \dots, p`.</span>

<span class="sd">    If the coefficients provided are matrices :math:`(C_0, C_1, \dots, C_p)`,</span>
<span class="sd">    each of shape :math:`(m, m)`, then the companion matrix is an</span>
<span class="sd">    :math:`nm \times nm` matrix formed with the elements in the first column</span>
<span class="sd">    defined as :math:`\phi_i = -C_0^{-1} C_i&#39;, i \in 1, \dots, p`.</span>

<span class="sd">    It is important to understand the expected signs of the coefficients. A</span>
<span class="sd">    typical AR(p) model is written as:</span>

<span class="sd">    .. math::</span>
<span class="sd">        y_t = a_1 y_{t-1} + \dots + a_p y_{t-p} + \varepsilon_t</span>

<span class="sd">    This can be rewritten as:</span>

<span class="sd">    .. math::</span>
<span class="sd">        (1 - a_1 L - \dots - a_p L^p )y_t = \varepsilon_t \\</span>
<span class="sd">        (1 + c_1 L + \dots + c_p L^p )y_t = \varepsilon_t \\</span>
<span class="sd">        c(L) y_t = \varepsilon_t</span>

<span class="sd">    The coefficients from this form are defined to be :math:`c_i = - a_i`, and</span>
<span class="sd">    it is the :math:`c_i` coefficients that this function expects to be</span>
<span class="sd">    provided.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">identity_matrix</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">polynomial</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)):</span>
        <span class="c1"># GH 5570, allow numpy integer types, but coerce to python int</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">polynomial</span><span class="p">)</span>
        <span class="n">m</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">polynomial</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">polynomial</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Companion matrix polynomials must include at&quot;</span>
                             <span class="s2">&quot; least two terms.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">polynomial</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">polynomial</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># Note: can&#39;t use polynomial[0] because of the special behavior</span>
                <span class="c1"># associated with matrix polynomials and the constant 1, see</span>
                <span class="c1"># below.</span>
                <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">polynomial</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="n">m</span> <span class="o">=</span> <span class="mi">1</span>

            <span class="c1"># Check if we just have a scalar polynomial</span>
            <span class="k">if</span> <span class="n">m</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">polynomial</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">polynomial</span><span class="p">)</span>
            <span class="c1"># Check if 1 was passed as the first argument (indicating an</span>
            <span class="c1"># identity matrix)</span>
            <span class="k">elif</span> <span class="n">polynomial</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">polynomial</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
                <span class="n">identity_matrix</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">m</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">polynomial</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">polynomial</span><span class="p">)</span>

    <span class="n">matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span> <span class="o">*</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">*</span> <span class="n">m</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">polynomial</span><span class="p">)</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag_indices</span><span class="p">((</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">m</span><span class="p">)</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">idx</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">m</span><span class="p">)</span>
    <span class="n">matrix</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">polynomial</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">m</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">matrix</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">polynomial</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">/</span> <span class="n">polynomial</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">identity_matrix</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="n">matrix</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="n">m</span><span class="p">:(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">m</span><span class="p">,</span> <span class="p">:</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">polynomial</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">inv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">polynomial</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="n">matrix</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="n">m</span><span class="p">:(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">m</span><span class="p">,</span> <span class="p">:</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">inv</span><span class="p">,</span> <span class="n">polynomial</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
    <span class="k">return</span> <span class="n">matrix</span></div>


<div class="viewcode-block" id="diff"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.tools.diff.html#statsmodels.tsa.statespace.tools.diff">[docs]</a><span class="k">def</span> <span class="nf">diff</span><span class="p">(</span><span class="n">series</span><span class="p">,</span> <span class="n">k_diff</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">k_seasonal_diff</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">seasonal_periods</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Difference a series simply and/or seasonally along the zero-th axis.</span>

<span class="sd">    Given a series (denoted :math:`y_t`), performs the differencing operation</span>

<span class="sd">    .. math::</span>

<span class="sd">        \Delta^d \Delta_s^D y_t</span>

<span class="sd">    where :math:`d =` `diff`, :math:`s =` `seasonal_periods`,</span>
<span class="sd">    :math:`D =` `seasonal\_diff`, and :math:`\Delta` is the difference</span>
<span class="sd">    operator.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    series : array_like</span>
<span class="sd">        The series to be differenced.</span>
<span class="sd">    diff : int, optional</span>
<span class="sd">        The number of simple differences to perform. Default is 1.</span>
<span class="sd">    seasonal_diff : int or None, optional</span>
<span class="sd">        The number of seasonal differences to perform. Default is no seasonal</span>
<span class="sd">        differencing.</span>
<span class="sd">    seasonal_periods : int, optional</span>
<span class="sd">        The seasonal lag. Default is 1. Unused if there is no seasonal</span>
<span class="sd">        differencing.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    differenced : array</span>
<span class="sd">        The differenced array.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">pandas</span> <span class="o">=</span> <span class="n">_is_using_pandas</span><span class="p">(</span><span class="n">series</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="n">differenced</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">series</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">pandas</span> <span class="k">else</span> <span class="n">series</span>

    <span class="c1"># Seasonal differencing</span>
    <span class="k">if</span> <span class="n">k_seasonal_diff</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">while</span> <span class="n">k_seasonal_diff</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">pandas</span><span class="p">:</span>
                <span class="n">differenced</span> <span class="o">=</span> <span class="p">(</span><span class="n">differenced</span><span class="p">[</span><span class="n">seasonal_periods</span><span class="p">:]</span> <span class="o">-</span>
                               <span class="n">differenced</span><span class="p">[:</span><span class="o">-</span><span class="n">seasonal_periods</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">sdiffed</span> <span class="o">=</span> <span class="n">differenced</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">seasonal_periods</span><span class="p">)</span>
                <span class="n">differenced</span> <span class="o">=</span> <span class="n">sdiffed</span><span class="p">[</span><span class="n">seasonal_periods</span><span class="p">:]</span>
            <span class="n">k_seasonal_diff</span> <span class="o">-=</span> <span class="mi">1</span>

    <span class="c1"># Simple differencing</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">pandas</span><span class="p">:</span>
        <span class="n">differenced</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">differenced</span><span class="p">,</span> <span class="n">k_diff</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">while</span> <span class="n">k_diff</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">differenced</span> <span class="o">=</span> <span class="n">differenced</span><span class="o">.</span><span class="n">diff</span><span class="p">()[</span><span class="mi">1</span><span class="p">:]</span>
            <span class="n">k_diff</span> <span class="o">-=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">differenced</span></div>


<span class="k">def</span> <span class="nf">concat</span><span class="p">(</span><span class="n">series</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">allow_mix</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Concatenate a set of series.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    series : iterable</span>
<span class="sd">        An iterable of series to be concatenated</span>
<span class="sd">    axis : int, optional</span>
<span class="sd">        The axis along which to concatenate. Default is 1 (columns).</span>
<span class="sd">    allow_mix : bool</span>
<span class="sd">        Whether or not to allow a mix of pandas and non-pandas objects. Default</span>
<span class="sd">        is False. If true, the returned object is an ndarray, and additional</span>
<span class="sd">        pandas metadata (e.g. column names, indices, etc) is lost.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    concatenated : array or pd.DataFrame</span>
<span class="sd">        The concatenated array. Will be a DataFrame if series are pandas</span>
<span class="sd">        objects.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">is_pandas</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[[</span><span class="n">_is_using_pandas</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">series</span><span class="p">]]</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">is_pandas</span><span class="p">):</span>
        <span class="n">concatenated</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">series</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="o">~</span><span class="n">is_pandas</span><span class="p">)</span> <span class="ow">or</span> <span class="n">allow_mix</span><span class="p">:</span>
        <span class="n">concatenated</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">series</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Attempted to concatenate Pandas objects with&#39;</span>
                         <span class="s1">&#39; non-Pandas objects with `allow_mix=False`.&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">concatenated</span>


<div class="viewcode-block" id="is_invertible"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.tools.is_invertible.html#statsmodels.tsa.statespace.tools.is_invertible">[docs]</a><span class="k">def</span> <span class="nf">is_invertible</span><span class="p">(</span><span class="n">polynomial</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mi">1</span> <span class="o">-</span> <span class="mf">1e-10</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Determine if a polynomial is invertible.</span>

<span class="sd">    Requires all roots of the polynomial lie inside the unit circle.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    polynomial : array_like or tuple, list</span>
<span class="sd">        Coefficients of a polynomial, in order of increasing degree.</span>
<span class="sd">        For example, `polynomial=[1, -0.5]` corresponds to the polynomial</span>
<span class="sd">        :math:`1 - 0.5x` which has root :math:`2`. If it is a matrix</span>
<span class="sd">        polynomial (in which case the coefficients are coefficient matrices),</span>
<span class="sd">        a tuple or list of matrices should be passed.</span>
<span class="sd">    threshold : number</span>
<span class="sd">        Allowed threshold for `is_invertible` to return True. Default is 1.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>

<span class="sd">    If the coefficients provided are scalars :math:`(c_0, c_1, \dots, c_n)`,</span>
<span class="sd">    then the corresponding polynomial is :math:`c_0 + c_1 L + \dots + c_n L^n`.</span>


<span class="sd">    If the coefficients provided are matrices :math:`(C_0, C_1, \dots, C_n)`,</span>
<span class="sd">    then the corresponding polynomial is :math:`C_0 + C_1 L + \dots + C_n L^n`.</span>

<span class="sd">    There are three equivalent methods of determining if the polynomial</span>
<span class="sd">    represented by the coefficients is invertible:</span>

<span class="sd">    The first method factorizes the polynomial into:</span>

<span class="sd">    .. math::</span>

<span class="sd">        C(L) &amp; = c_0 + c_1 L + \dots + c_n L^n \\</span>
<span class="sd">             &amp; = constant (1 - \lambda_1 L)</span>
<span class="sd">                 (1 - \lambda_2 L) \dots (1 - \lambda_n L)</span>

<span class="sd">    In order for :math:`C(L)` to be invertible, it must be that each factor</span>
<span class="sd">    :math:`(1 - \lambda_i L)` is invertible; the condition is then that</span>
<span class="sd">    :math:`|\lambda_i| &lt; 1`, where :math:`\lambda_i` is a root of the</span>
<span class="sd">    polynomial.</span>

<span class="sd">    The second method factorizes the polynomial into:</span>

<span class="sd">    .. math::</span>

<span class="sd">        C(L) &amp; = c_0 + c_1 L + \dots + c_n L^n \\</span>
<span class="sd">             &amp; = constant (L - \zeta_1) (L - \zeta_2) \dots (L - \zeta_3)</span>

<span class="sd">    The condition is now :math:`|\zeta_i| &gt; 1`, where :math:`\zeta_i` is a root</span>
<span class="sd">    of the polynomial with reversed coefficients and</span>
<span class="sd">    :math:`\lambda_i = \frac{1}{\zeta_i}`.</span>

<span class="sd">    Finally, a companion matrix can be formed using the coefficients of the</span>
<span class="sd">    polynomial. Then the eigenvalues of that matrix give the roots of the</span>
<span class="sd">    polynomial. This last method is the one actually used.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    companion_matrix</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># First method:</span>
    <span class="c1"># np.all(np.abs(np.roots(np.r_[1, params])) &lt; 1)</span>
    <span class="c1"># Second method:</span>
    <span class="c1"># np.all(np.abs(np.roots(np.r_[1, params][::-1])) &gt; 1)</span>
    <span class="c1"># Final method:</span>
    <span class="n">eigvals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigvals</span><span class="p">(</span><span class="n">companion_matrix</span><span class="p">(</span><span class="n">polynomial</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">eigvals</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">threshold</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">solve_discrete_lyapunov</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">complex_step</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Solves the discrete Lyapunov equation using a bilinear transformation.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This is a modification of the version in Scipy (see</span>
<span class="sd">    https://github.com/scipy/scipy/blob/master/scipy/linalg/_solvers.py)</span>
<span class="sd">    which allows passing through the complex numbers in the matrix a</span>
<span class="sd">    (usually the transition matrix) in order to allow complex step</span>
<span class="sd">    differentiation.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">eye</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">complex_step</span><span class="p">:</span>
        <span class="n">aH</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
        <span class="n">aHI_inv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">aH</span> <span class="o">+</span> <span class="n">eye</span><span class="p">)</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">aH</span> <span class="o">-</span> <span class="n">eye</span><span class="p">,</span> <span class="n">aHI_inv</span><span class="p">)</span>
        <span class="n">c</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">eye</span><span class="p">),</span> <span class="n">q</span><span class="p">),</span> <span class="n">aHI_inv</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">solve_sylvester</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">(),</span> <span class="n">b</span><span class="p">,</span> <span class="o">-</span><span class="n">c</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">aH</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
        <span class="n">aHI_inv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">aH</span> <span class="o">+</span> <span class="n">eye</span><span class="p">)</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">aH</span> <span class="o">-</span> <span class="n">eye</span><span class="p">,</span> <span class="n">aHI_inv</span><span class="p">)</span>
        <span class="n">c</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">eye</span><span class="p">),</span> <span class="n">q</span><span class="p">),</span> <span class="n">aHI_inv</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">solve_sylvester</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">transpose</span><span class="p">(),</span> <span class="n">b</span><span class="p">,</span> <span class="o">-</span><span class="n">c</span><span class="p">)</span>


<div class="viewcode-block" id="constrain_stationary_univariate"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.tools.constrain_stationary_univariate.html#statsmodels.tsa.statespace.tools.constrain_stationary_univariate">[docs]</a><span class="k">def</span> <span class="nf">constrain_stationary_univariate</span><span class="p">(</span><span class="n">unconstrained</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Transform unconstrained parameters used by the optimizer to constrained</span>
<span class="sd">    parameters used in likelihood evaluation</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    unconstrained : array</span>
<span class="sd">        Unconstrained parameters used by the optimizer, to be transformed to</span>
<span class="sd">        stationary coefficients of, e.g., an autoregressive or moving average</span>
<span class="sd">        component.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    constrained : array</span>
<span class="sd">        Constrained parameters of, e.g., an autoregressive or moving average</span>
<span class="sd">        component, to be transformed to arbitrary parameters used by the</span>
<span class="sd">        optimizer.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [*] Monahan, John F. 1984.</span>
<span class="sd">       &quot;A Note on Enforcing Stationarity in</span>
<span class="sd">       Autoregressive-moving Average Models.&quot;</span>
<span class="sd">       Biometrika 71 (2) (August 1): 403-404.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">n</span> <span class="o">=</span> <span class="n">unconstrained</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">unconstrained</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">unconstrained</span><span class="o">/</span><span class="p">((</span><span class="mi">1</span> <span class="o">+</span> <span class="n">unconstrained</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
            <span class="n">y</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">r</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">y</span><span class="p">[</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">k</span> <span class="o">-</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">y</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
    <span class="k">return</span> <span class="o">-</span><span class="n">y</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:]</span></div>


<div class="viewcode-block" id="unconstrain_stationary_univariate"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.tools.unconstrain_stationary_univariate.html#statsmodels.tsa.statespace.tools.unconstrain_stationary_univariate">[docs]</a><span class="k">def</span> <span class="nf">unconstrain_stationary_univariate</span><span class="p">(</span><span class="n">constrained</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Transform constrained parameters used in likelihood evaluation</span>
<span class="sd">    to unconstrained parameters used by the optimizer</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    constrained : array</span>
<span class="sd">        Constrained parameters of, e.g., an autoregressive or moving average</span>
<span class="sd">        component, to be transformed to arbitrary parameters used by the</span>
<span class="sd">        optimizer.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    unconstrained : array</span>
<span class="sd">        Unconstrained parameters used by the optimizer, to be transformed to</span>
<span class="sd">        stationary coefficients of, e.g., an autoregressive or moving average</span>
<span class="sd">        component.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [*] Monahan, John F. 1984.</span>
<span class="sd">       &quot;A Note on Enforcing Stationarity in</span>
<span class="sd">       Autoregressive-moving Average Models.&quot;</span>
<span class="sd">       Biometrika 71 (2) (August 1): 403-404.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">constrained</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">constrained</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">y</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="o">-</span><span class="n">constrained</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
            <span class="n">y</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">y</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span><span class="o">*</span><span class="n">y</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="o">-</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">y</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">diagonal</span><span class="p">()</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">r</span> <span class="o">/</span> <span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="n">r</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">x</span></div>


<span class="k">def</span> <span class="nf">_constrain_sv_less_than_one_python</span><span class="p">(</span><span class="n">unconstrained</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                       <span class="n">k_endog</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Transform arbitrary matrices to matrices with singular values less than</span>
<span class="sd">    one.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    unconstrained : list</span>
<span class="sd">        Arbitrary matrices. Should be a list of length `order`, where each</span>
<span class="sd">        element is an array sized `k_endog` x `k_endog`.</span>
<span class="sd">    order : integer, optional</span>
<span class="sd">        The order of the autoregression.</span>
<span class="sd">    k_endog : integer, optional</span>
<span class="sd">        The dimension of the data vector.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    constrained : list</span>
<span class="sd">        Partial autocorrelation matrices. Should be a list of length</span>
<span class="sd">        `order`, where each element is an array sized `k_endog` x `k_endog`.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Corresponds to Lemma 2.2 in Ansley and Kohn (1986). See</span>
<span class="sd">    `constrain_stationary_multivariate` for more details.</span>

<span class="sd">    There is a Cython implementation of this function that can be much faster,</span>
<span class="sd">    but which requires SciPy 0.14.0 or greater. See</span>
<span class="sd">    `constrain_stationary_multivariate` for details.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="kn">from</span> <span class="nn">scipy</span> <span class="k">import</span> <span class="n">linalg</span>

    <span class="n">constrained</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># P_s,  s = 1, ..., p</span>
    <span class="k">if</span> <span class="n">order</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">order</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">unconstrained</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">k_endog</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">k_endog</span> <span class="o">=</span> <span class="n">unconstrained</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">eye</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">k_endog</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">order</span><span class="p">):</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">unconstrained</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">B</span><span class="p">,</span> <span class="n">lower</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">cho_factor</span><span class="p">(</span><span class="n">eye</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">A</span><span class="o">.</span><span class="n">T</span><span class="p">),</span> <span class="n">lower</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">constrained</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve_triangular</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">lower</span><span class="o">=</span><span class="n">lower</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">constrained</span>


<span class="k">def</span> <span class="nf">_compute_coefficients_from_multivariate_pacf_python</span><span class="p">(</span>
        <span class="n">partial_autocorrelations</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">transform_variance</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">k_endog</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Transform matrices with singular values less than one to matrices</span>
<span class="sd">    corresponding to a stationary (or invertible) process.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    partial_autocorrelations : list</span>
<span class="sd">        Partial autocorrelation matrices. Should be a list of length `order`,</span>
<span class="sd">        where each element is an array sized `k_endog` x `k_endog`.</span>
<span class="sd">    error_variance : array</span>
<span class="sd">        The variance / covariance matrix of the error term. Should be sized</span>
<span class="sd">        `k_endog` x `k_endog`. This is used as input in the algorithm even if</span>
<span class="sd">        is not transformed by it (when `transform_variance` is False). The</span>
<span class="sd">        error term variance is required input when transformation is used</span>
<span class="sd">        either to force an autoregressive component to be stationary or to</span>
<span class="sd">        force a moving average component to be invertible.</span>
<span class="sd">    transform_variance : boolean, optional</span>
<span class="sd">        Whether or not to transform the error variance term. This option is</span>
<span class="sd">        not typically used, and the default is False.</span>
<span class="sd">    order : integer, optional</span>
<span class="sd">        The order of the autoregression.</span>
<span class="sd">    k_endog : integer, optional</span>
<span class="sd">        The dimension of the data vector.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    coefficient_matrices : list</span>
<span class="sd">        Transformed coefficient matrices leading to a stationary VAR</span>
<span class="sd">        representation.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Corresponds to Lemma 2.1 in Ansley and Kohn (1986). See</span>
<span class="sd">    `constrain_stationary_multivariate` for more details.</span>

<span class="sd">    There is a Cython implementation of this function that can be much faster,</span>
<span class="sd">    but which requires SciPy 0.14.0 or greater. See</span>
<span class="sd">    `constrain_stationary_multivariate` for details.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">scipy</span> <span class="k">import</span> <span class="n">linalg</span>

    <span class="k">if</span> <span class="n">order</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">order</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">partial_autocorrelations</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">k_endog</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">k_endog</span> <span class="o">=</span> <span class="n">partial_autocorrelations</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># If we want to keep the provided variance but with the constrained</span>
    <span class="c1"># coefficient matrices, we need to make a copy here, and then after the</span>
    <span class="c1"># main loop we will transform the coefficients to match the passed variance</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">transform_variance</span><span class="p">:</span>
        <span class="n">initial_variance</span> <span class="o">=</span> <span class="n">error_variance</span>
        <span class="c1"># Need to make the input variance large enough that the recursions</span>
        <span class="c1"># don&#39;t lead to zero-matrices due to roundoff error, which would case</span>
        <span class="c1"># exceptions from the Cholesky decompositions.</span>
        <span class="c1"># Note that this will still not always ensure positive definiteness,</span>
        <span class="c1"># and for k_endog, order large enough an exception may still be raised</span>
        <span class="n">error_variance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">k_endog</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">order</span> <span class="o">+</span> <span class="n">k_endog</span><span class="p">)</span><span class="o">**</span><span class="mi">10</span>

    <span class="n">forward_variances</span> <span class="o">=</span> <span class="p">[</span><span class="n">error_variance</span><span class="p">]</span>   <span class="c1"># \Sigma_s</span>
    <span class="n">backward_variances</span> <span class="o">=</span> <span class="p">[</span><span class="n">error_variance</span><span class="p">]</span>  <span class="c1"># \Sigma_s^*,  s = 0, ..., p</span>
    <span class="n">autocovariances</span> <span class="o">=</span> <span class="p">[</span><span class="n">error_variance</span><span class="p">]</span>     <span class="c1"># \Gamma_s</span>
    <span class="c1"># \phi_{s,k}, s = 1, ..., p</span>
    <span class="c1">#             k = 1, ..., s+1</span>
    <span class="n">forwards</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># \phi_{s,k}^*</span>
    <span class="n">backwards</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">error_variance_factor</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">cholesky</span><span class="p">(</span><span class="n">error_variance</span><span class="p">,</span> <span class="n">lower</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">forward_factors</span> <span class="o">=</span> <span class="p">[</span><span class="n">error_variance_factor</span><span class="p">]</span>
    <span class="n">backward_factors</span> <span class="o">=</span> <span class="p">[</span><span class="n">error_variance_factor</span><span class="p">]</span>

    <span class="c1"># We fill in the entries as follows:</span>
    <span class="c1"># [1,1]</span>
    <span class="c1"># [2,2], [2,1]</span>
    <span class="c1"># [3,3], [3,1], [3,2]</span>
    <span class="c1"># ...</span>
    <span class="c1"># [p,p], [p,1], ..., [p,p-1]</span>
    <span class="c1"># the last row, correctly ordered, is then used as the coefficients</span>
    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">order</span><span class="p">):</span>  <span class="c1"># s = 0, ..., p-1</span>
        <span class="n">prev_forwards</span> <span class="o">=</span> <span class="n">forwards</span>
        <span class="n">prev_backwards</span> <span class="o">=</span> <span class="n">backwards</span>
        <span class="n">forwards</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">backwards</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Create the &quot;last&quot; (k = s+1) matrix</span>
        <span class="c1"># Note: this is for k = s+1. However, below we then have to fill</span>
        <span class="c1"># in for k = 1, ..., s in order.</span>
        <span class="c1"># P L*^{-1} = x</span>
        <span class="c1"># x L* = P</span>
        <span class="c1"># L*&#39; x&#39; = P&#39;</span>
        <span class="n">forwards</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="n">linalg</span><span class="o">.</span><span class="n">solve_triangular</span><span class="p">(</span>
                <span class="n">backward_factors</span><span class="p">[</span><span class="n">s</span><span class="p">],</span> <span class="n">partial_autocorrelations</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
                <span class="n">lower</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">trans</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">))</span>
        <span class="n">forwards</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">forward_factors</span><span class="p">[</span><span class="n">s</span><span class="p">],</span> <span class="n">forwards</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

        <span class="c1"># P&#39; L^{-1} = x</span>
        <span class="c1"># x L = P&#39;</span>
        <span class="c1"># L&#39; x&#39; = P</span>
        <span class="n">backwards</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="n">linalg</span><span class="o">.</span><span class="n">solve_triangular</span><span class="p">(</span>
                <span class="n">forward_factors</span><span class="p">[</span><span class="n">s</span><span class="p">],</span> <span class="n">partial_autocorrelations</span><span class="p">[</span><span class="n">s</span><span class="p">],</span>
                <span class="n">lower</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">trans</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">))</span>
        <span class="n">backwards</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">backward_factors</span><span class="p">[</span><span class="n">s</span><span class="p">],</span> <span class="n">backwards</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

        <span class="c1"># Update the variance</span>
        <span class="c1"># Note: if s &gt;= 1, this will be further updated in the for loop</span>
        <span class="c1"># below</span>
        <span class="c1"># Also, this calculation will be re-used in the forward variance</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">forwards</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">backward_variances</span><span class="p">[</span><span class="n">s</span><span class="p">])</span>
        <span class="n">autocovariances</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tmp</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

        <span class="c1"># Create the remaining k = 1, ..., s matrices,</span>
        <span class="c1"># only has an effect if s &gt;= 1</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
            <span class="n">forwards</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">prev_forwards</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
                <span class="n">forwards</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">prev_backwards</span><span class="p">[</span><span class="n">s</span><span class="o">-</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)]))</span>

            <span class="n">backwards</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">prev_backwards</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
                <span class="n">backwards</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">prev_forwards</span><span class="p">[</span><span class="n">s</span><span class="o">-</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)]))</span>

            <span class="n">autocovariances</span><span class="p">[</span><span class="n">s</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">autocovariances</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span>
                                           <span class="n">prev_forwards</span><span class="p">[</span><span class="n">s</span><span class="o">-</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

        <span class="c1"># Create forward and backwards variances</span>
        <span class="n">forward_variances</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="n">forward_variances</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">forwards</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">backward_variances</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="n">backward_variances</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">-</span>
            <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">backwards</span><span class="p">[</span><span class="n">s</span><span class="p">],</span> <span class="n">forward_variances</span><span class="p">[</span><span class="n">s</span><span class="p">]),</span>
                <span class="n">backwards</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>
            <span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># Cholesky factors</span>
        <span class="n">forward_factors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="n">linalg</span><span class="o">.</span><span class="n">cholesky</span><span class="p">(</span><span class="n">forward_variances</span><span class="p">[</span><span class="n">s</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">lower</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">backward_factors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="n">linalg</span><span class="o">.</span><span class="n">cholesky</span><span class="p">(</span><span class="n">backward_variances</span><span class="p">[</span><span class="n">s</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">lower</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="c1"># If we do not want to use the transformed variance, we need to</span>
    <span class="c1"># adjust the constrained matrices, as presented in Lemma 2.3, see above</span>
    <span class="n">variance</span> <span class="o">=</span> <span class="n">forward_variances</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">transform_variance</span><span class="p">:</span>
        <span class="c1"># Here, we need to construct T such that:</span>
        <span class="c1"># variance = T * initial_variance * T&#39;</span>
        <span class="c1"># To do that, consider the Cholesky of variance (L) and</span>
        <span class="c1"># input_variance (M) to get:</span>
        <span class="c1"># L L&#39; = T M M&#39; T&#39; = (TM) (TM)&#39;</span>
        <span class="c1"># =&gt; L = T M</span>
        <span class="c1"># =&gt; L M^{-1} = T</span>
        <span class="n">initial_variance_factor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">cholesky</span><span class="p">(</span><span class="n">initial_variance</span><span class="p">)</span>
        <span class="n">transformed_variance_factor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">cholesky</span><span class="p">(</span><span class="n">variance</span><span class="p">)</span>
        <span class="n">transform</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">initial_variance_factor</span><span class="p">,</span>
                           <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">transformed_variance_factor</span><span class="p">))</span>
        <span class="n">inv_transform</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">transform</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">order</span><span class="p">):</span>
            <span class="n">forwards</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">transform</span><span class="p">,</span> <span class="n">forwards</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="n">inv_transform</span><span class="p">)</span>
            <span class="p">)</span>

    <span class="k">return</span> <span class="n">forwards</span><span class="p">,</span> <span class="n">variance</span>


<span class="k">def</span> <span class="nf">constrain_stationary_multivariate_python</span><span class="p">(</span><span class="n">unconstrained</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span>
                                             <span class="n">transform_variance</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                             <span class="n">prefix</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Transform unconstrained parameters used by the optimizer to constrained</span>
<span class="sd">    parameters used in likelihood evaluation for a vector autoregression.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    unconstrained : array or list</span>
<span class="sd">        Arbitrary matrices to be transformed to stationary coefficient matrices</span>
<span class="sd">        of the VAR. If a list, should be a list of length `order`, where each</span>
<span class="sd">        element is an array sized `k_endog` x `k_endog`. If an array, should be</span>
<span class="sd">        the matrices horizontally concatenated and sized</span>
<span class="sd">        `k_endog` x `k_endog * order`.</span>
<span class="sd">    error_variance : array</span>
<span class="sd">        The variance / covariance matrix of the error term. Should be sized</span>
<span class="sd">        `k_endog` x `k_endog`. This is used as input in the algorithm even if</span>
<span class="sd">        is not transformed by it (when `transform_variance` is False). The</span>
<span class="sd">        error term variance is required input when transformation is used</span>
<span class="sd">        either to force an autoregressive component to be stationary or to</span>
<span class="sd">        force a moving average component to be invertible.</span>
<span class="sd">    transform_variance : boolean, optional</span>
<span class="sd">        Whether or not to transform the error variance term. This option is</span>
<span class="sd">        not typically used, and the default is False.</span>
<span class="sd">    prefix : {&#39;s&#39;,&#39;d&#39;,&#39;c&#39;,&#39;z&#39;}, optional</span>
<span class="sd">        The appropriate BLAS prefix to use for the passed datatypes. Only</span>
<span class="sd">        use if absolutely sure that the prefix is correct or an error will</span>
<span class="sd">        result.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    constrained : array or list</span>
<span class="sd">        Transformed coefficient matrices leading to a stationary VAR</span>
<span class="sd">        representation. Will match the type of the passed `unconstrained`</span>
<span class="sd">        variable (so if a list was passed, a list will be returned).</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    In the notation of [1]_, the arguments `(variance, unconstrained)` are</span>
<span class="sd">    written as :math:`(\Sigma, A_1, \dots, A_p)`, where :math:`p` is the order</span>
<span class="sd">    of the vector autoregression, and is here determined by the length of</span>
<span class="sd">    the `unconstrained` argument.</span>

<span class="sd">    There are two steps in the constraining algorithm.</span>

<span class="sd">    First, :math:`(A_1, \dots, A_p)` are transformed into</span>
<span class="sd">    :math:`(P_1, \dots, P_p)` via Lemma 2.2 of [1]_.</span>

<span class="sd">    Second, :math:`(\Sigma, P_1, \dots, P_p)` are transformed into</span>
<span class="sd">    :math:`(\Sigma, \phi_1, \dots, \phi_p)` via Lemmas 2.1 and 2.3 of [1]_.</span>

<span class="sd">    If `transform_variance=True`, then only Lemma 2.1 is applied in the second</span>
<span class="sd">    step.</span>

<span class="sd">    While this function can be used even in the univariate case, it is much</span>
<span class="sd">    slower, so in that case `constrain_stationary_univariate` is preferred.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Ansley, Craig F., and Robert Kohn. 1986.</span>
<span class="sd">       &quot;A Note on Reparameterizing a Vector Autoregressive Moving Average Model</span>
<span class="sd">       to Enforce Stationarity.&quot;</span>
<span class="sd">       Journal of Statistical Computation and Simulation 24 (2): 99-106.</span>
<span class="sd">    .. [*] Ansley, Craig F, and Paul Newbold. 1979.</span>
<span class="sd">       &quot;Multivariate Partial Autocorrelations.&quot;</span>
<span class="sd">       In Proceedings of the Business and Economic Statistics Section, 349-53.</span>
<span class="sd">       American Statistical Association</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">use_list</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">unconstrained</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">use_list</span><span class="p">:</span>
        <span class="n">k_endog</span><span class="p">,</span> <span class="n">order</span> <span class="o">=</span> <span class="n">unconstrained</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">order</span> <span class="o">//=</span> <span class="n">k_endog</span>

        <span class="n">unconstrained</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">unconstrained</span><span class="p">[:</span><span class="n">k_endog</span><span class="p">,</span> <span class="n">i</span><span class="o">*</span><span class="n">k_endog</span><span class="p">:(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">k_endog</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">order</span><span class="p">)</span>
        <span class="p">]</span>

    <span class="n">order</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">unconstrained</span><span class="p">)</span>
    <span class="n">k_endog</span> <span class="o">=</span> <span class="n">unconstrained</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># Step 1: convert from arbitrary matrices to those with singular values</span>
    <span class="c1"># less than one.</span>
    <span class="n">sv_constrained</span> <span class="o">=</span> <span class="n">_constrain_sv_less_than_one_python</span><span class="p">(</span>
        <span class="n">unconstrained</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">k_endog</span><span class="p">)</span>

    <span class="c1"># Step 2: convert matrices from our &quot;partial autocorrelation matrix&quot; space</span>
    <span class="c1"># (matrices with singular values less than one) to the space of stationary</span>
    <span class="c1"># coefficient matrices</span>
    <span class="n">constrained</span><span class="p">,</span> <span class="n">var</span> <span class="o">=</span> <span class="n">_compute_coefficients_from_multivariate_pacf_python</span><span class="p">(</span>
        <span class="n">sv_constrained</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">transform_variance</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">k_endog</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">use_list</span><span class="p">:</span>
        <span class="n">constrained</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">constrained</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
            <span class="n">k_endog</span><span class="p">,</span> <span class="n">k_endog</span> <span class="o">*</span> <span class="n">order</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">constrained</span><span class="p">,</span> <span class="n">var</span>


<div class="viewcode-block" id="constrain_stationary_multivariate"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.tools.constrain_stationary_multivariate.html#statsmodels.tsa.statespace.tools.constrain_stationary_multivariate">[docs]</a><span class="k">def</span> <span class="nf">constrain_stationary_multivariate</span><span class="p">(</span><span class="n">unconstrained</span><span class="p">,</span> <span class="n">variance</span><span class="p">,</span>
                                      <span class="n">transform_variance</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                      <span class="n">prefix</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

    <span class="n">use_list</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">unconstrained</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span>
    <span class="k">if</span> <span class="n">use_list</span><span class="p">:</span>
        <span class="n">unconstrained</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">unconstrained</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">k_endog</span><span class="p">,</span> <span class="n">order</span> <span class="o">=</span> <span class="n">unconstrained</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">order</span> <span class="o">//=</span> <span class="n">k_endog</span>

    <span class="k">if</span> <span class="n">order</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Must have order at least 1&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">k_endog</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Must have at least 1 endogenous variable&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">prefix</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">prefix</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">find_best_blas_type</span><span class="p">(</span>
            <span class="p">[</span><span class="n">unconstrained</span><span class="p">,</span> <span class="n">variance</span><span class="p">])</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="n">prefix_dtype_map</span><span class="p">[</span><span class="n">prefix</span><span class="p">]</span>

    <span class="n">unconstrained</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asfortranarray</span><span class="p">(</span><span class="n">unconstrained</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">variance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asfortranarray</span><span class="p">(</span><span class="n">variance</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

    <span class="c1"># Step 1: convert from arbitrary matrices to those with singular values</span>
    <span class="c1"># less than one.</span>
    <span class="c1"># sv_constrained = _constrain_sv_less_than_one(unconstrained, order,</span>
    <span class="c1">#                                              k_endog, prefix)</span>
    <span class="n">sv_constrained</span> <span class="o">=</span> <span class="n">prefix_sv_map</span><span class="p">[</span><span class="n">prefix</span><span class="p">](</span><span class="n">unconstrained</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">k_endog</span><span class="p">)</span>

    <span class="c1"># Step 2: convert matrices from our &quot;partial autocorrelation matrix&quot;</span>
    <span class="c1"># space (matrices with singular values less than one) to the space of</span>
    <span class="c1"># stationary coefficient matrices</span>
    <span class="n">constrained</span><span class="p">,</span> <span class="n">variance</span> <span class="o">=</span> <span class="n">prefix_pacf_map</span><span class="p">[</span><span class="n">prefix</span><span class="p">](</span>
        <span class="n">sv_constrained</span><span class="p">,</span> <span class="n">variance</span><span class="p">,</span> <span class="n">transform_variance</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">k_endog</span><span class="p">)</span>

    <span class="n">constrained</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">constrained</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">variance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">variance</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">use_list</span><span class="p">:</span>
        <span class="n">constrained</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">constrained</span><span class="p">[:</span><span class="n">k_endog</span><span class="p">,</span> <span class="n">i</span><span class="o">*</span><span class="n">k_endog</span><span class="p">:(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">k_endog</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">order</span><span class="p">)</span>
        <span class="p">]</span>

    <span class="k">return</span> <span class="n">constrained</span><span class="p">,</span> <span class="n">variance</span></div>


<span class="n">constrain_stationary_multivariate</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="p">(</span>
    <span class="n">constrain_stationary_multivariate_python</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_unconstrain_sv_less_than_one</span><span class="p">(</span><span class="n">constrained</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">k_endog</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Transform matrices with singular values less than one to arbitrary</span>
<span class="sd">    matrices.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    constrained : list</span>
<span class="sd">        The partial autocorrelation matrices. Should be a list of length</span>
<span class="sd">        `order`, where each element is an array sized `k_endog` x `k_endog`.</span>
<span class="sd">    order : integer, optional</span>
<span class="sd">        The order of the autoregression.</span>
<span class="sd">    k_endog : integer, optional</span>
<span class="sd">        The dimension of the data vector.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    unconstrained : list</span>
<span class="sd">        Unconstrained matrices. A list of length `order`, where each element is</span>
<span class="sd">        an array sized `k_endog` x `k_endog`.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Corresponds to the inverse of Lemma 2.2 in Ansley and Kohn (1986). See</span>
<span class="sd">    `unconstrain_stationary_multivariate` for more details.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">scipy</span> <span class="k">import</span> <span class="n">linalg</span>

    <span class="n">unconstrained</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># A_s,  s = 1, ..., p</span>
    <span class="k">if</span> <span class="n">order</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">order</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">constrained</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">k_endog</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">k_endog</span> <span class="o">=</span> <span class="n">constrained</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">eye</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">k_endog</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">order</span><span class="p">):</span>
        <span class="n">P</span> <span class="o">=</span> <span class="n">constrained</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="c1"># B^{-1} B^{-1}&#39; = I - P P&#39;</span>
        <span class="n">B_inv</span><span class="p">,</span> <span class="n">lower</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">cho_factor</span><span class="p">(</span><span class="n">eye</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">P</span><span class="o">.</span><span class="n">T</span><span class="p">),</span> <span class="n">lower</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># A = BP</span>
        <span class="c1"># B^{-1} A = P</span>
        <span class="n">unconstrained</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve_triangular</span><span class="p">(</span><span class="n">B_inv</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">lower</span><span class="o">=</span><span class="n">lower</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">unconstrained</span>


<span class="k">def</span> <span class="nf">_compute_multivariate_sample_acovf</span><span class="p">(</span><span class="n">endog</span><span class="p">,</span> <span class="n">maxlag</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computer multivariate sample autocovariances</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    endog : array_like</span>
<span class="sd">        Sample data on which to compute sample autocovariances. Shaped</span>
<span class="sd">        `nobs` x `k_endog`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    sample_autocovariances : list</span>
<span class="sd">        A list of the first `maxlag` sample autocovariance matrices. Each</span>
<span class="sd">        matrix is shaped `k_endog` x `k_endog`.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This function computes the forward sample autocovariances:</span>

<span class="sd">    .. math::</span>

<span class="sd">        \hat \Gamma(s) = \frac{1}{n} \sum_{t=1}^{n-s}</span>
<span class="sd">        (Z_t - \bar Z) (Z_{t+s} - \bar Z)&#39;</span>

<span class="sd">    See page 353 of Wei (1990). This function is primarily implemented for</span>
<span class="sd">    checking the partial autocorrelation functions below, and so is quite slow.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [*] Wei, William. 1990.</span>
<span class="sd">        Time Series Analysis : Univariate and Multivariate Methods.</span>
<span class="sd">       Boston: Pearson.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Get the (demeaned) data as an array</span>
    <span class="n">endog</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">endog</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">endog</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">endog</span> <span class="o">=</span> <span class="n">endog</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
    <span class="n">endog</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">endog</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1"># Dimensions</span>
    <span class="n">nobs</span><span class="p">,</span> <span class="n">k_endog</span> <span class="o">=</span> <span class="n">endog</span><span class="o">.</span><span class="n">shape</span>

    <span class="n">sample_autocovariances</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">maxlag</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">sample_autocovariances</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">k_endog</span><span class="p">,</span> <span class="n">k_endog</span><span class="p">)))</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nobs</span> <span class="o">-</span> <span class="n">s</span><span class="p">):</span>
            <span class="n">sample_autocovariances</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">endog</span><span class="p">[</span><span class="n">t</span><span class="p">],</span> <span class="n">endog</span><span class="p">[</span><span class="n">t</span><span class="o">+</span><span class="n">s</span><span class="p">])</span>
        <span class="n">sample_autocovariances</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">/=</span> <span class="n">nobs</span>

    <span class="k">return</span> <span class="n">sample_autocovariances</span>


<span class="k">def</span> <span class="nf">_compute_multivariate_acovf_from_coefficients</span><span class="p">(</span>
        <span class="n">coefficients</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">maxlag</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">forward_autocovariances</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute multivariate autocovariances from vector autoregression coefficient</span>
<span class="sd">    matrices</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    coefficients : array or list</span>
<span class="sd">        The coefficients matrices. If a list, should be a list of length</span>
<span class="sd">        `order`, where each element is an array sized `k_endog` x `k_endog`. If</span>
<span class="sd">        an array, should be the coefficient matrices horizontally concatenated</span>
<span class="sd">        and sized `k_endog` x `k_endog * order`.</span>
<span class="sd">    error_variance : array</span>
<span class="sd">        The variance / covariance matrix of the error term. Should be sized</span>
<span class="sd">        `k_endog` x `k_endog`.</span>
<span class="sd">    maxlag : integer, optional</span>
<span class="sd">        The maximum autocovariance to compute. Default is `order`-1. Can be</span>
<span class="sd">        zero, in which case it returns the variance.</span>
<span class="sd">    forward_autocovariances : boolean, optional</span>
<span class="sd">        Whether or not to compute forward autocovariances</span>
<span class="sd">        :math:`E(y_t y_{t+j}&#39;)`. Default is False, so that backward</span>
<span class="sd">        autocovariances :math:`E(y_t y_{t-j}&#39;)` are returned.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    autocovariances : list</span>
<span class="sd">        A list of the first `maxlag` autocovariance matrices. Each matrix is</span>
<span class="sd">        shaped `k_endog` x `k_endog`.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Computes</span>

<span class="sd">    .. math::</span>

<span class="sd">        \Gamma(j) = E(y_t y_{t-j}&#39;)</span>

<span class="sd">    for j = 1, ..., `maxlag`, unless `forward_autocovariances` is specified,</span>
<span class="sd">    in which case it computes:</span>

<span class="sd">    .. math::</span>

<span class="sd">        E(y_t y_{t+j}&#39;) = \Gamma(j)&#39;</span>

<span class="sd">    Coefficients are assumed to be provided from the VAR model:</span>

<span class="sd">    .. math::</span>
<span class="sd">        y_t = A_1 y_{t-1} + \dots + A_p y_{t-p} + \varepsilon_t</span>

<span class="sd">    Autocovariances are calculated by solving the associated discrete Lyapunov</span>
<span class="sd">    equation of the state space representation of the VAR process.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">scipy</span> <span class="k">import</span> <span class="n">linalg</span>

    <span class="c1"># Convert coefficients to a list of matrices, for use in</span>
    <span class="c1"># `companion_matrix`; get dimensions</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">coefficients</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span><span class="p">:</span>
        <span class="n">order</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">coefficients</span><span class="p">)</span>
        <span class="n">k_endog</span> <span class="o">=</span> <span class="n">coefficients</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">k_endog</span><span class="p">,</span> <span class="n">order</span> <span class="o">=</span> <span class="n">coefficients</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">order</span> <span class="o">//=</span> <span class="n">k_endog</span>

        <span class="n">coefficients</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">coefficients</span><span class="p">[:</span><span class="n">k_endog</span><span class="p">,</span> <span class="n">i</span><span class="o">*</span><span class="n">k_endog</span><span class="p">:(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">k_endog</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">order</span><span class="p">)</span>
        <span class="p">]</span>

    <span class="k">if</span> <span class="n">maxlag</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">maxlag</span> <span class="o">=</span> <span class="n">order</span><span class="o">-</span><span class="mi">1</span>

    <span class="c1"># Start with VAR(p): w_{t+1} = phi_1 w_t + ... + phi_p w_{t-p+1} + u_{t+1}</span>
    <span class="c1"># Then stack the VAR(p) into a VAR(1) in companion matrix form:</span>
    <span class="c1"># z_{t+1} = F z_t + v_t</span>
    <span class="n">companion</span> <span class="o">=</span> <span class="n">companion_matrix</span><span class="p">(</span>
        <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">coefficients</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">order</span><span class="p">)]</span>
    <span class="p">)</span><span class="o">.</span><span class="n">T</span>

    <span class="c1"># Compute the error variance matrix for the stacked form: E v_t v_t&#39;</span>
    <span class="n">selected_variance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">companion</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">selected_variance</span><span class="p">[:</span><span class="n">k_endog</span><span class="p">,</span> <span class="p">:</span><span class="n">k_endog</span><span class="p">]</span> <span class="o">=</span> <span class="n">error_variance</span>

    <span class="c1"># Compute the unconditional variance of z_t: E z_t z_t&#39;</span>
    <span class="n">stacked_cov</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">solve_discrete_lyapunov</span><span class="p">(</span><span class="n">companion</span><span class="p">,</span> <span class="n">selected_variance</span><span class="p">)</span>

    <span class="c1"># The first (block) row of the variance of z_t gives the first p-1</span>
    <span class="c1"># autocovariances of w_t: \Gamma_i = E w_t w_t+i with \Gamma_0 = Var(w_t)</span>
    <span class="c1"># Note: these are okay, checked against ArmaProcess</span>
    <span class="n">autocovariances</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">stacked_cov</span><span class="p">[:</span><span class="n">k_endog</span><span class="p">,</span> <span class="n">i</span><span class="o">*</span><span class="n">k_endog</span><span class="p">:(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">k_endog</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">order</span><span class="p">,</span> <span class="n">maxlag</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
    <span class="p">]</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">maxlag</span> <span class="o">-</span> <span class="p">(</span><span class="n">order</span><span class="o">-</span><span class="mi">1</span><span class="p">)):</span>
        <span class="n">stacked_cov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">companion</span><span class="p">,</span> <span class="n">stacked_cov</span><span class="p">)</span>
        <span class="n">autocovariances</span> <span class="o">+=</span> <span class="p">[</span>
            <span class="n">stacked_cov</span><span class="p">[:</span><span class="n">k_endog</span><span class="p">,</span> <span class="o">-</span><span class="n">k_endog</span><span class="p">:]</span>
        <span class="p">]</span>

    <span class="k">if</span> <span class="n">forward_autocovariances</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">autocovariances</span><span class="p">)):</span>
            <span class="n">autocovariances</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">autocovariances</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>

    <span class="k">return</span> <span class="n">autocovariances</span>


<span class="k">def</span> <span class="nf">_compute_multivariate_sample_pacf</span><span class="p">(</span><span class="n">endog</span><span class="p">,</span> <span class="n">maxlag</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computer multivariate sample partial autocorrelations</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    endog : array_like</span>
<span class="sd">        Sample data on which to compute sample autocovariances. Shaped</span>
<span class="sd">        `nobs` x `k_endog`.</span>
<span class="sd">    maxlag : integer</span>
<span class="sd">        Maximum lag for which to calculate sample partial autocorrelations.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    sample_pacf : list</span>
<span class="sd">        A list of the first `maxlag` sample partial autocorrelation matrices.</span>
<span class="sd">        Each matrix is shaped `k_endog` x `k_endog`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sample_autocovariances</span> <span class="o">=</span> <span class="n">_compute_multivariate_sample_acovf</span><span class="p">(</span><span class="n">endog</span><span class="p">,</span> <span class="n">maxlag</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">_compute_multivariate_pacf_from_autocovariances</span><span class="p">(</span>
        <span class="n">sample_autocovariances</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_compute_multivariate_pacf_from_autocovariances</span><span class="p">(</span><span class="n">autocovariances</span><span class="p">,</span>
                                                    <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">k_endog</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute multivariate partial autocorrelations from autocovariances.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    autocovariances : list</span>
<span class="sd">        Autocorrelations matrices. Should be a list of length `order` + 1,</span>
<span class="sd">        where each element is an array sized `k_endog` x `k_endog`.</span>
<span class="sd">    order : integer, optional</span>
<span class="sd">        The order of the autoregression.</span>
<span class="sd">    k_endog : integer, optional</span>
<span class="sd">        The dimension of the data vector.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    pacf : list</span>
<span class="sd">        List of first `order` multivariate partial autocorrelations.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Note that this computes multivariate partial autocorrelations.</span>

<span class="sd">    Corresponds to the inverse of Lemma 2.1 in Ansley and Kohn (1986). See</span>
<span class="sd">    `unconstrain_stationary_multivariate` for more details.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Computes sample partial autocorrelations if sample autocovariances are</span>
<span class="sd">    given.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">scipy</span> <span class="k">import</span> <span class="n">linalg</span>

    <span class="k">if</span> <span class="n">order</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">order</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">autocovariances</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
    <span class="k">if</span> <span class="n">k_endog</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">k_endog</span> <span class="o">=</span> <span class="n">autocovariances</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># Now apply the Ansley and Kohn (1986) algorithm, except that instead of</span>
    <span class="c1"># calculating phi_{s+1, s+1} = L_s P_{s+1} {L_s^*}^{-1} (which requires</span>
    <span class="c1"># the partial autocorrelation P_{s+1} which is what we&#39;re trying to</span>
    <span class="c1"># calculate here), we calculate it as in Ansley and Newbold (1979), using</span>
    <span class="c1"># the autocovariances \Gamma_s and the forwards and backwards residual</span>
    <span class="c1"># variances \Sigma_s, \Sigma_s^*:</span>
    <span class="c1"># phi_{s+1, s+1} = [ \Gamma_{s+1}&#39; - \phi_{s,1} \Gamma_s&#39; - ... -</span>
    <span class="c1">#                    \phi_{s,s} \Gamma_1&#39; ] {\Sigma_s^*}^{-1}</span>

    <span class="c1"># Forward and backward variances</span>
    <span class="n">forward_variances</span> <span class="o">=</span> <span class="p">[]</span>   <span class="c1"># \Sigma_s</span>
    <span class="n">backward_variances</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># \Sigma_s^*,  s = 0, ..., p</span>
    <span class="c1"># \phi_{s,k}, s = 1, ..., p</span>
    <span class="c1">#             k = 1, ..., s+1</span>
    <span class="n">forwards</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># \phi_{s,k}^*</span>
    <span class="n">backwards</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">forward_factors</span> <span class="o">=</span> <span class="p">[]</span>   <span class="c1"># L_s</span>
    <span class="n">backward_factors</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># L_s^*,  s = 0, ..., p</span>

    <span class="c1"># Ultimately we want to construct the partial autocorrelation matrices</span>
    <span class="c1"># Note that this is &quot;1-indexed&quot; in the sense that it stores P_1, ... P_p</span>
    <span class="c1"># rather than starting with P_0.</span>
    <span class="n">partial_autocorrelations</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># We fill in the entries of phi_{s,k} as follows:</span>
    <span class="c1"># [1,1]</span>
    <span class="c1"># [2,2], [2,1]</span>
    <span class="c1"># [3,3], [3,1], [3,2]</span>
    <span class="c1"># ...</span>
    <span class="c1"># [p,p], [p,1], ..., [p,p-1]</span>
    <span class="c1"># the last row, correctly ordered, should be the same as the coefficient</span>
    <span class="c1"># matrices provided in the argument `constrained`</span>
    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">order</span><span class="p">):</span>  <span class="c1"># s = 0, ..., p-1</span>
        <span class="n">prev_forwards</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">forwards</span><span class="p">)</span>
        <span class="n">prev_backwards</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">backwards</span><span class="p">)</span>
        <span class="n">forwards</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">backwards</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Create forward and backwards variances Sigma_s, Sigma*_s</span>
        <span class="n">forward_variance</span> <span class="o">=</span> <span class="n">autocovariances</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">backward_variance</span> <span class="o">=</span> <span class="n">autocovariances</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
            <span class="n">forward_variance</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">prev_forwards</span><span class="p">[</span><span class="n">k</span><span class="p">],</span>
                                       <span class="n">autocovariances</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">backward_variance</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">prev_backwards</span><span class="p">[</span><span class="n">k</span><span class="p">],</span>
                                        <span class="n">autocovariances</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

        <span class="n">forward_variances</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">forward_variance</span><span class="p">)</span>
        <span class="n">backward_variances</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">backward_variance</span><span class="p">)</span>

        <span class="c1"># Cholesky factors</span>
        <span class="n">forward_factors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="n">linalg</span><span class="o">.</span><span class="n">cholesky</span><span class="p">(</span><span class="n">forward_variances</span><span class="p">[</span><span class="n">s</span><span class="p">],</span> <span class="n">lower</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">backward_factors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="n">linalg</span><span class="o">.</span><span class="n">cholesky</span><span class="p">(</span><span class="n">backward_variances</span><span class="p">[</span><span class="n">s</span><span class="p">],</span> <span class="n">lower</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># Create the intermediate sum term</span>
        <span class="k">if</span> <span class="n">s</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># phi_11 = \Gamma_1&#39; \Gamma_0^{-1}</span>
            <span class="c1"># phi_11 \Gamma_0 = \Gamma_1&#39;</span>
            <span class="c1"># \Gamma_0 phi_11&#39; = \Gamma_1</span>
            <span class="n">forwards</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">linalg</span><span class="o">.</span><span class="n">cho_solve</span><span class="p">(</span>
                <span class="p">(</span><span class="n">forward_factors</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="kc">True</span><span class="p">),</span> <span class="n">autocovariances</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
            <span class="c1"># backwards.append(forwards[-1])</span>
            <span class="c1"># phi_11_star = \Gamma_1 \Gamma_0^{-1}</span>
            <span class="c1"># phi_11_star \Gamma_0 = \Gamma_1</span>
            <span class="c1"># \Gamma_0 phi_11_star&#39; = \Gamma_1&#39;</span>
            <span class="n">backwards</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">linalg</span><span class="o">.</span><span class="n">cho_solve</span><span class="p">(</span>
                <span class="p">(</span><span class="n">backward_factors</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="kc">True</span><span class="p">),</span> <span class="n">autocovariances</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># G := \Gamma_{s+1}&#39; -</span>
            <span class="c1">#      \phi_{s,1} \Gamma_s&#39; - .. - \phi_{s,s} \Gamma_1&#39;</span>
            <span class="n">tmp_sum</span> <span class="o">=</span> <span class="n">autocovariances</span><span class="p">[</span><span class="n">s</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
                <span class="n">tmp_sum</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">prev_forwards</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">autocovariances</span><span class="p">[</span><span class="n">s</span><span class="o">-</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

            <span class="c1"># Create the &quot;last&quot; (k = s+1) matrix</span>
            <span class="c1"># Note: this is for k = s+1. However, below we then have to</span>
            <span class="c1"># fill in for k = 1, ..., s in order.</span>
            <span class="c1"># phi = G Sigma*^{-1}</span>
            <span class="c1"># phi Sigma* = G</span>
            <span class="c1"># Sigma*&#39; phi&#39; = G&#39;</span>
            <span class="c1"># Sigma* phi&#39; = G&#39;</span>
            <span class="c1"># (because Sigma* is symmetric)</span>
            <span class="n">forwards</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">linalg</span><span class="o">.</span><span class="n">cho_solve</span><span class="p">(</span>
                <span class="p">(</span><span class="n">backward_factors</span><span class="p">[</span><span class="n">s</span><span class="p">],</span> <span class="kc">True</span><span class="p">),</span> <span class="n">tmp_sum</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

            <span class="c1"># phi = G&#39; Sigma^{-1}</span>
            <span class="c1"># phi Sigma = G&#39;</span>
            <span class="c1"># Sigma&#39; phi&#39; = G</span>
            <span class="c1"># Sigma phi&#39; = G</span>
            <span class="c1"># (because Sigma is symmetric)</span>
            <span class="n">backwards</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">linalg</span><span class="o">.</span><span class="n">cho_solve</span><span class="p">(</span>
                <span class="p">(</span><span class="n">forward_factors</span><span class="p">[</span><span class="n">s</span><span class="p">],</span> <span class="kc">True</span><span class="p">),</span> <span class="n">tmp_sum</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

        <span class="c1"># Create the remaining k = 1, ..., s matrices,</span>
        <span class="c1"># only has an effect if s &gt;= 1</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
            <span class="n">forwards</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">prev_forwards</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
                <span class="n">forwards</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">prev_backwards</span><span class="p">[</span><span class="n">s</span><span class="o">-</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)]))</span>
            <span class="n">backwards</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">prev_backwards</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
                <span class="n">backwards</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">prev_forwards</span><span class="p">[</span><span class="n">s</span><span class="o">-</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)]))</span>

        <span class="c1"># Partial autocorrelation matrix: P_{s+1}</span>
        <span class="c1"># P = L^{-1} phi L*</span>
        <span class="c1"># L P = (phi L*)</span>
        <span class="n">partial_autocorrelations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve_triangular</span><span class="p">(</span>
            <span class="n">forward_factors</span><span class="p">[</span><span class="n">s</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">forwards</span><span class="p">[</span><span class="n">s</span><span class="p">],</span> <span class="n">backward_factors</span><span class="p">[</span><span class="n">s</span><span class="p">]),</span>
            <span class="n">lower</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">partial_autocorrelations</span>


<span class="k">def</span> <span class="nf">_compute_multivariate_pacf_from_coefficients</span><span class="p">(</span><span class="n">constrained</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span>
                                                 <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">k_endog</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Transform matrices corresponding to a stationary (or invertible) process</span>
<span class="sd">    to matrices with singular values less than one.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    constrained : array or list</span>
<span class="sd">        The coefficients matrices. If a list, should be a list of length</span>
<span class="sd">        `order`, where each element is an array sized `k_endog` x `k_endog`. If</span>
<span class="sd">        an array, should be the coefficient matrices horizontally concatenated</span>
<span class="sd">        and sized `k_endog` x `k_endog * order`.</span>
<span class="sd">    error_variance : array</span>
<span class="sd">        The variance / covariance matrix of the error term. Should be sized</span>
<span class="sd">        `k_endog` x `k_endog`.</span>
<span class="sd">    order : integer, optional</span>
<span class="sd">        The order of the autoregression.</span>
<span class="sd">    k_endog : integer, optional</span>
<span class="sd">        The dimension of the data vector.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    pacf : list</span>
<span class="sd">        List of first `order` multivariate partial autocorrelations.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Note that this computes multivariate partial autocorrelations.</span>

<span class="sd">    Corresponds to the inverse of Lemma 2.1 in Ansley and Kohn (1986). See</span>
<span class="sd">    `unconstrain_stationary_multivariate` for more details.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>

<span class="sd">    Coefficients are assumed to be provided from the VAR model:</span>

<span class="sd">    .. math::</span>
<span class="sd">        y_t = A_1 y_{t-1} + \dots + A_p y_{t-p} + \varepsilon_t</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">constrained</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span><span class="p">:</span>
        <span class="n">order</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">constrained</span><span class="p">)</span>
        <span class="n">k_endog</span> <span class="o">=</span> <span class="n">constrained</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">k_endog</span><span class="p">,</span> <span class="n">order</span> <span class="o">=</span> <span class="n">constrained</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">order</span> <span class="o">//=</span> <span class="n">k_endog</span>

    <span class="c1"># Get autocovariances for the process; these are defined to be</span>
    <span class="c1"># E z_t z_{t-j}&#39;</span>
    <span class="c1"># However, we want E z_t z_{t+j}&#39; = (E z_t z_{t-j}&#39;)&#39;</span>
    <span class="n">_acovf</span> <span class="o">=</span> <span class="n">_compute_multivariate_acovf_from_coefficients</span>

    <span class="n">autocovariances</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">autocovariance</span><span class="o">.</span><span class="n">T</span> <span class="k">for</span> <span class="n">autocovariance</span> <span class="ow">in</span>
        <span class="n">_acovf</span><span class="p">(</span><span class="n">constrained</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">maxlag</span><span class="o">=</span><span class="n">order</span><span class="p">)]</span>

    <span class="k">return</span> <span class="n">_compute_multivariate_pacf_from_autocovariances</span><span class="p">(</span><span class="n">autocovariances</span><span class="p">)</span>


<div class="viewcode-block" id="unconstrain_stationary_multivariate"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.tools.unconstrain_stationary_multivariate.html#statsmodels.tsa.statespace.tools.unconstrain_stationary_multivariate">[docs]</a><span class="k">def</span> <span class="nf">unconstrain_stationary_multivariate</span><span class="p">(</span><span class="n">constrained</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Transform constrained parameters used in likelihood evaluation</span>
<span class="sd">    to unconstrained parameters used by the optimizer</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    constrained : array or list</span>
<span class="sd">        Constrained parameters of, e.g., an autoregressive or moving average</span>
<span class="sd">        component, to be transformed to arbitrary parameters used by the</span>
<span class="sd">        optimizer. If a list, should be a list of length `order`, where each</span>
<span class="sd">        element is an array sized `k_endog` x `k_endog`. If an array, should be</span>
<span class="sd">        the coefficient matrices horizontally concatenated and sized</span>
<span class="sd">        `k_endog` x `k_endog * order`.</span>
<span class="sd">    error_variance : array</span>
<span class="sd">        The variance / covariance matrix of the error term. Should be sized</span>
<span class="sd">        `k_endog` x `k_endog`. This is used as input in the algorithm even if</span>
<span class="sd">        is not transformed by it (when `transform_variance` is False).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    unconstrained : array</span>
<span class="sd">        Unconstrained parameters used by the optimizer, to be transformed to</span>
<span class="sd">        stationary coefficients of, e.g., an autoregressive or moving average</span>
<span class="sd">        component. Will match the type of the passed `constrained`</span>
<span class="sd">        variable (so if a list was passed, a list will be returned).</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Uses the list representation internally, even if an array is passed.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [*] Ansley, Craig F., and Robert Kohn. 1986.</span>
<span class="sd">       &quot;A Note on Reparameterizing a Vector Autoregressive Moving Average Model</span>
<span class="sd">       to Enforce Stationarity.&quot;</span>
<span class="sd">       Journal of Statistical Computation and Simulation 24 (2): 99-106.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">use_list</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">constrained</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">use_list</span><span class="p">:</span>
        <span class="n">k_endog</span><span class="p">,</span> <span class="n">order</span> <span class="o">=</span> <span class="n">constrained</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">order</span> <span class="o">//=</span> <span class="n">k_endog</span>

        <span class="n">constrained</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">constrained</span><span class="p">[:</span><span class="n">k_endog</span><span class="p">,</span> <span class="n">i</span><span class="o">*</span><span class="n">k_endog</span><span class="p">:(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">k_endog</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">order</span><span class="p">)</span>
        <span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">order</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">constrained</span><span class="p">)</span>
        <span class="n">k_endog</span> <span class="o">=</span> <span class="n">constrained</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># Step 1: convert matrices from the space of stationary</span>
    <span class="c1"># coefficient matrices to our &quot;partial autocorrelation matrix&quot; space</span>
    <span class="c1"># (matrices with singular values less than one)</span>
    <span class="n">partial_autocorrelations</span> <span class="o">=</span> <span class="n">_compute_multivariate_pacf_from_coefficients</span><span class="p">(</span>
        <span class="n">constrained</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">k_endog</span><span class="p">)</span>

    <span class="c1"># Step 2: convert from arbitrary matrices to those with singular values</span>
    <span class="c1"># less than one.</span>
    <span class="n">unconstrained</span> <span class="o">=</span> <span class="n">_unconstrain_sv_less_than_one</span><span class="p">(</span>
        <span class="n">partial_autocorrelations</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">k_endog</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">use_list</span><span class="p">:</span>
        <span class="n">unconstrained</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">unconstrained</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">unconstrained</span><span class="p">,</span> <span class="n">error_variance</span></div>


<div class="viewcode-block" id="validate_matrix_shape"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.tools.validate_matrix_shape.html#statsmodels.tsa.statespace.tools.validate_matrix_shape">[docs]</a><span class="k">def</span> <span class="nf">validate_matrix_shape</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">nrows</span><span class="p">,</span> <span class="n">ncols</span><span class="p">,</span> <span class="n">nobs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Validate the shape of a possibly time-varying matrix, or raise an exception</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    name : str</span>
<span class="sd">        The name of the matrix being validated (used in exception messages)</span>
<span class="sd">    shape : array_like</span>
<span class="sd">        The shape of the matrix to be validated. May be of size 2 or (if</span>
<span class="sd">        the matrix is time-varying) 3.</span>
<span class="sd">    nrows : int</span>
<span class="sd">        The expected number of rows.</span>
<span class="sd">    ncols : int</span>
<span class="sd">        The expected number of columns.</span>
<span class="sd">    nobs : int</span>
<span class="sd">        The number of observations (used to validate the last dimension of a</span>
<span class="sd">        time-varying matrix)</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If the matrix is not of the desired shape.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ndim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>

    <span class="c1"># Enforce dimension</span>
    <span class="k">if</span> <span class="n">ndim</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid value for </span><span class="si">%s</span><span class="s1"> matrix. Requires a&#39;</span>
                         <span class="s1">&#39; 2- or 3-dimensional array, got </span><span class="si">%d</span><span class="s1"> dimensions&#39;</span> <span class="o">%</span>
                         <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">ndim</span><span class="p">))</span>
    <span class="c1"># Enforce the shape of the matrix</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">nrows</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid dimensions for </span><span class="si">%s</span><span class="s1"> matrix: requires </span><span class="si">%d</span><span class="s1">&#39;</span>
                         <span class="s1">&#39; rows, got </span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">nrows</span><span class="p">,</span> <span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">ncols</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid dimensions for </span><span class="si">%s</span><span class="s1"> matrix: requires </span><span class="si">%d</span><span class="s1">&#39;</span>
                         <span class="s1">&#39; columns, got </span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">ncols</span><span class="p">,</span> <span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

    <span class="c1"># If we don&#39;t yet know `nobs`, don&#39;t allow time-varying arrays</span>
    <span class="k">if</span> <span class="n">nobs</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">or</span> <span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid dimensions for </span><span class="si">%s</span><span class="s1"> matrix: time-varying&#39;</span>
                         <span class="s1">&#39; matrices cannot be given unless `nobs` is specified&#39;</span>
                         <span class="s1">&#39; (implicitly when a dataset is bound or else set&#39;</span>
                         <span class="s1">&#39; explicity)&#39;</span> <span class="o">%</span> <span class="n">name</span><span class="p">)</span>

    <span class="c1"># Enforce time-varying array size</span>
    <span class="k">if</span> <span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">and</span> <span class="n">nobs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">nobs</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid dimensions for time-varying </span><span class="si">%s</span><span class="s1">&#39;</span>
                         <span class="s1">&#39; matrix. Requires shape (*,*,</span><span class="si">%d</span><span class="s1">), got </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span>
                         <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">nobs</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">shape</span><span class="p">)))</span></div>


<div class="viewcode-block" id="validate_vector_shape"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.tools.validate_vector_shape.html#statsmodels.tsa.statespace.tools.validate_vector_shape">[docs]</a><span class="k">def</span> <span class="nf">validate_vector_shape</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">nrows</span><span class="p">,</span> <span class="n">nobs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Validate the shape of a possibly time-varying vector, or raise an exception</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    name : str</span>
<span class="sd">        The name of the vector being validated (used in exception messages)</span>
<span class="sd">    shape : array_like</span>
<span class="sd">        The shape of the vector to be validated. May be of size 1 or (if</span>
<span class="sd">        the vector is time-varying) 2.</span>
<span class="sd">    nrows : int</span>
<span class="sd">        The expected number of rows (elements of the vector).</span>
<span class="sd">    nobs : int</span>
<span class="sd">        The number of observations (used to validate the last dimension of a</span>
<span class="sd">        time-varying vector)</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If the vector is not of the desired shape.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ndim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
    <span class="c1"># Enforce dimension</span>
    <span class="k">if</span> <span class="n">ndim</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid value for </span><span class="si">%s</span><span class="s1"> vector. Requires a&#39;</span>
                         <span class="s1">&#39; 1- or 2-dimensional array, got </span><span class="si">%d</span><span class="s1"> dimensions&#39;</span> <span class="o">%</span>
                         <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">ndim</span><span class="p">))</span>
    <span class="c1"># Enforce the shape of the vector</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">nrows</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid dimensions for </span><span class="si">%s</span><span class="s1"> vector: requires </span><span class="si">%d</span><span class="s1">&#39;</span>
                         <span class="s1">&#39; rows, got </span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">nrows</span><span class="p">,</span> <span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

    <span class="c1"># If we don&#39;t yet know `nobs`, don&#39;t allow time-varying arrays</span>
    <span class="k">if</span> <span class="n">nobs</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid dimensions for </span><span class="si">%s</span><span class="s1"> vector: time-varying&#39;</span>
                         <span class="s1">&#39; vectors cannot be given unless `nobs` is specified&#39;</span>
                         <span class="s1">&#39; (implicitly when a dataset is bound or else set&#39;</span>
                         <span class="s1">&#39; explicity)&#39;</span> <span class="o">%</span> <span class="n">name</span><span class="p">)</span>

    <span class="c1"># Enforce time-varying array size</span>
    <span class="k">if</span> <span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">nobs</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid dimensions for time-varying </span><span class="si">%s</span><span class="s1">&#39;</span>
                         <span class="s1">&#39; vector. Requires shape (*,</span><span class="si">%d</span><span class="s1">), got </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span>
                         <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">nobs</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">shape</span><span class="p">)))</span></div>


<span class="k">def</span> <span class="nf">reorder_missing_matrix</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">missing</span><span class="p">,</span> <span class="n">reorder_rows</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                           <span class="n">reorder_cols</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">is_diagonal</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                           <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Reorder the rows or columns of a time-varying matrix where all non-missing</span>
<span class="sd">    values are in the upper left corner of the matrix.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    matrix : array_like</span>
<span class="sd">        The matrix to be reordered. Must have shape (n, m, nobs).</span>
<span class="sd">    missing : array_like of bool</span>
<span class="sd">        The vector of missing indices. Must have shape (k, nobs) where `k = n`</span>
<span class="sd">        if `reorder_rows is True` and `k = m` if `reorder_cols is True`.</span>
<span class="sd">    reorder_rows : bool, optional</span>
<span class="sd">        Whether or not the rows of the matrix should be re-ordered. Default</span>
<span class="sd">        is False.</span>
<span class="sd">    reorder_cols : bool, optional</span>
<span class="sd">        Whether or not the columns of the matrix should be re-ordered. Default</span>
<span class="sd">        is False.</span>
<span class="sd">    is_diagonal : bool, optional</span>
<span class="sd">        Whether or not the matrix is diagonal. If this is True, must also have</span>
<span class="sd">        `n = m`. Default is False.</span>
<span class="sd">    inplace : bool, optional</span>
<span class="sd">        Whether or not to reorder the matrix in-place.</span>
<span class="sd">    prefix : {&#39;s&#39;, &#39;d&#39;, &#39;c&#39;, &#39;z&#39;}, optional</span>
<span class="sd">        The Fortran prefix of the vector. Default is to automatically detect</span>
<span class="sd">        the dtype. This parameter should only be used with caution.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    reordered_matrix : array_like</span>
<span class="sd">        The reordered matrix.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">prefix</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">prefix</span> <span class="o">=</span> <span class="n">find_best_blas_type</span><span class="p">((</span><span class="n">matrix</span><span class="p">,))[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">reorder</span> <span class="o">=</span> <span class="n">prefix_reorder_missing_matrix_map</span><span class="p">[</span><span class="n">prefix</span><span class="p">]</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">inplace</span><span class="p">:</span>
        <span class="n">matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>

    <span class="n">reorder</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">asfortranarray</span><span class="p">(</span><span class="n">missing</span><span class="p">),</span> <span class="n">reorder_rows</span><span class="p">,</span> <span class="n">reorder_cols</span><span class="p">,</span>
            <span class="n">is_diagonal</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">matrix</span>


<span class="k">def</span> <span class="nf">reorder_missing_vector</span><span class="p">(</span><span class="n">vector</span><span class="p">,</span> <span class="n">missing</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Reorder the elements of a time-varying vector where all non-missing</span>
<span class="sd">    values are in the first elements of the vector.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    vector : array_like</span>
<span class="sd">        The vector to be reordered. Must have shape (n, nobs).</span>
<span class="sd">    missing : array_like of bool</span>
<span class="sd">        The vector of missing indices. Must have shape (n, nobs).</span>
<span class="sd">    inplace : bool, optional</span>
<span class="sd">        Whether or not to reorder the matrix in-place. Default is False.</span>
<span class="sd">    prefix : {&#39;s&#39;, &#39;d&#39;, &#39;c&#39;, &#39;z&#39;}, optional</span>
<span class="sd">        The Fortran prefix of the vector. Default is to automatically detect</span>
<span class="sd">        the dtype. This parameter should only be used with caution.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    reordered_vector : array_like</span>
<span class="sd">        The reordered vector.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">prefix</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">prefix</span> <span class="o">=</span> <span class="n">find_best_blas_type</span><span class="p">((</span><span class="n">vector</span><span class="p">,))[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">reorder</span> <span class="o">=</span> <span class="n">prefix_reorder_missing_vector_map</span><span class="p">[</span><span class="n">prefix</span><span class="p">]</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">inplace</span><span class="p">:</span>
        <span class="n">vector</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">vector</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>

    <span class="n">reorder</span><span class="p">(</span><span class="n">vector</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">asfortranarray</span><span class="p">(</span><span class="n">missing</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">vector</span>


<span class="k">def</span> <span class="nf">copy_missing_matrix</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">missing</span><span class="p">,</span> <span class="n">missing_rows</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">missing_cols</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                        <span class="n">is_diagonal</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Copy the rows or columns of a time-varying matrix where all non-missing</span>
<span class="sd">    values are in the upper left corner of the matrix.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    A : array_like</span>
<span class="sd">        The matrix from which to copy. Must have shape (n, m, nobs) or</span>
<span class="sd">        (n, m, 1).</span>
<span class="sd">    B : array_like</span>
<span class="sd">        The matrix to copy to. Must have shape (n, m, nobs).</span>
<span class="sd">    missing : array_like of bool</span>
<span class="sd">        The vector of missing indices. Must have shape (k, nobs) where `k = n`</span>
<span class="sd">        if `reorder_rows is True` and `k = m` if `reorder_cols is True`.</span>
<span class="sd">    missing_rows : bool, optional</span>
<span class="sd">        Whether or not the rows of the matrix are a missing dimension. Default</span>
<span class="sd">        is False.</span>
<span class="sd">    missing_cols : bool, optional</span>
<span class="sd">        Whether or not the columns of the matrix are a missing dimension.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    is_diagonal : bool, optional</span>
<span class="sd">        Whether or not the matrix is diagonal. If this is True, must also have</span>
<span class="sd">        `n = m`. Default is False.</span>
<span class="sd">    inplace : bool, optional</span>
<span class="sd">        Whether or not to copy to B in-place. Default is False.</span>
<span class="sd">    prefix : {&#39;s&#39;, &#39;d&#39;, &#39;c&#39;, &#39;z&#39;}, optional</span>
<span class="sd">        The Fortran prefix of the vector. Default is to automatically detect</span>
<span class="sd">        the dtype. This parameter should only be used with caution.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    copied_matrix : array_like</span>
<span class="sd">        The matrix B with the non-missing submatrix of A copied onto it.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">prefix</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">prefix</span> <span class="o">=</span> <span class="n">find_best_blas_type</span><span class="p">((</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">copy</span> <span class="o">=</span> <span class="n">prefix_copy_missing_matrix_map</span><span class="p">[</span><span class="n">prefix</span><span class="p">]</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">inplace</span><span class="p">:</span>
        <span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>

    <span class="c1"># We may have been given an F-contiguous memoryview; in that case, we don&#39;t</span>
    <span class="c1"># want to alter it or convert it to a numpy array</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">A</span><span class="o">.</span><span class="n">is_f_contig</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">()</span>
    <span class="k">except</span> <span class="p">(</span><span class="ne">AttributeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">):</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asfortranarray</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>

    <span class="n">copy</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">asfortranarray</span><span class="p">(</span><span class="n">missing</span><span class="p">),</span> <span class="n">missing_rows</span><span class="p">,</span> <span class="n">missing_cols</span><span class="p">,</span>
         <span class="n">is_diagonal</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">B</span>


<span class="k">def</span> <span class="nf">copy_missing_vector</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">missing</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Reorder the elements of a time-varying vector where all non-missing</span>
<span class="sd">    values are in the first elements of the vector.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        The vector from which to copy. Must have shape (n, nobs) or (n, 1).</span>
<span class="sd">    b : array_like</span>
<span class="sd">        The vector to copy to. Must have shape (n, nobs).</span>
<span class="sd">    missing : array_like of bool</span>
<span class="sd">        The vector of missing indices. Must have shape (n, nobs).</span>
<span class="sd">    inplace : bool, optional</span>
<span class="sd">        Whether or not to copy to b in-place. Default is False.</span>
<span class="sd">    prefix : {&#39;s&#39;, &#39;d&#39;, &#39;c&#39;, &#39;z&#39;}, optional</span>
<span class="sd">        The Fortran prefix of the vector. Default is to automatically detect</span>
<span class="sd">        the dtype. This parameter should only be used with caution.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    copied_vector : array_like</span>
<span class="sd">        The vector b with the non-missing subvector of b copied onto it.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">prefix</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">prefix</span> <span class="o">=</span> <span class="n">find_best_blas_type</span><span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">copy</span> <span class="o">=</span> <span class="n">prefix_copy_missing_vector_map</span><span class="p">[</span><span class="n">prefix</span><span class="p">]</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">inplace</span><span class="p">:</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>

    <span class="c1"># We may have been given an F-contiguous memoryview; in that case, we don&#39;t</span>
    <span class="c1"># want to alter it or convert it to a numpy array</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">a</span><span class="o">.</span><span class="n">is_f_contig</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">()</span>
    <span class="k">except</span> <span class="p">(</span><span class="ne">AttributeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">):</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asfortranarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

    <span class="n">copy</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">asfortranarray</span><span class="p">(</span><span class="n">missing</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">b</span>


<span class="k">def</span> <span class="nf">copy_index_matrix</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">index_rows</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">index_cols</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                      <span class="n">is_diagonal</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Copy the rows or columns of a time-varying matrix where all non-index</span>
<span class="sd">    values are in the upper left corner of the matrix.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    A : array_like</span>
<span class="sd">        The matrix from which to copy. Must have shape (n, m, nobs) or</span>
<span class="sd">        (n, m, 1).</span>
<span class="sd">    B : array_like</span>
<span class="sd">        The matrix to copy to. Must have shape (n, m, nobs).</span>
<span class="sd">    index : array_like of bool</span>
<span class="sd">        The vector of index indices. Must have shape (k, nobs) where `k = n`</span>
<span class="sd">        if `reorder_rows is True` and `k = m` if `reorder_cols is True`.</span>
<span class="sd">    index_rows : bool, optional</span>
<span class="sd">        Whether or not the rows of the matrix are a index dimension. Default</span>
<span class="sd">        is False.</span>
<span class="sd">    index_cols : bool, optional</span>
<span class="sd">        Whether or not the columns of the matrix are a index dimension.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    is_diagonal : bool, optional</span>
<span class="sd">        Whether or not the matrix is diagonal. If this is True, must also have</span>
<span class="sd">        `n = m`. Default is False.</span>
<span class="sd">    inplace : bool, optional</span>
<span class="sd">        Whether or not to copy to B in-place. Default is False.</span>
<span class="sd">    prefix : {&#39;s&#39;, &#39;d&#39;, &#39;c&#39;, &#39;z&#39;}, optional</span>
<span class="sd">        The Fortran prefix of the vector. Default is to automatically detect</span>
<span class="sd">        the dtype. This parameter should only be used with caution.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    copied_matrix : array_like</span>
<span class="sd">        The matrix B with the non-index submatrix of A copied onto it.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">prefix</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">prefix</span> <span class="o">=</span> <span class="n">find_best_blas_type</span><span class="p">((</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">copy</span> <span class="o">=</span> <span class="n">prefix_copy_index_matrix_map</span><span class="p">[</span><span class="n">prefix</span><span class="p">]</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">inplace</span><span class="p">:</span>
        <span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>

    <span class="c1"># We may have been given an F-contiguous memoryview; in that case, we don&#39;t</span>
    <span class="c1"># want to alter it or convert it to a numpy array</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">A</span><span class="o">.</span><span class="n">is_f_contig</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">()</span>
    <span class="k">except</span> <span class="p">(</span><span class="ne">AttributeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">):</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asfortranarray</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>

    <span class="n">copy</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">asfortranarray</span><span class="p">(</span><span class="n">index</span><span class="p">),</span> <span class="n">index_rows</span><span class="p">,</span> <span class="n">index_cols</span><span class="p">,</span>
         <span class="n">is_diagonal</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">B</span>


<span class="k">def</span> <span class="nf">copy_index_vector</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Reorder the elements of a time-varying vector where all non-index</span>
<span class="sd">    values are in the first elements of the vector.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        The vector from which to copy. Must have shape (n, nobs) or (n, 1).</span>
<span class="sd">    b : array_like</span>
<span class="sd">        The vector to copy to. Must have shape (n, nobs).</span>
<span class="sd">    index : array_like of bool</span>
<span class="sd">        The vector of index indices. Must have shape (n, nobs).</span>
<span class="sd">    inplace : bool, optional</span>
<span class="sd">        Whether or not to copy to b in-place. Default is False.</span>
<span class="sd">    prefix : {&#39;s&#39;, &#39;d&#39;, &#39;c&#39;, &#39;z&#39;}, optional</span>
<span class="sd">        The Fortran prefix of the vector. Default is to automatically detect</span>
<span class="sd">        the dtype. This parameter should only be used with caution.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    copied_vector : array_like</span>
<span class="sd">        The vector b with the non-index subvector of b copied onto it.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">prefix</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">prefix</span> <span class="o">=</span> <span class="n">find_best_blas_type</span><span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">copy</span> <span class="o">=</span> <span class="n">prefix_copy_index_vector_map</span><span class="p">[</span><span class="n">prefix</span><span class="p">]</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">inplace</span><span class="p">:</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>

    <span class="c1"># We may have been given an F-contiguous memoryview; in that case, we don&#39;t</span>
    <span class="c1"># want to alter it or convert it to a numpy array</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">a</span><span class="o">.</span><span class="n">is_f_contig</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">()</span>
    <span class="k">except</span> <span class="p">(</span><span class="ne">AttributeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">):</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asfortranarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

    <span class="n">copy</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">asfortranarray</span><span class="p">(</span><span class="n">index</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">b</span>


<span class="k">def</span> <span class="nf">prepare_exog</span><span class="p">(</span><span class="n">exog</span><span class="p">):</span>
    <span class="n">k_exog</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">exog</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">exog_is_using_pandas</span> <span class="o">=</span> <span class="n">_is_using_pandas</span><span class="p">(</span><span class="n">exog</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">exog_is_using_pandas</span><span class="p">:</span>
            <span class="n">exog</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">exog</span><span class="p">)</span>

        <span class="c1"># Make sure we have 2-dimensional array</span>
        <span class="k">if</span> <span class="n">exog</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">exog_is_using_pandas</span><span class="p">:</span>
                <span class="n">exog</span> <span class="o">=</span> <span class="n">exog</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">exog</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">exog</span><span class="p">)</span>

        <span class="n">k_exog</span> <span class="o">=</span> <span class="n">exog</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">k_exog</span><span class="p">,</span> <span class="n">exog</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">prepare_trend_spec</span><span class="p">(</span><span class="n">trend</span><span class="p">):</span>
    <span class="c1"># Trend</span>
    <span class="k">if</span> <span class="n">trend</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">trend</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;n&#39;</span><span class="p">,</span> <span class="s1">&#39;nc&#39;</span><span class="p">]:</span>
        <span class="n">polynomial_trend</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">0</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">trend</span> <span class="o">==</span> <span class="s1">&#39;nc&#39;</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Argument option trend=&#39;nc&#39; is deprecated. Please&quot;</span>
                          <span class="s2">&quot; use option trend=&#39;n&#39;.&quot;</span><span class="p">,</span> <span class="ne">DeprecationWarning</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">trend</span> <span class="o">==</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span>
        <span class="n">polynomial_trend</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">elif</span> <span class="n">trend</span> <span class="o">==</span> <span class="s1">&#39;t&#39;</span><span class="p">:</span>
        <span class="n">polynomial_trend</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="k">elif</span> <span class="n">trend</span> <span class="o">==</span> <span class="s1">&#39;ct&#39;</span><span class="p">:</span>
        <span class="n">polynomial_trend</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="k">elif</span> <span class="n">trend</span> <span class="o">==</span> <span class="s1">&#39;ctt&#39;</span><span class="p">:</span>
        <span class="c1"># TODO deprecate ctt?</span>
        <span class="n">polynomial_trend</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">trend</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">trend</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">trend</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">polynomial_trend</span> <span class="o">=</span> <span class="p">(</span><span class="n">trend</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid trend method.&#39;</span><span class="p">)</span>

    <span class="c1"># Note: k_trend is not the degree of the trend polynomial, because e.g.</span>
    <span class="c1"># k_trend = 1 corresponds to the degree zero polynomial (with only a</span>
    <span class="c1"># constant term).</span>
    <span class="n">k_trend</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">polynomial_trend</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">polynomial_trend</span><span class="p">,</span> <span class="n">k_trend</span>


<span class="k">def</span> <span class="nf">prepare_trend_data</span><span class="p">(</span><span class="n">polynomial_trend</span><span class="p">,</span> <span class="n">k_trend</span><span class="p">,</span> <span class="n">nobs</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="c1"># Cache the arrays for calculating the intercept from the trend</span>
    <span class="c1"># components</span>
    <span class="n">time_trend</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="n">nobs</span> <span class="o">+</span> <span class="n">offset</span><span class="p">)</span>
    <span class="n">trend_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nobs</span><span class="p">,</span> <span class="n">k_trend</span><span class="p">))</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">polynomial_trend</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">trend_data</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">nobs</span><span class="p">,)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">trend_data</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">time_trend</span><span class="o">**</span><span class="n">k</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">trend_data</span>
</pre></div>




          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2009-2018, Josef Perktold, Skipper Seabold, Jonathan Taylor, statsmodels-developers.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.1.2.
    </div>
  </body>
</html>