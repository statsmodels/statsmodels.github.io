


<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      <link rel="icon" href="../../../../_static/favicon.ico">
    
    
  
      
        <title>statsmodels.tsa.statespace.mlemodel - statsmodels 0.14.3</title>
      
    
  <link rel="icon" type="image/png" sizes="32x32" href="../../../../_static/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="../../../../_static/icons/favicon-16x16.png">
  <link rel="manifest" href="../../../../_static/icons/site.webmanifest">
  <link rel="mask-icon" href="../../../../_static/icons/safari-pinned-tab.svg" color="#919191">
  <meta name="msapplication-TileColor" content="#2b5797">
  <meta name="msapplication-config" content="../../../../_static/icons/browserconfig.xml">
  <link rel="stylesheet" href="../../../../_static/stylesheets/examples.css">
  <link rel="stylesheet" href="../../../../_static/stylesheets/deprecation.css">
    
      
        
        
          
          
          <meta name="theme-color" content="#4051b5">
        
      
      

    
    
    
      
        
        
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
        <link rel="stylesheet" type="text/css" href="../../../../_static/sphinx_immaterial_theme.3625f807144f53acf.min.css?v=fbfc4466" />
        <link rel="stylesheet" type="text/css" href="../../../../_static/graphviz.css?v=fd3f3429" />
        <link rel="stylesheet" type="text/css" href="../../../../_static/plot_directive.css" />
    <script>__md_scope=new URL("../../../..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="" data-md-color-primary="indigo" data-md-color-accent="blue">
  
    
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
      <div data-md-component="outdated" hidden>
        
      </div>
    
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../../../../index.html" title="statsmodels 0.14.3" class="md-header__button md-logo" aria-label="statsmodels 0.14.3" data-md-component="logo">
      <img src="../../../../_static/statsmodels-logo-v2-bw.svg" alt="logo">
    </a>
    <label class="md-header__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            statsmodels 0.14.3
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              statsmodels.tsa.statespace.mlemodel
            
          </span>
        </div>
      </div>
    </div>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header__source">
        <a href="https://github.com/statsmodels/statsmodels/" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc.--><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg>
  </div>
  <div class="md-source__repository">
    statsmodels
  </div>
</a>
      </div>
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../../../../index.html" title="statsmodels 0.14.3" class="md-nav__button md-logo" aria-label="statsmodels 0.14.3" data-md-component="logo">
      <img src="../../../../_static/statsmodels-logo-v2-bw.svg" alt="logo">
    </a>
    statsmodels 0.14.3
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/statsmodels/statsmodels/" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc.--><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg>
  </div>
  <div class="md-source__repository">
    statsmodels
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      

  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../install.html" class="md-nav__link">
        <span title="/install.rst (reference label)" class="md-ellipsis">Installing statsmodels</span>
      </a>
    </li>
  

    
      
      
      

  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../gettingstarted.html" class="md-nav__link">
        <span title="/gettingstarted.rst (reference label)" class="md-ellipsis">Getting started</span>
      </a>
    </li>
  

    
      
      
      

  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../user-guide.html" class="md-nav__link">
        <span title="/user-guide.rst (reference label)" class="md-ellipsis">User Guide</span>
      </a>
    </li>
  

    
      
      
      

  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../examples/index.html" class="md-nav__link">
        <span title="/examples/index.rst (reference label)" class="md-ellipsis">Examples</span>
      </a>
    </li>
  

    
      
      
      

  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../api.html" class="md-nav__link">
        <span title="/api.rst (reference label)" class="md-ellipsis">API Reference</span>
      </a>
    </li>
  

    
      
      
      

  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../about.html" class="md-nav__link">
        <span title="/about.rst (reference label)" class="md-ellipsis">About statsmodels</span>
      </a>
    </li>
  

    
      
      
      

  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../dev/index.html" class="md-nav__link">
        <span title="/dev/index.rst (reference label)" class="md-ellipsis">Developer Page</span>
      </a>
    </li>
  

    
      
      
      

  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../release/index.html" class="md-nav__link">
        <span title="/release/index.rst (reference label)" class="md-ellipsis">Release Notes</span>
      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

  

<nav class="md-nav md-nav--secondary">
  
  
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset" role="main">
                  


<h1>Source code for statsmodels.tsa.statespace.mlemodel</h1><div class="highlight"><pre>
<span></span><code><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">State Space Model</span>

<span class="sd">Author: Chad Fulton</span>
<span class="sd">License: Simplified-BSD</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">statsmodels.compat.pandas</span> <span class="kn">import</span> <span class="n">is_int_index</span>

<span class="kn">import</span> <span class="nn">contextlib</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">import</span> <span class="nn">datetime</span> <span class="k">as</span> <span class="nn">dt</span>
<span class="kn">from</span> <span class="nn">types</span> <span class="kn">import</span> <span class="n">SimpleNamespace</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">norm</span>

<span class="kn">from</span> <span class="nn">statsmodels.tools.tools</span> <span class="kn">import</span> <span class="n">pinv_extended</span><span class="p">,</span> <span class="n">Bunch</span>
<span class="kn">from</span> <span class="nn">statsmodels.tools.sm_exceptions</span> <span class="kn">import</span> <span class="n">PrecisionWarning</span><span class="p">,</span> <span class="n">ValueWarning</span>
<span class="kn">from</span> <span class="nn">statsmodels.tools.numdiff</span> <span class="kn">import</span> <span class="p">(</span><span class="n">_get_epsilon</span><span class="p">,</span> <span class="n">approx_hess_cs</span><span class="p">,</span>
                                       <span class="n">approx_fprime_cs</span><span class="p">,</span> <span class="n">approx_fprime</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">statsmodels.tools.decorators</span> <span class="kn">import</span> <span class="n">cache_readonly</span>
<span class="kn">from</span> <span class="nn">statsmodels.tools.eval_measures</span> <span class="kn">import</span> <span class="n">aic</span><span class="p">,</span> <span class="n">aicc</span><span class="p">,</span> <span class="n">bic</span><span class="p">,</span> <span class="n">hqic</span>

<span class="kn">import</span> <span class="nn">statsmodels.base.wrapper</span> <span class="k">as</span> <span class="nn">wrap</span>

<span class="kn">import</span> <span class="nn">statsmodels.tsa.base.prediction</span> <span class="k">as</span> <span class="nn">pred</span>

<span class="kn">from</span> <span class="nn">statsmodels.base.data</span> <span class="kn">import</span> <span class="n">PandasData</span>
<span class="kn">import</span> <span class="nn">statsmodels.tsa.base.tsa_model</span> <span class="k">as</span> <span class="nn">tsbase</span>

<span class="kn">from</span> <span class="nn">.news</span> <span class="kn">import</span> <span class="n">NewsResults</span>
<span class="kn">from</span> <span class="nn">.simulation_smoother</span> <span class="kn">import</span> <span class="n">SimulationSmoother</span>
<span class="kn">from</span> <span class="nn">.kalman_smoother</span> <span class="kn">import</span> <span class="n">SmootherResults</span>
<span class="kn">from</span> <span class="nn">.kalman_filter</span> <span class="kn">import</span> <span class="n">INVERT_UNIVARIATE</span><span class="p">,</span> <span class="n">SOLVE_LU</span><span class="p">,</span> <span class="n">MEMORY_CONSERVE</span>
<span class="kn">from</span> <span class="nn">.initialization</span> <span class="kn">import</span> <span class="n">Initialization</span>
<span class="kn">from</span> <span class="nn">.tools</span> <span class="kn">import</span> <span class="n">prepare_exog</span><span class="p">,</span> <span class="n">concat</span><span class="p">,</span> <span class="n">_safe_cond</span><span class="p">,</span> <span class="n">get_impact_dates</span>


<span class="k">def</span> <span class="nf">_handle_args</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">defaults</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">output_args</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># We need to handle positional arguments in two ways, in case this was</span>
    <span class="c1"># called by a Scipy optimization routine</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># the fit() method will pass a dictionary</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">flags</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># otherwise, a user may have just used positional arguments...</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">flags</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">args</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">names</span><span class="p">)):</span>
            <span class="n">output_args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">flags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">names</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">defaults</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>

        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">flags</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;loglike() got multiple values for keyword&quot;</span>
                                <span class="s2">&quot; argument &#39;</span><span class="si">%s</span><span class="s2">&#39;&quot;</span> <span class="o">%</span> <span class="n">name</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">names</span><span class="p">)):</span>
            <span class="n">output_args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">names</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">defaults</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>

    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">output_args</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">kwargs</span><span class="p">,)</span>


<span class="k">def</span> <span class="nf">_check_index</span><span class="p">(</span><span class="n">desired_index</span><span class="p">,</span> <span class="n">dta</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s1">&#39;data&#39;</span><span class="p">):</span>
    <span class="n">given_index</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dta</span><span class="p">,</span> <span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">)):</span>
        <span class="n">given_index</span> <span class="o">=</span> <span class="n">dta</span><span class="o">.</span><span class="n">index</span>
    <span class="k">if</span> <span class="n">given_index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">desired_index</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">given_index</span><span class="p">):</span>
        <span class="n">desired_freq</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">desired_index</span><span class="p">,</span> <span class="s1">&#39;freq&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">given_freq</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">given_index</span><span class="p">,</span> <span class="s1">&#39;freq&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">desired_freq</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">given_freq</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span>
                <span class="n">desired_freq</span> <span class="o">!=</span> <span class="n">given_freq</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Given </span><span class="si">%s</span><span class="s1"> does not have an index&#39;</span>
                             <span class="s1">&#39; that extends the index of the&#39;</span>
                             <span class="s1">&#39; model. Expected index frequency is&#39;</span>
                             <span class="s1">&#39; &quot;</span><span class="si">%s</span><span class="s1">&quot;, but got &quot;</span><span class="si">%s</span><span class="s1">&quot;.&#39;</span>
                             <span class="o">%</span> <span class="p">(</span><span class="n">title</span><span class="p">,</span> <span class="n">desired_freq</span><span class="p">,</span> <span class="n">given_freq</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Given </span><span class="si">%s</span><span class="s1"> does not have an index&#39;</span>
                             <span class="s1">&#39; that extends the index of the&#39;</span>
                             <span class="s1">&#39; model.&#39;</span> <span class="o">%</span> <span class="n">title</span><span class="p">)</span>


<div class="viewcode-block" id="MLEModel">
<a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEModel.html#statsmodels.tsa.statespace.mlemodel.MLEModel">[docs]</a>
<span class="k">class</span> <span class="nc">MLEModel</span><span class="p">(</span><span class="n">tsbase</span><span class="o">.</span><span class="n">TimeSeriesModel</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    State space model for maximum likelihood estimation</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    endog : array_like</span>
<span class="sd">        The observed time-series process :math:`y`</span>
<span class="sd">    k_states : int</span>
<span class="sd">        The dimension of the unobserved state process.</span>
<span class="sd">    exog : array_like, optional</span>
<span class="sd">        Array of exogenous regressors, shaped nobs x k. Default is no</span>
<span class="sd">        exogenous regressors.</span>
<span class="sd">    dates : array_like of datetime, optional</span>
<span class="sd">        An array-like object of datetime objects. If a Pandas object is given</span>
<span class="sd">        for endog, it is assumed to have a DateIndex.</span>
<span class="sd">    freq : str, optional</span>
<span class="sd">        The frequency of the time-series. A Pandas offset or &#39;B&#39;, &#39;D&#39;, &#39;W&#39;,</span>
<span class="sd">        &#39;M&#39;, &#39;A&#39;, or &#39;Q&#39;. This is optional if dates are given.</span>
<span class="sd">    **kwargs</span>
<span class="sd">        Keyword arguments may be used to provide default values for state space</span>
<span class="sd">        matrices or for Kalman filtering options. See `Representation`, and</span>
<span class="sd">        `KalmanFilter` for more details.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    ssm : statsmodels.tsa.statespace.kalman_filter.KalmanFilter</span>
<span class="sd">        Underlying state space representation.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    statsmodels.tsa.statespace.mlemodel.MLEResults</span>
<span class="sd">    statsmodels.tsa.statespace.kalman_filter.KalmanFilter</span>
<span class="sd">    statsmodels.tsa.statespace.representation.Representation</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This class wraps the state space model with Kalman filtering to add in</span>
<span class="sd">    functionality for maximum likelihood estimation. In particular, it adds</span>
<span class="sd">    the concept of updating the state space representation based on a defined</span>
<span class="sd">    set of parameters, through the `update` method or `updater` attribute (see</span>
<span class="sd">    below for more details on which to use when), and it adds a `fit` method</span>
<span class="sd">    which uses a numerical optimizer to select the parameters that maximize</span>
<span class="sd">    the likelihood of the model.</span>

<span class="sd">    The `start_params` `update` method must be overridden in the</span>
<span class="sd">    child class (and the `transform` and `untransform` methods, if needed).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">endog</span><span class="p">,</span> <span class="n">k_states</span><span class="p">,</span> <span class="n">exog</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dates</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># Initialize the model base</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">endog</span><span class="o">=</span><span class="n">endog</span><span class="p">,</span> <span class="n">exog</span><span class="o">=</span><span class="n">exog</span><span class="p">,</span>
                         <span class="n">dates</span><span class="o">=</span><span class="n">dates</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="n">freq</span><span class="p">,</span>
                         <span class="n">missing</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">)</span>

        <span class="c1"># Store kwargs to recreate model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_init_kwargs</span> <span class="o">=</span> <span class="n">kwargs</span>

        <span class="c1"># Prepared the endog array: C-ordered, shape=(nobs x k_endog)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">endog</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">exog</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prepare_data</span><span class="p">()</span>

        <span class="c1"># Dimensions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">endog</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k_states</span> <span class="o">=</span> <span class="n">k_states</span>

        <span class="c1"># Initialize the state-space representation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initialize_statespace</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Setup holder for fixed parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_has_fixed_params</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fixed_params</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_params_index</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fixed_params_index</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_free_params_index</span> <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="MLEModel.prepare_data">
<a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEModel.prepare_data.html#statsmodels.tsa.statespace.mlemodel.MLEModel.prepare_data">[docs]</a>
    <span class="k">def</span> <span class="nf">prepare_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Prepare data for use in the state space representation</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">endog</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">require</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">orig_endog</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span> <span class="n">requirements</span><span class="o">=</span><span class="s2">&quot;CW&quot;</span>
        <span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">exog</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">orig_exog</span>
        <span class="k">if</span> <span class="n">exog</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">exog</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">exog</span><span class="p">)</span>

        <span class="c1"># Base class may allow 1-dim data, whereas we need 2-dim</span>
        <span class="k">if</span> <span class="n">endog</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">endog</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">endog</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># this will be C-contiguous</span>

        <span class="k">return</span> <span class="n">endog</span><span class="p">,</span> <span class="n">exog</span></div>


<div class="viewcode-block" id="MLEModel.initialize_statespace">
<a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEModel.initialize_statespace.html#statsmodels.tsa.statespace.mlemodel.MLEModel.initialize_statespace">[docs]</a>
    <span class="k">def</span> <span class="nf">initialize_statespace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the state space representation</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Additional keyword arguments to pass to the state space class</span>
<span class="sd">            constructor.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># (Now self.endog is C-ordered and in long format (nobs x k_endog). To</span>
        <span class="c1"># get F-ordered and in wide format just need to transpose)</span>
        <span class="n">endog</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">endog</span><span class="o">.</span><span class="n">T</span>

        <span class="c1"># Instantiate the state space object</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span> <span class="o">=</span> <span class="n">SimulationSmoother</span><span class="p">(</span><span class="n">endog</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_states</span><span class="p">,</span>
                                      <span class="n">nobs</span><span class="o">=</span><span class="n">endog</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c1"># Bind the data to the model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">endog</span><span class="p">)</span>

        <span class="c1"># Other dimensions, now that `ssm` is available</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">k_endog</span></div>


    <span class="k">def</span> <span class="nf">_get_index_with_final_state</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># The index we inherit from `TimeSeriesModel` will only cover the</span>
        <span class="c1"># data sample itself, but we will also need an index value for the</span>
        <span class="c1"># final state which is the next time step to the last datapoint.</span>
        <span class="c1"># This method figures out an appropriate value for the three types of</span>
        <span class="c1"># supported indexes: date-based, Int64Index, or RangeIndex</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index_dates</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DatetimeIndex</span><span class="p">):</span>
                <span class="n">index</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">date_range</span><span class="p">(</span>
                    <span class="n">start</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">periods</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                    <span class="n">freq</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="o">.</span><span class="n">freq</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">PeriodIndex</span><span class="p">):</span>
                <span class="n">index</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">period_range</span><span class="p">(</span>
                    <span class="n">start</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">periods</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                    <span class="n">freq</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="o">.</span><span class="n">freq</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">RangeIndex</span><span class="p">):</span>
            <span class="c1"># COMPAT: pd.RangeIndex does not have start, stop, step prior to</span>
            <span class="c1">#         pandas 0.25</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="o">.</span><span class="n">start</span>
                <span class="n">stop</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="o">.</span><span class="n">stop</span>
                <span class="n">step</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="o">.</span><span class="n">step</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="n">start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="o">.</span><span class="n">_start</span>
                <span class="n">stop</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="o">.</span><span class="n">_stop</span>
                <span class="n">step</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="o">.</span><span class="n">_step</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">RangeIndex</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span> <span class="o">+</span> <span class="n">step</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">is_int_index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">):</span>
            <span class="c1"># The only valid Int64Index is a full, incrementing index, so this</span>
            <span class="c1"># is general</span>
            <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="o">+</span> <span class="p">[</span><span class="n">value</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span>
        <span class="k">return</span> <span class="n">index</span>

    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="fm">__setitem__</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_init_kwds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Get keywords based on model attributes</span>
        <span class="n">kwds</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_get_init_kwds</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">kwds</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
                <span class="n">kwds</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">kwds</span>

<div class="viewcode-block" id="MLEModel.clone">
<a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEModel.clone.html#statsmodels.tsa.statespace.mlemodel.MLEModel.clone">[docs]</a>
    <span class="k">def</span> <span class="nf">clone</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">endog</span><span class="p">,</span> <span class="n">exog</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Clone state space model with new data and optionally new specification</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        endog : array_like</span>
<span class="sd">            The observed time-series process :math:`y`</span>
<span class="sd">        k_states : int</span>
<span class="sd">            The dimension of the unobserved state process.</span>
<span class="sd">        exog : array_like, optional</span>
<span class="sd">            Array of exogenous regressors, shaped nobs x k. Default is no</span>
<span class="sd">            exogenous regressors.</span>
<span class="sd">        kwargs</span>
<span class="sd">            Keyword arguments to pass to the new model class to change the</span>
<span class="sd">            model specification.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        model : MLEModel subclass</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method must be implemented</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;This method is not implemented in the base&#39;</span>
                                  <span class="s1">&#39; class and must be set up by each specific&#39;</span>
                                  <span class="s1">&#39; model.&#39;</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">_clone_from_init_kwds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">endog</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># Cannot make this the default, because there is extra work required</span>
        <span class="c1"># for subclasses to make _get_init_kwds useful.</span>
        <span class="n">use_kwargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_init_kwds</span><span class="p">()</span>
        <span class="n">use_kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Check for `exog`</span>
        <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;k_exog&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;exog&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Cloning a model with an exogenous component&#39;</span>
                             <span class="s1">&#39; requires specifying a new exogenous array using&#39;</span>
                             <span class="s1">&#39; the `exog` argument.&#39;</span><span class="p">)</span>

        <span class="n">mod</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">endog</span><span class="p">,</span> <span class="o">**</span><span class="n">use_kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">mod</span>

<div class="viewcode-block" id="MLEModel.set_filter_method">
<a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEModel.set_filter_method.html#statsmodels.tsa.statespace.mlemodel.MLEModel.set_filter_method">[docs]</a>
    <span class="k">def</span> <span class="nf">set_filter_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filter_method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the filtering method</span>

<span class="sd">        The filtering method controls aspects of which Kalman filtering</span>
<span class="sd">        approach will be used.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filter_method : int, optional</span>
<span class="sd">            Bitmask value to set the filter method to. See notes for details.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Keyword arguments may be used to influence the filter method by</span>
<span class="sd">            setting individual boolean flags. See notes for details.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method is rarely used. See the corresponding function in the</span>
<span class="sd">        `KalmanFilter` class for details.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">set_filter_method</span><span class="p">(</span><span class="n">filter_method</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="MLEModel.set_inversion_method">
<a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEModel.set_inversion_method.html#statsmodels.tsa.statespace.mlemodel.MLEModel.set_inversion_method">[docs]</a>
    <span class="k">def</span> <span class="nf">set_inversion_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inversion_method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the inversion method</span>

<span class="sd">        The Kalman filter may contain one matrix inversion: that of the</span>
<span class="sd">        forecast error covariance matrix. The inversion method controls how and</span>
<span class="sd">        if that inverse is performed.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        inversion_method : int, optional</span>
<span class="sd">            Bitmask value to set the inversion method to. See notes for</span>
<span class="sd">            details.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Keyword arguments may be used to influence the inversion method by</span>
<span class="sd">            setting individual boolean flags. See notes for details.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method is rarely used. See the corresponding function in the</span>
<span class="sd">        `KalmanFilter` class for details.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">set_inversion_method</span><span class="p">(</span><span class="n">inversion_method</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="MLEModel.set_stability_method">
<a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEModel.set_stability_method.html#statsmodels.tsa.statespace.mlemodel.MLEModel.set_stability_method">[docs]</a>
    <span class="k">def</span> <span class="nf">set_stability_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stability_method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the numerical stability method</span>

<span class="sd">        The Kalman filter is a recursive algorithm that may in some cases</span>
<span class="sd">        suffer issues with numerical stability. The stability method controls</span>
<span class="sd">        what, if any, measures are taken to promote stability.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        stability_method : int, optional</span>
<span class="sd">            Bitmask value to set the stability method to. See notes for</span>
<span class="sd">            details.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Keyword arguments may be used to influence the stability method by</span>
<span class="sd">            setting individual boolean flags. See notes for details.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method is rarely used. See the corresponding function in the</span>
<span class="sd">        `KalmanFilter` class for details.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">set_stability_method</span><span class="p">(</span><span class="n">stability_method</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="MLEModel.set_conserve_memory">
<a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEModel.set_conserve_memory.html#statsmodels.tsa.statespace.mlemodel.MLEModel.set_conserve_memory">[docs]</a>
    <span class="k">def</span> <span class="nf">set_conserve_memory</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">conserve_memory</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the memory conservation method</span>

<span class="sd">        By default, the Kalman filter computes a number of intermediate</span>
<span class="sd">        matrices at each iteration. The memory conservation options control</span>
<span class="sd">        which of those matrices are stored.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        conserve_memory : int, optional</span>
<span class="sd">            Bitmask value to set the memory conservation method to. See notes</span>
<span class="sd">            for details.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Keyword arguments may be used to influence the memory conservation</span>
<span class="sd">            method by setting individual boolean flags.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method is rarely used. See the corresponding function in the</span>
<span class="sd">        `KalmanFilter` class for details.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">set_conserve_memory</span><span class="p">(</span><span class="n">conserve_memory</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="MLEModel.set_smoother_output">
<a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEModel.set_smoother_output.html#statsmodels.tsa.statespace.mlemodel.MLEModel.set_smoother_output">[docs]</a>
    <span class="k">def</span> <span class="nf">set_smoother_output</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">smoother_output</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the smoother output</span>

<span class="sd">        The smoother can produce several types of results. The smoother output</span>
<span class="sd">        variable controls which are calculated and returned.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        smoother_output : int, optional</span>
<span class="sd">            Bitmask value to set the smoother output to. See notes for details.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Keyword arguments may be used to influence the smoother output by</span>
<span class="sd">            setting individual boolean flags.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method is rarely used. See the corresponding function in the</span>
<span class="sd">        `KalmanSmoother` class for details.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">set_smoother_output</span><span class="p">(</span><span class="n">smoother_output</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="MLEModel.initialize_known">
<a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEModel.initialize_known.html#statsmodels.tsa.statespace.mlemodel.MLEModel.initialize_known">[docs]</a>
    <span class="k">def</span> <span class="nf">initialize_known</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">initial_state</span><span class="p">,</span> <span class="n">initial_state_cov</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize known&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">initialize_known</span><span class="p">(</span><span class="n">initial_state</span><span class="p">,</span> <span class="n">initial_state_cov</span><span class="p">)</span></div>


<div class="viewcode-block" id="MLEModel.initialize_approximate_diffuse">
<a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEModel.initialize_approximate_diffuse.html#statsmodels.tsa.statespace.mlemodel.MLEModel.initialize_approximate_diffuse">[docs]</a>
    <span class="k">def</span> <span class="nf">initialize_approximate_diffuse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variance</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize approximate diffuse&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">initialize_approximate_diffuse</span><span class="p">(</span><span class="n">variance</span><span class="p">)</span></div>


<div class="viewcode-block" id="MLEModel.initialize_stationary">
<a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEModel.initialize_stationary.html#statsmodels.tsa.statespace.mlemodel.MLEModel.initialize_stationary">[docs]</a>
    <span class="k">def</span> <span class="nf">initialize_stationary</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize stationary&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">initialize_stationary</span><span class="p">()</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">initialization</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">initialization</span>

    <span class="nd">@initialization</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">initialization</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">initialization</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">initial_variance</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">initial_variance</span>

    <span class="nd">@initial_variance</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">initial_variance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">initial_variance</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">loglikelihood_burn</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">loglikelihood_burn</span>

    <span class="nd">@loglikelihood_burn</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">loglikelihood_burn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">loglikelihood_burn</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">tolerance</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">tolerance</span>

    <span class="nd">@tolerance</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">tolerance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">tolerance</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">_validate_can_fix_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">param_names</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">param_name</span> <span class="ow">in</span> <span class="n">param_names</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">param_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid parameter name passed: &quot;</span><span class="si">%s</span><span class="s1">&quot;.&#39;</span>
                                 <span class="o">%</span> <span class="n">param_name</span><span class="p">)</span>

<div class="viewcode-block" id="MLEModel.fix_params">
<a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEModel.fix_params.html#statsmodels.tsa.statespace.mlemodel.MLEModel.fix_params">[docs]</a>
    <span class="nd">@contextlib</span><span class="o">.</span><span class="n">contextmanager</span>
    <span class="k">def</span> <span class="nf">fix_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fix parameters to specific values (context manager)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : dict</span>
<span class="sd">            Dictionary describing the fixed parameter values, of the form</span>
<span class="sd">            `param_name: fixed_value`. See the `param_names` property for valid</span>
<span class="sd">            parameter names.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; mod = sm.tsa.SARIMAX(endog, order=(1, 0, 1))</span>
<span class="sd">        &gt;&gt;&gt; with mod.fix_params({&#39;ar.L1&#39;: 0.5}):</span>
<span class="sd">                res = mod.fit()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">k_params</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">)</span>
        <span class="c1"># Initialization (this is done here rather than in the constructor</span>
        <span class="c1"># because param_names may not be available at that point)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fixed_params</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_fixed_params</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_params_index</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
                <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">k_params</span><span class="p">)))</span>

        <span class="c1"># Cache the current fixed parameters</span>
        <span class="n">cache_fixed_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fixed_params</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">cache_has_fixed_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_fixed_params</span>
        <span class="n">cache_fixed_params_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fixed_params_index</span>
        <span class="n">cache_free_params_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_free_params_index</span>

        <span class="c1"># Validate parameter names and values</span>
        <span class="n">all_fixed_param_names</span> <span class="o">=</span> <span class="p">(</span>
            <span class="nb">set</span><span class="p">(</span><span class="n">params</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">|</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_fixed_params</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_validate_can_fix_params</span><span class="p">(</span><span class="n">all_fixed_param_names</span><span class="p">)</span>

        <span class="c1"># Set the new fixed parameters, keeping the order as given by</span>
        <span class="c1"># param_names</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fixed_params</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fixed_params</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">name</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fixed_params</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_names</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fixed_params</span><span class="p">}</span>

        <span class="c1"># Update associated values</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_has_fixed_params</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fixed_params_index</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_params_index</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
                                    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fixed_params</span><span class="o">.</span><span class="n">keys</span><span class="p">()]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_free_params_index</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
            <span class="nb">set</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">k_params</span><span class="p">))</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_fixed_params_index</span><span class="p">))</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">yield</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="c1"># Reset the fixed parameters</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_has_fixed_params</span> <span class="o">=</span> <span class="n">cache_has_fixed_params</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_fixed_params</span> <span class="o">=</span> <span class="n">cache_fixed_params</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_fixed_params_index</span> <span class="o">=</span> <span class="n">cache_fixed_params_index</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_free_params_index</span> <span class="o">=</span> <span class="n">cache_free_params_index</span></div>


<div class="viewcode-block" id="MLEModel.fit">
<a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEModel.fit.html#statsmodels.tsa.statespace.mlemodel.MLEModel.fit">[docs]</a>
    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">includes_fixed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">cov_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cov_kwds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;lbfgs&#39;</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span>
            <span class="n">full_output</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">disp</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">return_params</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">optim_score</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">optim_complex_step</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">optim_hessian</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">flags</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">low_memory</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fits the model by maximum likelihood via Kalman filter.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        start_params : array_like, optional</span>
<span class="sd">            Initial guess of the solution for the loglikelihood maximization.</span>
<span class="sd">            If None, the default is given by Model.start_params.</span>
<span class="sd">        transformed : bool, optional</span>
<span class="sd">            Whether or not `start_params` is already transformed. Default is</span>
<span class="sd">            True.</span>
<span class="sd">        includes_fixed : bool, optional</span>
<span class="sd">            If parameters were previously fixed with the `fix_params` method,</span>
<span class="sd">            this argument describes whether or not `start_params` also includes</span>
<span class="sd">            the fixed parameters, in addition to the free parameters. Default</span>
<span class="sd">            is False.</span>
<span class="sd">        cov_type : str, optional</span>
<span class="sd">            The `cov_type` keyword governs the method for calculating the</span>
<span class="sd">            covariance matrix of parameter estimates. Can be one of:</span>

<span class="sd">            - &#39;opg&#39; for the outer product of gradient estimator</span>
<span class="sd">            - &#39;oim&#39; for the observed information matrix estimator, calculated</span>
<span class="sd">              using the method of Harvey (1989)</span>
<span class="sd">            - &#39;approx&#39; for the observed information matrix estimator,</span>
<span class="sd">              calculated using a numerical approximation of the Hessian matrix.</span>
<span class="sd">            - &#39;robust&#39; for an approximate (quasi-maximum likelihood) covariance</span>
<span class="sd">              matrix that may be valid even in the presence of some</span>
<span class="sd">              misspecifications. Intermediate calculations use the &#39;oim&#39;</span>
<span class="sd">              method.</span>
<span class="sd">            - &#39;robust_approx&#39; is the same as &#39;robust&#39; except that the</span>
<span class="sd">              intermediate calculations use the &#39;approx&#39; method.</span>
<span class="sd">            - &#39;none&#39; for no covariance matrix calculation.</span>

<span class="sd">            Default is &#39;opg&#39; unless memory conservation is used to avoid</span>
<span class="sd">            computing the loglikelihood values for each observation, in which</span>
<span class="sd">            case the default is &#39;approx&#39;.</span>
<span class="sd">        cov_kwds : dict or None, optional</span>
<span class="sd">            A dictionary of arguments affecting covariance matrix computation.</span>

<span class="sd">            **opg, oim, approx, robust, robust_approx**</span>

<span class="sd">            - &#39;approx_complex_step&#39; : bool, optional - If True, numerical</span>
<span class="sd">              approximations are computed using complex-step methods. If False,</span>
<span class="sd">              numerical approximations are computed using finite difference</span>
<span class="sd">              methods. Default is True.</span>
<span class="sd">            - &#39;approx_centered&#39; : bool, optional - If True, numerical</span>
<span class="sd">              approximations computed using finite difference methods use a</span>
<span class="sd">              centered approximation. Default is False.</span>
<span class="sd">        method : str, optional</span>
<span class="sd">            The `method` determines which solver from `scipy.optimize`</span>
<span class="sd">            is used, and it can be chosen from among the following strings:</span>

<span class="sd">            - &#39;newton&#39; for Newton-Raphson</span>
<span class="sd">            - &#39;nm&#39; for Nelder-Mead</span>
<span class="sd">            - &#39;bfgs&#39; for Broyden-Fletcher-Goldfarb-Shanno (BFGS)</span>
<span class="sd">            - &#39;lbfgs&#39; for limited-memory BFGS with optional box constraints</span>
<span class="sd">            - &#39;powell&#39; for modified Powell&#39;s method</span>
<span class="sd">            - &#39;cg&#39; for conjugate gradient</span>
<span class="sd">            - &#39;ncg&#39; for Newton-conjugate gradient</span>
<span class="sd">            - &#39;basinhopping&#39; for global basin-hopping solver</span>

<span class="sd">            The explicit arguments in `fit` are passed to the solver,</span>
<span class="sd">            with the exception of the basin-hopping solver. Each</span>
<span class="sd">            solver has several optional arguments that are not the same across</span>
<span class="sd">            solvers. See the notes section below (or scipy.optimize) for the</span>
<span class="sd">            available arguments and for the list of explicit arguments that the</span>
<span class="sd">            basin-hopping solver supports.</span>
<span class="sd">        maxiter : int, optional</span>
<span class="sd">            The maximum number of iterations to perform.</span>
<span class="sd">        full_output : bool, optional</span>
<span class="sd">            Set to True to have all available output in the Results object&#39;s</span>
<span class="sd">            mle_retvals attribute. The output is dependent on the solver.</span>
<span class="sd">            See LikelihoodModelResults notes section for more information.</span>
<span class="sd">        disp : bool, optional</span>
<span class="sd">            Set to True to print convergence messages.</span>
<span class="sd">        callback : callable callback(xk), optional</span>
<span class="sd">            Called after each iteration, as callback(xk), where xk is the</span>
<span class="sd">            current parameter vector.</span>
<span class="sd">        return_params : bool, optional</span>
<span class="sd">            Whether or not to return only the array of maximizing parameters.</span>
<span class="sd">            Default is False.</span>
<span class="sd">        optim_score : {&#39;harvey&#39;, &#39;approx&#39;} or None, optional</span>
<span class="sd">            The method by which the score vector is calculated. &#39;harvey&#39; uses</span>
<span class="sd">            the method from Harvey (1989), &#39;approx&#39; uses either finite</span>
<span class="sd">            difference or complex step differentiation depending upon the</span>
<span class="sd">            value of `optim_complex_step`, and None uses the built-in gradient</span>
<span class="sd">            approximation of the optimizer. Default is None. This keyword is</span>
<span class="sd">            only relevant if the optimization method uses the score.</span>
<span class="sd">        optim_complex_step : bool, optional</span>
<span class="sd">            Whether or not to use complex step differentiation when</span>
<span class="sd">            approximating the score; if False, finite difference approximation</span>
<span class="sd">            is used. Default is True. This keyword is only relevant if</span>
<span class="sd">            `optim_score` is set to &#39;harvey&#39; or &#39;approx&#39;.</span>
<span class="sd">        optim_hessian : {&#39;opg&#39;, &#39;oim&#39;, &#39;approx&#39;}, optional</span>
<span class="sd">            The method by which the Hessian is numerically approximated. &#39;opg&#39;</span>
<span class="sd">            uses outer product of gradients, &#39;oim&#39; uses the information</span>
<span class="sd">            matrix formula from Harvey (1989), and &#39;approx&#39; uses numerical</span>
<span class="sd">            approximation. This keyword is only relevant if the</span>
<span class="sd">            optimization method uses the Hessian matrix.</span>
<span class="sd">        low_memory : bool, optional</span>
<span class="sd">            If set to True, techniques are applied to substantially reduce</span>
<span class="sd">            memory usage. If used, some features of the results object will</span>
<span class="sd">            not be available (including smoothed results and in-sample</span>
<span class="sd">            prediction), although out-of-sample forecasting is possible.</span>
<span class="sd">            Default is False.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Additional keyword arguments to pass to the optimizer.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        results</span>
<span class="sd">            Results object holding results from fitting a state space model.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        statsmodels.base.model.LikelihoodModel.fit</span>
<span class="sd">        statsmodels.tsa.statespace.mlemodel.MLEResults</span>
<span class="sd">        statsmodels.tsa.statespace.structural.UnobservedComponentsResults</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">start_params</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">start_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">start_params</span>
            <span class="n">transformed</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">includes_fixed</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># Update the score method</span>
        <span class="k">if</span> <span class="n">optim_score</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;lbfgs&#39;</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;approx_grad&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
            <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;epsilon&#39;</span><span class="p">,</span> <span class="mf">1e-5</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">optim_score</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">optim_score</span> <span class="o">=</span> <span class="s1">&#39;approx&#39;</span>

        <span class="c1"># Check for complex step differentiation</span>
        <span class="k">if</span> <span class="n">optim_complex_step</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">optim_complex_step</span> <span class="o">=</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">_complex_endog</span>
        <span class="k">elif</span> <span class="n">optim_complex_step</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">_complex_endog</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Cannot use complex step derivatives when data&#39;</span>
                             <span class="s1">&#39; or parameters are complex.&#39;</span><span class="p">)</span>

        <span class="c1"># Standardize starting parameters</span>
        <span class="n">start_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">handle_params</span><span class="p">(</span><span class="n">start_params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                          <span class="n">includes_fixed</span><span class="o">=</span><span class="n">includes_fixed</span><span class="p">)</span>

        <span class="c1"># Unconstrain the starting parameters</span>
        <span class="k">if</span> <span class="n">transformed</span><span class="p">:</span>
            <span class="n">start_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">untransform_params</span><span class="p">(</span><span class="n">start_params</span><span class="p">)</span>

        <span class="c1"># Remove any fixed parameters</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_fixed_params</span><span class="p">:</span>
            <span class="n">start_params</span> <span class="o">=</span> <span class="n">start_params</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_free_params_index</span><span class="p">]</span>

        <span class="c1"># If all parameters are fixed, we are done</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_fixed_params</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">start_params</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">mlefit</span> <span class="o">=</span> <span class="n">Bunch</span><span class="p">(</span><span class="n">params</span><span class="o">=</span><span class="p">[],</span> <span class="n">mle_retvals</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                           <span class="n">mle_settings</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Remove disallowed kwargs</span>
            <span class="n">disallow</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s2">&quot;concentrate_scale&quot;</span><span class="p">,</span>
                <span class="s2">&quot;enforce_stationarity&quot;</span><span class="p">,</span>
                <span class="s2">&quot;enforce_invertibility&quot;</span>
            <span class="p">)</span>
            <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">disallow</span><span class="p">}</span>
            <span class="c1"># Maximum likelihood estimation</span>
            <span class="k">if</span> <span class="n">flags</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">flags</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">flags</span><span class="o">.</span><span class="n">update</span><span class="p">({</span>
                <span class="s1">&#39;transformed&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
                <span class="s1">&#39;includes_fixed&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
                <span class="s1">&#39;score_method&#39;</span><span class="p">:</span> <span class="n">optim_score</span><span class="p">,</span>
                <span class="s1">&#39;approx_complex_step&#39;</span><span class="p">:</span> <span class="n">optim_complex_step</span>
            <span class="p">})</span>
            <span class="k">if</span> <span class="n">optim_hessian</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">flags</span><span class="p">[</span><span class="s1">&#39;hessian_method&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">optim_hessian</span>
            <span class="n">fargs</span> <span class="o">=</span> <span class="p">(</span><span class="n">flags</span><span class="p">,)</span>
            <span class="n">mlefit</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">start_params</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
                                 <span class="n">fargs</span><span class="o">=</span><span class="n">fargs</span><span class="p">,</span>
                                 <span class="n">maxiter</span><span class="o">=</span><span class="n">maxiter</span><span class="p">,</span>
                                 <span class="n">full_output</span><span class="o">=</span><span class="n">full_output</span><span class="p">,</span>
                                 <span class="n">disp</span><span class="o">=</span><span class="n">disp</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="n">callback</span><span class="p">,</span>
                                 <span class="n">skip_hessian</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Just return the fitted parameters if requested</span>
        <span class="k">if</span> <span class="n">return_params</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">handle_params</span><span class="p">(</span><span class="n">mlefit</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                      <span class="n">includes_fixed</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="c1"># Otherwise construct the results class if desired</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Handle memory conservation option</span>
            <span class="k">if</span> <span class="n">low_memory</span><span class="p">:</span>
                <span class="n">conserve_memory</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">conserve_memory</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">set_conserve_memory</span><span class="p">(</span><span class="n">MEMORY_CONSERVE</span><span class="p">)</span>

            <span class="c1"># Perform filtering / smoothing</span>
            <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">memory_no_predicted</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">memory_no_gain</span>
                    <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">memory_no_smoothing</span><span class="p">):</span>
                <span class="n">func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">smooth</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">mlefit</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">includes_fixed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                       <span class="n">cov_type</span><span class="o">=</span><span class="n">cov_type</span><span class="p">,</span> <span class="n">cov_kwds</span><span class="o">=</span><span class="n">cov_kwds</span><span class="p">)</span>

            <span class="n">res</span><span class="o">.</span><span class="n">mlefit</span> <span class="o">=</span> <span class="n">mlefit</span>
            <span class="n">res</span><span class="o">.</span><span class="n">mle_retvals</span> <span class="o">=</span> <span class="n">mlefit</span><span class="o">.</span><span class="n">mle_retvals</span>
            <span class="n">res</span><span class="o">.</span><span class="n">mle_settings</span> <span class="o">=</span> <span class="n">mlefit</span><span class="o">.</span><span class="n">mle_settings</span>

            <span class="c1"># Reset memory conservation</span>
            <span class="k">if</span> <span class="n">low_memory</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">set_conserve_memory</span><span class="p">(</span><span class="n">conserve_memory</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">res</span></div>


<div class="viewcode-block" id="MLEModel.fit_constrained">
<a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEModel.fit_constrained.html#statsmodels.tsa.statespace.mlemodel.MLEModel.fit_constrained">[docs]</a>
    <span class="k">def</span> <span class="nf">fit_constrained</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">constraints</span><span class="p">,</span> <span class="n">start_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">fit_kwds</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fit the model with some parameters subject to equality constraints.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        constraints : dict</span>
<span class="sd">            Dictionary of constraints, of the form `param_name: fixed_value`.</span>
<span class="sd">            See the `param_names` property for valid parameter names.</span>
<span class="sd">        start_params : array_like, optional</span>
<span class="sd">            Initial guess of the solution for the loglikelihood maximization.</span>
<span class="sd">            If None, the default is given by Model.start_params.</span>
<span class="sd">        **fit_kwds : keyword arguments</span>
<span class="sd">            fit_kwds are used in the optimization of the remaining parameters.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        results : Results instance</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; mod = sm.tsa.SARIMAX(endog, order=(1, 0, 1))</span>
<span class="sd">        &gt;&gt;&gt; res = mod.fit_constrained({&#39;ar.L1&#39;: 0.5})</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">fix_params</span><span class="p">(</span><span class="n">constraints</span><span class="p">):</span>
            <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">start_params</span><span class="p">,</span> <span class="o">**</span><span class="n">fit_kwds</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_res_classes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;fit&#39;</span><span class="p">:</span> <span class="p">(</span><span class="n">MLEResults</span><span class="p">,</span> <span class="n">MLEResultsWrapper</span><span class="p">)}</span>

    <span class="k">def</span> <span class="nf">_wrap_results</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">return_raw</span><span class="p">,</span> <span class="n">cov_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                      <span class="n">cov_kwds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">results_class</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">wrapper_class</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">return_raw</span><span class="p">:</span>
            <span class="c1"># Wrap in a results object</span>
            <span class="n">result_kwargs</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">if</span> <span class="n">cov_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">result_kwargs</span><span class="p">[</span><span class="s1">&#39;cov_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cov_type</span>
            <span class="k">if</span> <span class="n">cov_kwds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">result_kwargs</span><span class="p">[</span><span class="s1">&#39;cov_kwds&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cov_kwds</span>

            <span class="k">if</span> <span class="n">results_class</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">results_class</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_res_classes</span><span class="p">[</span><span class="s1">&#39;fit&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">wrapper_class</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">wrapper_class</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_res_classes</span><span class="p">[</span><span class="s1">&#39;fit&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>

            <span class="n">res</span> <span class="o">=</span> <span class="n">results_class</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="o">**</span><span class="n">result_kwargs</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">wrapper_class</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

<div class="viewcode-block" id="MLEModel.filter">
<a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEModel.filter.html#statsmodels.tsa.statespace.mlemodel.MLEModel.filter">[docs]</a>
    <span class="k">def</span> <span class="nf">filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">includes_fixed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
               <span class="n">complex_step</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">cov_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cov_kwds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="n">return_ssm</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">results_class</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="n">results_wrapper_class</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">low_memory</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Kalman filtering</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array_like</span>
<span class="sd">            Array of parameters at which to evaluate the loglikelihood</span>
<span class="sd">            function.</span>
<span class="sd">        transformed : bool, optional</span>
<span class="sd">            Whether or not `params` is already transformed. Default is True.</span>
<span class="sd">        return_ssm : bool,optional</span>
<span class="sd">            Whether or not to return only the state space output or a full</span>
<span class="sd">            results object. Default is to return a full results object.</span>
<span class="sd">        cov_type : str, optional</span>
<span class="sd">            See `MLEResults.fit` for a description of covariance matrix types</span>
<span class="sd">            for results object.</span>
<span class="sd">        cov_kwds : dict or None, optional</span>
<span class="sd">            See `MLEResults.get_robustcov_results` for a description required</span>
<span class="sd">            keywords for alternative covariance estimators</span>
<span class="sd">        low_memory : bool, optional</span>
<span class="sd">            If set to True, techniques are applied to substantially reduce</span>
<span class="sd">            memory usage. If used, some features of the results object will</span>
<span class="sd">            not be available (including in-sample prediction), although</span>
<span class="sd">            out-of-sample forecasting is possible. Default is False.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Additional keyword arguments to pass to the Kalman filter. See</span>
<span class="sd">            `KalmanFilter.filter` for more details.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">handle_params</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="n">transformed</span><span class="p">,</span>
                                    <span class="n">includes_fixed</span><span class="o">=</span><span class="n">includes_fixed</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">includes_fixed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="n">complex_step</span><span class="o">=</span><span class="n">complex_step</span><span class="p">)</span>

        <span class="c1"># Save the parameter names</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">param_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_names</span>

        <span class="k">if</span> <span class="n">complex_step</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;inversion_method&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">INVERT_UNIVARIATE</span> <span class="o">|</span> <span class="n">SOLVE_LU</span>

        <span class="c1"># Handle memory conservation</span>
        <span class="k">if</span> <span class="n">low_memory</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;conserve_memory&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">MEMORY_CONSERVE</span>

        <span class="c1"># Get the state space output</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">complex_step</span><span class="o">=</span><span class="n">complex_step</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Wrap in a results object</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_results</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">return_ssm</span><span class="p">,</span> <span class="n">cov_type</span><span class="p">,</span>
                                  <span class="n">cov_kwds</span><span class="p">,</span> <span class="n">results_class</span><span class="p">,</span>
                                  <span class="n">results_wrapper_class</span><span class="p">)</span></div>


<div class="viewcode-block" id="MLEModel.smooth">
<a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEModel.smooth.html#statsmodels.tsa.statespace.mlemodel.MLEModel.smooth">[docs]</a>
    <span class="k">def</span> <span class="nf">smooth</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">includes_fixed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
               <span class="n">complex_step</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">cov_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cov_kwds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="n">return_ssm</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">results_class</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="n">results_wrapper_class</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Kalman smoothing</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array_like</span>
<span class="sd">            Array of parameters at which to evaluate the loglikelihood</span>
<span class="sd">            function.</span>
<span class="sd">        transformed : bool, optional</span>
<span class="sd">            Whether or not `params` is already transformed. Default is True.</span>
<span class="sd">        return_ssm : bool,optional</span>
<span class="sd">            Whether or not to return only the state space output or a full</span>
<span class="sd">            results object. Default is to return a full results object.</span>
<span class="sd">        cov_type : str, optional</span>
<span class="sd">            See `MLEResults.fit` for a description of covariance matrix types</span>
<span class="sd">            for results object.</span>
<span class="sd">        cov_kwds : dict or None, optional</span>
<span class="sd">            See `MLEResults.get_robustcov_results` for a description required</span>
<span class="sd">            keywords for alternative covariance estimators</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Additional keyword arguments to pass to the Kalman filter. See</span>
<span class="sd">            `KalmanFilter.filter` for more details.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">handle_params</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="n">transformed</span><span class="p">,</span>
                                    <span class="n">includes_fixed</span><span class="o">=</span><span class="n">includes_fixed</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">includes_fixed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="n">complex_step</span><span class="o">=</span><span class="n">complex_step</span><span class="p">)</span>

        <span class="c1"># Save the parameter names</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">param_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_names</span>

        <span class="k">if</span> <span class="n">complex_step</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;inversion_method&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">INVERT_UNIVARIATE</span> <span class="o">|</span> <span class="n">SOLVE_LU</span>

        <span class="c1"># Get the state space output</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">smooth</span><span class="p">(</span><span class="n">complex_step</span><span class="o">=</span><span class="n">complex_step</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Wrap in a results object</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_results</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">return_ssm</span><span class="p">,</span> <span class="n">cov_type</span><span class="p">,</span>
                                  <span class="n">cov_kwds</span><span class="p">,</span> <span class="n">results_class</span><span class="p">,</span>
                                  <span class="n">results_wrapper_class</span><span class="p">)</span></div>


    <span class="n">_loglike_param_names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;transformed&#39;</span><span class="p">,</span> <span class="s1">&#39;includes_fixed&#39;</span><span class="p">,</span> <span class="s1">&#39;complex_step&#39;</span><span class="p">]</span>
    <span class="n">_loglike_param_defaults</span> <span class="o">=</span> <span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">]</span>

<div class="viewcode-block" id="MLEModel.loglike">
<a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEModel.loglike.html#statsmodels.tsa.statespace.mlemodel.MLEModel.loglike">[docs]</a>
    <span class="k">def</span> <span class="nf">loglike</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Loglikelihood evaluation</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array_like</span>
<span class="sd">            Array of parameters at which to evaluate the loglikelihood</span>
<span class="sd">            function.</span>
<span class="sd">        transformed : bool, optional</span>
<span class="sd">            Whether or not `params` is already transformed. Default is True.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Additional keyword arguments to pass to the Kalman filter. See</span>
<span class="sd">            `KalmanFilter.filter` for more details.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        update : modifies the internal state of the state space model to</span>
<span class="sd">                 reflect new params</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        [1]_ recommend maximizing the average likelihood to avoid scale issues;</span>
<span class="sd">        this is done automatically by the base Model fit method.</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        .. [1] Koopman, Siem Jan, Neil Shephard, and Jurgen A. Doornik. 1999.</span>
<span class="sd">           Statistical Algorithms for Models in State Space Using SsfPack 2.2.</span>
<span class="sd">           Econometrics Journal 2 (1): 107-60. doi:10.1111/1368-423X.00023.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">transformed</span><span class="p">,</span> <span class="n">includes_fixed</span><span class="p">,</span> <span class="n">complex_step</span><span class="p">,</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="n">_handle_args</span><span class="p">(</span>
            <span class="n">MLEModel</span><span class="o">.</span><span class="n">_loglike_param_names</span><span class="p">,</span> <span class="n">MLEModel</span><span class="o">.</span><span class="n">_loglike_param_defaults</span><span class="p">,</span>
            <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="n">params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">handle_params</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="n">transformed</span><span class="p">,</span>
                                    <span class="n">includes_fixed</span><span class="o">=</span><span class="n">includes_fixed</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">includes_fixed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="n">complex_step</span><span class="o">=</span><span class="n">complex_step</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">complex_step</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;inversion_method&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">INVERT_UNIVARIATE</span> <span class="o">|</span> <span class="n">SOLVE_LU</span>

        <span class="n">loglike</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">loglike</span><span class="p">(</span><span class="n">complex_step</span><span class="o">=</span><span class="n">complex_step</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Koopman, Shephard, and Doornik recommend maximizing the average</span>
        <span class="c1"># likelihood to avoid scale issues, but the averaging is done</span>
        <span class="c1"># automatically in the base model `fit` method</span>
        <span class="k">return</span> <span class="n">loglike</span></div>


<div class="viewcode-block" id="MLEModel.loglikeobs">
<a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEModel.loglikeobs.html#statsmodels.tsa.statespace.mlemodel.MLEModel.loglikeobs">[docs]</a>
    <span class="k">def</span> <span class="nf">loglikeobs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">includes_fixed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                   <span class="n">complex_step</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Loglikelihood evaluation</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array_like</span>
<span class="sd">            Array of parameters at which to evaluate the loglikelihood</span>
<span class="sd">            function.</span>
<span class="sd">        transformed : bool, optional</span>
<span class="sd">            Whether or not `params` is already transformed. Default is True.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Additional keyword arguments to pass to the Kalman filter. See</span>
<span class="sd">            `KalmanFilter.filter` for more details.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        update : modifies the internal state of the Model to reflect new params</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        [1]_ recommend maximizing the average likelihood to avoid scale issues;</span>
<span class="sd">        this is done automatically by the base Model fit method.</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        .. [1] Koopman, Siem Jan, Neil Shephard, and Jurgen A. Doornik. 1999.</span>
<span class="sd">           Statistical Algorithms for Models in State Space Using SsfPack 2.2.</span>
<span class="sd">           Econometrics Journal 2 (1): 107-60. doi:10.1111/1368-423X.00023.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">handle_params</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="n">transformed</span><span class="p">,</span>
                                    <span class="n">includes_fixed</span><span class="o">=</span><span class="n">includes_fixed</span><span class="p">)</span>

        <span class="c1"># If we&#39;re using complex-step differentiation, then we cannot use</span>
        <span class="c1"># Cholesky factorization</span>
        <span class="k">if</span> <span class="n">complex_step</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;inversion_method&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">INVERT_UNIVARIATE</span> <span class="o">|</span> <span class="n">SOLVE_LU</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">includes_fixed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="n">complex_step</span><span class="o">=</span><span class="n">complex_step</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">loglikeobs</span><span class="p">(</span><span class="n">complex_step</span><span class="o">=</span><span class="n">complex_step</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="MLEModel.simulation_smoother">
<a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEModel.simulation_smoother.html#statsmodels.tsa.statespace.mlemodel.MLEModel.simulation_smoother">[docs]</a>
    <span class="k">def</span> <span class="nf">simulation_smoother</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">simulation_output</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieve a simulation smoother for the state space model.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        simulation_output : int, optional</span>
<span class="sd">            Determines which simulation smoother output is calculated.</span>
<span class="sd">            Default is all (including state and disturbances).</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Additional keyword arguments, used to set the simulation output.</span>
<span class="sd">            See `set_simulation_output` for more details.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        SimulationSmoothResults</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">simulation_smoother</span><span class="p">(</span>
            <span class="n">simulation_output</span><span class="o">=</span><span class="n">simulation_output</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">_forecasts_error_partial_derivatives</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                             <span class="n">includes_fixed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                             <span class="n">approx_complex_step</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                             <span class="n">approx_centered</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                             <span class="n">res</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># We cannot use complex-step differentiation with non-transformed</span>
        <span class="c1"># parameters</span>
        <span class="k">if</span> <span class="n">approx_complex_step</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">approx_complex_step</span> <span class="o">=</span> <span class="n">transformed</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">transformed</span> <span class="ow">and</span> <span class="n">approx_complex_step</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot use complex-step approximations to&quot;</span>
                             <span class="s2">&quot; calculate the observed_information_matrix&quot;</span>
                             <span class="s2">&quot; with untransformed parameters.&quot;</span><span class="p">)</span>

        <span class="c1"># If we&#39;re using complex-step differentiation, then we cannot use</span>
        <span class="c1"># Cholesky factorization</span>
        <span class="k">if</span> <span class="n">approx_complex_step</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;inversion_method&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">INVERT_UNIVARIATE</span> <span class="o">|</span> <span class="n">SOLVE_LU</span>

        <span class="c1"># Get values at the params themselves</span>
        <span class="k">if</span> <span class="n">res</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="n">transformed</span><span class="p">,</span>
                        <span class="n">includes_fixed</span><span class="o">=</span><span class="n">includes_fixed</span><span class="p">,</span>
                        <span class="n">complex_step</span><span class="o">=</span><span class="n">approx_complex_step</span><span class="p">)</span>
            <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">complex_step</span><span class="o">=</span><span class="n">approx_complex_step</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Setup</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>

        <span class="c1"># Compute partial derivatives w.r.t. forecast error and forecast</span>
        <span class="c1"># error covariance</span>
        <span class="n">partials_forecasts_error</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
        <span class="p">)</span>
        <span class="n">partials_forecasts_error_cov</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">approx_complex_step</span><span class="p">:</span>
            <span class="n">epsilon</span> <span class="o">=</span> <span class="n">_get_epsilon</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
            <span class="n">increments</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">epsilon</span>

            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ih</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">increments</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">params</span> <span class="o">+</span> <span class="n">ih</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="n">transformed</span><span class="p">,</span>
                            <span class="n">includes_fixed</span><span class="o">=</span><span class="n">includes_fixed</span><span class="p">,</span>
                            <span class="n">complex_step</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">_res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">complex_step</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

                <span class="n">partials_forecasts_error</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">_res</span><span class="o">.</span><span class="n">forecasts_error</span><span class="o">.</span><span class="n">imag</span> <span class="o">/</span> <span class="n">epsilon</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="p">)</span>

                <span class="n">partials_forecasts_error_cov</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">_res</span><span class="o">.</span><span class="n">forecasts_error_cov</span><span class="o">.</span><span class="n">imag</span> <span class="o">/</span> <span class="n">epsilon</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">approx_centered</span><span class="p">:</span>
            <span class="n">epsilon</span> <span class="o">=</span> <span class="n">_get_epsilon</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
            <span class="n">ei</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,),</span> <span class="nb">float</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="n">ei</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">epsilon</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">params</span> <span class="o">+</span> <span class="n">ei</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="n">transformed</span><span class="p">,</span>
                            <span class="n">includes_fixed</span><span class="o">=</span><span class="n">includes_fixed</span><span class="p">,</span> <span class="n">complex_step</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="n">_res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">complex_step</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

                <span class="n">partials_forecasts_error</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">_res</span><span class="o">.</span><span class="n">forecasts_error</span> <span class="o">-</span> <span class="n">res</span><span class="o">.</span><span class="n">forecasts_error</span><span class="p">)</span> <span class="o">/</span> <span class="n">epsilon</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

                <span class="n">partials_forecasts_error_cov</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">_res</span><span class="o">.</span><span class="n">forecasts_error_cov</span> <span class="o">-</span>
                    <span class="n">res</span><span class="o">.</span><span class="n">forecasts_error_cov</span><span class="p">)</span> <span class="o">/</span> <span class="n">epsilon</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">ei</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">epsilon</span> <span class="o">=</span> <span class="n">_get_epsilon</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.</span>
            <span class="n">ei</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,),</span> <span class="nb">float</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="n">ei</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">epsilon</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">params</span> <span class="o">+</span> <span class="n">ei</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="n">transformed</span><span class="p">,</span>
                            <span class="n">includes_fixed</span><span class="o">=</span><span class="n">includes_fixed</span><span class="p">,</span> <span class="n">complex_step</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="n">_res1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">complex_step</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">params</span> <span class="o">-</span> <span class="n">ei</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="n">transformed</span><span class="p">,</span>
                            <span class="n">includes_fixed</span><span class="o">=</span><span class="n">includes_fixed</span><span class="p">,</span> <span class="n">complex_step</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="n">_res2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">complex_step</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

                <span class="n">partials_forecasts_error</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="p">(</span><span class="n">_res1</span><span class="o">.</span><span class="n">forecasts_error</span> <span class="o">-</span> <span class="n">_res2</span><span class="o">.</span><span class="n">forecasts_error</span><span class="p">)</span> <span class="o">/</span>
                    <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">epsilon</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>

                <span class="n">partials_forecasts_error_cov</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="p">(</span><span class="n">_res1</span><span class="o">.</span><span class="n">forecasts_error_cov</span> <span class="o">-</span> <span class="n">_res2</span><span class="o">.</span><span class="n">forecasts_error_cov</span><span class="p">)</span> <span class="o">/</span>
                    <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">epsilon</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>

                <span class="n">ei</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="k">return</span> <span class="n">partials_forecasts_error</span><span class="p">,</span> <span class="n">partials_forecasts_error_cov</span>

<div class="viewcode-block" id="MLEModel.observed_information_matrix">
<a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEModel.observed_information_matrix.html#statsmodels.tsa.statespace.mlemodel.MLEModel.observed_information_matrix">[docs]</a>
    <span class="k">def</span> <span class="nf">observed_information_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                    <span class="n">includes_fixed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                    <span class="n">approx_complex_step</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                    <span class="n">approx_centered</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Observed information matrix</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array_like, optional</span>
<span class="sd">            Array of parameters at which to evaluate the loglikelihood</span>
<span class="sd">            function.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Additional keyword arguments to pass to the Kalman filter. See</span>
<span class="sd">            `KalmanFilter.filter` for more details.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method is from Harvey (1989), which shows that the information</span>
<span class="sd">        matrix only depends on terms from the gradient. This implementation is</span>
<span class="sd">        partially analytic and partially numeric approximation, therefore,</span>
<span class="sd">        because it uses the analytic formula for the information matrix, with</span>
<span class="sd">        numerically computed elements of the gradient.</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        Harvey, Andrew C. 1990.</span>
<span class="sd">        Forecasting, Structural Time Series Models and the Kalman Filter.</span>
<span class="sd">        Cambridge University Press.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Setup</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>

        <span class="c1"># We cannot use complex-step differentiation with non-transformed</span>
        <span class="c1"># parameters</span>
        <span class="k">if</span> <span class="n">approx_complex_step</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">approx_complex_step</span> <span class="o">=</span> <span class="n">transformed</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">transformed</span> <span class="ow">and</span> <span class="n">approx_complex_step</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot use complex-step approximations to&quot;</span>
                             <span class="s2">&quot; calculate the observed_information_matrix&quot;</span>
                             <span class="s2">&quot; with untransformed parameters.&quot;</span><span class="p">)</span>

        <span class="c1"># Get values at the params themselves</span>
        <span class="n">params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">handle_params</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="n">transformed</span><span class="p">,</span>
                                    <span class="n">includes_fixed</span><span class="o">=</span><span class="n">includes_fixed</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">includes_fixed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="n">complex_step</span><span class="o">=</span><span class="n">approx_complex_step</span><span class="p">)</span>
        <span class="c1"># If we&#39;re using complex-step differentiation, then we cannot use</span>
        <span class="c1"># Cholesky factorization</span>
        <span class="k">if</span> <span class="n">approx_complex_step</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;inversion_method&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">INVERT_UNIVARIATE</span> <span class="o">|</span> <span class="n">SOLVE_LU</span>
        <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">complex_step</span><span class="o">=</span><span class="n">approx_complex_step</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">dtype</span>

        <span class="c1"># Save this for inversion later</span>
        <span class="n">inv_forecasts_error_cov</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">forecasts_error_cov</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="n">partials_forecasts_error</span><span class="p">,</span> <span class="n">partials_forecasts_error_cov</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_forecasts_error_partial_derivatives</span><span class="p">(</span>
                <span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="n">transformed</span><span class="p">,</span> <span class="n">includes_fixed</span><span class="o">=</span><span class="n">includes_fixed</span><span class="p">,</span>
                <span class="n">approx_complex_step</span><span class="o">=</span><span class="n">approx_complex_step</span><span class="p">,</span>
                <span class="n">approx_centered</span><span class="o">=</span><span class="n">approx_centered</span><span class="p">,</span> <span class="n">res</span><span class="o">=</span><span class="n">res</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>

        <span class="c1"># Compute the information matrix</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="p">,</span> <span class="n">n</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

        <span class="n">information_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">loglikelihood_burn</span><span class="p">,</span> <span class="n">res</span><span class="o">.</span><span class="n">nobs_diffuse</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="p">):</span>
            <span class="n">inv_forecasts_error_cov</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">forecasts_error_cov</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">t</span><span class="p">])</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="n">tmp</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">t</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
                    <span class="n">inv_forecasts_error_cov</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">t</span><span class="p">],</span>
                    <span class="n">partials_forecasts_error_cov</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">t</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span>
                <span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                    <span class="n">information_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span>
                        <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">tmp</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">t</span><span class="p">,</span> <span class="n">i</span><span class="p">],</span>
                                              <span class="n">tmp</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">t</span><span class="p">,</span> <span class="n">j</span><span class="p">]))</span>
                    <span class="p">)</span>
                    <span class="n">information_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span>
                        <span class="n">partials_forecasts_error</span><span class="p">[:,</span> <span class="n">t</span><span class="p">,</span> <span class="n">i</span><span class="p">],</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">inv_forecasts_error_cov</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">t</span><span class="p">],</span>
                               <span class="n">partials_forecasts_error</span><span class="p">[:,</span> <span class="n">t</span><span class="p">,</span> <span class="n">j</span><span class="p">])</span>
                    <span class="p">)</span>
        <span class="k">return</span> <span class="n">information_matrix</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nobs</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">loglikelihood_burn</span><span class="p">)</span></div>


<div class="viewcode-block" id="MLEModel.opg_information_matrix">
<a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEModel.opg_information_matrix.html#statsmodels.tsa.statespace.mlemodel.MLEModel.opg_information_matrix">[docs]</a>
    <span class="k">def</span> <span class="nf">opg_information_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                               <span class="n">includes_fixed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">approx_complex_step</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                               <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Outer product of gradients information matrix</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array_like, optional</span>
<span class="sd">            Array of parameters at which to evaluate the loglikelihood</span>
<span class="sd">            function.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Additional arguments to the `loglikeobs` method.</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        Berndt, Ernst R., Bronwyn Hall, Robert Hall, and Jerry Hausman. 1974.</span>
<span class="sd">        Estimation and Inference in Nonlinear Structural Models.</span>
<span class="sd">        NBER Chapters. National Bureau of Economic Research, Inc.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># We cannot use complex-step differentiation with non-transformed</span>
        <span class="c1"># parameters</span>
        <span class="k">if</span> <span class="n">approx_complex_step</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">approx_complex_step</span> <span class="o">=</span> <span class="n">transformed</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">transformed</span> <span class="ow">and</span> <span class="n">approx_complex_step</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot use complex-step approximations to&quot;</span>
                             <span class="s2">&quot; calculate the observed_information_matrix&quot;</span>
                             <span class="s2">&quot; with untransformed parameters.&quot;</span><span class="p">)</span>

        <span class="n">score_obs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">score_obs</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="n">transformed</span><span class="p">,</span>
                                   <span class="n">includes_fixed</span><span class="o">=</span><span class="n">includes_fixed</span><span class="p">,</span>
                                   <span class="n">approx_complex_step</span><span class="o">=</span><span class="n">approx_complex_step</span><span class="p">,</span>
                                   <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">score_obs</span><span class="p">,</span> <span class="n">score_obs</span><span class="p">)</span> <span class="o">/</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nobs</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">loglikelihood_burn</span><span class="p">)</span>
        <span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">_score_complex_step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># the default epsilon can be too small</span>
        <span class="c1"># inversion_method = INVERT_UNIVARIATE | SOLVE_LU</span>
        <span class="n">epsilon</span> <span class="o">=</span> <span class="n">_get_epsilon</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="mf">2.</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">))</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;transformed&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;complex_step&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">approx_fprime_cs</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">loglike</span><span class="p">,</span> <span class="n">epsilon</span><span class="o">=</span><span class="n">epsilon</span><span class="p">,</span>
                                <span class="n">kwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_score_finite_difference</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">approx_centered</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                 <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;transformed&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">approx_fprime</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">loglike</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">,</span>
                             <span class="n">centered</span><span class="o">=</span><span class="n">approx_centered</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_score_harvey</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">approx_complex_step</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">score_obs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_score_obs_harvey</span><span class="p">(</span>
            <span class="n">params</span><span class="p">,</span> <span class="n">approx_complex_step</span><span class="o">=</span><span class="n">approx_complex_step</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">score_obs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_score_obs_harvey</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">approx_complex_step</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                          <span class="n">approx_centered</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">includes_fixed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                          <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Score</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array_like, optional</span>
<span class="sd">            Array of parameters at which to evaluate the loglikelihood</span>
<span class="sd">            function.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Additional keyword arguments to pass to the Kalman filter. See</span>
<span class="sd">            `KalmanFilter.filter` for more details.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method is from Harvey (1989), section 3.4.5</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        Harvey, Andrew C. 1990.</span>
<span class="sd">        Forecasting, Structural Time Series Models and the Kalman Filter.</span>
<span class="sd">        Cambridge University Press.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>

        <span class="c1"># Get values at the params themselves</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">includes_fixed</span><span class="o">=</span><span class="n">includes_fixed</span><span class="p">,</span>
                    <span class="n">complex_step</span><span class="o">=</span><span class="n">approx_complex_step</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">approx_complex_step</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;inversion_method&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">INVERT_UNIVARIATE</span> <span class="o">|</span> <span class="n">SOLVE_LU</span>
        <span class="k">if</span> <span class="s1">&#39;transformed&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">del</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;transformed&#39;</span><span class="p">]</span>
        <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">complex_step</span><span class="o">=</span><span class="n">approx_complex_step</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Get forecasts error partials</span>
        <span class="n">partials_forecasts_error</span><span class="p">,</span> <span class="n">partials_forecasts_error_cov</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_forecasts_error_partial_derivatives</span><span class="p">(</span>
                <span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">includes_fixed</span><span class="o">=</span><span class="n">includes_fixed</span><span class="p">,</span>
                <span class="n">approx_complex_step</span><span class="o">=</span><span class="n">approx_complex_step</span><span class="p">,</span>
                <span class="n">approx_centered</span><span class="o">=</span><span class="n">approx_centered</span><span class="p">,</span> <span class="n">res</span><span class="o">=</span><span class="n">res</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>

        <span class="c1"># Compute partial derivatives w.r.t. likelihood function</span>
        <span class="n">partials</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
        <span class="n">k_endog</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="p">):</span>
            <span class="n">inv_forecasts_error_cov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span>
                    <span class="n">res</span><span class="o">.</span><span class="n">forecasts_error_cov</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">t</span><span class="p">])</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="n">partials</span><span class="p">[</span><span class="n">t</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">inv_forecasts_error_cov</span><span class="p">,</span>
                           <span class="n">partials_forecasts_error_cov</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">t</span><span class="p">,</span> <span class="n">i</span><span class="p">]),</span>
                    <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">k_endog</span><span class="p">)</span> <span class="o">-</span>
                     <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">inv_forecasts_error_cov</span><span class="p">,</span>
                            <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">forecasts_error</span><span class="p">[:,</span> <span class="n">t</span><span class="p">],</span>
                                     <span class="n">res</span><span class="o">.</span><span class="n">forecasts_error</span><span class="p">[:,</span> <span class="n">t</span><span class="p">])))))</span>
                <span class="c1"># 2 * dv / di * F^{-1} v_t</span>
                <span class="c1"># where x = F^{-1} v_t or F x = v</span>
                <span class="n">partials</span><span class="p">[</span><span class="n">t</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
                    <span class="n">partials_forecasts_error</span><span class="p">[:,</span> <span class="n">t</span><span class="p">,</span> <span class="n">i</span><span class="p">],</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">inv_forecasts_error_cov</span><span class="p">,</span> <span class="n">res</span><span class="o">.</span><span class="n">forecasts_error</span><span class="p">[:,</span> <span class="n">t</span><span class="p">]))</span>

        <span class="k">return</span> <span class="o">-</span><span class="n">partials</span> <span class="o">/</span> <span class="mf">2.</span>

    <span class="n">_score_param_names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;transformed&#39;</span><span class="p">,</span> <span class="s1">&#39;includes_fixed&#39;</span><span class="p">,</span> <span class="s1">&#39;score_method&#39;</span><span class="p">,</span>
                          <span class="s1">&#39;approx_complex_step&#39;</span><span class="p">,</span> <span class="s1">&#39;approx_centered&#39;</span><span class="p">]</span>
    <span class="n">_score_param_defaults</span> <span class="o">=</span> <span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="s1">&#39;approx&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">False</span><span class="p">]</span>

<div class="viewcode-block" id="MLEModel.score">
<a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEModel.score.html#statsmodels.tsa.statespace.mlemodel.MLEModel.score">[docs]</a>
    <span class="k">def</span> <span class="nf">score</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the score function at params.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array_like</span>
<span class="sd">            Array of parameters at which to evaluate the score.</span>
<span class="sd">        *args</span>
<span class="sd">            Additional positional arguments to the `loglike` method.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Additional keyword arguments to the `loglike` method.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        score : ndarray</span>
<span class="sd">            Score, evaluated at `params`.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This is a numerical approximation, calculated using first-order complex</span>
<span class="sd">        step differentiation on the `loglike` method.</span>

<span class="sd">        Both args and kwargs are necessary because the optimizer from</span>
<span class="sd">        `fit` must call this function and only supports passing arguments via</span>
<span class="sd">        args (for example `scipy.optimize.fmin_l_bfgs`).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="p">(</span><span class="n">transformed</span><span class="p">,</span> <span class="n">includes_fixed</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">approx_complex_step</span><span class="p">,</span>
         <span class="n">approx_centered</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">_handle_args</span><span class="p">(</span><span class="n">MLEModel</span><span class="o">.</span><span class="n">_score_param_names</span><span class="p">,</span>
                         <span class="n">MLEModel</span><span class="o">.</span><span class="n">_score_param_defaults</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>
        <span class="c1"># For fit() calls, the method is called &#39;score_method&#39; (to distinguish</span>
        <span class="c1"># it from the method used for fit) but generally in kwargs the method</span>
        <span class="c1"># will just be called &#39;method&#39;</span>
        <span class="k">if</span> <span class="s1">&#39;method&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">method</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;method&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">approx_complex_step</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">approx_complex_step</span> <span class="o">=</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">_complex_endog</span>
        <span class="k">if</span> <span class="n">approx_complex_step</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">_complex_endog</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Cannot use complex step derivatives when data&#39;</span>
                             <span class="s1">&#39; or parameters are complex.&#39;</span><span class="p">)</span>

        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">handle_params</span><span class="p">(</span>
            <span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="n">transformed</span><span class="p">,</span> <span class="n">includes_fixed</span><span class="o">=</span><span class="n">includes_fixed</span><span class="p">,</span>
            <span class="n">return_jacobian</span><span class="o">=</span><span class="ow">not</span> <span class="n">transformed</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">transformed</span><span class="p">:</span>
            <span class="n">params</span> <span class="o">=</span> <span class="n">out</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">params</span><span class="p">,</span> <span class="n">transform_score</span> <span class="o">=</span> <span class="n">out</span>

        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;harvey&#39;</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;includes_fixed&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">score</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_score_harvey</span><span class="p">(</span>
                <span class="n">params</span><span class="p">,</span> <span class="n">approx_complex_step</span><span class="o">=</span><span class="n">approx_complex_step</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;approx&#39;</span> <span class="ow">and</span> <span class="n">approx_complex_step</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;includes_fixed&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">score</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_score_complex_step</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;approx&#39;</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;includes_fixed&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">score</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_score_finite_difference</span><span class="p">(</span>
                <span class="n">params</span><span class="p">,</span> <span class="n">approx_centered</span><span class="o">=</span><span class="n">approx_centered</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Invalid score method.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">transformed</span><span class="p">:</span>
            <span class="n">score</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">transform_score</span><span class="p">,</span> <span class="n">score</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_fixed_params</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">includes_fixed</span><span class="p">:</span>
            <span class="n">score</span> <span class="o">=</span> <span class="n">score</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_free_params_index</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">score</span></div>


<div class="viewcode-block" id="MLEModel.score_obs">
<a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEModel.score_obs.html#statsmodels.tsa.statespace.mlemodel.MLEModel.score_obs">[docs]</a>
    <span class="k">def</span> <span class="nf">score_obs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;approx&#39;</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                  <span class="n">includes_fixed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">approx_complex_step</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                  <span class="n">approx_centered</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the score per observation, evaluated at params</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array_like</span>
<span class="sd">            Array of parameters at which to evaluate the score.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Additional arguments to the `loglike` method.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        score : ndarray</span>
<span class="sd">            Score per observation, evaluated at `params`.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This is a numerical approximation, calculated using first-order complex</span>
<span class="sd">        step differentiation on the `loglikeobs` method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">transformed</span> <span class="ow">and</span> <span class="n">approx_complex_step</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot use complex-step approximations to&quot;</span>
                             <span class="s2">&quot; calculate the score at each observation&quot;</span>
                             <span class="s2">&quot; with untransformed parameters.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">approx_complex_step</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">approx_complex_step</span> <span class="o">=</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">_complex_endog</span>
        <span class="k">if</span> <span class="n">approx_complex_step</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">_complex_endog</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Cannot use complex step derivatives when data&#39;</span>
                             <span class="s1">&#39; or parameters are complex.&#39;</span><span class="p">)</span>

        <span class="n">params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">handle_params</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                    <span class="n">includes_fixed</span><span class="o">=</span><span class="n">includes_fixed</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;transformed&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">transformed</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;includes_fixed&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;harvey&#39;</span><span class="p">:</span>
            <span class="n">score</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_score_obs_harvey</span><span class="p">(</span>
                <span class="n">params</span><span class="p">,</span> <span class="n">approx_complex_step</span><span class="o">=</span><span class="n">approx_complex_step</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;approx&#39;</span> <span class="ow">and</span> <span class="n">approx_complex_step</span><span class="p">:</span>
            <span class="c1"># the default epsilon can be too small</span>
            <span class="n">epsilon</span> <span class="o">=</span> <span class="n">_get_epsilon</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="mf">2.</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">))</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;complex_step&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">score</span> <span class="o">=</span> <span class="n">approx_fprime_cs</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">loglikeobs</span><span class="p">,</span> <span class="n">epsilon</span><span class="o">=</span><span class="n">epsilon</span><span class="p">,</span>
                                     <span class="n">kwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;approx&#39;</span><span class="p">:</span>
            <span class="n">score</span> <span class="o">=</span> <span class="n">approx_fprime</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">loglikeobs</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">,</span>
                                  <span class="n">centered</span><span class="o">=</span><span class="n">approx_centered</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Invalid scoreobs method.&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">score</span></div>


    <span class="n">_hessian_param_names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;transformed&#39;</span><span class="p">,</span> <span class="s1">&#39;hessian_method&#39;</span><span class="p">,</span>
                            <span class="s1">&#39;approx_complex_step&#39;</span><span class="p">,</span> <span class="s1">&#39;approx_centered&#39;</span><span class="p">]</span>
    <span class="n">_hessian_param_defaults</span> <span class="o">=</span> <span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="s1">&#39;approx&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">False</span><span class="p">]</span>

<div class="viewcode-block" id="MLEModel.hessian">
<a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEModel.hessian.html#statsmodels.tsa.statespace.mlemodel.MLEModel.hessian">[docs]</a>
    <span class="k">def</span> <span class="nf">hessian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Hessian matrix of the likelihood function, evaluated at the given</span>
<span class="sd">        parameters</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array_like</span>
<span class="sd">            Array of parameters at which to evaluate the hessian.</span>
<span class="sd">        *args</span>
<span class="sd">            Additional positional arguments to the `loglike` method.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Additional keyword arguments to the `loglike` method.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        hessian : ndarray</span>
<span class="sd">            Hessian matrix evaluated at `params`</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This is a numerical approximation.</span>

<span class="sd">        Both args and kwargs are necessary because the optimizer from</span>
<span class="sd">        `fit` must call this function and only supports passing arguments via</span>
<span class="sd">        args (for example `scipy.optimize.fmin_l_bfgs`).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">transformed</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">approx_complex_step</span><span class="p">,</span> <span class="n">approx_centered</span><span class="p">,</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">_handle_args</span><span class="p">(</span><span class="n">MLEModel</span><span class="o">.</span><span class="n">_hessian_param_names</span><span class="p">,</span>
                         <span class="n">MLEModel</span><span class="o">.</span><span class="n">_hessian_param_defaults</span><span class="p">,</span>
                         <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>
        <span class="c1"># For fit() calls, the method is called &#39;hessian_method&#39; (to</span>
        <span class="c1"># distinguish it from the method used for fit) but generally in kwargs</span>
        <span class="c1"># the method will just be called &#39;method&#39;</span>
        <span class="k">if</span> <span class="s1">&#39;method&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">method</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;method&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">transformed</span> <span class="ow">and</span> <span class="n">approx_complex_step</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot use complex-step approximations to&quot;</span>
                             <span class="s2">&quot; calculate the hessian with untransformed&quot;</span>
                             <span class="s2">&quot; parameters.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">approx_complex_step</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">approx_complex_step</span> <span class="o">=</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">_complex_endog</span>
        <span class="k">if</span> <span class="n">approx_complex_step</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">_complex_endog</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Cannot use complex step derivatives when data&#39;</span>
                             <span class="s1">&#39; or parameters are complex.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;oim&#39;</span><span class="p">:</span>
            <span class="n">hessian</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hessian_oim</span><span class="p">(</span>
                <span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="n">transformed</span><span class="p">,</span>
                <span class="n">approx_complex_step</span><span class="o">=</span><span class="n">approx_complex_step</span><span class="p">,</span>
                <span class="n">approx_centered</span><span class="o">=</span><span class="n">approx_centered</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;opg&#39;</span><span class="p">:</span>
            <span class="n">hessian</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hessian_opg</span><span class="p">(</span>
                <span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="n">transformed</span><span class="p">,</span>
                <span class="n">approx_complex_step</span><span class="o">=</span><span class="n">approx_complex_step</span><span class="p">,</span>
                <span class="n">approx_centered</span><span class="o">=</span><span class="n">approx_centered</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;approx&#39;</span> <span class="ow">and</span> <span class="n">approx_complex_step</span><span class="p">:</span>
            <span class="n">hessian</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hessian_complex_step</span><span class="p">(</span>
                <span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="n">transformed</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;approx&#39;</span><span class="p">:</span>
            <span class="n">hessian</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hessian_finite_difference</span><span class="p">(</span>
                <span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="n">transformed</span><span class="p">,</span>
                <span class="n">approx_centered</span><span class="o">=</span><span class="n">approx_centered</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Invalid Hessian calculation method.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">hessian</span></div>


    <span class="k">def</span> <span class="nf">_hessian_oim</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Hessian matrix computed using the Harvey (1989) information matrix</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">observed_information_matrix</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_hessian_opg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Hessian matrix computed using the outer product of gradients</span>
<span class="sd">        information matrix</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">opg_information_matrix</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_hessian_finite_difference</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">approx_centered</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                   <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Calculation of the Hessian using finite differences&#39;</span>
                      <span class="s1">&#39; is usually subject to substantial approximation&#39;</span>
                      <span class="s1">&#39; errors.&#39;</span><span class="p">,</span> <span class="n">PrecisionWarning</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">approx_centered</span><span class="p">:</span>
            <span class="n">epsilon</span> <span class="o">=</span> <span class="n">_get_epsilon</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">epsilon</span> <span class="o">=</span> <span class="n">_get_epsilon</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">))</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="n">hessian</span> <span class="o">=</span> <span class="n">approx_fprime</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_score_finite_difference</span><span class="p">,</span>
                                <span class="n">epsilon</span><span class="o">=</span><span class="n">epsilon</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">,</span>
                                <span class="n">centered</span><span class="o">=</span><span class="n">approx_centered</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">hessian</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nobs</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">loglikelihood_burn</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_hessian_complex_step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Hessian matrix computed by second-order complex-step differentiation</span>
<span class="sd">        on the `loglike` function.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># the default epsilon can be too small</span>
        <span class="n">epsilon</span> <span class="o">=</span> <span class="n">_get_epsilon</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="mf">3.</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">))</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;transformed&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;complex_step&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">hessian</span> <span class="o">=</span> <span class="n">approx_hess_cs</span><span class="p">(</span>
            <span class="n">params</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">loglike</span><span class="p">,</span> <span class="n">epsilon</span><span class="o">=</span><span class="n">epsilon</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">hessian</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nobs</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">loglikelihood_burn</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">start_params</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        (array) Starting parameters for maximum likelihood estimation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_start_params&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_start_params</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">param_names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        (list of str) List of human readable parameter names (for parameters</span>
<span class="sd">        actually included in the model).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_param_names&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_param_names</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;param.</span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">start_params</span><span class="p">))]</span>
            <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
                <span class="n">names</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">return</span> <span class="n">names</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">state_names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        (list of str) List of human readable names for unobserved states.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_state_names&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state_names</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;state.</span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_states</span><span class="p">)]</span>
        <span class="k">return</span> <span class="n">names</span>

<div class="viewcode-block" id="MLEModel.transform_jacobian">
<a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEModel.transform_jacobian.html#statsmodels.tsa.statespace.mlemodel.MLEModel.transform_jacobian">[docs]</a>
    <span class="k">def</span> <span class="nf">transform_jacobian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unconstrained</span><span class="p">,</span> <span class="n">approx_centered</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Jacobian matrix for the parameter transformation function</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        unconstrained : array_like</span>
<span class="sd">            Array of unconstrained parameters used by the optimizer.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        jacobian : ndarray</span>
<span class="sd">            Jacobian matrix of the transformation, evaluated at `unconstrained`</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        transform_params</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This is a numerical approximation using finite differences. Note that</span>
<span class="sd">        in general complex step methods cannot be used because it is not</span>
<span class="sd">        guaranteed that the `transform_params` method is a real function (e.g.</span>
<span class="sd">        if Cholesky decomposition is used).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">approx_fprime</span><span class="p">(</span><span class="n">unconstrained</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_params</span><span class="p">,</span>
                             <span class="n">centered</span><span class="o">=</span><span class="n">approx_centered</span><span class="p">)</span></div>


<div class="viewcode-block" id="MLEModel.transform_params">
<a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEModel.transform_params.html#statsmodels.tsa.statespace.mlemodel.MLEModel.transform_params">[docs]</a>
    <span class="k">def</span> <span class="nf">transform_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unconstrained</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Transform unconstrained parameters used by the optimizer to constrained</span>
<span class="sd">        parameters used in likelihood evaluation</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        unconstrained : array_like</span>
<span class="sd">            Array of unconstrained parameters used by the optimizer, to be</span>
<span class="sd">            transformed.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        constrained : array_like</span>
<span class="sd">            Array of constrained parameters which may be used in likelihood</span>
<span class="sd">            evaluation.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This is a noop in the base class, subclasses should override where</span>
<span class="sd">        appropriate.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">unconstrained</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span></div>


<div class="viewcode-block" id="MLEModel.untransform_params">
<a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEModel.untransform_params.html#statsmodels.tsa.statespace.mlemodel.MLEModel.untransform_params">[docs]</a>
    <span class="k">def</span> <span class="nf">untransform_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">constrained</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Transform constrained parameters used in likelihood evaluation</span>
<span class="sd">        to unconstrained parameters used by the optimizer</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        constrained : array_like</span>
<span class="sd">            Array of constrained parameters used in likelihood evaluation, to</span>
<span class="sd">            be transformed.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        unconstrained : array_like</span>
<span class="sd">            Array of unconstrained parameters used by the optimizer.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This is a noop in the base class, subclasses should override where</span>
<span class="sd">        appropriate.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">constrained</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span></div>


<div class="viewcode-block" id="MLEModel.handle_params">
<a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEModel.handle_params.html#statsmodels.tsa.statespace.mlemodel.MLEModel.handle_params">[docs]</a>
    <span class="k">def</span> <span class="nf">handle_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">includes_fixed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                      <span class="n">return_jacobian</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Ensure model parameters satisfy shape and other requirements</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Never want integer dtype, so convert to floats</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">params</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">):</span>
            <span class="n">params</span> <span class="o">=</span> <span class="n">params</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">includes_fixed</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_fixed_params</span><span class="p">:</span>
            <span class="n">k_params</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">)</span>
            <span class="n">new_params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">k_params</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">params</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">new_params</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_free_params_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">params</span>
            <span class="n">params</span> <span class="o">=</span> <span class="n">new_params</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">transformed</span><span class="p">:</span>
            <span class="c1"># It may be the case that the transformation relies on having</span>
            <span class="c1"># &quot;some&quot; (non-NaN) values for the fixed parameters, even if we will</span>
            <span class="c1"># not actually be transforming the fixed parameters (as they will)</span>
            <span class="c1"># be set below regardless</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">includes_fixed</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_fixed_params</span><span class="p">:</span>
                <span class="n">params</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_fixed_params_index</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_fixed_params</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>

            <span class="k">if</span> <span class="n">return_jacobian</span><span class="p">:</span>
                <span class="n">transform_score</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_jacobian</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
            <span class="n">params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_params</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">includes_fixed</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_fixed_params</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_fixed_params_index</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_fixed_params</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">transform_score</span><span class="p">)</span> <span class="k">if</span> <span class="n">return_jacobian</span> <span class="k">else</span> <span class="n">params</span></div>


<div class="viewcode-block" id="MLEModel.update">
<a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEModel.update.html#statsmodels.tsa.statespace.mlemodel.MLEModel.update">[docs]</a>
    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">includes_fixed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
               <span class="n">complex_step</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update the parameters of the model</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array_like</span>
<span class="sd">            Array of new parameters.</span>
<span class="sd">        transformed : bool, optional</span>
<span class="sd">            Whether or not `params` is already transformed. If set to False,</span>
<span class="sd">            `transform_params` is called. Default is True.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        params : array_like</span>
<span class="sd">            Array of parameters.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Since Model is a base class, this method should be overridden by</span>
<span class="sd">        subclasses to perform actual updating steps.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">handle_params</span><span class="p">(</span><span class="n">params</span><span class="o">=</span><span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="n">transformed</span><span class="p">,</span>
                                  <span class="n">includes_fixed</span><span class="o">=</span><span class="n">includes_fixed</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">_validate_out_of_sample_exog</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exog</span><span class="p">,</span> <span class="n">out_of_sample</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Validate given `exog` as satisfactory for out-of-sample operations</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        exog : array_like or None</span>
<span class="sd">            New observations of exogenous regressors, if applicable.</span>
<span class="sd">        out_of_sample : int</span>
<span class="sd">            Number of new observations required.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        exog : array or None</span>
<span class="sd">            A numpy array of shape (out_of_sample, k_exog) if the model</span>
<span class="sd">            contains an `exog` component, or None if it does not.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">k_exog</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;k_exog&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">out_of_sample</span> <span class="ow">and</span> <span class="n">k_exog</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">exog</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Out-of-sample operations in a model&#39;</span>
                                 <span class="s1">&#39; with a regression component require&#39;</span>
                                 <span class="s1">&#39; additional exogenous values via the&#39;</span>
                                 <span class="s1">&#39; `exog` argument.&#39;</span><span class="p">)</span>
            <span class="n">exog</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">exog</span><span class="p">)</span>
            <span class="n">required_exog_shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">out_of_sample</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_exog</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">exog</span> <span class="o">=</span> <span class="n">exog</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">required_exog_shape</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Provided exogenous values are not of the&#39;</span>
                                 <span class="s1">&#39; appropriate shape. Required </span><span class="si">%s</span><span class="s1">, got </span><span class="si">%s</span><span class="s1">.&#39;</span>
                                 <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">required_exog_shape</span><span class="p">),</span>
                                    <span class="nb">str</span><span class="p">(</span><span class="n">exog</span><span class="o">.</span><span class="n">shape</span><span class="p">)))</span>
        <span class="k">elif</span> <span class="n">k_exog</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">exog</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">exog</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Exogenous array provided, but additional data&#39;</span>
                          <span class="s1">&#39; is not required. `exog` argument ignored.&#39;</span><span class="p">,</span>
                          <span class="n">ValueWarning</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">exog</span>

    <span class="k">def</span> <span class="nf">_get_extension_time_varying_matrices</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">exog</span><span class="p">,</span> <span class="n">out_of_sample</span><span class="p">,</span> <span class="n">extend_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">includes_fixed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get updated time-varying state space system matrices</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array_like</span>
<span class="sd">            Array of parameters used to construct the time-varying system</span>
<span class="sd">            matrices.</span>
<span class="sd">        exog : array_like or None</span>
<span class="sd">            New observations of exogenous regressors, if applicable.</span>
<span class="sd">        out_of_sample : int</span>
<span class="sd">            Number of new observations required.</span>
<span class="sd">        extend_kwargs : dict, optional</span>
<span class="sd">            Dictionary of keyword arguments to pass to the state space model</span>
<span class="sd">            constructor. For example, for an SARIMAX state space model, this</span>
<span class="sd">            could be used to pass the `concentrate_scale=True` keyword</span>
<span class="sd">            argument. Any arguments that are not explicitly set in this</span>
<span class="sd">            dictionary will be copied from the current model instance.</span>
<span class="sd">        transformed : bool, optional</span>
<span class="sd">            Whether or not `start_params` is already transformed. Default is</span>
<span class="sd">            True.</span>
<span class="sd">        includes_fixed : bool, optional</span>
<span class="sd">            If parameters were previously fixed with the `fix_params` method,</span>
<span class="sd">            this argument describes whether or not `start_params` also includes</span>
<span class="sd">            the fixed parameters, in addition to the free parameters. Default</span>
<span class="sd">            is False.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get the appropriate exog for the extended sample</span>
        <span class="n">exog</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_validate_out_of_sample_exog</span><span class="p">(</span><span class="n">exog</span><span class="p">,</span> <span class="n">out_of_sample</span><span class="p">)</span>

        <span class="c1"># Create extended model</span>
        <span class="k">if</span> <span class="n">extend_kwargs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">extend_kwargs</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># Handle trend offset for extended model</span>
        <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;k_trend&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;trend_offset&#39;</span><span class="p">):</span>
            <span class="n">extend_kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span>
                <span class="s1">&#39;trend_offset&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">trend_offset</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="p">)</span>

        <span class="n">mod_extend</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span>
            <span class="n">endog</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">out_of_sample</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">)),</span> <span class="n">exog</span><span class="o">=</span><span class="n">exog</span><span class="p">,</span>
            <span class="o">**</span><span class="n">extend_kwargs</span><span class="p">)</span>
        <span class="n">mod_extend</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="n">transformed</span><span class="p">,</span>
                          <span class="n">includes_fixed</span><span class="o">=</span><span class="n">includes_fixed</span><span class="p">)</span>

        <span class="c1"># Retrieve the extensions to the time-varying system matrices and</span>
        <span class="c1"># put them in kwargs</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">shapes</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;obs&#39;</span> <span class="ow">or</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">original</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
            <span class="n">extended</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">mod_extend</span><span class="o">.</span><span class="n">ssm</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
            <span class="n">so</span> <span class="o">=</span> <span class="n">original</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">se</span> <span class="o">=</span> <span class="n">extended</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="p">((</span><span class="n">so</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">se</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span>
                    <span class="n">so</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">original</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">extended</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]))):</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">extended</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="o">-</span><span class="n">out_of_sample</span><span class="p">:]</span>

        <span class="k">return</span> <span class="n">kwargs</span>

<div class="viewcode-block" id="MLEModel.simulate">
<a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEModel.simulate.html#statsmodels.tsa.statespace.mlemodel.MLEModel.simulate">[docs]</a>
    <span class="k">def</span> <span class="nf">simulate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">nsimulations</span><span class="p">,</span> <span class="n">measurement_shocks</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">state_shocks</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">initial_state</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">anchor</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">repetitions</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">exog</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">extend_model</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">extend_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">includes_fixed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">pretransformed_measurement_shocks</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">pretransformed_state_shocks</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">pretransformed_initial_state</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Simulate a new time series following the state space model</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array_like</span>
<span class="sd">            Array of parameters to use in constructing the state space</span>
<span class="sd">            representation to use when simulating.</span>
<span class="sd">        nsimulations : int</span>
<span class="sd">            The number of observations to simulate. If the model is</span>
<span class="sd">            time-invariant this can be any number. If the model is</span>
<span class="sd">            time-varying, then this number must be less than or equal to the</span>
<span class="sd">            number of observations.</span>
<span class="sd">        measurement_shocks : array_like, optional</span>
<span class="sd">            If specified, these are the shocks to the measurement equation,</span>
<span class="sd">            :math:`\varepsilon_t`. If unspecified, these are automatically</span>
<span class="sd">            generated using a pseudo-random number generator. If specified,</span>
<span class="sd">            must be shaped `nsimulations` x `k_endog`, where `k_endog` is the</span>
<span class="sd">            same as in the state space model.</span>
<span class="sd">        state_shocks : array_like, optional</span>
<span class="sd">            If specified, these are the shocks to the state equation,</span>
<span class="sd">            :math:`\eta_t`. If unspecified, these are automatically</span>
<span class="sd">            generated using a pseudo-random number generator. If specified,</span>
<span class="sd">            must be shaped `nsimulations` x `k_posdef` where `k_posdef` is the</span>
<span class="sd">            same as in the state space model.</span>
<span class="sd">        initial_state : array_like, optional</span>
<span class="sd">            If specified, this is the initial state vector to use in</span>
<span class="sd">            simulation, which should be shaped (`k_states` x 1), where</span>
<span class="sd">            `k_states` is the same as in the state space model. If unspecified,</span>
<span class="sd">            but the model has been initialized, then that initialization is</span>
<span class="sd">            used. This must be specified if `anchor` is anything other than</span>
<span class="sd">            &quot;start&quot; or 0 (or else you can use the `simulate` method on a</span>
<span class="sd">            results object rather than on the model object).</span>
<span class="sd">        anchor : int, str, or datetime, optional</span>
<span class="sd">            First period for simulation. The simulation will be conditional on</span>
<span class="sd">            all existing datapoints prior to the `anchor`.  Type depends on the</span>
<span class="sd">            index of the given `endog` in the model. Two special cases are the</span>
<span class="sd">            strings &#39;start&#39; and &#39;end&#39;. `start` refers to beginning the</span>
<span class="sd">            simulation at the first period of the sample, and `end` refers to</span>
<span class="sd">            beginning the simulation at the first period after the sample.</span>
<span class="sd">            Integer values can run from 0 to `nobs`, or can be negative to</span>
<span class="sd">            apply negative indexing. Finally, if a date/time index was provided</span>
<span class="sd">            to the model, then this argument can be a date string to parse or a</span>
<span class="sd">            datetime type. Default is &#39;start&#39;.</span>
<span class="sd">        repetitions : int, optional</span>
<span class="sd">            Number of simulated paths to generate. Default is 1 simulated path.</span>
<span class="sd">        exog : array_like, optional</span>
<span class="sd">            New observations of exogenous regressors, if applicable.</span>
<span class="sd">        transformed : bool, optional</span>
<span class="sd">            Whether or not `params` is already transformed. Default is</span>
<span class="sd">            True.</span>
<span class="sd">        includes_fixed : bool, optional</span>
<span class="sd">            If parameters were previously fixed with the `fix_params` method,</span>
<span class="sd">            this argument describes whether or not `params` also includes</span>
<span class="sd">            the fixed parameters, in addition to the free parameters. Default</span>
<span class="sd">            is False.</span>
<span class="sd">        pretransformed_measurement_shocks : bool, optional</span>
<span class="sd">            If `measurement_shocks` is provided, this flag indicates whether it</span>
<span class="sd">            should be directly used as the shocks. If False, then it is assumed</span>
<span class="sd">            to contain draws from the standard Normal distribution that must be</span>
<span class="sd">            transformed using the `obs_cov` covariance matrix. Default is True.</span>
<span class="sd">        pretransformed_state_shocks : bool, optional</span>
<span class="sd">            If `state_shocks` is provided, this flag indicates whether it</span>
<span class="sd">            should be directly used as the shocks. If False, then it is assumed</span>
<span class="sd">            to contain draws from the standard Normal distribution that must be</span>
<span class="sd">            transformed using the `state_cov` covariance matrix. Default is</span>
<span class="sd">            True.</span>
<span class="sd">        pretransformed_initial_state : bool, optional</span>
<span class="sd">            If `initial_state` is provided, this flag indicates whether it</span>
<span class="sd">            should be directly used as the initial_state. If False, then it is</span>
<span class="sd">            assumed to contain draws from the standard Normal distribution that</span>
<span class="sd">            must be transformed using the `initial_state_cov` covariance</span>
<span class="sd">            matrix. Default is True.</span>
<span class="sd">        random_state : {None, int, Generator, RandomState}, optional</span>
<span class="sd">            If `seed` is None (or `np.random`), the</span>
<span class="sd">            class:``~numpy.random.RandomState`` singleton is used.</span>
<span class="sd">            If `seed` is an int, a new class:``~numpy.random.RandomState``</span>
<span class="sd">            instance is used, seeded with `seed`.</span>
<span class="sd">            If `seed` is already a class:``~numpy.random.Generator`` or</span>
<span class="sd">            class:``~numpy.random.RandomState`` instance then that instance is</span>
<span class="sd">            used.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        simulated_obs : ndarray</span>
<span class="sd">            An array of simulated observations. If `repetitions=None`, then it</span>
<span class="sd">            will be shaped (nsimulations x k_endog) or (nsimulations,) if</span>
<span class="sd">            `k_endog=1`. Otherwise it will be shaped</span>
<span class="sd">            (nsimulations x k_endog x repetitions). If the model was given</span>
<span class="sd">            Pandas input then the output will be a Pandas object. If</span>
<span class="sd">            `k_endog &gt; 1` and `repetitions` is not None, then the output will</span>
<span class="sd">            be a Pandas DataFrame that has a MultiIndex for the columns, with</span>
<span class="sd">            the first level containing the names of the `endog` variables and</span>
<span class="sd">            the second level containing the repetition number.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        impulse_responses</span>
<span class="sd">            Impulse response functions</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Make sure the model class has the current parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="n">transformed</span><span class="p">,</span>
                    <span class="n">includes_fixed</span><span class="o">=</span><span class="n">includes_fixed</span><span class="p">)</span>

        <span class="c1"># Get the starting location</span>
        <span class="k">if</span> <span class="n">anchor</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">anchor</span> <span class="o">==</span> <span class="s1">&#39;start&#39;</span><span class="p">:</span>
            <span class="n">iloc</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">elif</span> <span class="n">anchor</span> <span class="o">==</span> <span class="s1">&#39;end&#39;</span><span class="p">:</span>
            <span class="n">iloc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">iloc</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_index_loc</span><span class="p">(</span><span class="n">anchor</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">iloc</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
                <span class="n">iloc</span> <span class="o">=</span> <span class="n">iloc</span><span class="o">.</span><span class="n">start</span>

        <span class="k">if</span> <span class="n">iloc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">iloc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span> <span class="o">+</span> <span class="n">iloc</span>
        <span class="k">if</span> <span class="n">iloc</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Cannot anchor simulation outside of the sample.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">iloc</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">initial_state</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;If `anchor` is after the start of the sample,&#39;</span>
                             <span class="s1">&#39; must provide a value for `initial_state`.&#39;</span><span class="p">)</span>

        <span class="c1"># Get updated time-varying system matrices in **kwargs, if necessary</span>
        <span class="n">out_of_sample</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">iloc</span> <span class="o">+</span> <span class="n">nsimulations</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">extend_model</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">extend_model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exog</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">time_invariant</span>
        <span class="k">if</span> <span class="n">out_of_sample</span> <span class="ow">and</span> <span class="n">extend_model</span><span class="p">:</span>
            <span class="n">kwargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_extension_time_varying_matrices</span><span class="p">(</span>
                <span class="n">params</span><span class="p">,</span> <span class="n">exog</span><span class="p">,</span> <span class="n">out_of_sample</span><span class="p">,</span> <span class="n">extend_kwargs</span><span class="p">,</span>
                <span class="n">transformed</span><span class="o">=</span><span class="n">transformed</span><span class="p">,</span> <span class="n">includes_fixed</span><span class="o">=</span><span class="n">includes_fixed</span><span class="p">,</span>
                <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Standardize the dimensions of the initial state</span>
        <span class="k">if</span> <span class="n">initial_state</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">initial_state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">initial_state</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">initial_state</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">initial_state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">initial_state</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

        <span class="c1"># Construct a model that represents the simulation period</span>
        <span class="n">end</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="p">,</span> <span class="n">iloc</span> <span class="o">+</span> <span class="n">nsimulations</span><span class="p">)</span>
        <span class="n">nextend</span> <span class="o">=</span> <span class="n">iloc</span> <span class="o">+</span> <span class="n">nsimulations</span> <span class="o">-</span> <span class="n">end</span>
        <span class="n">sim_model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nextend</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">)),</span>
                                    <span class="n">start</span><span class="o">=</span><span class="n">iloc</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="n">end</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Simulate the data</span>
        <span class="n">_repetitions</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">repetitions</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">repetitions</span>
        <span class="n">sim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nsimulations</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">,</span> <span class="n">_repetitions</span><span class="p">))</span>
        <span class="n">simulator</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">_repetitions</span><span class="p">):</span>
            <span class="n">initial_state_variates</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="n">initial_state</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">initial_state</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">initial_state_variates</span> <span class="o">=</span> <span class="n">initial_state</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">initial_state_variates</span> <span class="o">=</span> <span class="n">initial_state</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span>

            <span class="c1"># TODO: allow specifying measurement / state shocks for each</span>
            <span class="c1"># repetition?</span>

            <span class="n">out</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">simulator</span> <span class="o">=</span> <span class="n">sim_model</span><span class="o">.</span><span class="n">simulate</span><span class="p">(</span>
                <span class="n">nsimulations</span><span class="p">,</span> <span class="n">measurement_shocks</span><span class="p">,</span> <span class="n">state_shocks</span><span class="p">,</span>
                <span class="n">initial_state_variates</span><span class="p">,</span>
                <span class="n">pretransformed_measurement_shocks</span><span class="o">=</span><span class="p">(</span>
                    <span class="n">pretransformed_measurement_shocks</span><span class="p">),</span>
                <span class="n">pretransformed_state_shocks</span><span class="o">=</span><span class="n">pretransformed_state_shocks</span><span class="p">,</span>
                <span class="n">pretransformed_initial_state</span><span class="o">=</span><span class="n">pretransformed_initial_state</span><span class="p">,</span>
                <span class="n">simulator</span><span class="o">=</span><span class="n">simulator</span><span class="p">,</span> <span class="n">return_simulator</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">)</span>

            <span class="n">sim</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">out</span>

        <span class="c1"># Wrap data / squeeze where appropriate</span>
        <span class="n">use_pandas</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">PandasData</span><span class="p">)</span>
        <span class="n">index</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">use_pandas</span><span class="p">:</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_prediction_index</span><span class="p">(</span>
                <span class="n">iloc</span><span class="p">,</span> <span class="n">iloc</span> <span class="o">+</span> <span class="n">nsimulations</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="c1"># If `repetitions` isn&#39;t set, we squeeze the last dimension(s)</span>
        <span class="k">if</span> <span class="n">repetitions</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">sim</span> <span class="o">=</span> <span class="n">sim</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">use_pandas</span><span class="p">:</span>
                    <span class="n">sim</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">sim</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">endog_names</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">sim</span> <span class="o">=</span> <span class="n">sim</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">use_pandas</span><span class="p">:</span>
                    <span class="n">sim</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">sim</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span>
                                       <span class="n">columns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">endog_names</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">use_pandas</span><span class="p">:</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">shape</span>
            <span class="n">endog_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">endog_names</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">endog_names</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="n">endog_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">endog_names</span><span class="p">]</span>
            <span class="n">columns</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="o">.</span><span class="n">from_product</span><span class="p">([</span><span class="n">endog_names</span><span class="p">,</span>
                                                  <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">])])</span>
            <span class="n">sim</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">sim</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span>
                               <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">sim</span></div>


<div class="viewcode-block" id="MLEModel.impulse_responses">
<a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEModel.impulse_responses.html#statsmodels.tsa.statespace.mlemodel.MLEModel.impulse_responses">[docs]</a>
    <span class="k">def</span> <span class="nf">impulse_responses</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">steps</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">impulse</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                          <span class="n">orthogonalized</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">cumulative</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">anchor</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                          <span class="n">exog</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">extend_model</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">extend_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                          <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">includes_fixed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Impulse response function</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array_like</span>
<span class="sd">            Array of model parameters.</span>
<span class="sd">        steps : int, optional</span>
<span class="sd">            The number of steps for which impulse responses are calculated.</span>
<span class="sd">            Default is 1. Note that for time-invariant models, the initial</span>
<span class="sd">            impulse is not counted as a step, so if `steps=1`, the output will</span>
<span class="sd">            have 2 entries.</span>
<span class="sd">        impulse : int, str or array_like</span>
<span class="sd">            If an integer, the state innovation to pulse; must be between 0</span>
<span class="sd">            and `k_posdef-1`. If a str, it indicates which column of df</span>
<span class="sd">            the unit (1) impulse is given.</span>
<span class="sd">            Alternatively, a custom impulse vector may be provided; must be</span>
<span class="sd">            shaped `k_posdef x 1`.</span>
<span class="sd">        orthogonalized : bool, optional</span>
<span class="sd">            Whether or not to perform impulse using orthogonalized innovations.</span>
<span class="sd">            Note that this will also affect custum `impulse` vectors. Default</span>
<span class="sd">            is False.</span>
<span class="sd">        cumulative : bool, optional</span>
<span class="sd">            Whether or not to return cumulative impulse responses. Default is</span>
<span class="sd">            False.</span>
<span class="sd">        anchor : int, str, or datetime, optional</span>
<span class="sd">            Time point within the sample for the state innovation impulse. Type</span>
<span class="sd">            depends on the index of the given `endog` in the model. Two special</span>
<span class="sd">            cases are the strings &#39;start&#39; and &#39;end&#39;, which refer to setting the</span>
<span class="sd">            impulse at the first and last points of the sample, respectively.</span>
<span class="sd">            Integer values can run from 0 to `nobs - 1`, or can be negative to</span>
<span class="sd">            apply negative indexing. Finally, if a date/time index was provided</span>
<span class="sd">            to the model, then this argument can be a date string to parse or a</span>
<span class="sd">            datetime type. Default is &#39;start&#39;.</span>
<span class="sd">        exog : array_like, optional</span>
<span class="sd">            New observations of exogenous regressors for our-of-sample periods,</span>
<span class="sd">            if applicable.</span>
<span class="sd">        transformed : bool, optional</span>
<span class="sd">            Whether or not `params` is already transformed. Default is</span>
<span class="sd">            True.</span>
<span class="sd">        includes_fixed : bool, optional</span>
<span class="sd">            If parameters were previously fixed with the `fix_params` method,</span>
<span class="sd">            this argument describes whether or not `params` also includes</span>
<span class="sd">            the fixed parameters, in addition to the free parameters. Default</span>
<span class="sd">            is False.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            If the model has time-varying design or transition matrices and the</span>
<span class="sd">            combination of `anchor` and `steps` implies creating impulse</span>
<span class="sd">            responses for the out-of-sample period, then these matrices must</span>
<span class="sd">            have updated values provided for the out-of-sample steps. For</span>
<span class="sd">            example, if `design` is a time-varying component, `nobs` is 10,</span>
<span class="sd">            `anchor=1`, and `steps` is 15, a (`k_endog` x `k_states` x 7)</span>
<span class="sd">            matrix must be provided with the new design matrix values.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        impulse_responses : ndarray</span>
<span class="sd">            Responses for each endogenous variable due to the impulse</span>
<span class="sd">            given by the `impulse` argument. For a time-invariant model, the</span>
<span class="sd">            impulse responses are given for `steps + 1` elements (this gives</span>
<span class="sd">            the &quot;initial impulse&quot; followed by `steps` responses for the</span>
<span class="sd">            important cases of VAR and SARIMAX models), while for time-varying</span>
<span class="sd">            models the impulse responses are only given for `steps` elements</span>
<span class="sd">            (to avoid having to unexpectedly provide updated time-varying</span>
<span class="sd">            matrices).</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        simulate</span>
<span class="sd">            Simulate a time series according to the given state space model,</span>
<span class="sd">            optionally with specified series for the innovations.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Intercepts in the measurement and state equation are ignored when</span>
<span class="sd">        calculating impulse responses.</span>

<span class="sd">        TODO: add an option to allow changing the ordering for the</span>
<span class="sd">              orthogonalized option. Will require permuting matrices when</span>
<span class="sd">              constructing the extended model.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Make sure the model class has the current parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="n">transformed</span><span class="p">,</span>
                    <span class="n">includes_fixed</span><span class="o">=</span><span class="n">includes_fixed</span><span class="p">)</span>

        <span class="c1"># For time-invariant models, add an additional `step`. This is the</span>
        <span class="c1"># default for time-invariant models based on the expected behavior for</span>
        <span class="c1"># ARIMA and VAR models: we want to record the initial impulse and also</span>
        <span class="c1"># `steps` values of the responses afterwards.</span>
        <span class="c1"># Note: we don&#39;t modify `steps` itself, because</span>
        <span class="c1"># `KalmanFilter.impulse_responses` also adds an additional step in this</span>
        <span class="c1"># case (this is so that there isn&#39;t different behavior when calling</span>
        <span class="c1"># this method versus that method). We just need to also keep track of</span>
        <span class="c1"># this here because we need to generate the correct extended model.</span>
        <span class="n">additional_steps</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">_design</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">_transition</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">_selection</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">additional_steps</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="c1"># Get the starting location</span>
        <span class="k">if</span> <span class="n">anchor</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">anchor</span> <span class="o">==</span> <span class="s1">&#39;start&#39;</span><span class="p">:</span>
            <span class="n">iloc</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">elif</span> <span class="n">anchor</span> <span class="o">==</span> <span class="s1">&#39;end&#39;</span><span class="p">:</span>
            <span class="n">iloc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">iloc</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_index_loc</span><span class="p">(</span><span class="n">anchor</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">iloc</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
                <span class="n">iloc</span> <span class="o">=</span> <span class="n">iloc</span><span class="o">.</span><span class="n">start</span>

        <span class="k">if</span> <span class="n">iloc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">iloc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span> <span class="o">+</span> <span class="n">iloc</span>
        <span class="k">if</span> <span class="n">iloc</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Cannot anchor impulse responses outside of the&#39;</span>
                             <span class="s1">&#39; sample.&#39;</span><span class="p">)</span>

        <span class="n">time_invariant</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">_design</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">_obs_cov</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">_transition</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">_selection</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">_state_cov</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Get updated time-varying system matrices in **kwargs, if necessary</span>
        <span class="c1"># (Note: KalmanFilter adds 1 to steps to account for the first impulse)</span>
        <span class="n">out_of_sample</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span>
            <span class="n">iloc</span> <span class="o">+</span> <span class="p">(</span><span class="n">steps</span> <span class="o">+</span> <span class="n">additional_steps</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">extend_model</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">extend_model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exog</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">time_invariant</span>
        <span class="k">if</span> <span class="n">out_of_sample</span> <span class="ow">and</span> <span class="n">extend_model</span><span class="p">:</span>
            <span class="n">kwargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_extension_time_varying_matrices</span><span class="p">(</span>
                <span class="n">params</span><span class="p">,</span> <span class="n">exog</span><span class="p">,</span> <span class="n">out_of_sample</span><span class="p">,</span> <span class="n">extend_kwargs</span><span class="p">,</span>
                <span class="n">transformed</span><span class="o">=</span><span class="n">transformed</span><span class="p">,</span> <span class="n">includes_fixed</span><span class="o">=</span><span class="n">includes_fixed</span><span class="p">,</span>
                <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Special handling for matrix terms that are time-varying but</span>
        <span class="c1"># irrelevant for impulse response functions. Must be set since</span>
        <span class="c1"># ssm.extend() requires that we pass new matrices for these, but they</span>
        <span class="c1"># are ignored for IRF purposes.</span>
        <span class="n">end</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="p">,</span> <span class="n">iloc</span> <span class="o">+</span> <span class="n">steps</span> <span class="o">+</span> <span class="n">additional_steps</span><span class="p">)</span>
        <span class="n">nextend</span> <span class="o">=</span> <span class="n">iloc</span> <span class="o">+</span> <span class="p">(</span><span class="n">steps</span> <span class="o">+</span> <span class="n">additional_steps</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">end</span>
        <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;obs_intercept&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="ow">and</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">_obs_intercept</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;obs_intercept&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">,</span> <span class="n">nextend</span><span class="p">))</span>
        <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;state_intercept&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="ow">and</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">_state_intercept</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;state_intercept&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">k_states</span><span class="p">,</span> <span class="n">nextend</span><span class="p">))</span>
        <span class="k">if</span> <span class="s1">&#39;obs_cov&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">_obs_cov</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;obs_cov&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">,</span> <span class="n">nextend</span><span class="p">))</span>
        <span class="c1"># Special handling for matrix terms that are time-varying but</span>
        <span class="c1"># only the value at the anchor matters for IRF purposes.</span>
        <span class="k">if</span> <span class="s1">&#39;state_cov&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">_state_cov</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">k_posdef</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">k_posdef</span><span class="p">,</span> <span class="n">nextend</span><span class="p">))</span>
            <span class="n">tmp</span><span class="p">[:]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;state_cov&#39;</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="n">iloc</span><span class="p">:</span><span class="n">iloc</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;state_cov&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span>
        <span class="k">if</span> <span class="s1">&#39;selection&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">_selection</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">k_states</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">k_posdef</span><span class="p">,</span> <span class="n">nextend</span><span class="p">))</span>
            <span class="n">tmp</span><span class="p">[:]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;selection&#39;</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="n">iloc</span><span class="p">:</span><span class="n">iloc</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;selection&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span>

        <span class="c1"># Construct a model that represents the simulation period</span>
        <span class="n">sim_model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">nextend</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">)),</span>
                                    <span class="n">start</span><span class="o">=</span><span class="n">iloc</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="n">end</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Compute the impulse responses</span>

        <span class="c1"># Convert endog name to index</span>
        <span class="n">use_pandas</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">PandasData</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">impulse</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">str</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">use_pandas</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Endog must be pd.DataFrame.&#39;</span><span class="p">)</span>
            <span class="n">impulse</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">endog_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">impulse</span><span class="p">)</span>

        <span class="n">irfs</span> <span class="o">=</span> <span class="n">sim_model</span><span class="o">.</span><span class="n">impulse_responses</span><span class="p">(</span>
            <span class="n">steps</span><span class="p">,</span> <span class="n">impulse</span><span class="p">,</span> <span class="n">orthogonalized</span><span class="p">,</span> <span class="n">cumulative</span><span class="p">)</span>

        <span class="c1"># IRF is (nobs x k_endog); do not want to squeeze in case of steps = 1</span>
        <span class="k">if</span> <span class="n">irfs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">irfs</span> <span class="o">=</span> <span class="n">irfs</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Wrap data / squeeze where appropriate</span>
        <span class="k">if</span> <span class="n">use_pandas</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">irfs</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">irfs</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">endog_names</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">irfs</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">irfs</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">endog_names</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">irfs</span></div>


<div class="viewcode-block" id="MLEModel.from_formula">
<a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEModel.from_formula.html#statsmodels.tsa.statespace.mlemodel.MLEModel.from_formula">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_formula</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">formula</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">subset</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Not implemented for state space models</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>
</div>



<div class="viewcode-block" id="MLEResults">
<a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEResults.html#statsmodels.tsa.statespace.mlemodel.MLEResults">[docs]</a>
<span class="k">class</span> <span class="nc">MLEResults</span><span class="p">(</span><span class="n">tsbase</span><span class="o">.</span><span class="n">TimeSeriesModelResults</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class to hold results from fitting a state space model.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    model : MLEModel instance</span>
<span class="sd">        The fitted model instance</span>
<span class="sd">    params : ndarray</span>
<span class="sd">        Fitted parameters</span>
<span class="sd">    filter_results : KalmanFilter instance</span>
<span class="sd">        The underlying state space model and Kalman filter output</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    model : Model instance</span>
<span class="sd">        A reference to the model that was fit.</span>
<span class="sd">    filter_results : KalmanFilter instance</span>
<span class="sd">        The underlying state space model and Kalman filter output</span>
<span class="sd">    nobs : float</span>
<span class="sd">        The number of observations used to fit the model.</span>
<span class="sd">    params : ndarray</span>
<span class="sd">        The parameters of the model.</span>
<span class="sd">    scale : float</span>
<span class="sd">        This is currently set to 1.0 unless the model uses concentrated</span>
<span class="sd">        filtering.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    MLEModel</span>
<span class="sd">    statsmodels.tsa.statespace.kalman_filter.FilterResults</span>
<span class="sd">    statsmodels.tsa.statespace.representation.FrozenRepresentation</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">results</span><span class="p">,</span> <span class="n">cov_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cov_kwds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">data</span>
        <span class="n">scale</span> <span class="o">=</span> <span class="n">results</span><span class="o">.</span><span class="n">scale</span>

        <span class="n">tsbase</span><span class="o">.</span><span class="n">TimeSeriesModelResults</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span>
                                               <span class="n">normalized_cov_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                               <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">)</span>

        <span class="c1"># Save the fixed parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_has_fixed_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">_has_fixed_params</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fixed_params_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">_fixed_params_index</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_free_params_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">_free_params_index</span>
        <span class="c1"># TODO: seems like maybe self.fixed_params should be the dictionary</span>
        <span class="c1"># itself, not just the keys?</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_fixed_params</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_fixed_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">_fixed_params</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fixed_params</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_fixed_params</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_fixed_params</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fixed_params</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">param_names</span> <span class="o">=</span> <span class="p">[</span>
            <span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> (fixed)&#39;</span> <span class="o">%</span> <span class="n">name</span> <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fixed_params</span> <span class="k">else</span> <span class="n">name</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">param_names</span> <span class="ow">or</span> <span class="p">[])]</span>

        <span class="c1"># Save the state space representation output</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filter_results</span> <span class="o">=</span> <span class="n">results</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="n">SmootherResults</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">smoother_results</span> <span class="o">=</span> <span class="n">results</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">smoother_results</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Dimensions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_results</span><span class="o">.</span><span class="n">nobs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nobs_diffuse</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_results</span><span class="o">.</span><span class="n">nobs_diffuse</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs_diffuse</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">loglikelihood_burn</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Care should be used when applying a loglikelihood&#39;</span>
                          <span class="s1">&#39; burn to a model with exact diffuse initialization.&#39;</span>
                          <span class="s1">&#39; Some results objects, e.g. degrees of freedom,&#39;</span>
                          <span class="s1">&#39; expect only one of the two to be set.&#39;</span><span class="p">)</span>
        <span class="c1"># This only excludes explicitly burned (usually approximate diffuse)</span>
        <span class="c1"># periods but does not exclude exact diffuse periods. This is</span>
        <span class="c1"># because the loglikelihood remains valid for the initial periods in</span>
        <span class="c1"># the exact diffuse case (see DK, 2012, section 7.2) and so also do</span>
        <span class="c1"># e.g. information criteria (see DK, 2012, section 7.4) and the score</span>
        <span class="c1"># vector (see DK, 2012, section 7.3.3, equation 7.15).</span>
        <span class="c1"># However, other objects should be excluded in the diffuse periods</span>
        <span class="c1"># (e.g. the diffuse forecast errors, so in some cases a different</span>
        <span class="c1"># nobs_effective will have to be computed and used)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nobs_effective</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">loglikelihood_burn</span>

        <span class="n">P</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_results</span><span class="o">.</span><span class="n">initial_diffuse_state_cov</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k_diffuse_states</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">P</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diagonal</span><span class="p">(</span><span class="n">P</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Degrees of freedom (see DK 2012, section 7.4)</span>
        <span class="n">k_free_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fixed_params</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">df_model</span> <span class="o">=</span> <span class="p">(</span><span class="n">k_free_params</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_diffuse_states</span>
                         <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_results</span><span class="o">.</span><span class="n">filter_concentrated</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">df_resid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs_effective</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">df_model</span>

        <span class="c1"># Setup covariance matrix notes dictionary</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;cov_kwds&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cov_kwds</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">cov_type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cov_type</span> <span class="o">=</span> <span class="s1">&#39;approx&#39;</span> <span class="k">if</span> <span class="n">results</span><span class="o">.</span><span class="n">memory_no_likelihood</span> <span class="k">else</span> <span class="s1">&#39;opg&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cov_type</span> <span class="o">=</span> <span class="n">cov_type</span>

        <span class="c1"># Setup the cache</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># Handle covariance matrix calculation</span>
        <span class="k">if</span> <span class="n">cov_kwds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cov_kwds</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cov_approx_complex_step</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">cov_kwds</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;approx_complex_step&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cov_approx_centered</span> <span class="o">=</span> <span class="n">cov_kwds</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;approx_centered&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_rank</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_get_robustcov_results</span><span class="p">(</span><span class="n">cov_type</span><span class="o">=</span><span class="n">cov_type</span><span class="p">,</span> <span class="n">use_self</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                        <span class="o">**</span><span class="n">cov_kwds</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">LinAlgError</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_rank</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">k_params</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cov_params_default</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">k_params</span><span class="p">,</span> <span class="n">k_params</span><span class="p">))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cov_kwds</span><span class="p">[</span><span class="s1">&#39;cov_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s1">&#39;Covariance matrix could not be calculated: singular.&#39;</span>
                <span class="s1">&#39; information matrix.&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">includes_fixed</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># References of filter and smoother output</span>
        <span class="n">extra_arrays</span> <span class="o">=</span> <span class="p">[</span>
            <span class="s1">&#39;filtered_state&#39;</span><span class="p">,</span> <span class="s1">&#39;filtered_state_cov&#39;</span><span class="p">,</span> <span class="s1">&#39;predicted_state&#39;</span><span class="p">,</span>
            <span class="s1">&#39;predicted_state_cov&#39;</span><span class="p">,</span> <span class="s1">&#39;forecasts&#39;</span><span class="p">,</span> <span class="s1">&#39;forecasts_error&#39;</span><span class="p">,</span>
            <span class="s1">&#39;forecasts_error_cov&#39;</span><span class="p">,</span> <span class="s1">&#39;standardized_forecasts_error&#39;</span><span class="p">,</span>
            <span class="s1">&#39;forecasts_error_diffuse_cov&#39;</span><span class="p">,</span> <span class="s1">&#39;predicted_diffuse_state_cov&#39;</span><span class="p">,</span>
            <span class="s1">&#39;scaled_smoothed_estimator&#39;</span><span class="p">,</span>
            <span class="s1">&#39;scaled_smoothed_estimator_cov&#39;</span><span class="p">,</span> <span class="s1">&#39;smoothing_error&#39;</span><span class="p">,</span>
            <span class="s1">&#39;smoothed_state&#39;</span><span class="p">,</span>
            <span class="s1">&#39;smoothed_state_cov&#39;</span><span class="p">,</span> <span class="s1">&#39;smoothed_state_autocov&#39;</span><span class="p">,</span>
            <span class="s1">&#39;smoothed_measurement_disturbance&#39;</span><span class="p">,</span>
            <span class="s1">&#39;smoothed_state_disturbance&#39;</span><span class="p">,</span>
            <span class="s1">&#39;smoothed_measurement_disturbance_cov&#39;</span><span class="p">,</span>
            <span class="s1">&#39;smoothed_state_disturbance_cov&#39;</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">extra_arrays</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filter_results</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>

        <span class="c1"># Remove too-short results when memory conservation was used</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_results</span><span class="o">.</span><span class="n">memory_no_forecast_mean</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">forecasts</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">forecasts_error</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_results</span><span class="o">.</span><span class="n">memory_no_forecast_cov</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">forecasts_error_cov</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_results</span><span class="o">.</span><span class="n">memory_no_predicted_mean</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">predicted_state</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_results</span><span class="o">.</span><span class="n">memory_no_predicted_cov</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">predicted_state_cov</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_results</span><span class="o">.</span><span class="n">memory_no_filtered_mean</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">filtered_state</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_results</span><span class="o">.</span><span class="n">memory_no_filtered_cov</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">filtered_state_cov</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_results</span><span class="o">.</span><span class="n">memory_no_gain</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_results</span><span class="o">.</span><span class="n">memory_no_smoothing</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_results</span><span class="o">.</span><span class="n">memory_no_std_forecast</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">standardized_forecasts_error</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Save more convenient access to states</span>
        <span class="c1"># (will create a private attribute _states here and provide actual</span>
        <span class="c1"># access via a getter, so that we can e.g. issue a warning in the case</span>
        <span class="c1"># that a useless Pandas index was given in the model specification)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_states</span> <span class="o">=</span> <span class="n">SimpleNamespace</span><span class="p">()</span>

        <span class="n">use_pandas</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">PandasData</span><span class="p">)</span>
        <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">_index</span>
        <span class="n">columns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">state_names</span>

        <span class="c1"># Predicted states</span>
        <span class="c1"># Note: a complication here is that we also include the initial values</span>
        <span class="c1"># here, so that we need an extended index in the Pandas case</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">predicted_state</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">filter_results</span><span class="o">.</span><span class="n">memory_no_predicted_mean</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_states</span><span class="o">.</span><span class="n">predicted</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="n">use_pandas</span><span class="p">:</span>
            <span class="n">extended_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">_get_index_with_final_state</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_states</span><span class="o">.</span><span class="n">predicted</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">predicted_state</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">extended_index</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_states</span><span class="o">.</span><span class="n">predicted</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predicted_state</span><span class="o">.</span><span class="n">T</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">predicted_state_cov</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">filter_results</span><span class="o">.</span><span class="n">memory_no_predicted_cov</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_states</span><span class="o">.</span><span class="n">predicted_cov</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="n">use_pandas</span><span class="p">:</span>
            <span class="n">extended_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">_get_index_with_final_state</span><span class="p">()</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">predicted_state_cov</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_states</span><span class="o">.</span><span class="n">predicted_cov</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="p">(</span><span class="n">tmp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">tmp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">tmp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">])),</span>
                <span class="n">index</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="o">.</span><span class="n">from_product</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">extended_index</span><span class="p">,</span> <span class="n">columns</span><span class="p">])</span><span class="o">.</span><span class="n">swaplevel</span><span class="p">(),</span>
                <span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_states</span><span class="o">.</span><span class="n">predicted_cov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">predicted_state_cov</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

        <span class="c1"># Filtered states</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filtered_state</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">filter_results</span><span class="o">.</span><span class="n">memory_no_filtered_mean</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_states</span><span class="o">.</span><span class="n">filtered</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="n">use_pandas</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_states</span><span class="o">.</span><span class="n">filtered</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">filtered_state</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_states</span><span class="o">.</span><span class="n">filtered</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filtered_state</span><span class="o">.</span><span class="n">T</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filtered_state_cov</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">filter_results</span><span class="o">.</span><span class="n">memory_no_filtered_cov</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_states</span><span class="o">.</span><span class="n">filtered_cov</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="n">use_pandas</span><span class="p">:</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filtered_state_cov</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_states</span><span class="o">.</span><span class="n">filtered_cov</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="p">(</span><span class="n">tmp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">tmp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">tmp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">])),</span>
                <span class="n">index</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="o">.</span><span class="n">from_product</span><span class="p">([</span><span class="n">index</span><span class="p">,</span> <span class="n">columns</span><span class="p">])</span><span class="o">.</span><span class="n">swaplevel</span><span class="p">(),</span>
                <span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_states</span><span class="o">.</span><span class="n">filtered_cov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">filtered_state_cov</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

        <span class="c1"># Smoothed states</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">smoothed_state</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_states</span><span class="o">.</span><span class="n">smoothed</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="n">use_pandas</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_states</span><span class="o">.</span><span class="n">smoothed</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">smoothed_state</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_states</span><span class="o">.</span><span class="n">smoothed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">smoothed_state</span><span class="o">.</span><span class="n">T</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">smoothed_state_cov</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_states</span><span class="o">.</span><span class="n">smoothed_cov</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="n">use_pandas</span><span class="p">:</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">smoothed_state_cov</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_states</span><span class="o">.</span><span class="n">smoothed_cov</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="p">(</span><span class="n">tmp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">tmp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">tmp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">])),</span>
                <span class="n">index</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="o">.</span><span class="n">from_product</span><span class="p">([</span><span class="n">index</span><span class="p">,</span> <span class="n">columns</span><span class="p">])</span><span class="o">.</span><span class="n">swaplevel</span><span class="p">(),</span>
                <span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_states</span><span class="o">.</span><span class="n">smoothed_cov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">smoothed_state_cov</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

        <span class="c1"># Handle removing data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data_attr_model</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_data_attr_model&#39;</span><span class="p">,</span> <span class="p">[])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data_attr_model</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="s1">&#39;ssm&#39;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data_attr</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">extra_arrays</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data_attr</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="s1">&#39;filter_results&#39;</span><span class="p">,</span> <span class="s1">&#39;smoother_results&#39;</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">_get_robustcov_results</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cov_type</span><span class="o">=</span><span class="s1">&#39;opg&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create new results instance with specified covariance estimator as</span>
<span class="sd">        default</span>

<span class="sd">        Note: creating new results instance currently not supported.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cov_type : str</span>
<span class="sd">            the type of covariance matrix estimator to use. See Notes below</span>
<span class="sd">        kwargs : depends on cov_type</span>
<span class="sd">            Required or optional arguments for covariance calculation.</span>
<span class="sd">            See Notes below.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        results : results instance</span>
<span class="sd">            This method creates a new results instance with the requested</span>
<span class="sd">            covariance as the default covariance of the parameters.</span>
<span class="sd">            Inferential statistics like p-values and hypothesis tests will be</span>
<span class="sd">            based on this covariance matrix.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The following covariance types and required or optional arguments are</span>
<span class="sd">        currently available:</span>

<span class="sd">        - &#39;opg&#39; for the outer product of gradient estimator</span>
<span class="sd">        - &#39;oim&#39; for the observed information matrix estimator, calculated</span>
<span class="sd">          using the method of Harvey (1989)</span>
<span class="sd">        - &#39;approx&#39; for the observed information matrix estimator,</span>
<span class="sd">          calculated using a numerical approximation of the Hessian matrix.</span>
<span class="sd">          Uses complex step approximation by default, or uses finite</span>
<span class="sd">          differences if `approx_complex_step=False` in the `cov_kwds`</span>
<span class="sd">          dictionary.</span>
<span class="sd">        - &#39;robust&#39; for an approximate (quasi-maximum likelihood) covariance</span>
<span class="sd">          matrix that may be valid even in the presence of some</span>
<span class="sd">          misspecifications. Intermediate calculations use the &#39;oim&#39;</span>
<span class="sd">          method.</span>
<span class="sd">        - &#39;robust_approx&#39; is the same as &#39;robust&#39; except that the</span>
<span class="sd">          intermediate calculations use the &#39;approx&#39; method.</span>
<span class="sd">        - &#39;none&#39; for no covariance matrix calculation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">statsmodels.base.covtype</span> <span class="kn">import</span> <span class="n">descriptions</span>

        <span class="n">use_self</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;use_self&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">use_self</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span>
            <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">,</span>
                <span class="n">normalized_cov_params</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">normalized_cov_params</span><span class="p">,</span>
                <span class="n">scale</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">)</span>

        <span class="c1"># Set the new covariance type</span>
        <span class="n">res</span><span class="o">.</span><span class="n">cov_type</span> <span class="o">=</span> <span class="n">cov_type</span>
        <span class="n">res</span><span class="o">.</span><span class="n">cov_kwds</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># Calculate the new covariance matrix</span>
        <span class="n">approx_complex_step</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cov_approx_complex_step</span>
        <span class="k">if</span> <span class="n">approx_complex_step</span><span class="p">:</span>
            <span class="n">approx_type_str</span> <span class="o">=</span> <span class="s1">&#39;complex-step&#39;</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cov_approx_centered</span><span class="p">:</span>
            <span class="n">approx_type_str</span> <span class="o">=</span> <span class="s1">&#39;centered finite differences&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">approx_type_str</span> <span class="o">=</span> <span class="s1">&#39;finite differences&#39;</span>

        <span class="n">k_params</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">k_params</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">res</span><span class="o">.</span><span class="n">cov_params_default</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
            <span class="n">res</span><span class="o">.</span><span class="n">_rank</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">res</span><span class="o">.</span><span class="n">cov_kwds</span><span class="p">[</span><span class="s1">&#39;description&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;No parameters estimated.&#39;</span>
        <span class="k">elif</span> <span class="n">cov_type</span> <span class="o">==</span> <span class="s1">&#39;custom&#39;</span><span class="p">:</span>
            <span class="n">res</span><span class="o">.</span><span class="n">cov_type</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;custom_cov_type&#39;</span><span class="p">]</span>
            <span class="n">res</span><span class="o">.</span><span class="n">cov_params_default</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;custom_cov_params&#39;</span><span class="p">]</span>
            <span class="n">res</span><span class="o">.</span><span class="n">cov_kwds</span><span class="p">[</span><span class="s1">&#39;description&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;custom_description&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fixed_params</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_free_params_index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_free_params_index</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">s_</span><span class="p">[</span><span class="o">...</span><span class="p">]</span>
            <span class="n">res</span><span class="o">.</span><span class="n">_rank</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">matrix_rank</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">cov_params_default</span><span class="p">[</span><span class="n">mask</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">cov_type</span> <span class="o">==</span> <span class="s1">&#39;none&#39;</span><span class="p">:</span>
            <span class="n">res</span><span class="o">.</span><span class="n">cov_params_default</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">k_params</span><span class="p">,</span> <span class="n">k_params</span><span class="p">))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">res</span><span class="o">.</span><span class="n">_rank</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">res</span><span class="o">.</span><span class="n">cov_kwds</span><span class="p">[</span><span class="s1">&#39;description&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">descriptions</span><span class="p">[</span><span class="s1">&#39;none&#39;</span><span class="p">]</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">cov_type</span> <span class="o">==</span> <span class="s1">&#39;approx&#39;</span><span class="p">:</span>
            <span class="n">res</span><span class="o">.</span><span class="n">cov_params_default</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">cov_params_approx</span>
            <span class="n">res</span><span class="o">.</span><span class="n">cov_kwds</span><span class="p">[</span><span class="s1">&#39;description&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">descriptions</span><span class="p">[</span><span class="s1">&#39;approx&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                                <span class="n">approx_type</span><span class="o">=</span><span class="n">approx_type_str</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">cov_type</span> <span class="o">==</span> <span class="s1">&#39;oim&#39;</span><span class="p">:</span>
            <span class="n">res</span><span class="o">.</span><span class="n">cov_params_default</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">cov_params_oim</span>
            <span class="n">res</span><span class="o">.</span><span class="n">cov_kwds</span><span class="p">[</span><span class="s1">&#39;description&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">descriptions</span><span class="p">[</span><span class="s1">&#39;OIM&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                                <span class="n">approx_type</span><span class="o">=</span><span class="n">approx_type_str</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">cov_type</span> <span class="o">==</span> <span class="s1">&#39;opg&#39;</span><span class="p">:</span>
            <span class="n">res</span><span class="o">.</span><span class="n">cov_params_default</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">cov_params_opg</span>
            <span class="n">res</span><span class="o">.</span><span class="n">cov_kwds</span><span class="p">[</span><span class="s1">&#39;description&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">descriptions</span><span class="p">[</span><span class="s1">&#39;OPG&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                                <span class="n">approx_type</span><span class="o">=</span><span class="n">approx_type_str</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">cov_type</span> <span class="o">==</span> <span class="s1">&#39;robust&#39;</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">cov_type</span> <span class="o">==</span> <span class="s1">&#39;robust_oim&#39;</span><span class="p">:</span>
            <span class="n">res</span><span class="o">.</span><span class="n">cov_params_default</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">cov_params_robust_oim</span>
            <span class="n">res</span><span class="o">.</span><span class="n">cov_kwds</span><span class="p">[</span><span class="s1">&#39;description&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">descriptions</span><span class="p">[</span><span class="s1">&#39;robust-OIM&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                                <span class="n">approx_type</span><span class="o">=</span><span class="n">approx_type_str</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">cov_type</span> <span class="o">==</span> <span class="s1">&#39;robust_approx&#39;</span><span class="p">:</span>
            <span class="n">res</span><span class="o">.</span><span class="n">cov_params_default</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">cov_params_robust_approx</span>
            <span class="n">res</span><span class="o">.</span><span class="n">cov_kwds</span><span class="p">[</span><span class="s1">&#39;description&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">descriptions</span><span class="p">[</span><span class="s1">&#39;robust-approx&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                                <span class="n">approx_type</span><span class="o">=</span><span class="n">approx_type_str</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Invalid covariance matrix type.&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">res</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">aic</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        (float) Akaike Information Criterion</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">aic</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">llf</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs_effective</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">df_model</span><span class="p">)</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">aicc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        (float) Akaike Information Criterion with small sample correction</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">aicc</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">llf</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs_effective</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">df_model</span><span class="p">)</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">bic</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        (float) Bayes Information Criterion</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">bic</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">llf</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs_effective</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">df_model</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_cov_params_approx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">approx_complex_step</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                           <span class="n">approx_centered</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="n">evaluated_hessian</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs_effective</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">hessian</span><span class="p">(</span>
            <span class="n">params</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">includes_fixed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">method</span><span class="o">=</span><span class="s1">&#39;approx&#39;</span><span class="p">,</span> <span class="n">approx_complex_step</span><span class="o">=</span><span class="n">approx_complex_step</span><span class="p">,</span>
            <span class="n">approx_centered</span><span class="o">=</span><span class="n">approx_centered</span><span class="p">)</span>
        <span class="c1"># TODO: Case with &quot;not approx_complex_step&quot; is not hit in</span>
        <span class="c1"># tests as of 2017-05-19</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fixed_params</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_free_params_index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_free_params_index</span><span class="p">)</span>
            <span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">singular_values</span><span class="p">)</span> <span class="o">=</span> <span class="n">pinv_extended</span><span class="p">(</span><span class="n">evaluated_hessian</span><span class="p">[</span><span class="n">mask</span><span class="p">])</span>
            <span class="n">neg_cov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">evaluated_hessian</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">neg_cov</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="p">(</span><span class="n">neg_cov</span><span class="p">,</span> <span class="n">singular_values</span><span class="p">)</span> <span class="o">=</span> <span class="n">pinv_extended</span><span class="p">(</span><span class="n">evaluated_hessian</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">includes_fixed</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rank</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_rank</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">matrix_rank</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">singular_values</span><span class="p">))</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">neg_cov</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">cov_params_approx</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        (array) The variance / covariance matrix. Computed using the numerical</span>
<span class="sd">        Hessian approximated by complex step or finite differences methods.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cov_params_approx</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cov_approx_complex_step</span><span class="p">,</span>
                                       <span class="bp">self</span><span class="o">.</span><span class="n">_cov_approx_centered</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_cov_params_oim</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">approx_complex_step</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">approx_centered</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="n">evaluated_hessian</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs_effective</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">hessian</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="n">hessian_method</span><span class="o">=</span><span class="s1">&#39;oim&#39;</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">includes_fixed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">approx_complex_step</span><span class="o">=</span><span class="n">approx_complex_step</span><span class="p">,</span>
            <span class="n">approx_centered</span><span class="o">=</span><span class="n">approx_centered</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fixed_params</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_free_params_index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_free_params_index</span><span class="p">)</span>
            <span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">singular_values</span><span class="p">)</span> <span class="o">=</span> <span class="n">pinv_extended</span><span class="p">(</span><span class="n">evaluated_hessian</span><span class="p">[</span><span class="n">mask</span><span class="p">])</span>
            <span class="n">neg_cov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">evaluated_hessian</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">neg_cov</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="p">(</span><span class="n">neg_cov</span><span class="p">,</span> <span class="n">singular_values</span><span class="p">)</span> <span class="o">=</span> <span class="n">pinv_extended</span><span class="p">(</span><span class="n">evaluated_hessian</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">includes_fixed</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rank</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_rank</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">matrix_rank</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">singular_values</span><span class="p">))</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">neg_cov</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">cov_params_oim</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        (array) The variance / covariance matrix. Computed using the method</span>
<span class="sd">        from Harvey (1989).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cov_params_oim</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cov_approx_complex_step</span><span class="p">,</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">_cov_approx_centered</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_cov_params_opg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">approx_complex_step</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">approx_centered</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="n">evaluated_hessian</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs_effective</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">_hessian_opg</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">includes_fixed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">approx_complex_step</span><span class="o">=</span><span class="n">approx_complex_step</span><span class="p">,</span>
            <span class="n">approx_centered</span><span class="o">=</span><span class="n">approx_centered</span><span class="p">)</span>

        <span class="n">no_free_params</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_free_params_index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span>
                          <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_free_params_index</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">no_free_params</span><span class="p">:</span>
            <span class="n">neg_cov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">evaluated_hessian</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">singular_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fixed_params</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_free_params_index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_free_params_index</span><span class="p">)</span>
            <span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">singular_values</span><span class="p">)</span> <span class="o">=</span> <span class="n">pinv_extended</span><span class="p">(</span><span class="n">evaluated_hessian</span><span class="p">[</span><span class="n">mask</span><span class="p">])</span>
            <span class="n">neg_cov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">evaluated_hessian</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">neg_cov</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="p">(</span><span class="n">neg_cov</span><span class="p">,</span> <span class="n">singular_values</span><span class="p">)</span> <span class="o">=</span> <span class="n">pinv_extended</span><span class="p">(</span><span class="n">evaluated_hessian</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">includes_fixed</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rank</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">no_free_params</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_rank</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_rank</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">matrix_rank</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">singular_values</span><span class="p">))</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">neg_cov</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">cov_params_opg</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        (array) The variance / covariance matrix. Computed using the outer</span>
<span class="sd">        product of gradients method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cov_params_opg</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cov_approx_complex_step</span><span class="p">,</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">_cov_approx_centered</span><span class="p">)</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">cov_params_robust</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        (array) The QMLE variance / covariance matrix. Alias for</span>
<span class="sd">        `cov_params_robust_oim`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cov_params_robust_oim</span>

    <span class="k">def</span> <span class="nf">_cov_params_robust_oim</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">approx_complex_step</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                               <span class="n">approx_centered</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="n">cov_opg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cov_params_opg</span><span class="p">(</span><span class="n">approx_complex_step</span><span class="o">=</span><span class="n">approx_complex_step</span><span class="p">,</span>
                                       <span class="n">approx_centered</span><span class="o">=</span><span class="n">approx_centered</span><span class="p">)</span>

        <span class="n">evaluated_hessian</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs_effective</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">hessian</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="n">hessian_method</span><span class="o">=</span><span class="s1">&#39;oim&#39;</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">includes_fixed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">approx_complex_step</span><span class="o">=</span><span class="n">approx_complex_step</span><span class="p">,</span>
            <span class="n">approx_centered</span><span class="o">=</span><span class="n">approx_centered</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fixed_params</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_free_params_index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_free_params_index</span><span class="p">)</span>
            <span class="n">cov_params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">evaluated_hessian</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

            <span class="n">cov_opg</span> <span class="o">=</span> <span class="n">cov_opg</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
            <span class="n">evaluated_hessian</span> <span class="o">=</span> <span class="n">evaluated_hessian</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>

            <span class="n">tmp</span><span class="p">,</span> <span class="n">singular_values</span> <span class="o">=</span> <span class="n">pinv_extended</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">evaluated_hessian</span><span class="p">,</span> <span class="n">cov_opg</span><span class="p">),</span> <span class="n">evaluated_hessian</span><span class="p">))</span>

            <span class="n">cov_params</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="p">(</span><span class="n">cov_params</span><span class="p">,</span> <span class="n">singular_values</span><span class="p">)</span> <span class="o">=</span> <span class="n">pinv_extended</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">evaluated_hessian</span><span class="p">,</span> <span class="n">cov_opg</span><span class="p">),</span> <span class="n">evaluated_hessian</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">includes_fixed</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rank</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_rank</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">matrix_rank</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">singular_values</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">cov_params</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">cov_params_robust_oim</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        (array) The QMLE variance / covariance matrix. Computed using the</span>
<span class="sd">        method from Harvey (1989) as the evaluated hessian.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cov_params_robust_oim</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cov_approx_complex_step</span><span class="p">,</span>
                                           <span class="bp">self</span><span class="o">.</span><span class="n">_cov_approx_centered</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_cov_params_robust_approx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">approx_complex_step</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                  <span class="n">approx_centered</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="n">cov_opg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cov_params_opg</span><span class="p">(</span><span class="n">approx_complex_step</span><span class="o">=</span><span class="n">approx_complex_step</span><span class="p">,</span>
                                       <span class="n">approx_centered</span><span class="o">=</span><span class="n">approx_centered</span><span class="p">)</span>

        <span class="n">evaluated_hessian</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs_effective</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">hessian</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">includes_fixed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">method</span><span class="o">=</span><span class="s1">&#39;approx&#39;</span><span class="p">,</span> <span class="n">approx_complex_step</span><span class="o">=</span><span class="n">approx_complex_step</span><span class="p">)</span>
        <span class="c1"># TODO: Case with &quot;not approx_complex_step&quot; is not</span>
        <span class="c1"># hit in tests as of 2017-05-19</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fixed_params</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_free_params_index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_free_params_index</span><span class="p">)</span>
            <span class="n">cov_params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">evaluated_hessian</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

            <span class="n">cov_opg</span> <span class="o">=</span> <span class="n">cov_opg</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
            <span class="n">evaluated_hessian</span> <span class="o">=</span> <span class="n">evaluated_hessian</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>

            <span class="n">tmp</span><span class="p">,</span> <span class="n">singular_values</span> <span class="o">=</span> <span class="n">pinv_extended</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">evaluated_hessian</span><span class="p">,</span> <span class="n">cov_opg</span><span class="p">),</span> <span class="n">evaluated_hessian</span><span class="p">))</span>

            <span class="n">cov_params</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="p">(</span><span class="n">cov_params</span><span class="p">,</span> <span class="n">singular_values</span><span class="p">)</span> <span class="o">=</span> <span class="n">pinv_extended</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">evaluated_hessian</span><span class="p">,</span> <span class="n">cov_opg</span><span class="p">),</span> <span class="n">evaluated_hessian</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">includes_fixed</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rank</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_rank</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">matrix_rank</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">singular_values</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">cov_params</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">cov_params_robust_approx</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        (array) The QMLE variance / covariance matrix. Computed using the</span>
<span class="sd">        numerical Hessian as the evaluated hessian.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cov_params_robust_approx</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cov_approx_complex_step</span><span class="p">,</span>
                                              <span class="bp">self</span><span class="o">.</span><span class="n">_cov_approx_centered</span><span class="p">)</span>

<div class="viewcode-block" id="MLEResults.info_criteria">
<a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEResults.info_criteria.html#statsmodels.tsa.statespace.mlemodel.MLEResults.info_criteria">[docs]</a>
    <span class="k">def</span> <span class="nf">info_criteria</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">criteria</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;standard&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Information criteria</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        criteria : {&#39;aic&#39;, &#39;bic&#39;, &#39;hqic&#39;}</span>
<span class="sd">            The information criteria to compute.</span>
<span class="sd">        method : {&#39;standard&#39;, &#39;lutkepohl&#39;}</span>
<span class="sd">            The method for information criteria computation. Default is</span>
<span class="sd">            &#39;standard&#39; method; &#39;lutkepohl&#39; computes the information criteria</span>
<span class="sd">            as in Ltkepohl (2007). See Notes for formulas.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The `&#39;standard&#39;` formulas are:</span>

<span class="sd">        .. math::</span>

<span class="sd">            AIC &amp; = -2 \log L(Y_n | \hat \psi) + 2 k \\</span>
<span class="sd">            BIC &amp; = -2 \log L(Y_n | \hat \psi) + k \log n \\</span>
<span class="sd">            HQIC &amp; = -2 \log L(Y_n | \hat \psi) + 2 k \log \log n \\</span>

<span class="sd">        where :math:`\hat \psi` are the maximum likelihood estimates of the</span>
<span class="sd">        parameters, :math:`n` is the number of observations, and `k` is the</span>
<span class="sd">        number of estimated parameters.</span>

<span class="sd">        Note that the `&#39;standard&#39;` formulas are returned from the `aic`, `bic`,</span>
<span class="sd">        and `hqic` results attributes.</span>

<span class="sd">        The `&#39;lutkepohl&#39;` formulas are (Ltkepohl, 2010):</span>

<span class="sd">        .. math::</span>

<span class="sd">            AIC_L &amp; = \log | Q | + \frac{2 k}{n} \\</span>
<span class="sd">            BIC_L &amp; = \log | Q | + \frac{k \log n}{n} \\</span>
<span class="sd">            HQIC_L &amp; = \log | Q | + \frac{2 k \log \log n}{n} \\</span>

<span class="sd">        where :math:`Q` is the state covariance matrix. Note that the Ltkepohl</span>
<span class="sd">        definitions do not apply to all state space models, and should be used</span>
<span class="sd">        with care outside of SARIMAX and VARMAX models.</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        .. [*] Ltkepohl, Helmut. 2007. *New Introduction to Multiple Time*</span>
<span class="sd">           *Series Analysis.* Berlin: Springer.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">criteria</span> <span class="o">=</span> <span class="n">criteria</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="n">method</span> <span class="o">=</span> <span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;standard&#39;</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">criteria</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;lutkepohl&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_results</span><span class="o">.</span><span class="n">state_cov</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Cannot compute Ltkepohl statistics for&#39;</span>
                                 <span class="s1">&#39; models with time-varying state covariance&#39;</span>
                                 <span class="s1">&#39; matrix.&#39;</span><span class="p">)</span>

            <span class="n">cov</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_results</span><span class="o">.</span><span class="n">state_cov</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">criteria</span> <span class="o">==</span> <span class="s1">&#39;aic&#39;</span><span class="p">:</span>
                <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">slogdet</span><span class="p">(</span><span class="n">cov</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span>
                                 <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">df_model</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs_effective</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">criteria</span> <span class="o">==</span> <span class="s1">&#39;bic&#39;</span><span class="p">:</span>
                <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">slogdet</span><span class="p">(</span><span class="n">cov</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span>
                                 <span class="bp">self</span><span class="o">.</span><span class="n">df_model</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nobs_effective</span><span class="p">)</span> <span class="o">/</span>
                                 <span class="bp">self</span><span class="o">.</span><span class="n">nobs_effective</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">criteria</span> <span class="o">==</span> <span class="s1">&#39;hqic&#39;</span><span class="p">:</span>
                <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">slogdet</span><span class="p">(</span><span class="n">cov</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span>
                                 <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">df_model</span> <span class="o">*</span>
                                 <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nobs_effective</span><span class="p">))</span> <span class="o">/</span>
                                 <span class="bp">self</span><span class="o">.</span><span class="n">nobs_effective</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid information criteria&#39;</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid information criteria computation method&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">out</span></div>


    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">fittedvalues</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        (array) The predicted values of the model. An (nobs x k_endog) array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># This is a (k_endog x nobs array; do not want to squeeze in case of</span>
        <span class="c1"># the corner case where nobs = 1 (mostly a concern in the predict or</span>
        <span class="c1"># forecast functions, but here also to maintain consistency)</span>
        <span class="n">fittedvalues</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">forecasts</span>
        <span class="k">if</span> <span class="n">fittedvalues</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">elif</span> <span class="n">fittedvalues</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">fittedvalues</span> <span class="o">=</span> <span class="n">fittedvalues</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fittedvalues</span> <span class="o">=</span> <span class="n">fittedvalues</span><span class="o">.</span><span class="n">T</span>
        <span class="k">return</span> <span class="n">fittedvalues</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">hqic</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        (float) Hannan-Quinn Information Criterion</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># return (-2 * self.llf +</span>
        <span class="c1">#         2 * np.log(np.log(self.nobs_effective)) * self.df_model)</span>
        <span class="k">return</span> <span class="n">hqic</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">llf</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs_effective</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">df_model</span><span class="p">)</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">llf_obs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        (float) The value of the log-likelihood function evaluated at `params`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_results</span><span class="o">.</span><span class="n">llf_obs</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">llf</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        (float) The value of the log-likelihood function evaluated at `params`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_results</span><span class="o">.</span><span class="n">llf</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">loglikelihood_burn</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        (float) The number of observations during which the likelihood is not</span>
<span class="sd">        evaluated.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_results</span><span class="o">.</span><span class="n">loglikelihood_burn</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">mae</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        (float) Mean absolute error</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">resid</span><span class="p">))</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">mse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        (float) Mean squared error</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sse</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">pvalues</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        (array) The p-values associated with the z-statistics of the</span>
<span class="sd">        coefficients. Note that the coefficients are assumed to have a Normal</span>
<span class="sd">        distribution.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pvalues</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">zvalues</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">pvalues</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="n">mask</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_free_params_index</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">mask</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">zvalues</span><span class="p">)</span>
        <span class="n">pvalues</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">sf</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">zvalues</span><span class="p">[</span><span class="n">mask</span><span class="p">]))</span> <span class="o">*</span> <span class="mi">2</span>
        <span class="k">return</span> <span class="n">pvalues</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">resid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        (array) The model residuals. An (nobs x k_endog) array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># This is a (k_endog x nobs array; do not want to squeeze in case of</span>
        <span class="c1"># the corner case where nobs = 1 (mostly a concern in the predict or</span>
        <span class="c1"># forecast functions, but here also to maintain consistency)</span>
        <span class="n">resid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">forecasts_error</span>
        <span class="k">if</span> <span class="n">resid</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">elif</span> <span class="n">resid</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">resid</span> <span class="o">=</span> <span class="n">resid</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">resid</span> <span class="o">=</span> <span class="n">resid</span><span class="o">.</span><span class="n">T</span>
        <span class="k">return</span> <span class="n">resid</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">states</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">_index_generated</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">_index_none</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;No supported index is available. The `states`&#39;</span>
                          <span class="s1">&#39; DataFrame uses a generated integer index&#39;</span><span class="p">,</span>
                          <span class="n">ValueWarning</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_states</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">sse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        (float) Sum of squared errors</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">resid</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">zvalues</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        (array) The z-statistics for the coefficients.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">bse</span>

<div class="viewcode-block" id="MLEResults.test_normality">
<a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEResults.test_normality.html#statsmodels.tsa.statespace.mlemodel.MLEResults.test_normality">[docs]</a>
    <span class="k">def</span> <span class="nf">test_normality</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Test for normality of standardized residuals.</span>

<span class="sd">        Null hypothesis is normality.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        method : {&#39;jarquebera&#39;, None}</span>
<span class="sd">            The statistical test for normality. Must be &#39;jarquebera&#39; for</span>
<span class="sd">            Jarque-Bera normality test. If None, an attempt is made to select</span>
<span class="sd">            an appropriate test.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        statsmodels.stats.stattools.jarque_bera</span>
<span class="sd">            The Jarque-Bera test of normality.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Let `d` = max(loglikelihood_burn, nobs_diffuse); this test is</span>
<span class="sd">        calculated ignoring the first `d` residuals.</span>

<span class="sd">        In the case of missing data, the maintained hypothesis is that the</span>
<span class="sd">        data are missing completely at random. This test is then run on the</span>
<span class="sd">        standardized residuals excluding those corresponding to missing</span>
<span class="sd">        observations.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">method</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">method</span> <span class="o">=</span> <span class="s1">&#39;jarquebera&#39;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">standardized_forecasts_error</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Cannot compute test statistic when standardized&#39;</span>
                             <span class="s1">&#39; forecast errors have not been computed.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;jarquebera&#39;</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">statsmodels.stats.stattools</span> <span class="kn">import</span> <span class="n">jarque_bera</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loglikelihood_burn</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs_diffuse</span><span class="p">)</span>
            <span class="n">output</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">k_endog</span><span class="p">):</span>
                <span class="n">resid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_results</span><span class="o">.</span><span class="n">standardized_forecasts_error</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">d</span><span class="p">:]</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">resid</span><span class="p">)</span>
                <span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">jarque_bera</span><span class="p">(</span><span class="n">resid</span><span class="p">[</span><span class="n">mask</span><span class="p">]))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Invalid normality test method.&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">output</span><span class="p">)</span></div>


<div class="viewcode-block" id="MLEResults.test_heteroskedasticity">
<a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEResults.test_heteroskedasticity.html#statsmodels.tsa.statespace.mlemodel.MLEResults.test_heteroskedasticity">[docs]</a>
    <span class="k">def</span> <span class="nf">test_heteroskedasticity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">alternative</span><span class="o">=</span><span class="s1">&#39;two-sided&#39;</span><span class="p">,</span>
                                <span class="n">use_f</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Test for heteroskedasticity of standardized residuals</span>

<span class="sd">        Tests whether the sum-of-squares in the first third of the sample is</span>
<span class="sd">        significantly different than the sum-of-squares in the last third</span>
<span class="sd">        of the sample. Analogous to a Goldfeld-Quandt test. The null hypothesis</span>
<span class="sd">        is of no heteroskedasticity.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        method : {&#39;breakvar&#39;, None}</span>
<span class="sd">            The statistical test for heteroskedasticity. Must be &#39;breakvar&#39;</span>
<span class="sd">            for test of a break in the variance. If None, an attempt is</span>
<span class="sd">            made to select an appropriate test.</span>
<span class="sd">        alternative : str, &#39;increasing&#39;, &#39;decreasing&#39; or &#39;two-sided&#39;</span>
<span class="sd">            This specifies the alternative for the p-value calculation. Default</span>
<span class="sd">            is two-sided.</span>
<span class="sd">        use_f : bool, optional</span>
<span class="sd">            Whether or not to compare against the asymptotic distribution</span>
<span class="sd">            (chi-squared) or the approximate small-sample distribution (F).</span>
<span class="sd">            Default is True (i.e. default is to compare against an F</span>
<span class="sd">            distribution).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        output : ndarray</span>
<span class="sd">            An array with `(test_statistic, pvalue)` for each endogenous</span>
<span class="sd">            variable. The array is then sized `(k_endog, 2)`. If the method is</span>
<span class="sd">            called as `het = res.test_heteroskedasticity()`, then `het[0]` is</span>
<span class="sd">            an array of size 2 corresponding to the first endogenous variable,</span>
<span class="sd">            where `het[0][0]` is the test statistic, and `het[0][1]` is the</span>
<span class="sd">            p-value.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        statsmodels.tsa.stattools.breakvar_heteroskedasticity_test</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The null hypothesis is of no heteroskedasticity.</span>

<span class="sd">        For :math:`h = [T/3]`, the test statistic is:</span>

<span class="sd">        .. math::</span>

<span class="sd">            H(h) = \sum_{t=T-h+1}^T  \tilde v_t^2</span>
<span class="sd">            \Bigg / \sum_{t=d+1}^{d+1+h} \tilde v_t^2</span>

<span class="sd">        where :math:`d` = max(loglikelihood_burn, nobs_diffuse)` (usually</span>
<span class="sd">        corresponding to diffuse initialization under either the approximate</span>
<span class="sd">        or exact approach).</span>

<span class="sd">        This statistic can be tested against an :math:`F(h,h)` distribution.</span>
<span class="sd">        Alternatively, :math:`h H(h)` is asymptotically distributed according</span>
<span class="sd">        to :math:`\chi_h^2`; this second test can be applied by passing</span>
<span class="sd">        `use_f=True` as an argument.</span>

<span class="sd">        See section 5.4 of [1]_ for the above formula and discussion, as well</span>
<span class="sd">        as additional details.</span>

<span class="sd">        TODO</span>

<span class="sd">        - Allow specification of :math:`h`</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        .. [1] Harvey, Andrew C. 1990. *Forecasting, Structural Time Series*</span>
<span class="sd">               *Models and the Kalman Filter.* Cambridge University Press.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">method</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">method</span> <span class="o">=</span> <span class="s1">&#39;breakvar&#39;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">standardized_forecasts_error</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Cannot compute test statistic when standardized&#39;</span>
                             <span class="s1">&#39; forecast errors have not been computed.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;breakvar&#39;</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">statsmodels.tsa.stattools</span> <span class="kn">import</span> <span class="p">(</span>
                <span class="n">breakvar_heteroskedasticity_test</span>
                <span class="p">)</span>
            <span class="c1"># Store some values</span>
            <span class="n">resid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_results</span><span class="o">.</span><span class="n">standardized_forecasts_error</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loglikelihood_burn</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs_diffuse</span><span class="p">)</span>
            <span class="c1"># This differs from self.nobs_effective because here we want to</span>
            <span class="c1"># exclude exact diffuse periods, whereas self.nobs_effective only</span>
            <span class="c1"># excludes explicitly burned (usually approximate diffuse) periods.</span>
            <span class="n">nobs_effective</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span> <span class="o">-</span> <span class="n">d</span>
            <span class="n">h</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">nobs_effective</span> <span class="o">/</span> <span class="mi">3</span><span class="p">))</span>

            <span class="n">test_statistics</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">p_values</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">k_endog</span><span class="p">):</span>
                <span class="n">test_statistic</span><span class="p">,</span> <span class="n">p_value</span> <span class="o">=</span> <span class="n">breakvar_heteroskedasticity_test</span><span class="p">(</span>
                    <span class="n">resid</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">d</span><span class="p">:],</span>
                    <span class="n">subset_length</span><span class="o">=</span><span class="n">h</span><span class="p">,</span>
                    <span class="n">alternative</span><span class="o">=</span><span class="n">alternative</span><span class="p">,</span>
                    <span class="n">use_f</span><span class="o">=</span><span class="n">use_f</span>
                    <span class="p">)</span>
                <span class="n">test_statistics</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">test_statistic</span><span class="p">)</span>
                <span class="n">p_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p_value</span><span class="p">)</span>

            <span class="n">output</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">test_statistics</span><span class="p">,</span> <span class="n">p_values</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Invalid heteroskedasticity test&#39;</span>
                                      <span class="s1">&#39; method.&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">output</span></div>


<div class="viewcode-block" id="MLEResults.test_serial_correlation">
<a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEResults.test_serial_correlation.html#statsmodels.tsa.statespace.mlemodel.MLEResults.test_serial_correlation">[docs]</a>
    <span class="k">def</span> <span class="nf">test_serial_correlation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">df_adjust</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">lags</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Ljung-Box test for no serial correlation of standardized residuals</span>

<span class="sd">        Null hypothesis is no serial correlation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        method : {&#39;ljungbox&#39;, &#39;boxpierce&#39;, None}</span>
<span class="sd">            The statistical test for serial correlation. If None, an attempt is</span>
<span class="sd">            made to select an appropriate test.</span>
<span class="sd">        lags : None, int or array_like</span>
<span class="sd">            If lags is an integer then this is taken to be the largest lag</span>
<span class="sd">            that is included, the test result is reported for all smaller lag</span>
<span class="sd">            length.</span>
<span class="sd">            If lags is a list or array, then all lags are included up to the</span>
<span class="sd">            largest lag in the list, however only the tests for the lags in the</span>
<span class="sd">            list are reported.</span>
<span class="sd">            If lags is None, then the default maxlag is min(10, nobs // 5) for</span>
<span class="sd">            non-seasonal models and min(2*m, nobs // 5) for seasonal time</span>
<span class="sd">            series where m is the seasonal period.</span>
<span class="sd">        df_adjust : bool, optional</span>
<span class="sd">            If True, the degrees of freedom consumed by the model is subtracted</span>
<span class="sd">            from the degrees-of-freedom used in the test so that the adjusted</span>
<span class="sd">            dof for the statistics are lags - model_df. In an ARMA model, this</span>
<span class="sd">            value is usually p+q where p is the AR order and q is the MA order.</span>
<span class="sd">            When using df_adjust, it is not possible to use tests based on</span>
<span class="sd">            fewer than model_df lags.</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        output : ndarray</span>
<span class="sd">            An array with `(test_statistic, pvalue)` for each endogenous</span>
<span class="sd">            variable and each lag. The array is then sized</span>
<span class="sd">            `(k_endog, 2, lags)`. If the method is called as</span>
<span class="sd">            `ljungbox = res.test_serial_correlation()`, then `ljungbox[i]`</span>
<span class="sd">            holds the results of the Ljung-Box test (as would be returned by</span>
<span class="sd">            `statsmodels.stats.diagnostic.acorr_ljungbox`) for the `i` th</span>
<span class="sd">            endogenous variable.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        statsmodels.stats.diagnostic.acorr_ljungbox</span>
<span class="sd">            Ljung-Box test for serial correlation.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Let `d` = max(loglikelihood_burn, nobs_diffuse); this test is</span>
<span class="sd">        calculated ignoring the first `d` residuals.</span>

<span class="sd">        Output is nan for any endogenous variable which has missing values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">method</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">method</span> <span class="o">=</span> <span class="s1">&#39;ljungbox&#39;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">standardized_forecasts_error</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Cannot compute test statistic when standardized&#39;</span>
                             <span class="s1">&#39; forecast errors have not been computed.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;ljungbox&#39;</span> <span class="ow">or</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;boxpierce&#39;</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">statsmodels.stats.diagnostic</span> <span class="kn">import</span> <span class="n">acorr_ljungbox</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loglikelihood_burn</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs_diffuse</span><span class="p">)</span>
            <span class="c1"># This differs from self.nobs_effective because here we want to</span>
            <span class="c1"># exclude exact diffuse periods, whereas self.nobs_effective only</span>
            <span class="c1"># excludes explicitly burned (usually approximate diffuse) periods.</span>
            <span class="n">nobs_effective</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span> <span class="o">-</span> <span class="n">d</span>
            <span class="n">output</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="c1"># Default lags for acorr_ljungbox is 40, but may not always have</span>
            <span class="c1"># that many observations</span>
            <span class="k">if</span> <span class="n">lags</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">seasonal_periods</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">,</span> <span class="s2">&quot;seasonal_periods&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">seasonal_periods</span><span class="p">:</span>
                    <span class="n">lags</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">seasonal_periods</span><span class="p">,</span> <span class="n">nobs_effective</span> <span class="o">//</span> <span class="mi">5</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">lags</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">nobs_effective</span> <span class="o">//</span> <span class="mi">5</span><span class="p">)</span>

            <span class="n">model_df</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="n">df_adjust</span><span class="p">:</span>
                <span class="n">model_df</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">df_model</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_diffuse_states</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

            <span class="n">cols</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;boxpierce&#39;</span> <span class="k">else</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">k_endog</span><span class="p">):</span>
                <span class="n">results</span> <span class="o">=</span> <span class="n">acorr_ljungbox</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">filter_results</span><span class="o">.</span><span class="n">standardized_forecasts_error</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">d</span><span class="p">:],</span>
                    <span class="n">lags</span><span class="o">=</span><span class="n">lags</span><span class="p">,</span> <span class="n">boxpierce</span><span class="o">=</span><span class="p">(</span><span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;boxpierce&#39;</span><span class="p">),</span>
                    <span class="n">model_df</span><span class="o">=</span><span class="n">model_df</span><span class="p">)</span>
                <span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">results</span><span class="p">)[:,</span> <span class="n">cols</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

            <span class="n">output</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">output</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Invalid serial correlation test&#39;</span>
                                      <span class="s1">&#39; method.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">output</span></div>


<div class="viewcode-block" id="MLEResults.get_prediction">
<a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEResults.get_prediction.html#statsmodels.tsa.statespace.mlemodel.MLEResults.get_prediction">[docs]</a>
    <span class="k">def</span> <span class="nf">get_prediction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dynamic</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                       <span class="n">information_set</span><span class="o">=</span><span class="s1">&#39;predicted&#39;</span><span class="p">,</span> <span class="n">signal_only</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                       <span class="n">index</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">exog</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">extend_model</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                       <span class="n">extend_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        In-sample prediction and out-of-sample forecasting</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        start : int, str, or datetime, optional</span>
<span class="sd">            Zero-indexed observation number at which to start forecasting,</span>
<span class="sd">            i.e., the first forecast is start. Can also be a date string to</span>
<span class="sd">            parse or a datetime type. Default is the the zeroth observation.</span>
<span class="sd">        end : int, str, or datetime, optional</span>
<span class="sd">            Zero-indexed observation number at which to end forecasting, i.e.,</span>
<span class="sd">            the last forecast is end. Can also be a date string to</span>
<span class="sd">            parse or a datetime type. However, if the dates index does not</span>
<span class="sd">            have a fixed frequency, end must be an integer index if you</span>
<span class="sd">            want out of sample prediction. Default is the last observation in</span>
<span class="sd">            the sample.</span>
<span class="sd">        dynamic : bool, int, str, or datetime, optional</span>
<span class="sd">            Integer offset relative to `start` at which to begin dynamic</span>
<span class="sd">            prediction. Can also be an absolute date string to parse or a</span>
<span class="sd">            datetime type (these are not interpreted as offsets).</span>
<span class="sd">            Prior to this observation, true endogenous values will be used for</span>
<span class="sd">            prediction; starting with this observation and continuing through</span>
<span class="sd">            the end of prediction, forecasted endogenous values will be used</span>
<span class="sd">            instead.</span>
<span class="sd">        information_set : str, optional</span>
<span class="sd">            The information set to condition each prediction on. Default is</span>
<span class="sd">            &quot;predicted&quot;, which computes predictions of period t values</span>
<span class="sd">            conditional on observed data through period t-1; these are</span>
<span class="sd">            one-step-ahead predictions, and correspond with the typical</span>
<span class="sd">            `fittedvalues` results attribute. Alternatives are &quot;filtered&quot;,</span>
<span class="sd">            which computes predictions of period t values conditional on</span>
<span class="sd">            observed data through period t, and &quot;smoothed&quot;, which computes</span>
<span class="sd">            predictions of period t values conditional on the entire dataset</span>
<span class="sd">            (including also future observations t+1, t+2, ...).</span>
<span class="sd">        signal_only : bool, optional</span>
<span class="sd">            Whether to compute predictions of only the &quot;signal&quot; component of</span>
<span class="sd">            the observation equation. Default is False. For example, the</span>
<span class="sd">            observation equation of a time-invariant model is</span>
<span class="sd">            :math:`y_t = d + Z \alpha_t + \varepsilon_t`, and the &quot;signal&quot;</span>
<span class="sd">            component is then :math:`Z \alpha_t`. If this argument is set to</span>
<span class="sd">            True, then predictions of the &quot;signal&quot; :math:`Z \alpha_t` will be</span>
<span class="sd">            returned. Otherwise, the default is for predictions of :math:`y_t`</span>
<span class="sd">            to be returned.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Additional arguments may required for forecasting beyond the end</span>
<span class="sd">            of the sample. See `FilterResults.predict` for more details.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        predictions : PredictionResults</span>
<span class="sd">            PredictionResults instance containing in-sample predictions /</span>
<span class="sd">            out-of-sample forecasts and results including confidence intervals.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        forecast</span>
<span class="sd">            Out-of-sample forecasts.</span>
<span class="sd">        predict</span>
<span class="sd">            In-sample predictions and out-of-sample forecasts.</span>
<span class="sd">        get_forecast</span>
<span class="sd">            Out-of-sample forecasts and results including confidence intervals.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Handle start, end, dynamic</span>
        <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">out_of_sample</span><span class="p">,</span> <span class="n">prediction_index</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">_get_prediction_index</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">index</span><span class="p">))</span>

        <span class="c1"># Handle `dynamic`</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dynamic</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">dt</span><span class="o">.</span><span class="n">datetime</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">)):</span>
            <span class="n">dynamic</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">_get_index_loc</span><span class="p">(</span><span class="n">dynamic</span><span class="p">)</span>
            <span class="c1"># Convert to offset relative to start</span>
            <span class="n">dynamic</span> <span class="o">=</span> <span class="n">dynamic</span> <span class="o">-</span> <span class="n">start</span>

        <span class="c1"># If we have out-of-sample forecasting and `exog` or in general any</span>
        <span class="c1"># kind of time-varying state space model, then we need to create an</span>
        <span class="c1"># extended model to get updated state space system matrices</span>
        <span class="k">if</span> <span class="n">extend_model</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">extend_model</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">exog</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span>
                            <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_results</span><span class="o">.</span><span class="n">time_invariant</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">out_of_sample</span> <span class="ow">and</span> <span class="n">extend_model</span><span class="p">:</span>
            <span class="n">kwargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">_get_extension_time_varying_matrices</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="n">exog</span><span class="p">,</span> <span class="n">out_of_sample</span><span class="p">,</span> <span class="n">extend_kwargs</span><span class="p">,</span>
                <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">includes_fixed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Make sure the model class has the current parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">includes_fixed</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Perform the prediction</span>
        <span class="c1"># This is a (k_endog x npredictions) array; do not want to squeeze in</span>
        <span class="c1"># case of npredictions = 1</span>
        <span class="n">prediction_results</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_results</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span>
            <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">+</span> <span class="n">out_of_sample</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dynamic</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Return a new mlemodel.PredictionResults object</span>
        <span class="k">return</span> <span class="n">PredictionResultsWrapper</span><span class="p">(</span><span class="n">PredictionResults</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">prediction_results</span><span class="p">,</span> <span class="n">information_set</span><span class="o">=</span><span class="n">information_set</span><span class="p">,</span>
            <span class="n">signal_only</span><span class="o">=</span><span class="n">signal_only</span><span class="p">,</span> <span class="n">row_labels</span><span class="o">=</span><span class="n">prediction_index</span><span class="p">))</span></div>


<div class="viewcode-block" id="MLEResults.get_forecast">
<a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEResults.get_forecast.html#statsmodels.tsa.statespace.mlemodel.MLEResults.get_forecast">[docs]</a>
    <span class="k">def</span> <span class="nf">get_forecast</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">steps</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">signal_only</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Out-of-sample forecasts and prediction intervals</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        steps : int, str, or datetime, optional</span>
<span class="sd">            If an integer, the number of steps to forecast from the end of the</span>
<span class="sd">            sample. Can also be a date string to parse or a datetime type.</span>
<span class="sd">            However, if the dates index does not have a fixed frequency, steps</span>
<span class="sd">            must be an integer. Default is 1.</span>
<span class="sd">        signal_only : bool, optional</span>
<span class="sd">            Whether to compute forecasts of only the &quot;signal&quot; component of</span>
<span class="sd">            the observation equation. Default is False. For example, the</span>
<span class="sd">            observation equation of a time-invariant model is</span>
<span class="sd">            :math:`y_t = d + Z \alpha_t + \varepsilon_t`, and the &quot;signal&quot;</span>
<span class="sd">            component is then :math:`Z \alpha_t`. If this argument is set to</span>
<span class="sd">            True, then forecasts of the &quot;signal&quot; :math:`Z \alpha_t` will be</span>
<span class="sd">            returned. Otherwise, the default is for forecasts of :math:`y_t`</span>
<span class="sd">            to be returned.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Additional arguments may required for forecasting beyond the end</span>
<span class="sd">            of the sample. See `FilterResults.predict` for more details.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        forecasts : PredictionResults</span>
<span class="sd">            PredictionResults instance containing out-of-sample forecasts and</span>
<span class="sd">            results including confidence intervals.</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        forecast</span>
<span class="sd">            Out-of-sample forecasts.</span>
<span class="sd">        predict</span>
<span class="sd">            In-sample predictions and out-of-sample forecasts.</span>
<span class="sd">        get_prediction</span>
<span class="sd">            In-sample predictions / out-of-sample forecasts and results</span>
<span class="sd">            including confidence intervals.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">steps</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span> <span class="o">+</span> <span class="n">steps</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">end</span> <span class="o">=</span> <span class="n">steps</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_prediction</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="n">end</span><span class="p">,</span>
                                   <span class="n">signal_only</span><span class="o">=</span><span class="n">signal_only</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="MLEResults.predict">
<a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEResults.predict.html#statsmodels.tsa.statespace.mlemodel.MLEResults.predict">[docs]</a>
    <span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dynamic</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">information_set</span><span class="o">=</span><span class="s1">&#39;predicted&#39;</span><span class="p">,</span> <span class="n">signal_only</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        In-sample prediction and out-of-sample forecasting</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        start : {int, str,datetime}, optional</span>
<span class="sd">            Zero-indexed observation number at which to start forecasting,</span>
<span class="sd">            i.e., the first forecast is start. Can also be a date string to</span>
<span class="sd">            parse or a datetime type. Default is the zeroth observation.</span>
<span class="sd">        end : {int, str,datetime}, optional</span>
<span class="sd">            Zero-indexed observation number at which to end forecasting, i.e.,</span>
<span class="sd">            the last forecast is end. Can also be a date string to</span>
<span class="sd">            parse or a datetime type. However, if the dates index does not</span>
<span class="sd">            have a fixed frequency, end must be an integer index if you</span>
<span class="sd">            want out of sample prediction. Default is the last observation in</span>
<span class="sd">            the sample.</span>
<span class="sd">        dynamic : {bool, int, str,datetime}, optional</span>
<span class="sd">            Integer offset relative to `start` at which to begin dynamic</span>
<span class="sd">            prediction. Can also be an absolute date string to parse or a</span>
<span class="sd">            datetime type (these are not interpreted as offsets).</span>
<span class="sd">            Prior to this observation, true endogenous values will be used for</span>
<span class="sd">            prediction; starting with this observation and continuing through</span>
<span class="sd">            the end of prediction, forecasted endogenous values will be used</span>
<span class="sd">            instead.</span>
<span class="sd">        information_set : str, optional</span>
<span class="sd">            The information set to condition each prediction on. Default is</span>
<span class="sd">            &quot;predicted&quot;, which computes predictions of period t values</span>
<span class="sd">            conditional on observed data through period t-1; these are</span>
<span class="sd">            one-step-ahead predictions, and correspond with the typical</span>
<span class="sd">            `fittedvalues` results attribute. Alternatives are &quot;filtered&quot;,</span>
<span class="sd">            which computes predictions of period t values conditional on</span>
<span class="sd">            observed data through period t, and &quot;smoothed&quot;, which computes</span>
<span class="sd">            predictions of period t values conditional on the entire dataset</span>
<span class="sd">            (including also future observations t+1, t+2, ...).</span>
<span class="sd">        signal_only : bool, optional</span>
<span class="sd">            Whether to compute predictions of only the &quot;signal&quot; component of</span>
<span class="sd">            the observation equation. Default is False. For example, the</span>
<span class="sd">            observation equation of a time-invariant model is</span>
<span class="sd">            :math:`y_t = d + Z \alpha_t + \varepsilon_t`, and the &quot;signal&quot;</span>
<span class="sd">            component is then :math:`Z \alpha_t`. If this argument is set to</span>
<span class="sd">            True, then predictions of the &quot;signal&quot; :math:`Z \alpha_t` will be</span>
<span class="sd">            returned. Otherwise, the default is for predictions of :math:`y_t`</span>
<span class="sd">            to be returned.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Additional arguments may be required for forecasting beyond the end</span>
<span class="sd">            of the sample. See ``FilterResults.predict`` for more details.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        predictions : array_like</span>
<span class="sd">            In-sample predictions / Out-of-sample forecasts. (Numpy array or</span>
<span class="sd">            Pandas Series or DataFrame, depending on input and dimensions).</span>
<span class="sd">            Dimensions are `(npredict x k_endog)`.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        forecast</span>
<span class="sd">            Out-of-sample forecasts.</span>
<span class="sd">        get_forecast</span>
<span class="sd">            Out-of-sample forecasts and results including confidence intervals.</span>
<span class="sd">        get_prediction</span>
<span class="sd">            In-sample predictions / out-of-sample forecasts and results</span>
<span class="sd">            including confidence intervals.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Perform the prediction</span>
        <span class="n">prediction_results</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_prediction</span><span class="p">(</span>
            <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">dynamic</span><span class="p">,</span> <span class="n">information_set</span><span class="o">=</span><span class="n">information_set</span><span class="p">,</span>
            <span class="n">signal_only</span><span class="o">=</span><span class="n">signal_only</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">prediction_results</span><span class="o">.</span><span class="n">predicted_mean</span></div>


<div class="viewcode-block" id="MLEResults.forecast">
<a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEResults.forecast.html#statsmodels.tsa.statespace.mlemodel.MLEResults.forecast">[docs]</a>
    <span class="k">def</span> <span class="nf">forecast</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">steps</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">signal_only</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Out-of-sample forecasts</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        steps : int, str, or datetime, optional</span>
<span class="sd">            If an integer, the number of steps to forecast from the end of the</span>
<span class="sd">            sample. Can also be a date string to parse or a datetime type.</span>
<span class="sd">            However, if the dates index does not have a fixed frequency, steps</span>
<span class="sd">            must be an integer. Default is 1.</span>
<span class="sd">        signal_only : bool, optional</span>
<span class="sd">            Whether to compute forecasts of only the &quot;signal&quot; component of</span>
<span class="sd">            the observation equation. Default is False. For example, the</span>
<span class="sd">            observation equation of a time-invariant model is</span>
<span class="sd">            :math:`y_t = d + Z \alpha_t + \varepsilon_t`, and the &quot;signal&quot;</span>
<span class="sd">            component is then :math:`Z \alpha_t`. If this argument is set to</span>
<span class="sd">            True, then forecasts of the &quot;signal&quot; :math:`Z \alpha_t` will be</span>
<span class="sd">            returned. Otherwise, the default is for forecasts of :math:`y_t`</span>
<span class="sd">            to be returned.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Additional arguments may required for forecasting beyond the end</span>
<span class="sd">            of the sample. See `FilterResults.predict` for more details.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        forecast : array_like</span>
<span class="sd">            Out-of-sample forecasts (Numpy array or Pandas Series or DataFrame,</span>
<span class="sd">            depending on input and dimensions).</span>
<span class="sd">            Dimensions are `(steps x k_endog)`.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        predict</span>
<span class="sd">            In-sample predictions and out-of-sample forecasts.</span>
<span class="sd">        get_forecast</span>
<span class="sd">            Out-of-sample forecasts and results including confidence intervals.</span>
<span class="sd">        get_prediction</span>
<span class="sd">            In-sample predictions / out-of-sample forecasts and results</span>
<span class="sd">            including confidence intervals.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">steps</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span> <span class="o">+</span> <span class="n">steps</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">end</span> <span class="o">=</span> <span class="n">steps</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="n">end</span><span class="p">,</span> <span class="n">signal_only</span><span class="o">=</span><span class="n">signal_only</span><span class="p">,</span>
                            <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="MLEResults.simulate">
<a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEResults.simulate.html#statsmodels.tsa.statespace.mlemodel.MLEResults.simulate">[docs]</a>
    <span class="k">def</span> <span class="nf">simulate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nsimulations</span><span class="p">,</span> <span class="n">measurement_shocks</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">state_shocks</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">initial_state</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">anchor</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">repetitions</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">exog</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">extend_model</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">extend_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">pretransformed_measurement_shocks</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">pretransformed_state_shocks</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">pretransformed_initial_state</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Simulate a new time series following the state space model</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nsimulations : int</span>
<span class="sd">            The number of observations to simulate. If the model is</span>
<span class="sd">            time-invariant this can be any number. If the model is</span>
<span class="sd">            time-varying, then this number must be less than or equal to the</span>
<span class="sd">            number</span>
<span class="sd">        measurement_shocks : array_like, optional</span>
<span class="sd">            If specified, these are the shocks to the measurement equation,</span>
<span class="sd">            :math:`\varepsilon_t`. If unspecified, these are automatically</span>
<span class="sd">            generated using a pseudo-random number generator. If specified,</span>
<span class="sd">            must be shaped `nsimulations` x `k_endog`, where `k_endog` is the</span>
<span class="sd">            same as in the state space model.</span>
<span class="sd">        state_shocks : array_like, optional</span>
<span class="sd">            If specified, these are the shocks to the state equation,</span>
<span class="sd">            :math:`\eta_t`. If unspecified, these are automatically</span>
<span class="sd">            generated using a pseudo-random number generator. If specified,</span>
<span class="sd">            must be shaped `nsimulations` x `k_posdef` where `k_posdef` is the</span>
<span class="sd">            same as in the state space model.</span>
<span class="sd">        initial_state : array_like, optional</span>
<span class="sd">            If specified, this is the initial state vector to use in</span>
<span class="sd">            simulation, which should be shaped (`k_states` x 1), where</span>
<span class="sd">            `k_states` is the same as in the state space model. If unspecified,</span>
<span class="sd">            but the model has been initialized, then that initialization is</span>
<span class="sd">            used. This must be specified if `anchor` is anything other than</span>
<span class="sd">            &quot;start&quot; or 0.</span>
<span class="sd">        anchor : int, str, or datetime, optional</span>
<span class="sd">            Starting point from which to begin the simulations; type depends on</span>
<span class="sd">            the index of the given `endog` model. Two special cases are the</span>
<span class="sd">            strings &#39;start&#39; and &#39;end&#39;, which refer to starting at the beginning</span>
<span class="sd">            and end of the sample, respectively. If a date/time index was</span>
<span class="sd">            provided to the model, then this argument can be a date string to</span>
<span class="sd">            parse or a datetime type. Otherwise, an integer index should be</span>
<span class="sd">            given. Default is &#39;start&#39;.</span>
<span class="sd">        repetitions : int, optional</span>
<span class="sd">            Number of simulated paths to generate. Default is 1 simulated path.</span>
<span class="sd">        exog : array_like, optional</span>
<span class="sd">            New observations of exogenous regressors, if applicable.</span>
<span class="sd">        pretransformed_measurement_shocks : bool, optional</span>
<span class="sd">            If `measurement_shocks` is provided, this flag indicates whether it</span>
<span class="sd">            should be directly used as the shocks. If False, then it is assumed</span>
<span class="sd">            to contain draws from the standard Normal distribution that must be</span>
<span class="sd">            transformed using the `obs_cov` covariance matrix. Default is True.</span>
<span class="sd">        pretransformed_state_shocks : bool, optional</span>
<span class="sd">            If `state_shocks` is provided, this flag indicates whether it</span>
<span class="sd">            should be directly used as the shocks. If False, then it is assumed</span>
<span class="sd">            to contain draws from the standard Normal distribution that must be</span>
<span class="sd">            transformed using the `state_cov` covariance matrix. Default is</span>
<span class="sd">            True.</span>
<span class="sd">        pretransformed_initial_state : bool, optional</span>
<span class="sd">            If `initial_state` is provided, this flag indicates whether it</span>
<span class="sd">            should be directly used as the initial_state. If False, then it is</span>
<span class="sd">            assumed to contain draws from the standard Normal distribution that</span>
<span class="sd">            must be transformed using the `initial_state_cov` covariance</span>
<span class="sd">            matrix. Default is True.</span>
<span class="sd">        random_state : {None, int, Generator, RandomState}, optional</span>
<span class="sd">            If `seed` is None (or `np.random`), the</span>
<span class="sd">            class:``~numpy.random.RandomState`` singleton is used.</span>
<span class="sd">            If `seed` is an int, a new class:``~numpy.random.RandomState``</span>
<span class="sd">            instance is used, seeded with `seed`.</span>
<span class="sd">            If `seed` is already a class:``~numpy.random.Generator`` or</span>
<span class="sd">            class:``~numpy.random.RandomState`` instance then that instance is</span>
<span class="sd">            used.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        simulated_obs : ndarray</span>
<span class="sd">            An array of simulated observations. If `repetitions=None`, then it</span>
<span class="sd">            will be shaped (nsimulations x k_endog) or (nsimulations,) if</span>
<span class="sd">            `k_endog=1`. Otherwise it will be shaped</span>
<span class="sd">            (nsimulations x k_endog x repetitions). If the model was given</span>
<span class="sd">            Pandas input then the output will be a Pandas object. If</span>
<span class="sd">            `k_endog &gt; 1` and `repetitions` is not None, then the output will</span>
<span class="sd">            be a Pandas DataFrame that has a MultiIndex for the columns, with</span>
<span class="sd">            the first level containing the names of the `endog` variables and</span>
<span class="sd">            the second level containing the repetition number.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        impulse_responses</span>
<span class="sd">            Impulse response functions</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get the starting location</span>
        <span class="k">if</span> <span class="n">anchor</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">anchor</span> <span class="o">==</span> <span class="s1">&#39;start&#39;</span><span class="p">:</span>
            <span class="n">iloc</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">elif</span> <span class="n">anchor</span> <span class="o">==</span> <span class="s1">&#39;end&#39;</span><span class="p">:</span>
            <span class="n">iloc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">iloc</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">_get_index_loc</span><span class="p">(</span><span class="n">anchor</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">iloc</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
                <span class="n">iloc</span> <span class="o">=</span> <span class="n">iloc</span><span class="o">.</span><span class="n">start</span>

        <span class="k">if</span> <span class="n">iloc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">iloc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span> <span class="o">+</span> <span class="n">iloc</span>
        <span class="k">if</span> <span class="n">iloc</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Cannot anchor simulation outside of the sample.&#39;</span><span class="p">)</span>

        <span class="c1"># GH 9162</span>
        <span class="kn">from</span> <span class="nn">statsmodels.tsa.statespace</span> <span class="kn">import</span> <span class="n">simulation_smoother</span>
        <span class="n">random_state</span> <span class="o">=</span> <span class="n">simulation_smoother</span><span class="o">.</span><span class="n">check_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span>

        <span class="c1"># Setup the initial state</span>
        <span class="k">if</span> <span class="n">initial_state</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">initial_state_moments</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">predicted_state</span><span class="p">[:,</span> <span class="n">iloc</span><span class="p">],</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">predicted_state_cov</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">iloc</span><span class="p">])</span>

            <span class="n">_repetitions</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">repetitions</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">repetitions</span>

            <span class="n">initial_state</span> <span class="o">=</span> <span class="n">random_state</span><span class="o">.</span><span class="n">multivariate_normal</span><span class="p">(</span>
                <span class="o">*</span><span class="n">initial_state_moments</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">_repetitions</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

        <span class="n">scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_results</span><span class="o">.</span><span class="n">filter_concentrated</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">fixed_scale</span><span class="p">(</span><span class="n">scale</span><span class="p">):</span>
            <span class="n">sim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">simulate</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="n">nsimulations</span><span class="p">,</span>
                <span class="n">measurement_shocks</span><span class="o">=</span><span class="n">measurement_shocks</span><span class="p">,</span>
                <span class="n">state_shocks</span><span class="o">=</span><span class="n">state_shocks</span><span class="p">,</span> <span class="n">initial_state</span><span class="o">=</span><span class="n">initial_state</span><span class="p">,</span>
                <span class="n">anchor</span><span class="o">=</span><span class="n">anchor</span><span class="p">,</span> <span class="n">repetitions</span><span class="o">=</span><span class="n">repetitions</span><span class="p">,</span> <span class="n">exog</span><span class="o">=</span><span class="n">exog</span><span class="p">,</span>
                <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">includes_fixed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">extend_model</span><span class="o">=</span><span class="n">extend_model</span><span class="p">,</span> <span class="n">extend_kwargs</span><span class="o">=</span><span class="n">extend_kwargs</span><span class="p">,</span>
                <span class="n">pretransformed_measurement_shocks</span><span class="o">=</span><span class="p">(</span>
                    <span class="n">pretransformed_measurement_shocks</span><span class="p">),</span>
                <span class="n">pretransformed_state_shocks</span><span class="o">=</span><span class="n">pretransformed_state_shocks</span><span class="p">,</span>
                <span class="n">pretransformed_initial_state</span><span class="o">=</span><span class="n">pretransformed_initial_state</span><span class="p">,</span>
                <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">sim</span></div>


<div class="viewcode-block" id="MLEResults.impulse_responses">
<a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEResults.impulse_responses.html#statsmodels.tsa.statespace.mlemodel.MLEResults.impulse_responses">[docs]</a>
    <span class="k">def</span> <span class="nf">impulse_responses</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">steps</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">impulse</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">orthogonalized</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                          <span class="n">cumulative</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Impulse response function</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        steps : int, optional</span>
<span class="sd">            The number of steps for which impulse responses are calculated.</span>
<span class="sd">            Default is 1. Note that for time-invariant models, the initial</span>
<span class="sd">            impulse is not counted as a step, so if `steps=1`, the output will</span>
<span class="sd">            have 2 entries.</span>
<span class="sd">        impulse : int, str or array_like</span>
<span class="sd">            If an integer, the state innovation to pulse; must be between 0</span>
<span class="sd">            and `k_posdef-1`. If a str, it indicates which column of df</span>
<span class="sd">            the unit (1) impulse is given.</span>
<span class="sd">            Alternatively, a custom impulse vector may be provided; must be</span>
<span class="sd">            shaped `k_posdef x 1`.</span>
<span class="sd">        orthogonalized : bool, optional</span>
<span class="sd">            Whether or not to perform impulse using orthogonalized innovations.</span>
<span class="sd">            Note that this will also affect custum `impulse` vectors. Default</span>
<span class="sd">            is False.</span>
<span class="sd">        cumulative : bool, optional</span>
<span class="sd">            Whether or not to return cumulative impulse responses. Default is</span>
<span class="sd">            False.</span>
<span class="sd">        anchor : int, str, or datetime, optional</span>
<span class="sd">            Time point within the sample for the state innovation impulse. Type</span>
<span class="sd">            depends on the index of the given `endog` in the model. Two special</span>
<span class="sd">            cases are the strings &#39;start&#39; and &#39;end&#39;, which refer to setting the</span>
<span class="sd">            impulse at the first and last points of the sample, respectively.</span>
<span class="sd">            Integer values can run from 0 to `nobs - 1`, or can be negative to</span>
<span class="sd">            apply negative indexing. Finally, if a date/time index was provided</span>
<span class="sd">            to the model, then this argument can be a date string to parse or a</span>
<span class="sd">            datetime type. Default is &#39;start&#39;.</span>
<span class="sd">        exog : array_like, optional</span>
<span class="sd">            New observations of exogenous regressors, if applicable.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            If the model has time-varying design or transition matrices and the</span>
<span class="sd">            combination of `anchor` and `steps` implies creating impulse</span>
<span class="sd">            responses for the out-of-sample period, then these matrices must</span>
<span class="sd">            have updated values provided for the out-of-sample steps. For</span>
<span class="sd">            example, if `design` is a time-varying component, `nobs` is 10,</span>
<span class="sd">            `anchor=1`, and `steps` is 15, a (`k_endog` x `k_states` x 7)</span>
<span class="sd">            matrix must be provided with the new design matrix values.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        impulse_responses : ndarray</span>
<span class="sd">            Responses for each endogenous variable due to the impulse</span>
<span class="sd">            given by the `impulse` argument. For a time-invariant model, the</span>
<span class="sd">            impulse responses are given for `steps + 1` elements (this gives</span>
<span class="sd">            the &quot;initial impulse&quot; followed by `steps` responses for the</span>
<span class="sd">            important cases of VAR and SARIMAX models), while for time-varying</span>
<span class="sd">            models the impulse responses are only given for `steps` elements</span>
<span class="sd">            (to avoid having to unexpectedly provide updated time-varying</span>
<span class="sd">            matrices).</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        simulate</span>
<span class="sd">            Simulate a time series according to the given state space model,</span>
<span class="sd">            optionally with specified series for the innovations.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Intercepts in the measurement and state equation are ignored when</span>
<span class="sd">        calculating impulse responses.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_results</span><span class="o">.</span><span class="n">filter_concentrated</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">fixed_scale</span><span class="p">(</span><span class="n">scale</span><span class="p">):</span>
            <span class="n">irfs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">impulse_responses</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="n">steps</span><span class="p">,</span> <span class="n">impulse</span><span class="p">,</span>
                                                <span class="n">orthogonalized</span><span class="p">,</span> <span class="n">cumulative</span><span class="p">,</span>
                                                <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="c1"># These are wrapped automatically, so just return the array</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">irfs</span><span class="p">,</span> <span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">)):</span>
                <span class="n">irfs</span> <span class="o">=</span> <span class="n">irfs</span><span class="o">.</span><span class="n">values</span>
        <span class="k">return</span> <span class="n">irfs</span></div>


    <span class="k">def</span> <span class="nf">_apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mod</span><span class="p">,</span> <span class="n">refit</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fit_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">fit_kwargs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fit_kwargs</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">if</span> <span class="n">refit</span><span class="p">:</span>
            <span class="n">fit_kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;start_params&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_fixed_params</span><span class="p">:</span>
                <span class="n">fit_kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;includes_fixed&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">mod</span><span class="o">.</span><span class="n">fit_constrained</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_fixed_params</span><span class="p">,</span> <span class="o">**</span><span class="n">fit_kwargs</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">mod</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="o">**</span><span class="n">fit_kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="s1">&#39;cov_type&#39;</span> <span class="ow">in</span> <span class="n">fit_kwargs</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Cannot specify covariance type in&#39;</span>
                                 <span class="s1">&#39; `fit_kwargs` unless refitting&#39;</span>
                                 <span class="s1">&#39; parameters (not available in extend).&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="s1">&#39;cov_kwds&#39;</span> <span class="ow">in</span> <span class="n">fit_kwargs</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Cannot specify covariance keyword arguments&#39;</span>
                                 <span class="s1">&#39; in `fit_kwargs` unless refitting&#39;</span>
                                 <span class="s1">&#39; parameters (not available in extend).&#39;</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cov_type</span> <span class="o">==</span> <span class="s1">&#39;none&#39;</span><span class="p">:</span>
                <span class="n">fit_kwargs</span><span class="p">[</span><span class="s1">&#39;cov_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;none&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">fit_kwargs</span><span class="p">[</span><span class="s1">&#39;cov_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;custom&#39;</span>
                <span class="n">fit_kwargs</span><span class="p">[</span><span class="s1">&#39;cov_kwds&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s1">&#39;custom_cov_type&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">cov_type</span><span class="p">,</span>
                    <span class="s1">&#39;custom_cov_params&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">cov_params_default</span><span class="p">,</span>
                    <span class="s1">&#39;custom_description&#39;</span><span class="p">:</span> <span class="p">(</span>
                        <span class="s1">&#39;Parameters and standard errors were estimated using a&#39;</span>
                        <span class="s1">&#39; different dataset and were then applied to this&#39;</span>
                        <span class="s1">&#39; dataset. </span><span class="si">%s</span><span class="s1">&#39;</span>
                        <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">cov_kwds</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;description&#39;</span><span class="p">,</span> <span class="s1">&#39;Unknown.&#39;</span><span class="p">))}</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">smoother_results</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">func</span> <span class="o">=</span> <span class="n">mod</span><span class="o">.</span><span class="n">smooth</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">func</span> <span class="o">=</span> <span class="n">mod</span><span class="o">.</span><span class="n">filter</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_fixed_params</span><span class="p">:</span>
                <span class="k">with</span> <span class="n">mod</span><span class="o">.</span><span class="n">fix_params</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_fixed_params</span><span class="p">):</span>
                    <span class="n">fit_kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;includes_fixed&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
                    <span class="n">res</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="o">**</span><span class="n">fit_kwargs</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="o">**</span><span class="n">fit_kwargs</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">res</span>

    <span class="k">def</span> <span class="nf">_get_previous_updated</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">comparison</span><span class="p">,</span> <span class="n">exog</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                              <span class="n">comparison_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># If we were given data, create a new results object</span>
        <span class="n">comparison_dataset</span> <span class="o">=</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span>
            <span class="n">comparison</span><span class="p">,</span> <span class="p">(</span><span class="n">MLEResults</span><span class="p">,</span> <span class="n">MLEResultsWrapper</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">comparison_dataset</span><span class="p">:</span>
            <span class="c1"># If `exog` is longer than `comparison`, then we extend it to match</span>
            <span class="n">nobs_endog</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">comparison</span><span class="p">)</span>
            <span class="n">nobs_exog</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">exog</span><span class="p">)</span> <span class="k">if</span> <span class="n">exog</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">nobs_endog</span>

            <span class="k">if</span> <span class="n">nobs_exog</span> <span class="o">&gt;</span> <span class="n">nobs_endog</span><span class="p">:</span>
                <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">ix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">_get_prediction_index</span><span class="p">(</span>
                    <span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="n">nobs_exog</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
                <span class="c1"># TODO: check that the index of `comparison` matches the model</span>
                <span class="n">comparison</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">comparison</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">comparison</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">comparison</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">comparison</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">comparison</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span> <span class="ow">or</span>
                        <span class="n">comparison</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">k_endog</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid shape for `comparison`. Must&#39;</span>
                                     <span class="sa">f</span><span class="s1">&#39; contain </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">k_endog</span><span class="si">}</span><span class="s1"> columns.&#39;</span><span class="p">)</span>
                <span class="n">extra</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nobs_exog</span> <span class="o">-</span> <span class="n">nobs_endog</span><span class="p">,</span>
                                  <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">k_endog</span><span class="p">))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="n">comparison</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">comparison</span><span class="p">,</span> <span class="n">extra</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="n">index</span><span class="o">=</span><span class="n">ix</span><span class="p">,</span>
                    <span class="n">columns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">endog_names</span><span class="p">)</span>

            <span class="c1"># Get the results object</span>
            <span class="n">comparison</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">comparison</span><span class="p">,</span> <span class="n">exog</span><span class="o">=</span><span class="n">exog</span><span class="p">,</span>
                                    <span class="n">copy_initialization</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Now, figure out the `updated` versus `previous` results objects</span>
        <span class="n">nmissing</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_results</span><span class="o">.</span><span class="n">missing</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">nmissing_comparison</span> <span class="o">=</span> <span class="n">comparison</span><span class="o">.</span><span class="n">filter_results</span><span class="o">.</span><span class="n">missing</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">comparison_type</span> <span class="o">==</span> <span class="s1">&#39;updated&#39;</span> <span class="ow">or</span> <span class="p">(</span><span class="n">comparison_type</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="p">(</span>
                <span class="n">comparison</span><span class="o">.</span><span class="n">nobs</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span> <span class="ow">or</span>
                <span class="p">(</span><span class="n">comparison</span><span class="o">.</span><span class="n">nobs</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span> <span class="ow">and</span>
                 <span class="n">nmissing</span> <span class="o">&gt;</span> <span class="n">nmissing_comparison</span><span class="p">)))):</span>
            <span class="n">updated</span> <span class="o">=</span> <span class="n">comparison</span>
            <span class="n">previous</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">comparison_type</span> <span class="o">==</span> <span class="s1">&#39;previous&#39;</span> <span class="ow">or</span> <span class="p">(</span><span class="n">comparison_type</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="p">(</span>
                <span class="n">comparison</span><span class="o">.</span><span class="n">nobs</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span> <span class="ow">or</span>
                <span class="p">(</span><span class="n">comparison</span><span class="o">.</span><span class="n">nobs</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span> <span class="ow">and</span>
                 <span class="n">nmissing</span> <span class="o">&lt;</span> <span class="n">nmissing_comparison</span><span class="p">)))):</span>
            <span class="n">updated</span> <span class="o">=</span> <span class="bp">self</span>
            <span class="n">previous</span> <span class="o">=</span> <span class="n">comparison</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Could not automatically determine the type&#39;</span>
                             <span class="s1">&#39; of comparison requested to compute the&#39;</span>
                             <span class="s1">&#39; News, so it must be specified as &quot;updated&quot;&#39;</span>
                             <span class="s1">&#39; or &quot;previous&quot;, using the `comparison_type`&#39;</span>
                             <span class="s1">&#39; keyword argument&#39;</span><span class="p">)</span>

        <span class="c1"># Check that the index of `updated` is a superset of the</span>
        <span class="c1"># index of `previous`</span>
        <span class="c1"># Note: the try/except block is for Pandas &lt; 0.25, in which</span>
        <span class="c1"># `PeriodIndex.difference` raises a ValueError if the argument is not</span>
        <span class="c1"># also a `PeriodIndex`.</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="n">previous</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">_index</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">updated</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">_index</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">diff</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The index associated with the updated results is&#39;</span>
                             <span class="s1">&#39; not a superset of the index associated with the&#39;</span>
                             <span class="s1">&#39; previous results, and so these datasets do not&#39;</span>
                             <span class="s1">&#39; appear to be related. Can only compute the&#39;</span>
                             <span class="s1">&#39; news by comparing this results set to previous&#39;</span>
                             <span class="s1">&#39; results objects.&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">previous</span><span class="p">,</span> <span class="n">updated</span><span class="p">,</span> <span class="n">comparison_dataset</span>

    <span class="k">def</span> <span class="nf">_news_previous_results</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">previous</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">periods</span><span class="p">,</span>
                               <span class="n">revisions_details_start</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                               <span class="n">state_index</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># Compute the news</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">smoother_results</span><span class="o">.</span><span class="n">news</span><span class="p">(</span>
            <span class="n">previous</span><span class="o">.</span><span class="n">smoother_results</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="n">end</span><span class="p">,</span>
            <span class="n">revisions_details_start</span><span class="o">=</span><span class="n">revisions_details_start</span><span class="p">,</span>
            <span class="n">state_index</span><span class="o">=</span><span class="n">state_index</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span> <span class="nf">_news_updated_results</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">updated</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">periods</span><span class="p">,</span>
                              <span class="n">revisions_details_start</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">state_index</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">updated</span><span class="o">.</span><span class="n">_news_previous_results</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">periods</span><span class="p">,</span>
            <span class="n">revisions_details_start</span><span class="o">=</span><span class="n">revisions_details_start</span><span class="p">,</span>
            <span class="n">state_index</span><span class="o">=</span><span class="n">state_index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_news_previous_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">endog</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">periods</span><span class="p">,</span> <span class="n">exog</span><span class="p">,</span>
                            <span class="n">revisions_details_start</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">state_index</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">previous</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">endog</span><span class="p">,</span> <span class="n">exog</span><span class="o">=</span><span class="n">exog</span><span class="p">,</span> <span class="n">copy_initialization</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_news_previous_results</span><span class="p">(</span>
            <span class="n">previous</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">periods</span><span class="p">,</span>
            <span class="n">revisions_details_start</span><span class="o">=</span><span class="n">revisions_details_start</span><span class="p">,</span>
            <span class="n">state_index</span><span class="o">=</span><span class="n">state_index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_news_updated_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">endog</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">periods</span><span class="p">,</span> <span class="n">exog</span><span class="p">,</span>
                           <span class="n">revisions_details_start</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">state_index</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">updated</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">endog</span><span class="p">,</span> <span class="n">exog</span><span class="o">=</span><span class="n">exog</span><span class="p">,</span> <span class="n">copy_initialization</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_news_updated_results</span><span class="p">(</span>
            <span class="n">updated</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">periods</span><span class="p">,</span>
            <span class="n">revisions_details_start</span><span class="o">=</span><span class="n">revisions_details_start</span><span class="p">,</span>
            <span class="n">state_index</span><span class="o">=</span><span class="n">state_index</span><span class="p">)</span>

<div class="viewcode-block" id="MLEResults.news">
<a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEResults.news.html#statsmodels.tsa.statespace.mlemodel.MLEResults.news">[docs]</a>
    <span class="k">def</span> <span class="nf">news</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">comparison</span><span class="p">,</span> <span class="n">impact_date</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">impacted_variable</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
             <span class="n">start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">periods</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">exog</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
             <span class="n">comparison_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">revisions_details_start</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
             <span class="n">state_index</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">return_raw</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mf">1e-10</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute impacts from updated data (news and revisions)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        comparison : array_like or MLEResults</span>
<span class="sd">            An updated dataset with updated and/or revised data from which the</span>
<span class="sd">            news can be computed, or an updated or previous results object</span>
<span class="sd">            to use in computing the news.</span>
<span class="sd">        impact_date : int, str, or datetime, optional</span>
<span class="sd">            A single specific period of impacts from news and revisions to</span>
<span class="sd">            compute. Can also be a date string to parse or a datetime type.</span>
<span class="sd">            This argument cannot be used in combination with `start`, `end`, or</span>
<span class="sd">            `periods`. Default is the first out-of-sample observation.</span>
<span class="sd">        impacted_variable : str, list, array, or slice, optional</span>
<span class="sd">            Observation variable label or slice of labels specifying that only</span>
<span class="sd">            specific impacted variables should be shown in the News output. The</span>
<span class="sd">            impacted variable(s) describe the variables that were *affected* by</span>
<span class="sd">            the news. If you do not know the labels for the variables, check</span>
<span class="sd">            the `endog_names` attribute of the model instance.</span>
<span class="sd">        start : int, str, or datetime, optional</span>
<span class="sd">            The first period of impacts from news and revisions to compute.</span>
<span class="sd">            Can also be a date string to parse or a datetime type. Default is</span>
<span class="sd">            the first out-of-sample observation.</span>
<span class="sd">        end : int, str, or datetime, optional</span>
<span class="sd">            The last period of impacts from news and revisions to compute.</span>
<span class="sd">            Can also be a date string to parse or a datetime type. Default is</span>
<span class="sd">            the first out-of-sample observation.</span>
<span class="sd">        periods : int, optional</span>
<span class="sd">            The number of periods of impacts from news and revisions to</span>
<span class="sd">            compute.</span>
<span class="sd">        exog : array_like, optional</span>
<span class="sd">            Array of exogenous regressors for the out-of-sample period, if</span>
<span class="sd">            applicable.</span>
<span class="sd">        comparison_type : {None, &#39;previous&#39;, &#39;updated&#39;}</span>
<span class="sd">            This denotes whether the `comparison` argument represents a</span>
<span class="sd">            *previous* results object or dataset or an *updated* results object</span>
<span class="sd">            or dataset. If not specified, then an attempt is made to determine</span>
<span class="sd">            the comparison type.</span>
<span class="sd">        revisions_details_start : bool, int, str, or datetime, optional</span>
<span class="sd">            The period at which to beging computing the detailed impacts of</span>
<span class="sd">            data revisions. Any revisions prior to this period will have their</span>
<span class="sd">            impacts grouped together. If a negative integer, interpreted as</span>
<span class="sd">            an offset from the end of the dataset. If set to True, detailed</span>
<span class="sd">            impacts are computed for all revisions, while if set to False, all</span>
<span class="sd">            revisions are grouped together. Default is False. Note that for</span>
<span class="sd">            large models, setting this to be near the beginning of the sample</span>
<span class="sd">            can cause this function to be slow.</span>
<span class="sd">        state_index : array_like, optional</span>
<span class="sd">            An optional index specifying a subset of states to use when</span>
<span class="sd">            constructing the impacts of revisions and news. For example, if</span>
<span class="sd">            `state_index=[0, 1]` is passed, then only the impacts to the</span>
<span class="sd">            observed variables arising from the impacts to the first two</span>
<span class="sd">            states will be returned. Default is to use all states.</span>
<span class="sd">        return_raw : bool, optional</span>
<span class="sd">            Whether or not to return only the specific output or a full</span>
<span class="sd">            results object. Default is to return a full results object.</span>
<span class="sd">        tolerance : float, optional</span>
<span class="sd">            The numerical threshold for determining zero impact. Default is</span>
<span class="sd">            that any impact less than 1e-10 is assumed to be zero.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        NewsResults</span>
<span class="sd">            Impacts of data revisions and news on estimates</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        .. [1] Babura, Marta, and Michele Modugno.</span>
<span class="sd">               &quot;Maximum likelihood estimation of factor models on datasets with</span>
<span class="sd">               arbitrary pattern of missing data.&quot;</span>
<span class="sd">               Journal of Applied Econometrics 29, no. 1 (2014): 133-160.</span>
<span class="sd">        .. [2] Babura, Marta, Domenico Giannone, and Lucrezia Reichlin.</span>
<span class="sd">               &quot;Nowcasting.&quot;</span>
<span class="sd">               The Oxford Handbook of Economic Forecasting. July 8, 2011.</span>
<span class="sd">        .. [3] Babura, Marta, Domenico Giannone, Michele Modugno, and Lucrezia</span>
<span class="sd">               Reichlin.</span>
<span class="sd">               &quot;Now-casting and the real-time data flow.&quot;</span>
<span class="sd">               In Handbook of economic forecasting, vol. 2, pp. 195-237.</span>
<span class="sd">               Elsevier, 2013.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Validate input</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">smoother_results</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Cannot compute news without Kalman smoother&#39;</span>
                             <span class="s1">&#39; results.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">state_index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">state_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">state_index</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">state_index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Cannot include negative indexes in&#39;</span>
                                 <span class="s1">&#39; `state_index`.&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">state_index</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">k_states</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Given state index </span><span class="si">{</span><span class="n">state_index</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s1"> is too&#39;</span>
                                 <span class="s1">&#39; large for the number of states in the model&#39;</span>
                                 <span class="sa">f</span><span class="s1">&#39; (</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">k_states</span><span class="si">}</span><span class="s1">).&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">revisions_details_start</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)):</span>
            <span class="n">revisions_details_start</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">_get_prediction_index</span><span class="p">(</span>
                    <span class="n">revisions_details_start</span><span class="p">,</span> <span class="n">revisions_details_start</span><span class="p">))</span>

        <span class="c1"># Get the previous and updated results objects from `self` and</span>
        <span class="c1"># `comparison`:</span>
        <span class="n">previous</span><span class="p">,</span> <span class="n">updated</span><span class="p">,</span> <span class="n">comparison_dataset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_previous_updated</span><span class="p">(</span>
            <span class="n">comparison</span><span class="p">,</span> <span class="n">exog</span><span class="o">=</span><span class="n">exog</span><span class="p">,</span> <span class="n">comparison_type</span><span class="o">=</span><span class="n">comparison_type</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Handle start, end, periods</span>
        <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">prediction_index</span> <span class="o">=</span> <span class="n">get_impact_dates</span><span class="p">(</span>
            <span class="n">previous_model</span><span class="o">=</span><span class="n">previous</span><span class="o">.</span><span class="n">model</span><span class="p">,</span> <span class="n">updated_model</span><span class="o">=</span><span class="n">updated</span><span class="o">.</span><span class="n">model</span><span class="p">,</span>
            <span class="n">impact_date</span><span class="o">=</span><span class="n">impact_date</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="n">end</span><span class="p">,</span> <span class="n">periods</span><span class="o">=</span><span class="n">periods</span><span class="p">)</span>

        <span class="c1"># News results will always use Pandas, so if the model&#39;s data was not</span>
        <span class="c1"># from Pandas, we&#39;ll create an index, as if the model&#39;s data had been</span>
        <span class="c1"># given a default Pandas index.</span>
        <span class="k">if</span> <span class="n">prediction_index</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">prediction_index</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">RangeIndex</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="n">end</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># For time-varying models try to create an appended `updated` model</span>
        <span class="c1"># with NaN values. Do not extend the model if this was already done</span>
        <span class="c1"># above (i.e. the case that `comparison` was a new dataset), because</span>
        <span class="c1"># in that case `exog` and `kwargs` should have</span>
        <span class="c1"># been set with the input `comparison` dataset in mind, and so would be</span>
        <span class="c1"># useless here. Ultimately, we&#39;ve already extended `updated` as far</span>
        <span class="c1"># as we can. So raise an  exception in that case with a useful message.</span>
        <span class="c1"># However, we still want to try to accommodate extending the model here</span>
        <span class="c1"># if it is possible.</span>
        <span class="c1"># Note that we do not need to extend time-invariant models, because</span>
        <span class="c1"># `KalmanSmoother.news` can itself handle any impact dates for</span>
        <span class="c1"># time-invariant models.</span>
        <span class="n">time_varying</span> <span class="o">=</span> <span class="ow">not</span> <span class="p">(</span><span class="n">previous</span><span class="o">.</span><span class="n">filter_results</span><span class="o">.</span><span class="n">time_invariant</span> <span class="ow">or</span>
                            <span class="n">updated</span><span class="o">.</span><span class="n">filter_results</span><span class="o">.</span><span class="n">time_invariant</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">time_varying</span> <span class="ow">and</span> <span class="n">end</span> <span class="o">&gt;=</span> <span class="n">updated</span><span class="o">.</span><span class="n">nobs</span><span class="p">:</span>
            <span class="c1"># If we the given `comparison` was a dataset and either `exog` or</span>
            <span class="c1"># `kwargs` was set, then we assume that we cannot create an updated</span>
            <span class="c1"># time-varying model (because then we can&#39;t tell if `kwargs` and</span>
            <span class="c1"># `exog` arguments are meant to apply to the `comparison` dataset</span>
            <span class="c1"># or to this extension)</span>
            <span class="k">if</span> <span class="n">comparison_dataset</span> <span class="ow">and</span> <span class="p">(</span><span class="n">exog</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">comparison</span> <span class="ow">is</span> <span class="n">updated</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;If providing an updated dataset as the&#39;</span>
                                     <span class="s1">&#39; `comparison` with a time-varying model,&#39;</span>
                                     <span class="s1">&#39; then the `end` period cannot be beyond&#39;</span>
                                     <span class="s1">&#39; the end of that updated dataset.&#39;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;If providing an previous dataset as the&#39;</span>
                                     <span class="s1">&#39; `comparison` with a time-varying model,&#39;</span>
                                     <span class="s1">&#39; then the `end` period cannot be beyond&#39;</span>
                                     <span class="s1">&#39; the end of the (updated) results&#39;</span>
                                     <span class="s1">&#39; object.&#39;</span><span class="p">)</span>

            <span class="c1"># Try to extend `updated`</span>
            <span class="n">updated_orig</span> <span class="o">=</span> <span class="n">updated</span>
            <span class="c1"># TODO: `append` should fix this k_endog=1 issue for us</span>
            <span class="c1"># TODO: is the + 1 necessary?</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">k_endog</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">extra</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">end</span> <span class="o">-</span> <span class="n">updated</span><span class="o">.</span><span class="n">nobs</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                                  <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">k_endog</span><span class="p">))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">extra</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">end</span> <span class="o">-</span> <span class="n">updated</span><span class="o">.</span><span class="n">nobs</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">updated</span> <span class="o">=</span> <span class="n">updated_orig</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">extra</span><span class="p">,</span> <span class="n">exog</span><span class="o">=</span><span class="n">exog</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Compute the news</span>
        <span class="n">news_results</span> <span class="o">=</span> <span class="n">updated</span><span class="o">.</span><span class="n">_news_previous_results</span><span class="p">(</span>
            <span class="n">previous</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">periods</span><span class="p">,</span>
            <span class="n">revisions_details_start</span><span class="o">=</span><span class="n">revisions_details_start</span><span class="p">,</span>
            <span class="n">state_index</span><span class="o">=</span><span class="n">state_index</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">return_raw</span><span class="p">:</span>
            <span class="n">news_results</span> <span class="o">=</span> <span class="n">NewsResults</span><span class="p">(</span>
                <span class="n">news_results</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">updated</span><span class="p">,</span> <span class="n">previous</span><span class="p">,</span> <span class="n">impacted_variable</span><span class="p">,</span>
                <span class="n">tolerance</span><span class="p">,</span> <span class="n">row_labels</span><span class="o">=</span><span class="n">prediction_index</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">news_results</span></div>


<div class="viewcode-block" id="MLEResults.get_smoothed_decomposition">
<a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEResults.get_smoothed_decomposition.html#statsmodels.tsa.statespace.mlemodel.MLEResults.get_smoothed_decomposition">[docs]</a>
    <span class="k">def</span> <span class="nf">get_smoothed_decomposition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">decomposition_of</span><span class="o">=</span><span class="s1">&#39;smoothed_state&#39;</span><span class="p">,</span>
                                   <span class="n">state_index</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Decompose smoothed output into contributions from observations</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        decomposition_of : {&quot;smoothed_state&quot;, &quot;smoothed_signal&quot;}</span>
<span class="sd">            The object to perform a decomposition of. If it is set to</span>
<span class="sd">            &quot;smoothed_state&quot;, then the elements of the smoothed state vector</span>
<span class="sd">            are decomposed into the contributions of each observation. If it</span>
<span class="sd">            is set to &quot;smoothed_signal&quot;, then the predictions of the</span>
<span class="sd">            observation vector based on the smoothed state vector are</span>
<span class="sd">            decomposed. Default is &quot;smoothed_state&quot;.</span>
<span class="sd">        state_index : array_like, optional</span>
<span class="sd">            An optional index specifying a subset of states to use when</span>
<span class="sd">            constructing the decomposition of the &quot;smoothed_signal&quot;. For</span>
<span class="sd">            example, if `state_index=[0, 1]` is passed, then only the</span>
<span class="sd">            contributions of observed variables to the smoothed signal arising</span>
<span class="sd">            from the first two states will be returned. Note that if not all</span>
<span class="sd">            states are used, the contributions will not sum to the smoothed</span>
<span class="sd">            signal. Default is to use all states.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        data_contributions : pd.DataFrame</span>
<span class="sd">            Contributions of observations to the decomposed object. If the</span>
<span class="sd">            smoothed state is being decomposed, then `data_contributions` is</span>
<span class="sd">            shaped `(k_states x nobs, k_endog x nobs)` with a `pd.MultiIndex`</span>
<span class="sd">            index corresponding to `state_to x date_to` and `pd.MultiIndex`</span>
<span class="sd">            columns corresponding to `variable_from x date_from`. If the</span>
<span class="sd">            smoothed signal is being decomposed, then `data_contributions` is</span>
<span class="sd">            shaped `(k_endog x nobs, k_endog x nobs)` with `pd.MultiIndex`-es</span>
<span class="sd">            corresponding to `variable_to x date_to` and</span>
<span class="sd">            `variable_from x date_from`.</span>
<span class="sd">        obs_intercept_contributions : pd.DataFrame</span>
<span class="sd">            Contributions of the observation intercept to the decomposed</span>
<span class="sd">            object. If the smoothed state is being decomposed, then</span>
<span class="sd">            `obs_intercept_contributions` is</span>
<span class="sd">            shaped `(k_states x nobs, k_endog x nobs)` with a `pd.MultiIndex`</span>
<span class="sd">            index corresponding to `state_to x date_to` and `pd.MultiIndex`</span>
<span class="sd">            columns corresponding to `obs_intercept_from x date_from`. If the</span>
<span class="sd">            smoothed signal is being decomposed, then</span>
<span class="sd">            `obs_intercept_contributions` is shaped</span>
<span class="sd">            `(k_endog x nobs, k_endog x nobs)` with `pd.MultiIndex`-es</span>
<span class="sd">            corresponding to `variable_to x date_to` and</span>
<span class="sd">            `obs_intercept_from x date_from`.</span>
<span class="sd">        state_intercept_contributions : pd.DataFrame</span>
<span class="sd">            Contributions of the state intercept to the decomposed</span>
<span class="sd">            object. If the smoothed state is being decomposed, then</span>
<span class="sd">            `state_intercept_contributions` is</span>
<span class="sd">            shaped `(k_states x nobs, k_states x nobs)` with a `pd.MultiIndex`</span>
<span class="sd">            index corresponding to `state_to x date_to` and `pd.MultiIndex`</span>
<span class="sd">            columns corresponding to `state_intercept_from x date_from`. If the</span>
<span class="sd">            smoothed signal is being decomposed, then</span>
<span class="sd">            `state_intercept_contributions` is shaped</span>
<span class="sd">            `(k_endog x nobs, k_states x nobs)` with `pd.MultiIndex`-es</span>
<span class="sd">            corresponding to `variable_to x date_to` and</span>
<span class="sd">            `state_intercept_from x date_from`.</span>
<span class="sd">        prior_contributions : pd.DataFrame</span>
<span class="sd">            Contributions of the prior to the decomposed object. If the</span>
<span class="sd">            smoothed state is being decomposed, then `prior_contributions` is</span>
<span class="sd">            shaped `(nobs x k_states, k_states)`, with a `pd.MultiIndex`</span>
<span class="sd">            index corresponding to `state_to x date_to` and columns</span>
<span class="sd">            corresponding to elements of the prior mean (aka &quot;initial state&quot;).</span>
<span class="sd">            If the smoothed signal is being decomposed, then</span>
<span class="sd">            `prior_contributions` is shaped `(nobs x k_endog, k_states)`,</span>
<span class="sd">            with a `pd.MultiIndex` index corresponding to</span>
<span class="sd">            `variable_to x date_to` and columns corresponding to elements of</span>
<span class="sd">            the prior mean.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Denote the smoothed state at time :math:`t` by :math:`\alpha_t`. Then</span>
<span class="sd">        the smoothed signal is :math:`Z_t \alpha_t`, where :math:`Z_t` is the</span>
<span class="sd">        design matrix operative at time :math:`t`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="p">(</span><span class="n">data_contributions</span><span class="p">,</span> <span class="n">obs_intercept_contributions</span><span class="p">,</span>
         <span class="n">state_intercept_contributions</span><span class="p">,</span> <span class="n">prior_contributions</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">smoother_results</span><span class="o">.</span><span class="n">get_smoothed_decomposition</span><span class="p">(</span>
                <span class="n">decomposition_of</span><span class="o">=</span><span class="n">decomposition_of</span><span class="p">,</span> <span class="n">state_index</span><span class="o">=</span><span class="n">state_index</span><span class="p">))</span>

        <span class="c1"># Construct indexes</span>
        <span class="n">endog_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">endog_names</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">k_endog</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">endog_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">endog_names</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">decomposition_of</span> <span class="o">==</span> <span class="s1">&#39;smoothed_state&#39;</span><span class="p">:</span>
            <span class="n">contributions_to</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="o">.</span><span class="n">from_product</span><span class="p">(</span>
                <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">state_names</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">_index</span><span class="p">],</span>
                <span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;state_to&#39;</span><span class="p">,</span> <span class="s1">&#39;date_to&#39;</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">contributions_to</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="o">.</span><span class="n">from_product</span><span class="p">(</span>
                <span class="p">[</span><span class="n">endog_names</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">_index</span><span class="p">],</span>
                <span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;variable_to&#39;</span><span class="p">,</span> <span class="s1">&#39;date_to&#39;</span><span class="p">])</span>
        <span class="n">contributions_from</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="o">.</span><span class="n">from_product</span><span class="p">(</span>
            <span class="p">[</span><span class="n">endog_names</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">_index</span><span class="p">],</span>
            <span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;variable_from&#39;</span><span class="p">,</span> <span class="s1">&#39;date_from&#39;</span><span class="p">])</span>
        <span class="n">obs_intercept_contributions_from</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="o">.</span><span class="n">from_product</span><span class="p">(</span>
            <span class="p">[</span><span class="n">endog_names</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">_index</span><span class="p">],</span>
            <span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;obs_intercept_from&#39;</span><span class="p">,</span> <span class="s1">&#39;date_from&#39;</span><span class="p">])</span>
        <span class="n">state_intercept_contributions_from</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="o">.</span><span class="n">from_product</span><span class="p">(</span>
            <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">state_names</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">_index</span><span class="p">],</span>
            <span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;state_intercept_from&#39;</span><span class="p">,</span> <span class="s1">&#39;date_from&#39;</span><span class="p">])</span>
        <span class="n">prior_contributions_from</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">state_names</span><span class="p">,</span>
                                            <span class="n">name</span><span class="o">=</span><span class="s1">&#39;initial_state_from&#39;</span><span class="p">)</span>

        <span class="c1"># Construct DataFrames</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="n">data_contributions</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">data_contributions</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
            <span class="n">data_contributions</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
                <span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">shape</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">),</span>
            <span class="n">index</span><span class="o">=</span><span class="n">contributions_to</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">contributions_from</span><span class="p">)</span>

        <span class="n">shape</span> <span class="o">=</span> <span class="n">obs_intercept_contributions</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">obs_intercept_contributions</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
            <span class="n">obs_intercept_contributions</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
                <span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">shape</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">),</span>
            <span class="n">index</span><span class="o">=</span><span class="n">contributions_to</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">obs_intercept_contributions_from</span><span class="p">)</span>

        <span class="n">shape</span> <span class="o">=</span> <span class="n">state_intercept_contributions</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">state_intercept_contributions</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
            <span class="n">state_intercept_contributions</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
                <span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">shape</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">),</span>
            <span class="n">index</span><span class="o">=</span><span class="n">contributions_to</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">state_intercept_contributions_from</span><span class="p">)</span>

        <span class="n">shape</span> <span class="o">=</span> <span class="n">prior_contributions</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">prior_contributions</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
            <span class="n">prior_contributions</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
                                        <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">),</span>
            <span class="n">index</span><span class="o">=</span><span class="n">contributions_to</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">prior_contributions_from</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">data_contributions</span><span class="p">,</span> <span class="n">obs_intercept_contributions</span><span class="p">,</span>
                <span class="n">state_intercept_contributions</span><span class="p">,</span> <span class="n">prior_contributions</span><span class="p">)</span></div>


<div class="viewcode-block" id="MLEResults.append">
<a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEResults.append.html#statsmodels.tsa.statespace.mlemodel.MLEResults.append">[docs]</a>
    <span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">endog</span><span class="p">,</span> <span class="n">exog</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">refit</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fit_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="n">copy_initialization</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Recreate the results object with new data appended to the original data</span>

<span class="sd">        Creates a new result object applied to a dataset that is created by</span>
<span class="sd">        appending new data to the end of the model&#39;s original data. The new</span>
<span class="sd">        results can then be used for analysis or forecasting.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        endog : array_like</span>
<span class="sd">            New observations from the modeled time-series process.</span>
<span class="sd">        exog : array_like, optional</span>
<span class="sd">            New observations of exogenous regressors, if applicable.</span>
<span class="sd">        refit : bool, optional</span>
<span class="sd">            Whether to re-fit the parameters, based on the combined dataset.</span>
<span class="sd">            Default is False (so parameters from the current results object</span>
<span class="sd">            are used to create the new results object).</span>
<span class="sd">        copy_initialization : bool, optional</span>
<span class="sd">            Whether or not to copy the initialization from the current results</span>
<span class="sd">            set to the new model. Default is False</span>
<span class="sd">        fit_kwargs : dict, optional</span>
<span class="sd">            Keyword arguments to pass to `fit` (if `refit=True`) or `filter` /</span>
<span class="sd">            `smooth`.</span>
<span class="sd">        copy_initialization : bool, optional</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Keyword arguments may be used to modify model specification</span>
<span class="sd">            arguments when created the new model object.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        results</span>
<span class="sd">            Updated Results object, that includes results from both the</span>
<span class="sd">            original dataset and the new dataset.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The `endog` and `exog` arguments to this method must be formatted in</span>
<span class="sd">        the same way (e.g. Pandas Series versus Numpy array) as were the</span>
<span class="sd">        `endog` and `exog` arrays passed to the original model.</span>

<span class="sd">        The `endog` argument to this method should consist of new observations</span>
<span class="sd">        that occurred directly after the last element of `endog`. For any other</span>
<span class="sd">        kind of dataset, see the `apply` method.</span>

<span class="sd">        This method will apply filtering to all of the original data as well</span>
<span class="sd">        as to the new data. To apply filtering only to the new data (which</span>
<span class="sd">        can be much faster if the original dataset is large), see the `extend`</span>
<span class="sd">        method.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        statsmodels.tsa.statespace.mlemodel.MLEResults.extend</span>
<span class="sd">        statsmodels.tsa.statespace.mlemodel.MLEResults.apply</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; index = pd.period_range(start=&#39;2000&#39;, periods=2, freq=&#39;Y&#39;)</span>
<span class="sd">        &gt;&gt;&gt; original_observations = pd.Series([1.2, 1.5], index=index)</span>
<span class="sd">        &gt;&gt;&gt; mod = sm.tsa.SARIMAX(original_observations)</span>
<span class="sd">        &gt;&gt;&gt; res = mod.fit()</span>
<span class="sd">        &gt;&gt;&gt; print(res.params)</span>
<span class="sd">        ar.L1     0.9756</span>
<span class="sd">        sigma2    0.0889</span>
<span class="sd">        dtype: float64</span>
<span class="sd">        &gt;&gt;&gt; print(res.fittedvalues)</span>
<span class="sd">        2000    0.0000</span>
<span class="sd">        2001    1.1707</span>
<span class="sd">        Freq: A-DEC, dtype: float64</span>
<span class="sd">        &gt;&gt;&gt; print(res.forecast(1))</span>
<span class="sd">        2002    1.4634</span>
<span class="sd">        Freq: A-DEC, dtype: float64</span>

<span class="sd">        &gt;&gt;&gt; new_index = pd.period_range(start=&#39;2002&#39;, periods=1, freq=&#39;Y&#39;)</span>
<span class="sd">        &gt;&gt;&gt; new_observations = pd.Series([0.9], index=new_index)</span>
<span class="sd">        &gt;&gt;&gt; updated_res = res.append(new_observations)</span>
<span class="sd">        &gt;&gt;&gt; print(updated_res.params)</span>
<span class="sd">        ar.L1     0.9756</span>
<span class="sd">        sigma2    0.0889</span>
<span class="sd">        dtype: float64</span>
<span class="sd">        &gt;&gt;&gt; print(updated_res.fittedvalues)</span>
<span class="sd">        2000    0.0000</span>
<span class="sd">        2001    1.1707</span>
<span class="sd">        2002    1.4634</span>
<span class="sd">        Freq: A-DEC, dtype: float64</span>
<span class="sd">        &gt;&gt;&gt; print(updated_res.forecast(1))</span>
<span class="sd">        2003    0.878</span>
<span class="sd">        Freq: A-DEC, dtype: float64</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span>
        <span class="n">end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">endog</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">append_ix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">_get_prediction_index</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>

        <span class="c1"># Check the index of the new data</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">PandasData</span><span class="p">):</span>
            <span class="n">_check_index</span><span class="p">(</span><span class="n">append_ix</span><span class="p">,</span> <span class="n">endog</span><span class="p">,</span> <span class="s1">&#39;`endog`&#39;</span><span class="p">)</span>

        <span class="c1"># Concatenate the new data to original data</span>
        <span class="n">new_endog</span> <span class="o">=</span> <span class="n">concat</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">orig_endog</span><span class="p">,</span> <span class="n">endog</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                           <span class="n">allow_mix</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Handle `exog`</span>
        <span class="k">if</span> <span class="n">exog</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">exog</span> <span class="o">=</span> <span class="n">prepare_exog</span><span class="p">(</span><span class="n">exog</span><span class="p">)</span>
            <span class="n">_check_index</span><span class="p">(</span><span class="n">append_ix</span><span class="p">,</span> <span class="n">exog</span><span class="p">,</span> <span class="s1">&#39;`exog`&#39;</span><span class="p">)</span>

            <span class="n">new_exog</span> <span class="o">=</span> <span class="n">concat</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">orig_exog</span><span class="p">,</span> <span class="n">exog</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                              <span class="n">allow_mix</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_exog</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Create a continuous index for the combined data</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">PandasData</span><span class="p">):</span>
            <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">end</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_endog</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">new_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">_get_prediction_index</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>

            <span class="c1"># Standardize `endog` to have the right index and columns</span>
            <span class="n">columns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">endog_names</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">columns</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">columns</span><span class="p">]</span>
            <span class="n">new_endog</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">new_endog</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">new_index</span><span class="p">,</span>
                                     <span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">)</span>

            <span class="c1"># Standardize `exog` to have the right index</span>
            <span class="k">if</span> <span class="n">new_exog</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">new_exog</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">new_exog</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">new_index</span><span class="p">,</span>
                                        <span class="n">columns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">exog_names</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">copy_initialization</span><span class="p">:</span>
            <span class="n">init</span> <span class="o">=</span> <span class="n">Initialization</span><span class="o">.</span><span class="n">from_results</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filter_results</span><span class="p">)</span>
            <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;initialization&#39;</span><span class="p">,</span> <span class="n">init</span><span class="p">)</span>

        <span class="n">mod</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">new_endog</span><span class="p">,</span> <span class="n">exog</span><span class="o">=</span><span class="n">new_exog</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">refit</span><span class="o">=</span><span class="n">refit</span><span class="p">,</span> <span class="n">fit_kwargs</span><span class="o">=</span><span class="n">fit_kwargs</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">res</span></div>


<div class="viewcode-block" id="MLEResults.extend">
<a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEResults.extend.html#statsmodels.tsa.statespace.mlemodel.MLEResults.extend">[docs]</a>
    <span class="k">def</span> <span class="nf">extend</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">endog</span><span class="p">,</span> <span class="n">exog</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fit_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Recreate the results object for new data that extends the original data</span>

<span class="sd">        Creates a new result object applied to a new dataset that is assumed to</span>
<span class="sd">        follow directly from the end of the model&#39;s original data. The new</span>
<span class="sd">        results can then be used for analysis or forecasting.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        endog : array_like</span>
<span class="sd">            New observations from the modeled time-series process.</span>
<span class="sd">        exog : array_like, optional</span>
<span class="sd">            New observations of exogenous regressors, if applicable.</span>
<span class="sd">        fit_kwargs : dict, optional</span>
<span class="sd">            Keyword arguments to pass to `filter` or `smooth`.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Keyword arguments may be used to modify model specification</span>
<span class="sd">            arguments when created the new model object.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        results</span>
<span class="sd">            Updated Results object, that includes results only for the new</span>
<span class="sd">            dataset.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        statsmodels.tsa.statespace.mlemodel.MLEResults.append</span>
<span class="sd">        statsmodels.tsa.statespace.mlemodel.MLEResults.apply</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The `endog` argument to this method should consist of new observations</span>
<span class="sd">        that occurred directly after the last element of the model&#39;s original</span>
<span class="sd">        `endog` array. For any other kind of dataset, see the `apply` method.</span>

<span class="sd">        This method will apply filtering only to the new data provided by the</span>
<span class="sd">        `endog` argument, which can be much faster than re-filtering the entire</span>
<span class="sd">        dataset. However, the returned results object will only have results</span>
<span class="sd">        for the new data. To retrieve results for both the new data and the</span>
<span class="sd">        original data, see the `append` method.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; index = pd.period_range(start=&#39;2000&#39;, periods=2, freq=&#39;Y&#39;)</span>
<span class="sd">        &gt;&gt;&gt; original_observations = pd.Series([1.2, 1.5], index=index)</span>
<span class="sd">        &gt;&gt;&gt; mod = sm.tsa.SARIMAX(original_observations)</span>
<span class="sd">        &gt;&gt;&gt; res = mod.fit()</span>
<span class="sd">        &gt;&gt;&gt; print(res.params)</span>
<span class="sd">        ar.L1     0.9756</span>
<span class="sd">        sigma2    0.0889</span>
<span class="sd">        dtype: float64</span>
<span class="sd">        &gt;&gt;&gt; print(res.fittedvalues)</span>
<span class="sd">        2000    0.0000</span>
<span class="sd">        2001    1.1707</span>
<span class="sd">        Freq: A-DEC, dtype: float64</span>
<span class="sd">        &gt;&gt;&gt; print(res.forecast(1))</span>
<span class="sd">        2002    1.4634</span>
<span class="sd">        Freq: A-DEC, dtype: float64</span>

<span class="sd">        &gt;&gt;&gt; new_index = pd.period_range(start=&#39;2002&#39;, periods=1, freq=&#39;Y&#39;)</span>
<span class="sd">        &gt;&gt;&gt; new_observations = pd.Series([0.9], index=new_index)</span>
<span class="sd">        &gt;&gt;&gt; updated_res = res.extend(new_observations)</span>
<span class="sd">        &gt;&gt;&gt; print(updated_res.params)</span>
<span class="sd">        ar.L1     0.9756</span>
<span class="sd">        sigma2    0.0889</span>
<span class="sd">        dtype: float64</span>
<span class="sd">        &gt;&gt;&gt; print(updated_res.fittedvalues)</span>
<span class="sd">        2002    1.4634</span>
<span class="sd">        Freq: A-DEC, dtype: float64</span>
<span class="sd">        &gt;&gt;&gt; print(updated_res.forecast(1))</span>
<span class="sd">        2003    0.878</span>
<span class="sd">        Freq: A-DEC, dtype: float64</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span>
        <span class="n">end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">endog</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">extend_ix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">_get_prediction_index</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">PandasData</span><span class="p">):</span>
            <span class="n">_check_index</span><span class="p">(</span><span class="n">extend_ix</span><span class="p">,</span> <span class="n">endog</span><span class="p">,</span> <span class="s1">&#39;`endog`&#39;</span><span class="p">)</span>

            <span class="c1"># Standardize `endog` to have the right index and columns</span>
            <span class="n">columns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">endog_names</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">columns</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">columns</span><span class="p">]</span>
            <span class="n">endog</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">endog</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">extend_ix</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">)</span>
        <span class="c1"># Extend the current fit result to additional data</span>
        <span class="n">mod</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">endog</span><span class="p">,</span> <span class="n">exog</span><span class="o">=</span><span class="n">exog</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">mod</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">initialization</span> <span class="o">=</span> <span class="n">Initialization</span><span class="p">(</span>
            <span class="n">mod</span><span class="o">.</span><span class="n">k_states</span><span class="p">,</span> <span class="s1">&#39;known&#39;</span><span class="p">,</span> <span class="n">constant</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">predicted_state</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span>
            <span class="n">stationary_cov</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">predicted_state_cov</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">refit</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fit_kwargs</span><span class="o">=</span><span class="n">fit_kwargs</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">res</span></div>


<div class="viewcode-block" id="MLEResults.apply">
<a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEResults.apply.html#statsmodels.tsa.statespace.mlemodel.MLEResults.apply">[docs]</a>
    <span class="k">def</span> <span class="nf">apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">endog</span><span class="p">,</span> <span class="n">exog</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">refit</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fit_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
              <span class="n">copy_initialization</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply the fitted parameters to new data unrelated to the original data</span>

<span class="sd">        Creates a new result object using the current fitted parameters,</span>
<span class="sd">        applied to a completely new dataset that is assumed to be unrelated to</span>
<span class="sd">        the model&#39;s original data. The new results can then be used for</span>
<span class="sd">        analysis or forecasting.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        endog : array_like</span>
<span class="sd">            New observations from the modeled time-series process.</span>
<span class="sd">        exog : array_like, optional</span>
<span class="sd">            New observations of exogenous regressors, if applicable.</span>
<span class="sd">        refit : bool, optional</span>
<span class="sd">            Whether to re-fit the parameters, using the new dataset.</span>
<span class="sd">            Default is False (so parameters from the current results object</span>
<span class="sd">            are used to create the new results object).</span>
<span class="sd">        copy_initialization : bool, optional</span>
<span class="sd">            Whether or not to copy the initialization from the current results</span>
<span class="sd">            set to the new model. Default is False</span>
<span class="sd">        fit_kwargs : dict, optional</span>
<span class="sd">            Keyword arguments to pass to `fit` (if `refit=True`) or `filter` /</span>
<span class="sd">            `smooth`.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Keyword arguments may be used to modify model specification</span>
<span class="sd">            arguments when created the new model object.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        results</span>
<span class="sd">            Updated Results object, that includes results only for the new</span>
<span class="sd">            dataset.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        statsmodels.tsa.statespace.mlemodel.MLEResults.append</span>
<span class="sd">        statsmodels.tsa.statespace.mlemodel.MLEResults.apply</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The `endog` argument to this method should consist of new observations</span>
<span class="sd">        that are not necessarily related to the original model&#39;s `endog`</span>
<span class="sd">        dataset. For observations that continue that original dataset by follow</span>
<span class="sd">        directly after its last element, see the `append` and `extend` methods.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; index = pd.period_range(start=&#39;2000&#39;, periods=2, freq=&#39;Y&#39;)</span>
<span class="sd">        &gt;&gt;&gt; original_observations = pd.Series([1.2, 1.5], index=index)</span>
<span class="sd">        &gt;&gt;&gt; mod = sm.tsa.SARIMAX(original_observations)</span>
<span class="sd">        &gt;&gt;&gt; res = mod.fit()</span>
<span class="sd">        &gt;&gt;&gt; print(res.params)</span>
<span class="sd">        ar.L1     0.9756</span>
<span class="sd">        sigma2    0.0889</span>
<span class="sd">        dtype: float64</span>
<span class="sd">        &gt;&gt;&gt; print(res.fittedvalues)</span>
<span class="sd">        2000    0.0000</span>
<span class="sd">        2001    1.1707</span>
<span class="sd">        Freq: A-DEC, dtype: float64</span>
<span class="sd">        &gt;&gt;&gt; print(res.forecast(1))</span>
<span class="sd">        2002    1.4634</span>
<span class="sd">        Freq: A-DEC, dtype: float64</span>

<span class="sd">        &gt;&gt;&gt; new_index = pd.period_range(start=&#39;1980&#39;, periods=3, freq=&#39;Y&#39;)</span>
<span class="sd">        &gt;&gt;&gt; new_observations = pd.Series([1.4, 0.3, 1.2], index=new_index)</span>
<span class="sd">        &gt;&gt;&gt; new_res = res.apply(new_observations)</span>
<span class="sd">        &gt;&gt;&gt; print(new_res.params)</span>
<span class="sd">        ar.L1     0.9756</span>
<span class="sd">        sigma2    0.0889</span>
<span class="sd">        dtype: float64</span>
<span class="sd">        &gt;&gt;&gt; print(new_res.fittedvalues)</span>
<span class="sd">        1980    1.1707</span>
<span class="sd">        1981    1.3659</span>
<span class="sd">        1982    0.2927</span>
<span class="sd">        Freq: A-DEC, dtype: float64</span>
<span class="sd">        Freq: A-DEC, dtype: float64</span>
<span class="sd">        &gt;&gt;&gt; print(new_res.forecast(1))</span>
<span class="sd">        1983    1.1707</span>
<span class="sd">        Freq: A-DEC, dtype: float64</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mod</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">endog</span><span class="p">,</span> <span class="n">exog</span><span class="o">=</span><span class="n">exog</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">copy_initialization</span><span class="p">:</span>
            <span class="n">init</span> <span class="o">=</span> <span class="n">Initialization</span><span class="o">.</span><span class="n">from_results</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filter_results</span><span class="p">)</span>
            <span class="n">mod</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">initialization</span> <span class="o">=</span> <span class="n">init</span>

        <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">refit</span><span class="o">=</span><span class="n">refit</span><span class="p">,</span> <span class="n">fit_kwargs</span><span class="o">=</span><span class="n">fit_kwargs</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">res</span></div>


<div class="viewcode-block" id="MLEResults.plot_diagnostics">
<a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEResults.plot_diagnostics.html#statsmodels.tsa.statespace.mlemodel.MLEResults.plot_diagnostics">[docs]</a>
    <span class="k">def</span> <span class="nf">plot_diagnostics</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variable</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">lags</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">fig</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                         <span class="n">truncate_endog_names</span><span class="o">=</span><span class="mi">24</span><span class="p">,</span> <span class="n">auto_ylims</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                         <span class="n">bartlett_confint</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">acf_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Diagnostic plots for standardized residuals of one endogenous variable</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        variable : int, optional</span>
<span class="sd">            Index of the endogenous variable for which the diagnostic plots</span>
<span class="sd">            should be created. Default is 0.</span>
<span class="sd">        lags : int, optional</span>
<span class="sd">            Number of lags to include in the correlogram. Default is 10.</span>
<span class="sd">        fig : Figure, optional</span>
<span class="sd">            If given, subplots are created in this figure instead of in a new</span>
<span class="sd">            figure. Note that the 2x2 grid will be created in the provided</span>
<span class="sd">            figure using `fig.add_subplot()`.</span>
<span class="sd">        figsize : tuple, optional</span>
<span class="sd">            If a figure is created, this argument allows specifying a size.</span>
<span class="sd">            The tuple is (width, height).</span>
<span class="sd">        auto_ylims : bool, optional</span>
<span class="sd">            If True, adjusts automatically the y-axis limits to ACF values.</span>
<span class="sd">        bartlett_confint : bool, default True</span>
<span class="sd">            Confidence intervals for ACF values are generally placed at 2</span>
<span class="sd">            standard errors around r_k. The formula used for standard error</span>
<span class="sd">            depends upon the situation. If the autocorrelations are being used</span>
<span class="sd">            to test for randomness of residuals as part of the ARIMA routine,</span>
<span class="sd">            the standard errors are determined assuming the residuals are white</span>
<span class="sd">            noise. The approximate formula for any lag is that standard error</span>
<span class="sd">            of each r_k = 1/sqrt(N). See section 9.4 of [1] for more details on</span>
<span class="sd">            the 1/sqrt(N) result. For more elementary discussion, see section</span>
<span class="sd">            5.3.2 in [2].</span>
<span class="sd">            For the ACF of raw data, the standard error at a lag k is</span>
<span class="sd">            found as if the right model was an MA(k-1). This allows the</span>
<span class="sd">            possible interpretation that if all autocorrelations past a</span>
<span class="sd">            certain lag are within the limits, the model might be an MA of</span>
<span class="sd">            order defined by the last significant autocorrelation. In this</span>
<span class="sd">            case, a moving average model is assumed for the data and the</span>
<span class="sd">            standard errors for the confidence intervals should be</span>
<span class="sd">            generated using Bartlett&#39;s formula. For more details on</span>
<span class="sd">            Bartlett formula result, see section 7.2 in [1].+</span>
<span class="sd">        acf_kwargs : dict, optional</span>
<span class="sd">            Optional dictionary of keyword arguments that are directly passed</span>
<span class="sd">            on to the correlogram Matplotlib plot produced by plot_acf().</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Figure</span>
<span class="sd">            Figure instance with diagnostic plots</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        statsmodels.graphics.gofplots.qqplot</span>
<span class="sd">        statsmodels.graphics.tsaplots.plot_acf</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Produces a 2x2 plot grid with the following plots (ordered clockwise</span>
<span class="sd">        from top left):</span>

<span class="sd">        1. Standardized residuals over time</span>
<span class="sd">        2. Histogram plus estimated density of standardized residuals, along</span>
<span class="sd">           with a Normal(0,1) density plotted for reference.</span>
<span class="sd">        3. Normal Q-Q plot, with Normal reference line.</span>
<span class="sd">        4. Correlogram</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        [1] Brockwell and Davis, 1987. Time Series Theory and Methods</span>
<span class="sd">        [2] Brockwell and Davis, 2010. Introduction to Time Series and</span>
<span class="sd">        Forecasting, 2nd edition.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">statsmodels.graphics.utils</span> <span class="kn">import</span> <span class="n">_import_mpl</span><span class="p">,</span> <span class="n">create_mpl_fig</span>
        <span class="n">_import_mpl</span><span class="p">()</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">create_mpl_fig</span><span class="p">(</span><span class="n">fig</span><span class="p">,</span> <span class="n">figsize</span><span class="p">)</span>
        <span class="c1"># Eliminate residuals associated with burned or diffuse likelihoods</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loglikelihood_burn</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs_diffuse</span><span class="p">)</span>

        <span class="c1"># If given a variable name, find the index</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">variable</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">endog_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">variable</span><span class="p">)</span>

        <span class="c1"># Get residuals</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="s1">&#39;dates&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">dates</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">dates</span><span class="p">[</span><span class="n">d</span><span class="p">:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nobs</span> <span class="o">-</span> <span class="n">d</span><span class="p">)</span>
        <span class="n">resid</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">filter_results</span><span class="o">.</span><span class="n">standardized_forecasts_error</span><span class="p">[</span><span class="n">variable</span><span class="p">,</span> <span class="n">d</span><span class="p">:],</span>
            <span class="n">index</span><span class="o">=</span><span class="n">ix</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">resid</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="nb">max</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">lags</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Length of endogenous variable must be larger the the number &quot;</span>
                <span class="s2">&quot;of lags used in the model and the number of observations &quot;</span>
                <span class="s2">&quot;burned in the log-likelihood calculation.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Top-left: residuals vs time</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">221</span><span class="p">)</span>
        <span class="n">resid</span><span class="o">.</span><span class="n">dropna</span><span class="p">()</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">hlines</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ix</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ix</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="n">ix</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ix</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">endog_names</span><span class="p">[</span><span class="n">variable</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">truncate_endog_names</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">name</span><span class="p">[:</span><span class="n">truncate_endog_names</span> <span class="o">-</span> <span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;...&#39;</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Standardized residual for &quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1">&quot;&#39;</span><span class="p">)</span>

        <span class="c1"># Top-right: histogram, Gaussian kernel density, Normal density</span>
        <span class="c1"># Can only do histogram and Gaussian kernel density on the non-null</span>
        <span class="c1"># elements</span>
        <span class="n">resid_nonmissing</span> <span class="o">=</span> <span class="n">resid</span><span class="o">.</span><span class="n">dropna</span><span class="p">()</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">222</span><span class="p">)</span>

        <span class="n">ax</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">resid_nonmissing</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Hist&#39;</span><span class="p">,</span>
                <span class="n">edgecolor</span><span class="o">=</span><span class="s1">&#39;#FFFFFF&#39;</span><span class="p">)</span>

        <span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">gaussian_kde</span><span class="p">,</span> <span class="n">norm</span>
        <span class="n">kde</span> <span class="o">=</span> <span class="n">gaussian_kde</span><span class="p">(</span><span class="n">resid_nonmissing</span><span class="p">)</span>
        <span class="n">xlim</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mf">1.96</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="mf">1.96</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">xlim</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">xlim</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">kde</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;KDE&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">norm</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;N(0,1)&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="n">xlim</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Histogram plus estimated density&#39;</span><span class="p">)</span>

        <span class="c1"># Bottom-left: QQ plot</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">223</span><span class="p">)</span>
        <span class="kn">from</span> <span class="nn">statsmodels.graphics.gofplots</span> <span class="kn">import</span> <span class="n">qqplot</span>
        <span class="n">qqplot</span><span class="p">(</span><span class="n">resid_nonmissing</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="s1">&#39;s&#39;</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Normal Q-Q&#39;</span><span class="p">)</span>

        <span class="c1"># Bottom-right: Correlogram</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">224</span><span class="p">)</span>
        <span class="kn">from</span> <span class="nn">statsmodels.graphics.tsaplots</span> <span class="kn">import</span> <span class="n">plot_acf</span>

        <span class="k">if</span> <span class="n">acf_kwargs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">acf_kwargs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">plot_acf</span><span class="p">(</span><span class="n">resid</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">lags</span><span class="o">=</span><span class="n">lags</span><span class="p">,</span> <span class="n">auto_ylims</span><span class="o">=</span><span class="n">auto_ylims</span><span class="p">,</span>
                 <span class="n">bartlett_confint</span><span class="o">=</span><span class="n">bartlett_confint</span><span class="p">,</span> <span class="o">**</span><span class="n">acf_kwargs</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Correlogram&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">fig</span></div>


<div class="viewcode-block" id="MLEResults.summary">
<a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEResults.summary.html#statsmodels.tsa.statespace.mlemodel.MLEResults.summary">[docs]</a>
    <span class="k">def</span> <span class="nf">summary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">.05</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">model_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">display_params</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">display_diagnostics</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">truncate_endog_names</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">display_max_endog</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">extra_top_left</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">extra_top_right</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Summarize the Model</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        alpha : float, optional</span>
<span class="sd">            Significance level for the confidence intervals. Default is 0.05.</span>
<span class="sd">        start : int, optional</span>
<span class="sd">            Integer of the start observation. Default is 0.</span>
<span class="sd">        model_name : str</span>
<span class="sd">            The name of the model used. Default is to use model class name.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        summary : Summary instance</span>
<span class="sd">            This holds the summary table and text, which can be printed or</span>
<span class="sd">            converted to various output formats.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        statsmodels.iolib.summary.Summary</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">statsmodels.iolib.summary</span> <span class="kn">import</span> <span class="n">Summary</span>
        <span class="kn">from</span> <span class="nn">statsmodels.iolib.table</span> <span class="kn">import</span> <span class="n">SimpleTable</span>
        <span class="kn">from</span> <span class="nn">statsmodels.iolib.tableformatting</span> <span class="kn">import</span> <span class="n">fmt_params</span>

        <span class="c1"># Model specification results</span>
        <span class="n">model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span>
        <span class="k">if</span> <span class="n">title</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">title</span> <span class="o">=</span> <span class="s1">&#39;Statespace Model Results&#39;</span>

        <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">_index_dates</span><span class="p">:</span>
            <span class="n">ix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">_index</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">ix</span><span class="p">[</span><span class="n">start</span><span class="p">]</span>
            <span class="n">sample</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;</span><span class="si">%02d</span><span class="s1">-</span><span class="si">%02d</span><span class="s1">-</span><span class="si">%02d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">month</span><span class="p">,</span> <span class="n">d</span><span class="o">.</span><span class="n">day</span><span class="p">,</span> <span class="n">d</span><span class="o">.</span><span class="n">year</span><span class="p">)]</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">ix</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">sample</span> <span class="o">+=</span> <span class="p">[</span><span class="s1">&#39;- &#39;</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="si">%02d</span><span class="s1">-</span><span class="si">%02d</span><span class="s1">-</span><span class="si">%02d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">month</span><span class="p">,</span> <span class="n">d</span><span class="o">.</span><span class="n">day</span><span class="p">,</span> <span class="n">d</span><span class="o">.</span><span class="n">year</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sample</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">start</span><span class="p">),</span> <span class="s1">&#39; - &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="p">)]</span>

        <span class="c1"># Standardize the model name as a list of str</span>
        <span class="k">if</span> <span class="n">model_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">model_name</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>

        <span class="c1"># Truncate endog names</span>
        <span class="k">if</span> <span class="n">truncate_endog_names</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">truncate_endog_names</span> <span class="o">=</span> <span class="kc">False</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">k_endog</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">24</span>
        <span class="n">endog_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">endog_names</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">endog_names</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">endog_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">endog_names</span><span class="p">]</span>
        <span class="n">endog_names</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">endog_names</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">truncate_endog_names</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">truncate_endog_names</span>
            <span class="n">endog_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">name</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">n</span> <span class="k">else</span> <span class="n">name</span><span class="p">[:</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;...&#39;</span>
                           <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">endog_names</span><span class="p">]</span>

        <span class="c1"># Shorten the endog name list if applicable</span>
        <span class="k">if</span> <span class="n">display_max_endog</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">display_max_endog</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="n">yname</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">k_endog</span> <span class="o">&gt;</span> <span class="n">display_max_endog</span><span class="p">:</span>
            <span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">k_endog</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">yname</span> <span class="o">=</span> <span class="s1">&#39;&quot;&#39;</span> <span class="o">+</span> <span class="n">endog_names</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="sa">f</span><span class="s1">&#39;&quot;, and </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s1"> more&#39;</span>

        <span class="c1"># Create the tables</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">model_name</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">model_name</span> <span class="o">=</span> <span class="p">[</span><span class="n">model_name</span><span class="p">]</span>

        <span class="n">top_left</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;Dep. Variable:&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)]</span>
        <span class="n">top_left</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s1">&#39;Model:&#39;</span><span class="p">,</span> <span class="p">[</span><span class="n">model_name</span><span class="p">[</span><span class="mi">0</span><span class="p">]]))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">model_name</span><span class="p">)):</span>
            <span class="n">top_left</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;+ &#39;</span> <span class="o">+</span> <span class="n">model_name</span><span class="p">[</span><span class="n">i</span><span class="p">]]))</span>
        <span class="n">top_left</span> <span class="o">+=</span> <span class="p">[</span>
            <span class="p">(</span><span class="s1">&#39;Date:&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
            <span class="p">(</span><span class="s1">&#39;Time:&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
            <span class="p">(</span><span class="s1">&#39;Sample:&#39;</span><span class="p">,</span> <span class="p">[</span><span class="n">sample</span><span class="p">[</span><span class="mi">0</span><span class="p">]]),</span>
            <span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="p">[</span><span class="n">sample</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
        <span class="p">]</span>

        <span class="n">top_right</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="s1">&#39;No. Observations:&#39;</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="p">]),</span>
            <span class="p">(</span><span class="s1">&#39;Log Likelihood&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;</span><span class="si">%#5.3f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">llf</span><span class="p">]),</span>
        <span class="p">]</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;rsquared&#39;</span><span class="p">):</span>
            <span class="n">top_right</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s1">&#39;R-squared:&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;</span><span class="si">%#8.3f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">rsquared</span><span class="p">]))</span>
        <span class="n">top_right</span> <span class="o">+=</span> <span class="p">[</span>
            <span class="p">(</span><span class="s1">&#39;AIC&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;</span><span class="si">%#5.3f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">aic</span><span class="p">]),</span>
            <span class="p">(</span><span class="s1">&#39;BIC&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;</span><span class="si">%#5.3f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">bic</span><span class="p">]),</span>
            <span class="p">(</span><span class="s1">&#39;HQIC&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;</span><span class="si">%#5.3f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">hqic</span><span class="p">])]</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filter_results</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">filter_results</span><span class="o">.</span><span class="n">filter_concentrated</span><span class="p">):</span>
            <span class="n">top_right</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s1">&#39;Scale&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;</span><span class="si">%#5.3f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">]))</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;cov_type&#39;</span><span class="p">):</span>
            <span class="n">cov_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cov_type</span>
            <span class="k">if</span> <span class="n">cov_type</span> <span class="o">==</span> <span class="s1">&#39;none&#39;</span><span class="p">:</span>
                <span class="n">cov_type</span> <span class="o">=</span> <span class="s1">&#39;Not computed&#39;</span>
            <span class="n">top_left</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s1">&#39;Covariance Type:&#39;</span><span class="p">,</span> <span class="p">[</span><span class="n">cov_type</span><span class="p">]))</span>

        <span class="k">if</span> <span class="n">extra_top_left</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">top_left</span> <span class="o">+=</span> <span class="n">extra_top_left</span>
        <span class="k">if</span> <span class="n">extra_top_right</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">top_right</span> <span class="o">+=</span> <span class="n">extra_top_right</span>

        <span class="n">summary</span> <span class="o">=</span> <span class="n">Summary</span><span class="p">()</span>
        <span class="n">summary</span><span class="o">.</span><span class="n">add_table_2cols</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gleft</span><span class="o">=</span><span class="n">top_left</span><span class="p">,</span> <span class="n">gright</span><span class="o">=</span><span class="n">top_right</span><span class="p">,</span>
                                <span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">,</span> <span class="n">yname</span><span class="o">=</span><span class="n">yname</span><span class="p">)</span>
        <span class="n">table_ix</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">display_params</span><span class="p">:</span>
            <span class="n">summary</span><span class="o">.</span><span class="n">add_table_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span>
                                     <span class="n">xname</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">,</span> <span class="n">use_t</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">table_ix</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># Diagnostic tests results</span>
        <span class="k">if</span> <span class="n">display_diagnostics</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">het</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">test_heteroskedasticity</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="s1">&#39;breakvar&#39;</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>  <span class="c1"># FIXME: catch something specific</span>
                <span class="n">het</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">k_endog</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">lb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">test_serial_correlation</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="s1">&#39;ljungbox&#39;</span><span class="p">,</span> <span class="n">lags</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>  <span class="c1"># FIXME: catch something specific</span>
                <span class="n">lb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">k_endog</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">jb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">test_normality</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="s1">&#39;jarquebera&#39;</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>  <span class="c1"># FIXME: catch something specific</span>
                <span class="n">jb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">k_endog</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">k_endog</span> <span class="o">&lt;=</span> <span class="n">display_max_endog</span><span class="p">:</span>
                <span class="n">format_str</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">array</span><span class="p">:</span> <span class="p">[</span>  <span class="c1"># noqa:E731</span>
                    <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">i</span><span class="si">:</span><span class="s1">.2f</span><span class="si">}</span><span class="s1">&#39;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">array</span><span class="p">])</span>
                <span class="p">]</span>
                <span class="n">diagn_left</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="p">(</span><span class="s1">&#39;Ljung-Box (L1) (Q):&#39;</span><span class="p">,</span> <span class="n">format_str</span><span class="p">(</span><span class="n">lb</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])),</span>
                    <span class="p">(</span><span class="s1">&#39;Prob(Q):&#39;</span><span class="p">,</span> <span class="n">format_str</span><span class="p">(</span><span class="n">lb</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])),</span>
                    <span class="p">(</span><span class="s1">&#39;Heteroskedasticity (H):&#39;</span><span class="p">,</span> <span class="n">format_str</span><span class="p">(</span><span class="n">het</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])),</span>
                    <span class="p">(</span><span class="s1">&#39;Prob(H) (two-sided):&#39;</span><span class="p">,</span> <span class="n">format_str</span><span class="p">(</span><span class="n">het</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]))]</span>

                <span class="n">diagn_right</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;Jarque-Bera (JB):&#39;</span><span class="p">,</span> <span class="n">format_str</span><span class="p">(</span><span class="n">jb</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])),</span>
                               <span class="p">(</span><span class="s1">&#39;Prob(JB):&#39;</span><span class="p">,</span> <span class="n">format_str</span><span class="p">(</span><span class="n">jb</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])),</span>
                               <span class="p">(</span><span class="s1">&#39;Skew:&#39;</span><span class="p">,</span> <span class="n">format_str</span><span class="p">(</span><span class="n">jb</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">])),</span>
                               <span class="p">(</span><span class="s1">&#39;Kurtosis:&#39;</span><span class="p">,</span> <span class="n">format_str</span><span class="p">(</span><span class="n">jb</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">]))</span>
                               <span class="p">]</span>

                <span class="n">summary</span><span class="o">.</span><span class="n">add_table_2cols</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gleft</span><span class="o">=</span><span class="n">diagn_left</span><span class="p">,</span>
                                        <span class="n">gright</span><span class="o">=</span><span class="n">diagn_right</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;LjungBox</span><span class="se">\n</span><span class="s1">(L1) (Q)&#39;</span><span class="p">,</span> <span class="s1">&#39;Prob(Q)&#39;</span><span class="p">,</span>
                           <span class="s1">&#39;Het.(H)&#39;</span><span class="p">,</span> <span class="s1">&#39;Prob(H)&#39;</span><span class="p">,</span>
                           <span class="s1">&#39;Jarque</span><span class="se">\n</span><span class="s1">Bera(JB)&#39;</span><span class="p">,</span> <span class="s1">&#39;Prob(JB)&#39;</span><span class="p">,</span> <span class="s1">&#39;Skew&#39;</span><span class="p">,</span> <span class="s1">&#39;Kurtosis&#39;</span><span class="p">]</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">lb</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">het</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">],</span> <span class="n">jb</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">4</span><span class="p">]],</span>
                    <span class="n">index</span><span class="o">=</span><span class="n">endog_names</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">)</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
                        <span class="k">lambda</span> <span class="n">num</span><span class="p">:</span> <span class="s1">&#39;&#39;</span> <span class="k">if</span> <span class="n">pd</span><span class="o">.</span><span class="n">isnull</span><span class="p">(</span><span class="n">num</span><span class="p">)</span> <span class="k">else</span> <span class="s1">&#39;</span><span class="si">%.2f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">num</span>
                    <span class="p">)</span>
                <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">applymap</span><span class="p">(</span>
                        <span class="k">lambda</span> <span class="n">num</span><span class="p">:</span> <span class="s1">&#39;&#39;</span> <span class="k">if</span> <span class="n">pd</span><span class="o">.</span><span class="n">isnull</span><span class="p">(</span><span class="n">num</span><span class="p">)</span> <span class="k">else</span> <span class="s1">&#39;</span><span class="si">%.2f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">num</span>
                    <span class="p">)</span>
                <span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;Residual of</span><span class="se">\n</span><span class="s1">Dep. variable&#39;</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>

                <span class="n">params_data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">values</span>
                <span class="n">params_header</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                <span class="n">params_stubs</span> <span class="o">=</span> <span class="kc">None</span>

                <span class="n">title</span> <span class="o">=</span> <span class="s1">&#39;Residual diagnostics:&#39;</span>
                <span class="n">table</span> <span class="o">=</span> <span class="n">SimpleTable</span><span class="p">(</span>
                    <span class="n">params_data</span><span class="p">,</span> <span class="n">params_header</span><span class="p">,</span> <span class="n">params_stubs</span><span class="p">,</span>
                    <span class="n">txt_fmt</span><span class="o">=</span><span class="n">fmt_params</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">)</span>
                <span class="n">summary</span><span class="o">.</span><span class="n">tables</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">table_ix</span><span class="p">,</span> <span class="n">table</span><span class="p">)</span>

        <span class="c1"># Add warnings/notes, added to text format only</span>
        <span class="n">etext</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;cov_type&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="s1">&#39;description&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cov_kwds</span><span class="p">:</span>
            <span class="n">etext</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cov_kwds</span><span class="p">[</span><span class="s1">&#39;description&#39;</span><span class="p">])</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rank</span> <span class="o">&lt;</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fixed_params</span><span class="p">)):</span>
            <span class="n">cov_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cov_params</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fixed_params</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_free_params_index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_free_params_index</span><span class="p">)</span>
                <span class="n">cov_params</span> <span class="o">=</span> <span class="n">cov_params</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
            <span class="n">etext</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;Covariance matrix is singular or near-singular,&quot;</span>
                         <span class="s2">&quot; with condition number </span><span class="si">%6.3g</span><span class="s2">. Standard errors may be&quot;</span>
                         <span class="s2">&quot; unstable.&quot;</span> <span class="o">%</span> <span class="n">_safe_cond</span><span class="p">(</span><span class="n">cov_params</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">etext</span><span class="p">:</span>
            <span class="n">etext</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2">] </span><span class="si">{</span><span class="n">text</span><span class="si">}</span><span class="s2">&quot;</span>
                     <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">text</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">etext</span><span class="p">)]</span>
            <span class="n">etext</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;Warnings:&quot;</span><span class="p">)</span>
            <span class="n">summary</span><span class="o">.</span><span class="n">add_extra_txt</span><span class="p">(</span><span class="n">etext</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">summary</span></div>
</div>



<span class="k">class</span> <span class="nc">MLEResultsWrapper</span><span class="p">(</span><span class="n">wrap</span><span class="o">.</span><span class="n">ResultsWrapper</span><span class="p">):</span>
    <span class="n">_attrs</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;zvalues&#39;</span><span class="p">:</span> <span class="s1">&#39;columns&#39;</span><span class="p">,</span>
        <span class="s1">&#39;cov_params_approx&#39;</span><span class="p">:</span> <span class="s1">&#39;cov&#39;</span><span class="p">,</span>
        <span class="s1">&#39;cov_params_default&#39;</span><span class="p">:</span> <span class="s1">&#39;cov&#39;</span><span class="p">,</span>
        <span class="s1">&#39;cov_params_oim&#39;</span><span class="p">:</span> <span class="s1">&#39;cov&#39;</span><span class="p">,</span>
        <span class="s1">&#39;cov_params_opg&#39;</span><span class="p">:</span> <span class="s1">&#39;cov&#39;</span><span class="p">,</span>
        <span class="s1">&#39;cov_params_robust&#39;</span><span class="p">:</span> <span class="s1">&#39;cov&#39;</span><span class="p">,</span>
        <span class="s1">&#39;cov_params_robust_approx&#39;</span><span class="p">:</span> <span class="s1">&#39;cov&#39;</span><span class="p">,</span>
        <span class="s1">&#39;cov_params_robust_oim&#39;</span><span class="p">:</span> <span class="s1">&#39;cov&#39;</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="n">_wrap_attrs</span> <span class="o">=</span> <span class="n">wrap</span><span class="o">.</span><span class="n">union_dicts</span><span class="p">(</span><span class="n">tsbase</span><span class="o">.</span><span class="n">TimeSeriesResultsWrapper</span><span class="o">.</span><span class="n">_wrap_attrs</span><span class="p">,</span>
                                   <span class="n">_attrs</span><span class="p">)</span>
    <span class="n">_methods</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;forecast&#39;</span><span class="p">:</span> <span class="s1">&#39;dates&#39;</span><span class="p">,</span>
        <span class="s1">&#39;impulse_responses&#39;</span><span class="p">:</span> <span class="s1">&#39;ynames&#39;</span>
    <span class="p">}</span>
    <span class="n">_wrap_methods</span> <span class="o">=</span> <span class="n">wrap</span><span class="o">.</span><span class="n">union_dicts</span><span class="p">(</span>
        <span class="n">tsbase</span><span class="o">.</span><span class="n">TimeSeriesResultsWrapper</span><span class="o">.</span><span class="n">_wrap_methods</span><span class="p">,</span> <span class="n">_methods</span><span class="p">)</span>
<span class="n">wrap</span><span class="o">.</span><span class="n">populate_wrapper</span><span class="p">(</span><span class="n">MLEResultsWrapper</span><span class="p">,</span> <span class="n">MLEResults</span><span class="p">)</span>  <span class="c1"># noqa:E305</span>


<div class="viewcode-block" id="PredictionResults">
<a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.PredictionResults.html#statsmodels.tsa.statespace.mlemodel.PredictionResults">[docs]</a>
<span class="k">class</span> <span class="nc">PredictionResults</span><span class="p">(</span><span class="n">pred</span><span class="o">.</span><span class="n">PredictionResults</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Prediction result from MLE models</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    model : MLEModel</span>
<span class="sd">        The models used to make the prediction</span>
<span class="sd">    prediction_results : kalman_filter.PredictionResults instance</span>
<span class="sd">        Results object from prediction after fitting or filtering a state space</span>
<span class="sd">        model.</span>
<span class="sd">    row_labels : iterable</span>
<span class="sd">        Row labels for the predicted data.</span>
<span class="sd">    information_set : str</span>
<span class="sd">        Name of information set</span>
<span class="sd">    signal_only : bool</span>
<span class="sd">        Whether the prediction is for the signal only</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    model : MLEModel</span>
<span class="sd">        The models used to make the prediction</span>
<span class="sd">    prediction_results : kalman_filter.PredictionResults instance</span>
<span class="sd">        Results object from prediction after fitting or filtering a state space</span>
<span class="sd">        model.</span>
<span class="sd">    information_set : str</span>
<span class="sd">        Name of information set</span>
<span class="sd">    signal_only : bool</span>
<span class="sd">        Whether the prediction is for the signal only</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">prediction_results</span><span class="p">,</span> <span class="n">row_labels</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">information_set</span><span class="o">=</span><span class="s1">&#39;predicted&#39;</span><span class="p">,</span> <span class="n">signal_only</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">model</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">k_endog</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">endog</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">prediction_results</span><span class="o">.</span><span class="n">endog</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                              <span class="n">name</span><span class="o">=</span><span class="n">model</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">endog_names</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">endog</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">prediction_results</span><span class="o">.</span><span class="n">endog</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
                                 <span class="n">columns</span><span class="o">=</span><span class="n">model</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">endog_names</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">Bunch</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">model</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span>
            <span class="n">endog</span><span class="o">=</span><span class="n">endog</span><span class="p">,</span> <span class="n">predict_dates</span><span class="o">=</span><span class="n">row_labels</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prediction_results</span> <span class="o">=</span> <span class="n">prediction_results</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">information_set</span> <span class="o">=</span> <span class="n">information_set</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">signal_only</span> <span class="o">=</span> <span class="n">signal_only</span>

        <span class="c1"># Get required values</span>
        <span class="n">k_endog</span><span class="p">,</span> <span class="n">nobs</span> <span class="o">=</span> <span class="n">prediction_results</span><span class="o">.</span><span class="n">endog</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prediction_results</span><span class="o">.</span><span class="n">results</span>
        <span class="k">if</span> <span class="n">information_set</span> <span class="o">==</span> <span class="s1">&#39;predicted&#39;</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">res</span><span class="o">.</span><span class="n">memory_no_forecast_mean</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">signal_only</span><span class="p">:</span>
                <span class="n">predicted_mean</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prediction_results</span><span class="o">.</span><span class="n">forecasts</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">predicted_mean</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prediction_results</span><span class="o">.</span><span class="n">predicted_signal</span>
        <span class="k">elif</span> <span class="n">information_set</span> <span class="o">==</span> <span class="s1">&#39;filtered&#39;</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">res</span><span class="o">.</span><span class="n">memory_no_filtered_mean</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">signal_only</span><span class="p">:</span>
                <span class="n">predicted_mean</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prediction_results</span><span class="o">.</span><span class="n">filtered_forecasts</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">predicted_mean</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prediction_results</span><span class="o">.</span><span class="n">filtered_signal</span>
        <span class="k">elif</span> <span class="n">information_set</span> <span class="o">==</span> <span class="s1">&#39;smoothed&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">signal_only</span><span class="p">:</span>
                <span class="n">predicted_mean</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prediction_results</span><span class="o">.</span><span class="n">smoothed_forecasts</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">predicted_mean</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prediction_results</span><span class="o">.</span><span class="n">smoothed_signal</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">predicted_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">k_endog</span><span class="p">,</span> <span class="n">nobs</span><span class="p">))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

        <span class="k">if</span> <span class="n">predicted_mean</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">predicted_mean</span> <span class="o">=</span> <span class="n">predicted_mean</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">predicted_mean</span> <span class="o">=</span> <span class="n">predicted_mean</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">information_set</span> <span class="o">==</span> <span class="s1">&#39;predicted&#39;</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">res</span><span class="o">.</span><span class="n">memory_no_forecast_cov</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">signal_only</span><span class="p">:</span>
                <span class="n">var_pred_mean</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prediction_results</span><span class="o">.</span><span class="n">forecasts_error_cov</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">var_pred_mean</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prediction_results</span><span class="o">.</span><span class="n">predicted_signal_cov</span>
        <span class="k">elif</span> <span class="n">information_set</span> <span class="o">==</span> <span class="s1">&#39;filtered&#39;</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">res</span><span class="o">.</span><span class="n">memory_no_filtered_mean</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">signal_only</span><span class="p">:</span>
                <span class="n">var_pred_mean</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">prediction_results</span><span class="o">.</span><span class="n">filtered_forecasts_error_cov</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">var_pred_mean</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prediction_results</span><span class="o">.</span><span class="n">filtered_signal_cov</span>
        <span class="k">elif</span> <span class="n">information_set</span> <span class="o">==</span> <span class="s1">&#39;smoothed&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">signal_only</span><span class="p">:</span>
                <span class="n">var_pred_mean</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">prediction_results</span><span class="o">.</span><span class="n">smoothed_forecasts_error_cov</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">var_pred_mean</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prediction_results</span><span class="o">.</span><span class="n">smoothed_signal_cov</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">var_pred_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">k_endog</span><span class="p">,</span> <span class="n">k_endog</span><span class="p">,</span> <span class="n">nobs</span><span class="p">))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

        <span class="k">if</span> <span class="n">var_pred_mean</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">var_pred_mean</span> <span class="o">=</span> <span class="n">var_pred_mean</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">var_pred_mean</span> <span class="o">=</span> <span class="n">var_pred_mean</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>

        <span class="c1"># Initialize</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">predicted_mean</span><span class="p">,</span> <span class="n">var_pred_mean</span><span class="p">,</span>
                         <span class="n">dist</span><span class="o">=</span><span class="s1">&#39;norm&#39;</span><span class="p">,</span>
                         <span class="n">row_labels</span><span class="o">=</span><span class="n">row_labels</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">se_mean</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Replace negative values with np.nan to avoid a RuntimeWarning</span>
        <span class="n">var_pred_mean</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">var_pred_mean</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">var_pred_mean</span><span class="p">[</span><span class="n">var_pred_mean</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">if</span> <span class="n">var_pred_mean</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">se_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">var_pred_mean</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">se_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">var_pred_mean</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">diagonal</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">se_mean</span>

<div class="viewcode-block" id="PredictionResults.conf_int">
<a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.PredictionResults.conf_int.html#statsmodels.tsa.statespace.mlemodel.PredictionResults.conf_int">[docs]</a>
    <span class="k">def</span> <span class="nf">conf_int</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;endpoint&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="c1"># TODO: this performs metadata wrapping, and that should be handled</span>
        <span class="c1">#       by attach_* methods. However, they do not currently support</span>
        <span class="c1">#       this use case.</span>
        <span class="n">_use_pandas</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_use_pandas</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_use_pandas</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">conf_int</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">conf_int</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_use_pandas</span> <span class="o">=</span> <span class="n">_use_pandas</span>

        <span class="c1"># Create a dataframe</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_row_labels</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">conf_int</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">conf_int</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">row_labels</span><span class="p">)</span>

            <span class="c1"># Attach the endog names</span>
            <span class="n">ynames</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">ynames</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">ynames</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">list</span><span class="p">:</span>
                <span class="n">ynames</span> <span class="o">=</span> <span class="p">[</span><span class="n">ynames</span><span class="p">]</span>
            <span class="n">names</span> <span class="o">=</span> <span class="p">([</span><span class="sa">f</span><span class="s1">&#39;lower </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1">&#39;</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">ynames</span><span class="p">]</span> <span class="o">+</span>
                     <span class="p">[</span><span class="sa">f</span><span class="s1">&#39;upper </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1">&#39;</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">ynames</span><span class="p">])</span>
            <span class="n">conf_int</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="n">names</span>

        <span class="k">return</span> <span class="n">conf_int</span></div>


<div class="viewcode-block" id="PredictionResults.summary_frame">
<a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.PredictionResults.summary_frame.html#statsmodels.tsa.statespace.mlemodel.PredictionResults.summary_frame">[docs]</a>
    <span class="k">def</span> <span class="nf">summary_frame</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">endog</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.05</span><span class="p">):</span>
        <span class="c1"># TODO: finish and cleanup</span>
        <span class="c1"># import pandas as pd</span>
        <span class="c1"># ci_obs = self.conf_int(alpha=alpha, obs=True) # need to split</span>
        <span class="n">ci_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">conf_int</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">))</span>
        <span class="n">_use_pandas</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_use_pandas</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_use_pandas</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">to_include</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">predicted_mean</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">yname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">ynames</span>
            <span class="n">to_include</span><span class="p">[</span><span class="s1">&#39;mean&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predicted_mean</span>
            <span class="n">to_include</span><span class="p">[</span><span class="s1">&#39;mean_se&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">se_mean</span>
            <span class="n">k_endog</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">yname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">ynames</span><span class="p">[</span><span class="n">endog</span><span class="p">]</span>
            <span class="n">to_include</span><span class="p">[</span><span class="s1">&#39;mean&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predicted_mean</span><span class="p">[:,</span> <span class="n">endog</span><span class="p">]</span>
            <span class="n">to_include</span><span class="p">[</span><span class="s1">&#39;mean_se&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">se_mean</span><span class="p">[:,</span> <span class="n">endog</span><span class="p">]</span>
            <span class="n">k_endog</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predicted_mean</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_use_pandas</span> <span class="o">=</span> <span class="n">_use_pandas</span>
        <span class="n">to_include</span><span class="p">[</span><span class="s1">&#39;mean_ci_lower&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ci_mean</span><span class="p">[:,</span> <span class="n">endog</span><span class="p">]</span>
        <span class="n">to_include</span><span class="p">[</span><span class="s1">&#39;mean_ci_upper&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ci_mean</span><span class="p">[:,</span> <span class="n">k_endog</span> <span class="o">+</span> <span class="n">endog</span><span class="p">]</span>

        <span class="c1"># pandas dict does not handle 2d_array</span>
        <span class="c1"># data = np.column_stack(list(to_include.values()))</span>
        <span class="c1"># names = ....</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">to_include</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_row_labels</span><span class="p">,</span>
                           <span class="n">columns</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">to_include</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
        <span class="n">res</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">yname</span>
        <span class="k">return</span> <span class="n">res</span></div>
</div>



<span class="k">class</span> <span class="nc">PredictionResultsWrapper</span><span class="p">(</span><span class="n">wrap</span><span class="o">.</span><span class="n">ResultsWrapper</span><span class="p">):</span>
    <span class="n">_attrs</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;predicted_mean&#39;</span><span class="p">:</span> <span class="s1">&#39;dates&#39;</span><span class="p">,</span>
        <span class="s1">&#39;se_mean&#39;</span><span class="p">:</span> <span class="s1">&#39;dates&#39;</span><span class="p">,</span>
        <span class="s1">&#39;t_values&#39;</span><span class="p">:</span> <span class="s1">&#39;dates&#39;</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="n">_wrap_attrs</span> <span class="o">=</span> <span class="n">wrap</span><span class="o">.</span><span class="n">union_dicts</span><span class="p">(</span><span class="n">_attrs</span><span class="p">)</span>

    <span class="n">_methods</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">_wrap_methods</span> <span class="o">=</span> <span class="n">wrap</span><span class="o">.</span><span class="n">union_dicts</span><span class="p">(</span><span class="n">_methods</span><span class="p">)</span>
<span class="n">wrap</span><span class="o">.</span><span class="n">populate_wrapper</span><span class="p">(</span><span class="n">PredictionResultsWrapper</span><span class="p">,</span> <span class="n">PredictionResults</span><span class="p">)</span>  <span class="c1"># noqa:E305</span>
</code></pre></div>

  <hr>
<div class="md-source-file">
  <small>
    
      Last update:
      Sep 16, 2024
    
  </small>
</div>





                
              </article>
            </div>
          
          
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  
  
  <div class="md-footer-meta md-typeset">
    
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
    <div class="md-footer-copyright__highlight">
        &#169; Copyright 2009-2023, Josef Perktold, Skipper Seabold, Jonathan Taylor, statsmodels-developers.
        
    </div>
  
    Created using
    <a href="https://www.sphinx-doc.org/" target="_blank" rel="noopener">Sphinx</a>
    7.3.7.
     and
    <a href="https://github.com/jbms/sphinx-immaterial/" target="_blank" rel="noopener">Sphinx-Immaterial</a>
  
</div>
      
        <div class="md-social">
  
    
    
    <a href="https://github.com/statsmodels/statsmodels/" target="_blank" rel="noopener" title="Source on github.com" class="md-social__link">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc.--><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg>
    </a>
  
    
    
      
      
    
    <a href="https://pypi.org/project/statsmodels/" target="_blank" rel="noopener" title="pypi.org" class="md-social__link">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc.--><path d="M439.8 200.5c-7.7-30.9-22.3-54.2-53.4-54.2h-40.1v47.4c0 36.8-31.2 67.8-66.8 67.8H172.7c-29.2 0-53.4 25-53.4 54.3v101.8c0 29 25.2 46 53.4 54.3 33.8 9.9 66.3 11.7 106.8 0 26.9-7.8 53.4-23.5 53.4-54.3v-40.7H226.2v-13.6h160.2c31.1 0 42.6-21.7 53.4-54.2 11.2-33.5 10.7-65.7 0-108.6zM286.2 404c11.1 0 20.1 9.1 20.1 20.3 0 11.3-9 20.4-20.1 20.4-11 0-20.1-9.2-20.1-20.4.1-11.3 9.1-20.3 20.1-20.3zM167.8 248.1h106.8c29.7 0 53.4-24.5 53.4-54.3V91.9c0-29-24.4-50.7-53.4-55.6-35.8-5.9-74.7-5.6-106.8.1-45.2 8-53.4 24.7-53.4 55.6v40.7h106.9v13.6h-147c-31.1 0-58.3 18.7-66.8 54.2-9.8 40.7-10.2 66.1 0 108.6 7.6 31.6 25.7 54.2 56.8 54.2H101v-48.8c0-35.3 30.5-66.4 66.8-66.4zm-6.7-142.6c-11.1 0-20.1-9.1-20.1-20.3.1-11.3 9-20.4 20.1-20.4 11 0 20.1 9.2 20.1 20.4s-9 20.3-20.1 20.3z"/></svg>
    </a>
  
    
    
      
      
    
    <a href="https://doi.org/10.5281/zenodo.593847" target="_blank" rel="noopener" title="doi.org" class="md-social__link">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc.--><path d="M0 216C0 149.7 53.7 96 120 96h8c17.7 0 32 14.3 32 32s-14.3 32-32 32h-8c-30.9 0-56 25.1-56 56v8h64c35.3 0 64 28.7 64 64v64c0 35.3-28.7 64-64 64H64c-35.3 0-64-28.7-64-64V216zm256 0c0-66.3 53.7-120 120-120h8c17.7 0 32 14.3 32 32s-14.3 32-32 32h-8c-30.9 0-56 25.1-56 56v8h64c35.3 0 64 28.7 64 64v64c0 35.3-28.7 64-64 64h-64c-35.3 0-64-28.7-64-64V216z"/></svg>
    </a>
  
</div>
      
    </div>
    
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    <script id="__config" type="application/json">{"base": "../../../..", "features": [], "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.config.lang": "en", "search.config.pipeline": "trimmer, stopWordFilter", "search.config.separator": "[\\s\\-]+", "search.placeholder": "Search", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version.title": "Select version"}, "version": {"provider": "mike", "staticVersions": null, "versionPath": "../versions-v3.json"}}</script>
    
      
        <script src="../../../../_static/sphinx_immaterial_theme.f9d9eeeb247ace16c.min.js?v=8ec58cb5"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    
  </body>
</html>