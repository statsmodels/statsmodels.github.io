

<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <meta name="lang:clipboard.copy" content="Copy to clipboard">
  <meta name="lang:clipboard.copied" content="Copied to clipboard">
  <meta name="lang:search.language" content="en">
  <meta name="lang:search.pipeline.stopwords" content="True">
  <meta name="lang:search.pipeline.trimmer" content="True">
  <meta name="lang:search.result.none" content="No matching documents">
  <meta name="lang:search.result.one" content="1 matching document">
  <meta name="lang:search.result.other" content="# matching documents">
  <meta name="lang:search.tokenizer" content="[\s\-]+">

  
    <link href="https://fonts.gstatic.com/" rel="preconnect" crossorigin>
    <link href="https://fonts.googleapis.com/css?family=Roboto+Mono:400,500,700|Roboto:300,400,400i,700&display=fallback" rel="stylesheet">

    <style>
      body,
      input {
        font-family: "Roboto", "Helvetica Neue", Helvetica, Arial, sans-serif
      }

      code,
      kbd,
      pre {
        font-family: "Roboto Mono", "Courier New", Courier, monospace
      }
    </style>
  

  <link rel="stylesheet" href="../../../../_static/stylesheets/application.css"/>
  <link rel="stylesheet" href="../../../../_static/stylesheets/application-palette.css"/>
  <link rel="stylesheet" href="../../../../_static/stylesheets/application-fixes.css"/>
  
  <link rel="stylesheet" href="../../../../_static/fonts/material-icons.css"/>
  
  <meta name="theme-color" content="#3f51b5">
  <script src="../../../../_static/javascripts/modernizr.js"></script>
  
  
  
    <title>statsmodels.tsa.statespace.kalman_filter &#8212; statsmodels</title>
  <link rel="icon" type="image/png" sizes="32x32" href="../../../../_static/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="../../../../_static/icons/favicon-16x16.png">
  <link rel="manifest" href="../../../../_static/icons/site.webmanifest">
  <link rel="mask-icon" href="../../../../_static/icons/safari-pinned-tab.svg" color="#919191">
  <meta name="msapplication-TileColor" content="#2b5797">
  <meta name="msapplication-config" content="../../../../_static/icons/browserconfig.xml">
  <link rel="stylesheet" href="../../../../_static/stylesheets/examples.css">
  <link rel="stylesheet" href="../../../../_static/stylesheets/deprecation.css">
    <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/material.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/graphviz.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/plot_directive.css" />
    <script data-url_root="../../../../" id="documentation_options" src="../../../../_static/documentation_options.js"></script>
    <script src="../../../../_static/jquery.js"></script>
    <script src="../../../../_static/underscore.js"></script>
    <script src="../../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../../../../_static/doctools.js"></script>
    <script src="../../../../_static/sphinx_highlight.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <link rel="shortcut icon" href="../../../../_static/favicon.ico"/>
    <link rel="author" title="About these documents" href="../../../../about.html" />
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
  
   

  </head>
  <body dir=ltr
        data-md-color-primary=indigo data-md-color-accent=blue>
  
  <svg class="md-svg">
    <defs data-children-count="0">
      
      <svg xmlns="http://www.w3.org/2000/svg" width="416" height="448" viewBox="0 0 416 448" id="__github"><path fill="currentColor" d="M160 304q0 10-3.125 20.5t-10.75 19T128 352t-18.125-8.5-10.75-19T96 304t3.125-20.5 10.75-19T128 256t18.125 8.5 10.75 19T160 304zm160 0q0 10-3.125 20.5t-10.75 19T288 352t-18.125-8.5-10.75-19T256 304t3.125-20.5 10.75-19T288 256t18.125 8.5 10.75 19T320 304zm40 0q0-30-17.25-51T296 232q-10.25 0-48.75 5.25Q229.5 240 208 240t-39.25-2.75Q130.75 232 120 232q-29.5 0-46.75 21T56 304q0 22 8 38.375t20.25 25.75 30.5 15 35 7.375 37.25 1.75h42q20.5 0 37.25-1.75t35-7.375 30.5-15 20.25-25.75T360 304zm56-44q0 51.75-15.25 82.75-9.5 19.25-26.375 33.25t-35.25 21.5-42.5 11.875-42.875 5.5T212 416q-19.5 0-35.5-.75t-36.875-3.125-38.125-7.5-34.25-12.875T37 371.5t-21.5-28.75Q0 312 0 260q0-59.25 34-99-6.75-20.5-6.75-42.5 0-29 12.75-54.5 27 0 47.5 9.875t47.25 30.875Q171.5 96 212 96q37 0 70 8 26.25-20.5 46.75-30.25T376 64q12.75 25.5 12.75 54.5 0 21.75-6.75 42 34 40 34 99.5z"/></svg>
      
    </defs>
  </svg>
  
  <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer">
  <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search">
  <label class="md-overlay" data-md-component="overlay" for="__drawer"></label>
  <a href="#_modules/statsmodels/tsa/statespace/kalman_filter" tabindex="1" class="md-skip"> Skip to content </a>
  <header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid">
    <div class="md-flex navheader">
      <div class="md-flex__cell md-flex__cell--shrink">
        <a href="../../../../index.html" title="statsmodels"
           class="md-header-nav__button md-logo">
          
              <img src="../../../../_static/statsmodels-logo-v2-bw.svg" height="26"
                   alt="statsmodels logo">
          
        </a>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        <label class="md-icon md-icon--menu md-header-nav__button" for="__drawer"></label>
      </div>
      <div class="md-flex__cell md-flex__cell--stretch">
        <div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
          <span class="md-header-nav__topic">statsmodels 0.13.5</span>
          <span class="md-header-nav__topic"> statsmodels.tsa.statespace.kalman_filter </span>
        </div>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        <label class="md-icon md-icon--search md-header-nav__button" for="__search"></label>
        
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" action="../../../../search.html" method="get" name="search">
      <input type="text" class="md-search__input" name="q" placeholder="Search"
             autocapitalize="off" autocomplete="off" spellcheck="false"
             data-md-component="query" data-md-state="active">
      <label class="md-icon md-search__icon" for="__search"></label>
      <button type="reset" class="md-icon md-search__icon" data-md-component="reset" tabindex="-1">
        &#xE5CD;
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="result">
          <div class="md-search-result__meta">
            Type to start searching
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>

      </div>
      
        <div class="md-flex__cell md-flex__cell--shrink">
          <div class="md-header-nav__source">
            <a href="https://github.com/statsmodels/statsmodels" title="Go to repository" class="md-source" data-md-source="github">

    <div class="md-source__icon">
      <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24" width="28" height="28">
        <use xlink:href="#__github" width="24" height="24"></use>
      </svg>
    </div>
  
  <div class="md-source__repository">
    statsmodels
  </div>
</a>
          </div>
        </div>
      
      
  
  <script src="../../../../_static/javascripts/version_dropdown.js"></script>
  <script>
    var json_loc = "../../../../../versions-v2.json",
        target_loc = "../../../../../",
        text = "Versions";
    $( document ).ready( add_version_dropdown(json_loc, target_loc, text));
  </script>
  

    </div>
  </nav>
</header>

  
  <div class="md-container">
    
    
    
  <nav class="md-tabs" data-md-component="tabs">
    <div class="md-tabs__inner md-grid">
      <ul class="md-tabs__list">
          <li class="md-tabs__item"><a href="../../../index.html" class="md-tabs__link">Module code</a></li>
      </ul>
    </div>
  </nav>
    <main class="md-main">
      <div class="md-main__inner md-grid" data-md-component="container">
        
          <div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
            <div class="md-sidebar__scrollwrap">
              <div class="md-sidebar__inner">
                <nav class="md-nav md-nav--primary" data-md-level="0">
  <label class="md-nav__title md-nav__title--site" for="__drawer">
    <a href="../../../../index.html" title="statsmodels" class="md-nav__button md-logo">
      
        <img src="../../../../_static/statsmodels-logo-v2-bw.svg" alt=" logo" width="48" height="48">
      
    </a>
    <a href="../../../../index.html"
       title="statsmodels">statsmodels 0.13.5</a>
  </label>
    <div class="md-nav__source">
      <a href="https://github.com/statsmodels/statsmodels" title="Go to repository" class="md-source" data-md-source="github">

    <div class="md-source__icon">
      <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24" width="28" height="28">
        <use xlink:href="#__github" width="24" height="24"></use>
      </svg>
    </div>
  
  <div class="md-source__repository">
    statsmodels
  </div>
</a>
    </div>
  
  

  
  <ul class="md-nav__list">
    <li class="md-nav__item">
    
    
      <a href="../../../../install.html" class="md-nav__link">Installing statsmodels</a>
      
    
    </li>
    <li class="md-nav__item">
    
    
      <a href="../../../../gettingstarted.html" class="md-nav__link">Getting started</a>
      
    
    </li>
    <li class="md-nav__item">
    
    
      <a href="../../../../user-guide.html" class="md-nav__link">User Guide</a>
      
    
    </li>
    <li class="md-nav__item">
    
    
      <a href="../../../../examples/index.html" class="md-nav__link">Examples</a>
      
    
    </li>
    <li class="md-nav__item">
    
    
      <a href="../../../../api.html" class="md-nav__link">API Reference</a>
      
    
    </li>
    <li class="md-nav__item">
    
    
      <a href="../../../../about.html" class="md-nav__link">About statsmodels</a>
      
    
    </li>
    <li class="md-nav__item">
    
    
      <a href="../../../../dev/index.html" class="md-nav__link">Developer Page</a>
      
    
    </li>
    <li class="md-nav__item">
    
    
      <a href="../../../../release/index.html" class="md-nav__link">Release Notes</a>
      
    
    </li>
  </ul>
  

</nav>
              </div>
            </div>
          </div>
          <div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
            <div class="md-sidebar__scrollwrap">
              <div class="md-sidebar__inner">
                
<nav class="md-nav md-nav--secondary">
  <ul class="md-nav__list" data-md-scrollfix="">
    

<li id="searchbox" class="md-nav__item"></li>

  </ul>
</nav>
              </div>
            </div>
          </div>
        
        <div class="md-content">
          <article class="md-content__inner md-typeset" role="main">
            
  <h1 id="modules-statsmodels-tsa-statespace-kalman-filter--page-root">Source code for statsmodels.tsa.statespace.kalman_filter</h1><div class="highlight"><pre>
<span></span><span class="sd">"""</span>
<span class="sd">State Space Representation and Kalman Filter</span>

<span class="sd">Author: Chad Fulton</span>
<span class="sd">License: Simplified-BSD</span>
<span class="sd">"""</span>

<span class="kn">import</span> <span class="nn">contextlib</span>
<span class="kn">from</span> <span class="nn">warnings</span> <span class="kn">import</span> <span class="n">warn</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">.representation</span> <span class="kn">import</span> <span class="n">OptionWrapper</span><span class="p">,</span> <span class="n">Representation</span><span class="p">,</span> <span class="n">FrozenRepresentation</span>
<span class="kn">from</span> <span class="nn">.tools</span> <span class="kn">import</span> <span class="n">reorder_missing_matrix</span><span class="p">,</span> <span class="n">reorder_missing_vector</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">tools</span>
<span class="kn">from</span> <span class="nn">statsmodels.tools.sm_exceptions</span> <span class="kn">import</span> <span class="n">ValueWarning</span>

<span class="c1"># Define constants</span>
<span class="n">FILTER_CONVENTIONAL</span> <span class="o">=</span> <span class="mh">0x01</span>     <span class="c1"># Durbin and Koopman (2012), Chapter 4</span>
<span class="n">FILTER_EXACT_INITIAL</span> <span class="o">=</span> <span class="mh">0x02</span>    <span class="c1"># ibid., Chapter 5.6</span>
<span class="n">FILTER_AUGMENTED</span> <span class="o">=</span> <span class="mh">0x04</span>        <span class="c1"># ibid., Chapter 5.7</span>
<span class="n">FILTER_SQUARE_ROOT</span> <span class="o">=</span> <span class="mh">0x08</span>      <span class="c1"># ibid., Chapter 6.3</span>
<span class="n">FILTER_UNIVARIATE</span> <span class="o">=</span> <span class="mh">0x10</span>       <span class="c1"># ibid., Chapter 6.4</span>
<span class="n">FILTER_COLLAPSED</span> <span class="o">=</span> <span class="mh">0x20</span>        <span class="c1"># ibid., Chapter 6.5</span>
<span class="n">FILTER_EXTENDED</span> <span class="o">=</span> <span class="mh">0x40</span>         <span class="c1"># ibid., Chapter 10.2</span>
<span class="n">FILTER_UNSCENTED</span> <span class="o">=</span> <span class="mh">0x80</span>        <span class="c1"># ibid., Chapter 10.3</span>
<span class="n">FILTER_CONCENTRATED</span> <span class="o">=</span> <span class="mh">0x100</span>    <span class="c1"># Harvey (1989), Chapter 3.4</span>
<span class="n">FILTER_CHANDRASEKHAR</span> <span class="o">=</span> <span class="mh">0x200</span>   <span class="c1"># Herbst (2015)</span>

<span class="n">INVERT_UNIVARIATE</span> <span class="o">=</span> <span class="mh">0x01</span>
<span class="n">SOLVE_LU</span> <span class="o">=</span> <span class="mh">0x02</span>
<span class="n">INVERT_LU</span> <span class="o">=</span> <span class="mh">0x04</span>
<span class="n">SOLVE_CHOLESKY</span> <span class="o">=</span> <span class="mh">0x08</span>
<span class="n">INVERT_CHOLESKY</span> <span class="o">=</span> <span class="mh">0x10</span>

<span class="n">STABILITY_FORCE_SYMMETRY</span> <span class="o">=</span> <span class="mh">0x01</span>

<span class="n">MEMORY_STORE_ALL</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">MEMORY_NO_FORECAST_MEAN</span> <span class="o">=</span> <span class="mh">0x01</span>
<span class="n">MEMORY_NO_FORECAST_COV</span> <span class="o">=</span> <span class="mh">0x02</span>
<span class="n">MEMORY_NO_FORECAST</span> <span class="o">=</span> <span class="n">MEMORY_NO_FORECAST_MEAN</span> <span class="o">|</span> <span class="n">MEMORY_NO_FORECAST_COV</span>
<span class="n">MEMORY_NO_PREDICTED_MEAN</span> <span class="o">=</span> <span class="mh">0x04</span>
<span class="n">MEMORY_NO_PREDICTED_COV</span> <span class="o">=</span> <span class="mh">0x08</span>
<span class="n">MEMORY_NO_PREDICTED</span> <span class="o">=</span> <span class="n">MEMORY_NO_PREDICTED_MEAN</span> <span class="o">|</span> <span class="n">MEMORY_NO_PREDICTED_COV</span>
<span class="n">MEMORY_NO_FILTERED_MEAN</span> <span class="o">=</span> <span class="mh">0x10</span>
<span class="n">MEMORY_NO_FILTERED_COV</span> <span class="o">=</span> <span class="mh">0x20</span>
<span class="n">MEMORY_NO_FILTERED</span> <span class="o">=</span> <span class="n">MEMORY_NO_FILTERED_MEAN</span> <span class="o">|</span> <span class="n">MEMORY_NO_FILTERED_COV</span>
<span class="n">MEMORY_NO_LIKELIHOOD</span> <span class="o">=</span> <span class="mh">0x40</span>
<span class="n">MEMORY_NO_GAIN</span> <span class="o">=</span> <span class="mh">0x80</span>
<span class="n">MEMORY_NO_SMOOTHING</span> <span class="o">=</span> <span class="mh">0x100</span>
<span class="n">MEMORY_NO_STD_FORECAST</span> <span class="o">=</span> <span class="mh">0x200</span>
<span class="n">MEMORY_CONSERVE</span> <span class="o">=</span> <span class="p">(</span>
    <span class="n">MEMORY_NO_FORECAST_COV</span> <span class="o">|</span> <span class="n">MEMORY_NO_PREDICTED</span> <span class="o">|</span> <span class="n">MEMORY_NO_FILTERED</span> <span class="o">|</span>
    <span class="n">MEMORY_NO_LIKELIHOOD</span> <span class="o">|</span> <span class="n">MEMORY_NO_GAIN</span> <span class="o">|</span> <span class="n">MEMORY_NO_SMOOTHING</span>
<span class="p">)</span>

<span class="n">TIMING_INIT_PREDICTED</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">TIMING_INIT_FILTERED</span> <span class="o">=</span> <span class="mi">1</span>


<div class="viewcode-block" id="KalmanFilter"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.kalman_filter.KalmanFilter.html#statsmodels.tsa.statespace.simulation_smoother.KalmanFilter">[docs]</a><span class="k">class</span> <span class="nc">KalmanFilter</span><span class="p">(</span><span class="n">Representation</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">"""</span>
<span class="sd">    State space representation of a time series process, with Kalman filter</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    k_endog : {array_like, int}</span>
<span class="sd">        The observed time-series process :math:`y` if array like or the</span>
<span class="sd">        number of variables in the process if an integer.</span>
<span class="sd">    k_states : int</span>
<span class="sd">        The dimension of the unobserved state process.</span>
<span class="sd">    k_posdef : int, optional</span>
<span class="sd">        The dimension of a guaranteed positive definite covariance matrix</span>
<span class="sd">        describing the shocks in the transition equation. Must be less than</span>
<span class="sd">        or equal to `k_states`. Default is `k_states`.</span>
<span class="sd">    loglikelihood_burn : int, optional</span>
<span class="sd">        The number of initial periods during which the loglikelihood is not</span>
<span class="sd">        recorded. Default is 0.</span>
<span class="sd">    tolerance : float, optional</span>
<span class="sd">        The tolerance at which the Kalman filter determines convergence to</span>
<span class="sd">        steady-state. Default is 1e-19.</span>
<span class="sd">    results_class : class, optional</span>
<span class="sd">        Default results class to use to save filtering output. Default is</span>
<span class="sd">        `FilterResults`. If specified, class must extend from `FilterResults`.</span>
<span class="sd">    **kwargs</span>
<span class="sd">        Keyword arguments may be used to provide values for the filter,</span>
<span class="sd">        inversion, and stability methods. See `set_filter_method`,</span>
<span class="sd">        `set_inversion_method`, and `set_stability_method`.</span>
<span class="sd">        Keyword arguments may be used to provide default values for state space</span>
<span class="sd">        matrices. See `Representation` for more details.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    FilterResults</span>
<span class="sd">    statsmodels.tsa.statespace.representation.Representation</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    There are several types of options available for controlling the Kalman</span>
<span class="sd">    filter operation. All options are internally held as bitmasks, but can be</span>
<span class="sd">    manipulated by setting class attributes, which act like boolean flags. For</span>
<span class="sd">    more information, see the `set_*` class method documentation. The options</span>
<span class="sd">    are:</span>

<span class="sd">    filter_method</span>
<span class="sd">        The filtering method controls aspects of which</span>
<span class="sd">        Kalman filtering approach will be used.</span>
<span class="sd">    inversion_method</span>
<span class="sd">        The Kalman filter may contain one matrix inversion: that of the</span>
<span class="sd">        forecast error covariance matrix. The inversion method controls how and</span>
<span class="sd">        if that inverse is performed.</span>
<span class="sd">    stability_method</span>
<span class="sd">        The Kalman filter is a recursive algorithm that may in some cases</span>
<span class="sd">        suffer issues with numerical stability. The stability method controls</span>
<span class="sd">        what, if any, measures are taken to promote stability.</span>
<span class="sd">    conserve_memory</span>
<span class="sd">        By default, the Kalman filter computes a number of intermediate</span>
<span class="sd">        matrices at each iteration. The memory conservation options control</span>
<span class="sd">        which of those matrices are stored.</span>
<span class="sd">    filter_timing</span>
<span class="sd">        By default, the Kalman filter follows Durbin and Koopman, 2012, in</span>
<span class="sd">        initializing the filter with predicted values. Kim and Nelson, 1999,</span>
<span class="sd">        instead initialize the filter with filtered values, which is</span>
<span class="sd">        essentially just a different timing convention.</span>

<span class="sd">    The `filter_method` and `inversion_method` options intentionally allow</span>
<span class="sd">    the possibility that multiple methods will be indicated. In the case that</span>
<span class="sd">    multiple methods are selected, the underlying Kalman filter will attempt to</span>
<span class="sd">    select the optional method given the input data.</span>

<span class="sd">    For example, it may be that INVERT_UNIVARIATE and SOLVE_CHOLESKY are</span>
<span class="sd">    indicated (this is in fact the default case). In this case, if the</span>
<span class="sd">    endogenous vector is 1-dimensional (`k_endog` = 1), then INVERT_UNIVARIATE</span>
<span class="sd">    is used and inversion reduces to simple division, and if it has a larger</span>
<span class="sd">    dimension, the Cholesky decomposition along with linear solving (rather</span>
<span class="sd">    than explicit matrix inversion) is used. If only SOLVE_CHOLESKY had been</span>
<span class="sd">    set, then the Cholesky decomposition method would *always* be used, even in</span>
<span class="sd">    the case of 1-dimensional data.</span>
<span class="sd">    """</span>

    <span class="n">filter_methods</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s1">'filter_conventional'</span><span class="p">,</span> <span class="s1">'filter_exact_initial'</span><span class="p">,</span> <span class="s1">'filter_augmented'</span><span class="p">,</span>
        <span class="s1">'filter_square_root'</span><span class="p">,</span> <span class="s1">'filter_univariate'</span><span class="p">,</span> <span class="s1">'filter_collapsed'</span><span class="p">,</span>
        <span class="s1">'filter_extended'</span><span class="p">,</span> <span class="s1">'filter_unscented'</span><span class="p">,</span> <span class="s1">'filter_concentrated'</span><span class="p">,</span>
        <span class="s1">'filter_chandrasekhar'</span>
    <span class="p">]</span>

    <span class="n">filter_conventional</span> <span class="o">=</span> <span class="n">OptionWrapper</span><span class="p">(</span><span class="s1">'filter_method'</span><span class="p">,</span> <span class="n">FILTER_CONVENTIONAL</span><span class="p">)</span>
    <span class="sd">"""</span>
<span class="sd">    (bool) Flag for conventional Kalman filtering.</span>
<span class="sd">    """</span>
    <span class="n">filter_exact_initial</span> <span class="o">=</span> <span class="n">OptionWrapper</span><span class="p">(</span><span class="s1">'filter_method'</span><span class="p">,</span> <span class="n">FILTER_EXACT_INITIAL</span><span class="p">)</span>
    <span class="sd">"""</span>
<span class="sd">    (bool) Flag for exact initial Kalman filtering. Not implemented.</span>
<span class="sd">    """</span>
    <span class="n">filter_augmented</span> <span class="o">=</span> <span class="n">OptionWrapper</span><span class="p">(</span><span class="s1">'filter_method'</span><span class="p">,</span> <span class="n">FILTER_AUGMENTED</span><span class="p">)</span>
    <span class="sd">"""</span>
<span class="sd">    (bool) Flag for augmented Kalman filtering. Not implemented.</span>
<span class="sd">    """</span>
    <span class="n">filter_square_root</span> <span class="o">=</span> <span class="n">OptionWrapper</span><span class="p">(</span><span class="s1">'filter_method'</span><span class="p">,</span> <span class="n">FILTER_SQUARE_ROOT</span><span class="p">)</span>
    <span class="sd">"""</span>
<span class="sd">    (bool) Flag for square-root Kalman filtering. Not implemented.</span>
<span class="sd">    """</span>
    <span class="n">filter_univariate</span> <span class="o">=</span> <span class="n">OptionWrapper</span><span class="p">(</span><span class="s1">'filter_method'</span><span class="p">,</span> <span class="n">FILTER_UNIVARIATE</span><span class="p">)</span>
    <span class="sd">"""</span>
<span class="sd">    (bool) Flag for univariate filtering of multivariate observation vector.</span>
<span class="sd">    """</span>
    <span class="n">filter_collapsed</span> <span class="o">=</span> <span class="n">OptionWrapper</span><span class="p">(</span><span class="s1">'filter_method'</span><span class="p">,</span> <span class="n">FILTER_COLLAPSED</span><span class="p">)</span>
    <span class="sd">"""</span>
<span class="sd">    (bool) Flag for Kalman filtering with collapsed observation vector.</span>
<span class="sd">    """</span>
    <span class="n">filter_extended</span> <span class="o">=</span> <span class="n">OptionWrapper</span><span class="p">(</span><span class="s1">'filter_method'</span><span class="p">,</span> <span class="n">FILTER_EXTENDED</span><span class="p">)</span>
    <span class="sd">"""</span>
<span class="sd">    (bool) Flag for extended Kalman filtering. Not implemented.</span>
<span class="sd">    """</span>
    <span class="n">filter_unscented</span> <span class="o">=</span> <span class="n">OptionWrapper</span><span class="p">(</span><span class="s1">'filter_method'</span><span class="p">,</span> <span class="n">FILTER_UNSCENTED</span><span class="p">)</span>
    <span class="sd">"""</span>
<span class="sd">    (bool) Flag for unscented Kalman filtering. Not implemented.</span>
<span class="sd">    """</span>
    <span class="n">filter_concentrated</span> <span class="o">=</span> <span class="n">OptionWrapper</span><span class="p">(</span><span class="s1">'filter_method'</span><span class="p">,</span> <span class="n">FILTER_CONCENTRATED</span><span class="p">)</span>
    <span class="sd">"""</span>
<span class="sd">    (bool) Flag for Kalman filtering with concentrated log-likelihood.</span>
<span class="sd">    """</span>
    <span class="n">filter_chandrasekhar</span> <span class="o">=</span> <span class="n">OptionWrapper</span><span class="p">(</span><span class="s1">'filter_method'</span><span class="p">,</span> <span class="n">FILTER_CHANDRASEKHAR</span><span class="p">)</span>
    <span class="sd">"""</span>
<span class="sd">    (bool) Flag for filtering with Chandrasekhar recursions.</span>
<span class="sd">    """</span>

    <span class="n">inversion_methods</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s1">'invert_univariate'</span><span class="p">,</span> <span class="s1">'solve_lu'</span><span class="p">,</span> <span class="s1">'invert_lu'</span><span class="p">,</span> <span class="s1">'solve_cholesky'</span><span class="p">,</span>
        <span class="s1">'invert_cholesky'</span>
    <span class="p">]</span>

    <span class="n">invert_univariate</span> <span class="o">=</span> <span class="n">OptionWrapper</span><span class="p">(</span><span class="s1">'inversion_method'</span><span class="p">,</span> <span class="n">INVERT_UNIVARIATE</span><span class="p">)</span>
    <span class="sd">"""</span>
<span class="sd">    (bool) Flag for univariate inversion method (recommended).</span>
<span class="sd">    """</span>
    <span class="n">solve_lu</span> <span class="o">=</span> <span class="n">OptionWrapper</span><span class="p">(</span><span class="s1">'inversion_method'</span><span class="p">,</span> <span class="n">SOLVE_LU</span><span class="p">)</span>
    <span class="sd">"""</span>
<span class="sd">    (bool) Flag for LU and linear solver inversion method.</span>
<span class="sd">    """</span>
    <span class="n">invert_lu</span> <span class="o">=</span> <span class="n">OptionWrapper</span><span class="p">(</span><span class="s1">'inversion_method'</span><span class="p">,</span> <span class="n">INVERT_LU</span><span class="p">)</span>
    <span class="sd">"""</span>
<span class="sd">    (bool) Flag for LU inversion method.</span>
<span class="sd">    """</span>
    <span class="n">solve_cholesky</span> <span class="o">=</span> <span class="n">OptionWrapper</span><span class="p">(</span><span class="s1">'inversion_method'</span><span class="p">,</span> <span class="n">SOLVE_CHOLESKY</span><span class="p">)</span>
    <span class="sd">"""</span>
<span class="sd">    (bool) Flag for Cholesky and linear solver inversion method (recommended).</span>
<span class="sd">    """</span>
    <span class="n">invert_cholesky</span> <span class="o">=</span> <span class="n">OptionWrapper</span><span class="p">(</span><span class="s1">'inversion_method'</span><span class="p">,</span> <span class="n">INVERT_CHOLESKY</span><span class="p">)</span>
    <span class="sd">"""</span>
<span class="sd">    (bool) Flag for Cholesky inversion method.</span>
<span class="sd">    """</span>

    <span class="n">stability_methods</span> <span class="o">=</span> <span class="p">[</span><span class="s1">'stability_force_symmetry'</span><span class="p">]</span>

    <span class="n">stability_force_symmetry</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">OptionWrapper</span><span class="p">(</span><span class="s1">'stability_method'</span><span class="p">,</span> <span class="n">STABILITY_FORCE_SYMMETRY</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="sd">"""</span>
<span class="sd">    (bool) Flag for enforcing covariance matrix symmetry</span>
<span class="sd">    """</span>

    <span class="n">memory_options</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s1">'memory_store_all'</span><span class="p">,</span> <span class="s1">'memory_no_forecast_mean'</span><span class="p">,</span>
        <span class="s1">'memory_no_forecast_cov'</span><span class="p">,</span> <span class="s1">'memory_no_forecast'</span><span class="p">,</span>
        <span class="s1">'memory_no_predicted_mean'</span><span class="p">,</span> <span class="s1">'memory_no_predicted_cov'</span><span class="p">,</span>
        <span class="s1">'memory_no_predicted'</span><span class="p">,</span> <span class="s1">'memory_no_filtered_mean'</span><span class="p">,</span>
        <span class="s1">'memory_no_filtered_cov'</span><span class="p">,</span> <span class="s1">'memory_no_filtered'</span><span class="p">,</span>
        <span class="s1">'memory_no_likelihood'</span><span class="p">,</span> <span class="s1">'memory_no_gain'</span><span class="p">,</span>
        <span class="s1">'memory_no_smoothing'</span><span class="p">,</span> <span class="s1">'memory_no_std_forecast'</span><span class="p">,</span> <span class="s1">'memory_conserve'</span>
    <span class="p">]</span>

    <span class="n">memory_store_all</span> <span class="o">=</span> <span class="n">OptionWrapper</span><span class="p">(</span><span class="s1">'conserve_memory'</span><span class="p">,</span> <span class="n">MEMORY_STORE_ALL</span><span class="p">)</span>
    <span class="sd">"""</span>
<span class="sd">    (bool) Flag for storing all intermediate results in memory (default).</span>
<span class="sd">    """</span>
    <span class="n">memory_no_forecast_mean</span> <span class="o">=</span> <span class="n">OptionWrapper</span><span class="p">(</span>
        <span class="s1">'conserve_memory'</span><span class="p">,</span> <span class="n">MEMORY_NO_FORECAST_MEAN</span><span class="p">)</span>
    <span class="sd">"""</span>
<span class="sd">    (bool) Flag to prevent storing forecasts and forecast errors.</span>
<span class="sd">    """</span>
    <span class="n">memory_no_forecast_cov</span> <span class="o">=</span> <span class="n">OptionWrapper</span><span class="p">(</span>
        <span class="s1">'conserve_memory'</span><span class="p">,</span> <span class="n">MEMORY_NO_FORECAST_COV</span><span class="p">)</span>
    <span class="sd">"""</span>
<span class="sd">    (bool) Flag to prevent storing forecast error covariance matrices.</span>
<span class="sd">    """</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">memory_no_forecast</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        (bool) Flag to prevent storing all forecast-related output.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">memory_no_forecast_mean</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">memory_no_forecast_cov</span>

    <span class="nd">@memory_no_forecast</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">memory_no_forecast</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">bool</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">memory_no_forecast_mean</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">memory_no_forecast_cov</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">memory_no_forecast_mean</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">memory_no_forecast_cov</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="n">memory_no_predicted_mean</span> <span class="o">=</span> <span class="n">OptionWrapper</span><span class="p">(</span>
        <span class="s1">'conserve_memory'</span><span class="p">,</span> <span class="n">MEMORY_NO_PREDICTED_MEAN</span><span class="p">)</span>
    <span class="sd">"""</span>
<span class="sd">    (bool) Flag to prevent storing predicted states.</span>
<span class="sd">    """</span>
    <span class="n">memory_no_predicted_cov</span> <span class="o">=</span> <span class="n">OptionWrapper</span><span class="p">(</span>
        <span class="s1">'conserve_memory'</span><span class="p">,</span> <span class="n">MEMORY_NO_PREDICTED_COV</span><span class="p">)</span>
    <span class="sd">"""</span>
<span class="sd">    (bool) Flag to prevent storing predicted state covariance matrices.</span>
<span class="sd">    """</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">memory_no_predicted</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        (bool) Flag to prevent storing predicted state and covariance matrices.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">memory_no_predicted_mean</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">memory_no_predicted_cov</span>

    <span class="nd">@memory_no_predicted</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">memory_no_predicted</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">bool</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">memory_no_predicted_mean</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">memory_no_predicted_cov</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">memory_no_predicted_mean</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">memory_no_predicted_cov</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="n">memory_no_filtered_mean</span> <span class="o">=</span> <span class="n">OptionWrapper</span><span class="p">(</span>
        <span class="s1">'conserve_memory'</span><span class="p">,</span> <span class="n">MEMORY_NO_FILTERED_MEAN</span><span class="p">)</span>
    <span class="sd">"""</span>
<span class="sd">    (bool) Flag to prevent storing filtered states.</span>
<span class="sd">    """</span>
    <span class="n">memory_no_filtered_cov</span> <span class="o">=</span> <span class="n">OptionWrapper</span><span class="p">(</span>
        <span class="s1">'conserve_memory'</span><span class="p">,</span> <span class="n">MEMORY_NO_FILTERED_COV</span><span class="p">)</span>
    <span class="sd">"""</span>
<span class="sd">    (bool) Flag to prevent storing filtered state covariance matrices.</span>
<span class="sd">    """</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">memory_no_filtered</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        (bool) Flag to prevent storing filtered state and covariance matrices.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">memory_no_filtered_mean</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">memory_no_filtered_cov</span>

    <span class="nd">@memory_no_filtered</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">memory_no_filtered</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">bool</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">memory_no_filtered_mean</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">memory_no_filtered_cov</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">memory_no_filtered_mean</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">memory_no_filtered_cov</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="n">memory_no_likelihood</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">OptionWrapper</span><span class="p">(</span><span class="s1">'conserve_memory'</span><span class="p">,</span> <span class="n">MEMORY_NO_LIKELIHOOD</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="sd">"""</span>
<span class="sd">    (bool) Flag to prevent storing likelihood values for each observation.</span>
<span class="sd">    """</span>
    <span class="n">memory_no_gain</span> <span class="o">=</span> <span class="n">OptionWrapper</span><span class="p">(</span><span class="s1">'conserve_memory'</span><span class="p">,</span> <span class="n">MEMORY_NO_GAIN</span><span class="p">)</span>
    <span class="sd">"""</span>
<span class="sd">    (bool) Flag to prevent storing the Kalman gain matrices.</span>
<span class="sd">    """</span>
    <span class="n">memory_no_smoothing</span> <span class="o">=</span> <span class="n">OptionWrapper</span><span class="p">(</span><span class="s1">'conserve_memory'</span><span class="p">,</span> <span class="n">MEMORY_NO_SMOOTHING</span><span class="p">)</span>
    <span class="sd">"""</span>
<span class="sd">    (bool) Flag to prevent storing likelihood values for each observation.</span>
<span class="sd">    """</span>
    <span class="n">memory_no_std_forecast</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">OptionWrapper</span><span class="p">(</span><span class="s1">'conserve_memory'</span><span class="p">,</span> <span class="n">MEMORY_NO_STD_FORECAST</span><span class="p">))</span>
    <span class="sd">"""</span>
<span class="sd">    (bool) Flag to prevent storing standardized forecast errors.</span>
<span class="sd">    """</span>
    <span class="n">memory_conserve</span> <span class="o">=</span> <span class="n">OptionWrapper</span><span class="p">(</span><span class="s1">'conserve_memory'</span><span class="p">,</span> <span class="n">MEMORY_CONSERVE</span><span class="p">)</span>
    <span class="sd">"""</span>
<span class="sd">    (bool) Flag to conserve the maximum amount of memory.</span>
<span class="sd">    """</span>

    <span class="n">timing_options</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s1">'timing_init_predicted'</span><span class="p">,</span> <span class="s1">'timing_init_filtered'</span>
    <span class="p">]</span>
    <span class="n">timing_init_predicted</span> <span class="o">=</span> <span class="n">OptionWrapper</span><span class="p">(</span><span class="s1">'filter_timing'</span><span class="p">,</span>
                                          <span class="n">TIMING_INIT_PREDICTED</span><span class="p">)</span>
    <span class="sd">"""</span>
<span class="sd">    (bool) Flag for the default timing convention (Durbin and Koopman, 2012).</span>
<span class="sd">    """</span>
    <span class="n">timing_init_filtered</span> <span class="o">=</span> <span class="n">OptionWrapper</span><span class="p">(</span><span class="s1">'filter_timing'</span><span class="p">,</span> <span class="n">TIMING_INIT_FILTERED</span><span class="p">)</span>
    <span class="sd">"""</span>
<span class="sd">    (bool) Flag for the alternate timing convention (Kim and Nelson, 2012).</span>
<span class="sd">    """</span>

    <span class="c1"># Default filter options</span>
    <span class="n">filter_method</span> <span class="o">=</span> <span class="n">FILTER_CONVENTIONAL</span>
    <span class="sd">"""</span>
<span class="sd">    (int) Filtering method bitmask.</span>
<span class="sd">    """</span>
    <span class="n">inversion_method</span> <span class="o">=</span> <span class="n">INVERT_UNIVARIATE</span> <span class="o">|</span> <span class="n">SOLVE_CHOLESKY</span>
    <span class="sd">"""</span>
<span class="sd">    (int) Inversion method bitmask.</span>
<span class="sd">    """</span>
    <span class="n">stability_method</span> <span class="o">=</span> <span class="n">STABILITY_FORCE_SYMMETRY</span>
    <span class="sd">"""</span>
<span class="sd">    (int) Stability method bitmask.</span>
<span class="sd">    """</span>
    <span class="n">conserve_memory</span> <span class="o">=</span> <span class="n">MEMORY_STORE_ALL</span>
    <span class="sd">"""</span>
<span class="sd">    (int) Memory conservation bitmask.</span>
<span class="sd">    """</span>
    <span class="n">filter_timing</span> <span class="o">=</span> <span class="n">TIMING_INIT_PREDICTED</span>
    <span class="sd">"""</span>
<span class="sd">    (int) Filter timing.</span>
<span class="sd">    """</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k_endog</span><span class="p">,</span> <span class="n">k_states</span><span class="p">,</span> <span class="n">k_posdef</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">loglikelihood_burn</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mf">1e-19</span><span class="p">,</span> <span class="n">results_class</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">kalman_filter_classes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">KalmanFilter</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">k_endog</span><span class="p">,</span> <span class="n">k_states</span><span class="p">,</span> <span class="n">k_posdef</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>

        <span class="c1"># Setup the underlying Kalman filter storage</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_kalman_filters</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># Filter options</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loglikelihood_burn</span> <span class="o">=</span> <span class="n">loglikelihood_burn</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">results_class</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">results_class</span> <span class="k">if</span> <span class="n">results_class</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">FilterResults</span>
        <span class="p">)</span>
        <span class="c1"># Options</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prefix_kalman_filter_map</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">kalman_filter_classes</span>
            <span class="k">if</span> <span class="n">kalman_filter_classes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="k">else</span> <span class="n">tools</span><span class="o">.</span><span class="n">prefix_kalman_filter_map</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">set_filter_method</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_inversion_method</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_stability_method</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_conserve_memory</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_filter_timing</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">tolerance</span> <span class="o">=</span> <span class="n">tolerance</span>

        <span class="c1"># Internal flags</span>
        <span class="c1"># The _scale internal flag is used because we may want to</span>
        <span class="c1"># use a fixed scale, in which case we want the flag to the Cython</span>
        <span class="c1"># Kalman filter to indicate that the scale should not be concentrated</span>
        <span class="c1"># out, so that self.filter_concentrated = False, but we still want to</span>
        <span class="c1"># alert the results object that we are viewing the model as one in</span>
        <span class="c1"># which the scale had been concentrated out for e.g. degree of freedom</span>
        <span class="c1"># computations.</span>
        <span class="c1"># This value should always be None, except within the fixed_scale</span>
        <span class="c1"># context, and should not be modified by users or anywhere else.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_scale</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_clone_kwargs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">endog</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># See Representation._clone_kwargs for docstring</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">KalmanFilter</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_clone_kwargs</span><span class="p">(</span><span class="n">endog</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Get defaults for options</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">'filter_method'</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_method</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">'inversion_method'</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">inversion_method</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">'stability_method'</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">stability_method</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">'conserve_memory'</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">conserve_memory</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">'filter_timing'</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_timing</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">'tolerance'</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tolerance</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">'loglikelihood_burn'</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">loglikelihood_burn</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">kwargs</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_kalman_filter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">prefix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prefix</span>
        <span class="k">if</span> <span class="n">prefix</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kalman_filters</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kalman_filters</span><span class="p">[</span><span class="n">prefix</span><span class="p">]</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_initialize_filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filter_method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">inversion_method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                           <span class="n">stability_method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">conserve_memory</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                           <span class="n">tolerance</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">filter_timing</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                           <span class="n">loglikelihood_burn</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">filter_method</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">filter_method</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_method</span>
        <span class="k">if</span> <span class="n">inversion_method</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">inversion_method</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inversion_method</span>
        <span class="k">if</span> <span class="n">stability_method</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">stability_method</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stability_method</span>
        <span class="k">if</span> <span class="n">conserve_memory</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">conserve_memory</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">conserve_memory</span>
        <span class="k">if</span> <span class="n">loglikelihood_burn</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">loglikelihood_burn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">loglikelihood_burn</span>
        <span class="k">if</span> <span class="n">filter_timing</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">filter_timing</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_timing</span>
        <span class="k">if</span> <span class="n">tolerance</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tolerance</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tolerance</span>

        <span class="c1"># Make sure we have endog</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">endog</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">'Must bind a dataset to the model before'</span>
                               <span class="s1">' filtering or smoothing.'</span><span class="p">)</span>

        <span class="c1"># Initialize the representation matrices</span>
        <span class="n">prefix</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">create_statespace</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_representation</span><span class="p">()</span>

        <span class="c1"># Determine if we need to (re-)create the filter</span>
        <span class="c1"># (definitely need to recreate if we recreated the _statespace object)</span>
        <span class="n">create_filter</span> <span class="o">=</span> <span class="n">create_statespace</span> <span class="ow">or</span> <span class="n">prefix</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kalman_filters</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">create_filter</span><span class="p">:</span>
            <span class="n">kalman_filter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kalman_filters</span><span class="p">[</span><span class="n">prefix</span><span class="p">]</span>

            <span class="n">create_filter</span> <span class="o">=</span> <span class="p">(</span>
                <span class="ow">not</span> <span class="n">kalman_filter</span><span class="o">.</span><span class="n">conserve_memory</span> <span class="o">==</span> <span class="n">conserve_memory</span> <span class="ow">or</span>
                <span class="ow">not</span> <span class="n">kalman_filter</span><span class="o">.</span><span class="n">loglikelihood_burn</span> <span class="o">==</span> <span class="n">loglikelihood_burn</span>
            <span class="p">)</span>

        <span class="c1"># If the dtype-specific _kalman_filter does not exist (or if we need</span>
        <span class="c1"># to re-create it), create it</span>
        <span class="k">if</span> <span class="n">create_filter</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">prefix</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kalman_filters</span><span class="p">:</span>
                <span class="c1"># Delete the old filter</span>
                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kalman_filters</span><span class="p">[</span><span class="n">prefix</span><span class="p">]</span>
            <span class="c1"># Setup the filter</span>
            <span class="bp">cls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prefix_kalman_filter_map</span><span class="p">[</span><span class="n">prefix</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_kalman_filters</span><span class="p">[</span><span class="n">prefix</span><span class="p">]</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_statespaces</span><span class="p">[</span><span class="n">prefix</span><span class="p">],</span> <span class="n">filter_method</span><span class="p">,</span> <span class="n">inversion_method</span><span class="p">,</span>
                <span class="n">stability_method</span><span class="p">,</span> <span class="n">conserve_memory</span><span class="p">,</span> <span class="n">filter_timing</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">,</span>
                <span class="n">loglikelihood_burn</span>
            <span class="p">)</span>
        <span class="c1"># Otherwise, update the filter parameters</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">kalman_filter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kalman_filters</span><span class="p">[</span><span class="n">prefix</span><span class="p">]</span>
            <span class="n">kalman_filter</span><span class="o">.</span><span class="n">set_filter_method</span><span class="p">(</span><span class="n">filter_method</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
            <span class="n">kalman_filter</span><span class="o">.</span><span class="n">inversion_method</span> <span class="o">=</span> <span class="n">inversion_method</span>
            <span class="n">kalman_filter</span><span class="o">.</span><span class="n">stability_method</span> <span class="o">=</span> <span class="n">stability_method</span>
            <span class="n">kalman_filter</span><span class="o">.</span><span class="n">filter_timing</span> <span class="o">=</span> <span class="n">filter_timing</span>
            <span class="n">kalman_filter</span><span class="o">.</span><span class="n">tolerance</span> <span class="o">=</span> <span class="n">tolerance</span>
            <span class="c1"># conserve_memory and loglikelihood_burn changes always lead to</span>
            <span class="c1"># re-created filters</span>

        <span class="k">return</span> <span class="n">prefix</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">create_filter</span><span class="p">,</span> <span class="n">create_statespace</span>

<div class="viewcode-block" id="KalmanFilter.set_filter_method"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.kalman_filter.KalmanFilter.set_filter_method.html#statsmodels.tsa.statespace.simulation_smoother.KalmanFilter.set_filter_method">[docs]</a>    <span class="k">def</span> <span class="nf">set_filter_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filter_method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">"""</span>
<span class="sd">        Set the filtering method</span>

<span class="sd">        The filtering method controls aspects of which Kalman filtering</span>
<span class="sd">        approach will be used.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filter_method : int, optional</span>
<span class="sd">            Bitmask value to set the filter method to. See notes for details.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Keyword arguments may be used to influence the filter method by</span>
<span class="sd">            setting individual boolean flags. See notes for details.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The filtering method is defined by a collection of boolean flags, and</span>
<span class="sd">        is internally stored as a bitmask. The methods available are:</span>

<span class="sd">        FILTER_CONVENTIONAL</span>
<span class="sd">            Conventional Kalman filter.</span>
<span class="sd">        FILTER_UNIVARIATE</span>
<span class="sd">            Univariate approach to Kalman filtering. Overrides conventional</span>
<span class="sd">            method if both are specified.</span>
<span class="sd">        FILTER_COLLAPSED</span>
<span class="sd">            Collapsed approach to Kalman filtering. Will be used *in addition*</span>
<span class="sd">            to conventional or univariate filtering.</span>
<span class="sd">        FILTER_CONCENTRATED</span>
<span class="sd">            Use the concentrated log-likelihood function. Will be used</span>
<span class="sd">            *in addition* to the other options.</span>

<span class="sd">        Note that only the first method is available if using a Scipy version</span>
<span class="sd">        older than 0.16.</span>

<span class="sd">        If the bitmask is set directly via the `filter_method` argument, then</span>
<span class="sd">        the full method must be provided.</span>

<span class="sd">        If keyword arguments are used to set individual boolean flags, then</span>
<span class="sd">        the lowercase of the method must be used as an argument name, and the</span>
<span class="sd">        value is the desired value of the boolean flag (True or False).</span>

<span class="sd">        Note that the filter method may also be specified by directly modifying</span>
<span class="sd">        the class attributes which are defined similarly to the keyword</span>
<span class="sd">        arguments.</span>

<span class="sd">        The default filtering method is FILTER_CONVENTIONAL.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; mod = sm.tsa.statespace.SARIMAX(range(10))</span>
<span class="sd">        &gt;&gt;&gt; mod.ssm.filter_method</span>
<span class="sd">        1</span>
<span class="sd">        &gt;&gt;&gt; mod.ssm.filter_conventional</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; mod.ssm.filter_univariate = True</span>
<span class="sd">        &gt;&gt;&gt; mod.ssm.filter_method</span>
<span class="sd">        17</span>
<span class="sd">        &gt;&gt;&gt; mod.ssm.set_filter_method(filter_univariate=False,</span>
<span class="sd">        ...                           filter_collapsed=True)</span>
<span class="sd">        &gt;&gt;&gt; mod.ssm.filter_method</span>
<span class="sd">        33</span>
<span class="sd">        &gt;&gt;&gt; mod.ssm.set_filter_method(filter_method=1)</span>
<span class="sd">        &gt;&gt;&gt; mod.ssm.filter_conventional</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; mod.ssm.filter_univariate</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; mod.ssm.filter_collapsed</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; mod.ssm.filter_univariate = True</span>
<span class="sd">        &gt;&gt;&gt; mod.ssm.filter_method</span>
<span class="sd">        17</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="n">filter_method</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">filter_method</span> <span class="o">=</span> <span class="n">filter_method</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">KalmanFilter</span><span class="o">.</span><span class="n">filter_methods</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">name</span><span class="p">])</span></div>

<div class="viewcode-block" id="KalmanFilter.set_inversion_method"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.kalman_filter.KalmanFilter.set_inversion_method.html#statsmodels.tsa.statespace.simulation_smoother.KalmanFilter.set_inversion_method">[docs]</a>    <span class="k">def</span> <span class="nf">set_inversion_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inversion_method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">"""</span>
<span class="sd">        Set the inversion method</span>

<span class="sd">        The Kalman filter may contain one matrix inversion: that of the</span>
<span class="sd">        forecast error covariance matrix. The inversion method controls how and</span>
<span class="sd">        if that inverse is performed.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        inversion_method : int, optional</span>
<span class="sd">            Bitmask value to set the inversion method to. See notes for</span>
<span class="sd">            details.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Keyword arguments may be used to influence the inversion method by</span>
<span class="sd">            setting individual boolean flags. See notes for details.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The inversion method is defined by a collection of boolean flags, and</span>
<span class="sd">        is internally stored as a bitmask. The methods available are:</span>

<span class="sd">        INVERT_UNIVARIATE</span>
<span class="sd">            If the endogenous time series is univariate, then inversion can be</span>
<span class="sd">            performed by simple division. If this flag is set and the time</span>
<span class="sd">            series is univariate, then division will always be used even if</span>
<span class="sd">            other flags are also set.</span>
<span class="sd">        SOLVE_LU</span>
<span class="sd">            Use an LU decomposition along with a linear solver (rather than</span>
<span class="sd">            ever actually inverting the matrix).</span>
<span class="sd">        INVERT_LU</span>
<span class="sd">            Use an LU decomposition along with typical matrix inversion.</span>
<span class="sd">        SOLVE_CHOLESKY</span>
<span class="sd">            Use a Cholesky decomposition along with a linear solver.</span>
<span class="sd">        INVERT_CHOLESKY</span>
<span class="sd">            Use an Cholesky decomposition along with typical matrix inversion.</span>

<span class="sd">        If the bitmask is set directly via the `inversion_method` argument,</span>
<span class="sd">        then the full method must be provided.</span>

<span class="sd">        If keyword arguments are used to set individual boolean flags, then</span>
<span class="sd">        the lowercase of the method must be used as an argument name, and the</span>
<span class="sd">        value is the desired value of the boolean flag (True or False).</span>

<span class="sd">        Note that the inversion method may also be specified by directly</span>
<span class="sd">        modifying the class attributes which are defined similarly to the</span>
<span class="sd">        keyword arguments.</span>

<span class="sd">        The default inversion method is `INVERT_UNIVARIATE | SOLVE_CHOLESKY`</span>

<span class="sd">        Several things to keep in mind are:</span>

<span class="sd">        - If the filtering method is specified to be univariate, then simple</span>
<span class="sd">          division is always used regardless of the dimension of the endogenous</span>
<span class="sd">          time series.</span>
<span class="sd">        - Cholesky decomposition is about twice as fast as LU decomposition,</span>
<span class="sd">          but it requires that the matrix be positive definite. While this</span>
<span class="sd">          should generally be true, it may not be in every case.</span>
<span class="sd">        - Using a linear solver rather than true matrix inversion is generally</span>
<span class="sd">          faster and is numerically more stable.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; mod = sm.tsa.statespace.SARIMAX(range(10))</span>
<span class="sd">        &gt;&gt;&gt; mod.ssm.inversion_method</span>
<span class="sd">        1</span>
<span class="sd">        &gt;&gt;&gt; mod.ssm.solve_cholesky</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; mod.ssm.invert_univariate</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; mod.ssm.invert_lu</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; mod.ssm.invert_univariate = False</span>
<span class="sd">        &gt;&gt;&gt; mod.ssm.inversion_method</span>
<span class="sd">        8</span>
<span class="sd">        &gt;&gt;&gt; mod.ssm.set_inversion_method(solve_cholesky=False,</span>
<span class="sd">        ...                              invert_cholesky=True)</span>
<span class="sd">        &gt;&gt;&gt; mod.ssm.inversion_method</span>
<span class="sd">        16</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="n">inversion_method</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">inversion_method</span> <span class="o">=</span> <span class="n">inversion_method</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">KalmanFilter</span><span class="o">.</span><span class="n">inversion_methods</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">name</span><span class="p">])</span></div>

<div class="viewcode-block" id="KalmanFilter.set_stability_method"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.kalman_filter.KalmanFilter.set_stability_method.html#statsmodels.tsa.statespace.simulation_smoother.KalmanFilter.set_stability_method">[docs]</a>    <span class="k">def</span> <span class="nf">set_stability_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stability_method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">"""</span>
<span class="sd">        Set the numerical stability method</span>

<span class="sd">        The Kalman filter is a recursive algorithm that may in some cases</span>
<span class="sd">        suffer issues with numerical stability. The stability method controls</span>
<span class="sd">        what, if any, measures are taken to promote stability.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        stability_method : int, optional</span>
<span class="sd">            Bitmask value to set the stability method to. See notes for</span>
<span class="sd">            details.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Keyword arguments may be used to influence the stability method by</span>
<span class="sd">            setting individual boolean flags. See notes for details.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The stability method is defined by a collection of boolean flags, and</span>
<span class="sd">        is internally stored as a bitmask. The methods available are:</span>

<span class="sd">        STABILITY_FORCE_SYMMETRY = 0x01</span>
<span class="sd">            If this flag is set, symmetry of the predicted state covariance</span>
<span class="sd">            matrix is enforced at each iteration of the filter, where each</span>
<span class="sd">            element is set to the average of the corresponding elements in the</span>
<span class="sd">            upper and lower triangle.</span>

<span class="sd">        If the bitmask is set directly via the `stability_method` argument,</span>
<span class="sd">        then the full method must be provided.</span>

<span class="sd">        If keyword arguments are used to set individual boolean flags, then</span>
<span class="sd">        the lowercase of the method must be used as an argument name, and the</span>
<span class="sd">        value is the desired value of the boolean flag (True or False).</span>

<span class="sd">        Note that the stability method may also be specified by directly</span>
<span class="sd">        modifying the class attributes which are defined similarly to the</span>
<span class="sd">        keyword arguments.</span>

<span class="sd">        The default stability method is `STABILITY_FORCE_SYMMETRY`</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; mod = sm.tsa.statespace.SARIMAX(range(10))</span>
<span class="sd">        &gt;&gt;&gt; mod.ssm.stability_method</span>
<span class="sd">        1</span>
<span class="sd">        &gt;&gt;&gt; mod.ssm.stability_force_symmetry</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; mod.ssm.stability_force_symmetry = False</span>
<span class="sd">        &gt;&gt;&gt; mod.ssm.stability_method</span>
<span class="sd">        0</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="n">stability_method</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stability_method</span> <span class="o">=</span> <span class="n">stability_method</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">KalmanFilter</span><span class="o">.</span><span class="n">stability_methods</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">name</span><span class="p">])</span></div>

<div class="viewcode-block" id="KalmanFilter.set_conserve_memory"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.kalman_filter.KalmanFilter.set_conserve_memory.html#statsmodels.tsa.statespace.simulation_smoother.KalmanFilter.set_conserve_memory">[docs]</a>    <span class="k">def</span> <span class="nf">set_conserve_memory</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">conserve_memory</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">"""</span>
<span class="sd">        Set the memory conservation method</span>

<span class="sd">        By default, the Kalman filter computes a number of intermediate</span>
<span class="sd">        matrices at each iteration. The memory conservation options control</span>
<span class="sd">        which of those matrices are stored.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        conserve_memory : int, optional</span>
<span class="sd">            Bitmask value to set the memory conservation method to. See notes</span>
<span class="sd">            for details.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Keyword arguments may be used to influence the memory conservation</span>
<span class="sd">            method by setting individual boolean flags. See notes for details.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The memory conservation method is defined by a collection of boolean</span>
<span class="sd">        flags, and is internally stored as a bitmask. The methods available</span>
<span class="sd">        are:</span>

<span class="sd">        MEMORY_STORE_ALL</span>
<span class="sd">            Store all intermediate matrices. This is the default value.</span>
<span class="sd">        MEMORY_NO_FORECAST_MEAN</span>
<span class="sd">            Do not store the forecast or forecast errors. If this option is</span>
<span class="sd">            used, the `predict` method from the results class is unavailable.</span>
<span class="sd">        MEMORY_NO_FORECAST_COV</span>
<span class="sd">            Do not store the forecast error covariance matrices.</span>
<span class="sd">        MEMORY_NO_FORECAST</span>
<span class="sd">            Do not store the forecast, forecast error, or forecast error</span>
<span class="sd">            covariance matrices. If this option is used, the `predict` method</span>
<span class="sd">            from the results class is unavailable.</span>
<span class="sd">        MEMORY_NO_PREDICTED_MEAN</span>
<span class="sd">            Do not store the predicted state.</span>
<span class="sd">        MEMORY_NO_PREDICTED_COV</span>
<span class="sd">            Do not store the predicted state covariance</span>
<span class="sd">            matrices.</span>
<span class="sd">        MEMORY_NO_PREDICTED</span>
<span class="sd">            Do not store the predicted state or predicted state covariance</span>
<span class="sd">            matrices.</span>
<span class="sd">        MEMORY_NO_FILTERED_MEAN</span>
<span class="sd">            Do not store the filtered state.</span>
<span class="sd">        MEMORY_NO_FILTERED_COV</span>
<span class="sd">            Do not store the filtered state covariance</span>
<span class="sd">            matrices.</span>
<span class="sd">        MEMORY_NO_FILTERED</span>
<span class="sd">            Do not store the filtered state or filtered state covariance</span>
<span class="sd">            matrices.</span>
<span class="sd">        MEMORY_NO_LIKELIHOOD</span>
<span class="sd">            Do not store the vector of loglikelihood values for each</span>
<span class="sd">            observation. Only the sum of the loglikelihood values is stored.</span>
<span class="sd">        MEMORY_NO_GAIN</span>
<span class="sd">            Do not store the Kalman gain matrices.</span>
<span class="sd">        MEMORY_NO_SMOOTHING</span>
<span class="sd">            Do not store temporary variables related to Kalman smoothing. If</span>
<span class="sd">            this option is used, smoothing is unavailable.</span>
<span class="sd">        MEMORY_NO_STD_FORECAST</span>
<span class="sd">            Do not store standardized forecast errors.</span>
<span class="sd">        MEMORY_CONSERVE</span>
<span class="sd">            Do not store any intermediate matrices.</span>

<span class="sd">        If the bitmask is set directly via the `conserve_memory` argument,</span>
<span class="sd">        then the full method must be provided.</span>

<span class="sd">        If keyword arguments are used to set individual boolean flags, then</span>
<span class="sd">        the lowercase of the method must be used as an argument name, and the</span>
<span class="sd">        value is the desired value of the boolean flag (True or False).</span>

<span class="sd">        Note that the memory conservation method may also be specified by</span>
<span class="sd">        directly modifying the class attributes which are defined similarly to</span>
<span class="sd">        the keyword arguments.</span>

<span class="sd">        The default memory conservation method is `MEMORY_STORE_ALL`, so that</span>
<span class="sd">        all intermediate matrices are stored.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; mod = sm.tsa.statespace.SARIMAX(range(10))</span>
<span class="sd">        &gt;&gt;&gt; mod.ssm..conserve_memory</span>
<span class="sd">        0</span>
<span class="sd">        &gt;&gt;&gt; mod.ssm.memory_no_predicted</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; mod.ssm.memory_no_predicted = True</span>
<span class="sd">        &gt;&gt;&gt; mod.ssm.conserve_memory</span>
<span class="sd">        2</span>
<span class="sd">        &gt;&gt;&gt; mod.ssm.set_conserve_memory(memory_no_filtered=True,</span>
<span class="sd">        ...                             memory_no_forecast=True)</span>
<span class="sd">        &gt;&gt;&gt; mod.ssm.conserve_memory</span>
<span class="sd">        7</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="n">conserve_memory</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">conserve_memory</span> <span class="o">=</span> <span class="n">conserve_memory</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">KalmanFilter</span><span class="o">.</span><span class="n">memory_options</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">name</span><span class="p">])</span></div>

<div class="viewcode-block" id="KalmanFilter.set_filter_timing"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.kalman_filter.KalmanFilter.set_filter_timing.html#statsmodels.tsa.statespace.simulation_smoother.KalmanFilter.set_filter_timing">[docs]</a>    <span class="k">def</span> <span class="nf">set_filter_timing</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alternate_timing</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">"""</span>
<span class="sd">        Set the filter timing convention</span>

<span class="sd">        By default, the Kalman filter follows Durbin and Koopman, 2012, in</span>
<span class="sd">        initializing the filter with predicted values. Kim and Nelson, 1999,</span>
<span class="sd">        instead initialize the filter with filtered values, which is</span>
<span class="sd">        essentially just a different timing convention.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        alternate_timing : int, optional</span>
<span class="sd">            Whether or not to use the alternate timing convention. Default is</span>
<span class="sd">            unspecified.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Keyword arguments may be used to influence the memory conservation</span>
<span class="sd">            method by setting individual boolean flags. See notes for details.</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="n">alternate_timing</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">filter_timing</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">alternate_timing</span><span class="p">)</span>
        <span class="k">if</span> <span class="s1">'timing_init_predicted'</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">filter_timing</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="ow">not</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">'timing_init_predicted'</span><span class="p">])</span>
        <span class="k">if</span> <span class="s1">'timing_init_filtered'</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">filter_timing</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">'timing_init_filtered'</span><span class="p">])</span></div>

<div class="viewcode-block" id="KalmanFilter.fixed_scale"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.kalman_filter.KalmanFilter.fixed_scale.html#statsmodels.tsa.statespace.simulation_smoother.KalmanFilter.fixed_scale">[docs]</a>    <span class="nd">@contextlib</span><span class="o">.</span><span class="n">contextmanager</span>
    <span class="k">def</span> <span class="nf">fixed_scale</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scale</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        fixed_scale(scale)</span>

<span class="sd">        Context manager for fixing the scale when FILTER_CONCENTRATED is set</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        scale : numeric</span>
<span class="sd">            Scale of the model.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This a no-op if scale is None.</span>

<span class="sd">        This context manager is most useful in models which are explicitly</span>
<span class="sd">        concentrating out the scale, so that the set of parameters they are</span>
<span class="sd">        estimating does not include the scale.</span>
<span class="sd">        """</span>
        <span class="c1"># If a scale was provided, use it and do not concentrate it out of the</span>
        <span class="c1"># loglikelihood</span>
        <span class="k">if</span> <span class="n">scale</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">scale</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_concentrated</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'Cannot provide scale if filter method does'</span>
                                 <span class="s1">' not include FILTER_CONCENTRATED.'</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">filter_concentrated</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_scale</span> <span class="o">=</span> <span class="n">scale</span>
            <span class="n">obs_cov</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s1">'obs_cov'</span><span class="p">]</span>
            <span class="n">state_cov</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s1">'state_cov'</span><span class="p">]</span>
            <span class="bp">self</span><span class="p">[</span><span class="s1">'obs_cov'</span><span class="p">]</span> <span class="o">=</span> <span class="n">scale</span> <span class="o">*</span> <span class="n">obs_cov</span>
            <span class="bp">self</span><span class="p">[</span><span class="s1">'state_cov'</span><span class="p">]</span> <span class="o">=</span> <span class="n">scale</span> <span class="o">*</span> <span class="n">state_cov</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">yield</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="c1"># If a scale was provided, reset the model</span>
            <span class="k">if</span> <span class="n">scale</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">scale</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="p">[</span><span class="s1">'state_cov'</span><span class="p">]</span> <span class="o">=</span> <span class="n">state_cov</span>
                <span class="bp">self</span><span class="p">[</span><span class="s1">'obs_cov'</span><span class="p">]</span> <span class="o">=</span> <span class="n">obs_cov</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">filter_concentrated</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_scale</span> <span class="o">=</span> <span class="kc">None</span></div>

    <span class="k">def</span> <span class="nf">_filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filter_method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">inversion_method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">stability_method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">conserve_memory</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">filter_timing</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">loglikelihood_burn</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">complex_step</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="c1"># Initialize the filter</span>
        <span class="n">prefix</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">create_filter</span><span class="p">,</span> <span class="n">create_statespace</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_filter</span><span class="p">(</span>
                <span class="n">filter_method</span><span class="p">,</span> <span class="n">inversion_method</span><span class="p">,</span> <span class="n">stability_method</span><span class="p">,</span>
                <span class="n">conserve_memory</span><span class="p">,</span> <span class="n">filter_timing</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">,</span> <span class="n">loglikelihood_burn</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="n">kfilter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kalman_filters</span><span class="p">[</span><span class="n">prefix</span><span class="p">]</span>

        <span class="c1"># Initialize the state</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_state</span><span class="p">(</span><span class="n">prefix</span><span class="o">=</span><span class="n">prefix</span><span class="p">,</span> <span class="n">complex_step</span><span class="o">=</span><span class="n">complex_step</span><span class="p">)</span>

        <span class="c1"># Run the filter</span>
        <span class="n">kfilter</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">kfilter</span>

<div class="viewcode-block" id="KalmanFilter.filter"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.kalman_filter.KalmanFilter.filter.html#statsmodels.tsa.statespace.simulation_smoother.KalmanFilter.filter">[docs]</a>    <span class="k">def</span> <span class="nf">filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filter_method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">inversion_method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="n">stability_method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">conserve_memory</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">filter_timing</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="n">tolerance</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">loglikelihood_burn</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">complex_step</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">"""</span>
<span class="sd">        Apply the Kalman filter to the statespace model.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filter_method : int, optional</span>
<span class="sd">            Determines which Kalman filter to use. Default is conventional.</span>
<span class="sd">        inversion_method : int, optional</span>
<span class="sd">            Determines which inversion technique to use. Default is by Cholesky</span>
<span class="sd">            decomposition.</span>
<span class="sd">        stability_method : int, optional</span>
<span class="sd">            Determines which numerical stability techniques to use. Default is</span>
<span class="sd">            to enforce symmetry of the predicted state covariance matrix.</span>
<span class="sd">        conserve_memory : int, optional</span>
<span class="sd">            Determines what output from the filter to store. Default is to</span>
<span class="sd">            store everything.</span>
<span class="sd">        filter_timing : int, optional</span>
<span class="sd">            Determines the timing convention of the filter. Default is that</span>
<span class="sd">            from Durbin and Koopman (2012), in which the filter is initialized</span>
<span class="sd">            with predicted values.</span>
<span class="sd">        tolerance : float, optional</span>
<span class="sd">            The tolerance at which the Kalman filter determines convergence to</span>
<span class="sd">            steady-state. Default is 1e-19.</span>
<span class="sd">        loglikelihood_burn : int, optional</span>
<span class="sd">            The number of initial periods during which the loglikelihood is not</span>
<span class="sd">            recorded. Default is 0.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This function by default does not compute variables required for</span>
<span class="sd">        smoothing.</span>
<span class="sd">        """</span>
        <span class="c1"># Handle memory conservation</span>
        <span class="k">if</span> <span class="n">conserve_memory</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">conserve_memory</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">conserve_memory</span> <span class="o">|</span> <span class="n">MEMORY_NO_SMOOTHING</span>
        <span class="n">conserve_memory_cache</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">conserve_memory</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_conserve_memory</span><span class="p">(</span><span class="n">conserve_memory</span><span class="p">)</span>

        <span class="c1"># Run the filter</span>
        <span class="n">kfilter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filter</span><span class="p">(</span>
            <span class="n">filter_method</span><span class="p">,</span> <span class="n">inversion_method</span><span class="p">,</span> <span class="n">stability_method</span><span class="p">,</span> <span class="n">conserve_memory</span><span class="p">,</span>
            <span class="n">filter_timing</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">,</span> <span class="n">loglikelihood_burn</span><span class="p">,</span> <span class="n">complex_step</span><span class="p">)</span>

        <span class="c1"># Create the results object</span>
        <span class="n">results</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">results_class</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">results</span><span class="o">.</span><span class="n">update_representation</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">results</span><span class="o">.</span><span class="n">update_filter</span><span class="p">(</span><span class="n">kfilter</span><span class="p">)</span>

        <span class="c1"># Resent memory conservation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_conserve_memory</span><span class="p">(</span><span class="n">conserve_memory_cache</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">results</span></div>

<div class="viewcode-block" id="KalmanFilter.loglike"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.kalman_filter.KalmanFilter.loglike.html#statsmodels.tsa.statespace.simulation_smoother.KalmanFilter.loglike">[docs]</a>    <span class="k">def</span> <span class="nf">loglike</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">"""</span>
<span class="sd">        Calculate the loglikelihood associated with the statespace model.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Additional keyword arguments to pass to the Kalman filter. See</span>
<span class="sd">            `KalmanFilter.filter` for more details.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        loglike : float</span>
<span class="sd">            The joint loglikelihood.</span>
<span class="sd">        """</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">'conserve_memory'</span><span class="p">,</span>
                          <span class="n">MEMORY_CONSERVE</span> <span class="o">^</span> <span class="n">MEMORY_NO_LIKELIHOOD</span><span class="p">)</span>
        <span class="n">kfilter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filter</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">loglikelihood_burn</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">'loglikelihood_burn'</span><span class="p">,</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">loglikelihood_burn</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">'conserve_memory'</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">MEMORY_NO_LIKELIHOOD</span><span class="p">):</span>
            <span class="n">loglike</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">kfilter</span><span class="o">.</span><span class="n">loglikelihood</span><span class="p">[</span><span class="n">loglikelihood_burn</span><span class="p">:])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">loglike</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">kfilter</span><span class="o">.</span><span class="n">loglikelihood</span><span class="p">)</span>

        <span class="c1"># Need to modify the computed log-likelihood to incorporate the</span>
        <span class="c1"># MLE scale.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_method</span> <span class="o">&amp;</span> <span class="n">FILTER_CONCENTRATED</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">loglikelihood_burn</span><span class="p">,</span> <span class="n">kfilter</span><span class="o">.</span><span class="n">nobs_diffuse</span><span class="p">)</span>
            <span class="n">nobs_k_endog</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span> <span class="o">-</span>
                <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_statespace</span><span class="o">.</span><span class="n">nmissing</span><span class="p">)[</span><span class="n">d</span><span class="p">:])</span>

            <span class="c1"># In the univariate case, we need to subtract observations</span>
            <span class="c1"># associated with a singular forecast error covariance matrix</span>
            <span class="n">nobs_k_endog</span> <span class="o">-=</span> <span class="n">kfilter</span><span class="o">.</span><span class="n">nobs_kendog_univariate_singular</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">'conserve_memory'</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">MEMORY_NO_LIKELIHOOD</span><span class="p">):</span>
                <span class="n">scale</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">kfilter</span><span class="o">.</span><span class="n">scale</span><span class="p">[</span><span class="n">d</span><span class="p">:])</span> <span class="o">/</span> <span class="n">nobs_k_endog</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">scale</span> <span class="o">=</span> <span class="n">kfilter</span><span class="o">.</span><span class="n">scale</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">nobs_k_endog</span>

            <span class="n">loglike</span> <span class="o">+=</span> <span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">nobs_k_endog</span>

            <span class="c1"># Now need to modify this for diffuse initialization, since for</span>
            <span class="c1"># diffuse periods we only need to add in the scale value part if</span>
            <span class="c1"># the diffuse forecast error covariance matrix element was singular</span>
            <span class="k">if</span> <span class="n">kfilter</span><span class="o">.</span><span class="n">nobs_diffuse</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">nobs_k_endog</span> <span class="o">-=</span> <span class="n">kfilter</span><span class="o">.</span><span class="n">nobs_kendog_diffuse_nonsingular</span>

            <span class="n">loglike</span> <span class="o">+=</span> <span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">nobs_k_endog</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">scale</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">loglike</span></div>

<div class="viewcode-block" id="KalmanFilter.loglikeobs"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.kalman_filter.KalmanFilter.loglikeobs.html#statsmodels.tsa.statespace.simulation_smoother.KalmanFilter.loglikeobs">[docs]</a>    <span class="k">def</span> <span class="nf">loglikeobs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">"""</span>
<span class="sd">        Calculate the loglikelihood for each observation associated with the</span>
<span class="sd">        statespace model.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Additional keyword arguments to pass to the Kalman filter. See</span>
<span class="sd">            `KalmanFilter.filter` for more details.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        If `loglikelihood_burn` is positive, then the entries in the returned</span>
<span class="sd">        loglikelihood vector are set to be zero for those initial time periods.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        loglike : array of float</span>
<span class="sd">            Array of loglikelihood values for each observation.</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">memory_no_likelihood</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">'Cannot compute loglikelihood if'</span>
                               <span class="s1">' MEMORY_NO_LIKELIHOOD option is selected.'</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_method</span> <span class="o">&amp;</span> <span class="n">FILTER_CONCENTRATED</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">'conserve_memory'</span><span class="p">,</span>
                              <span class="n">MEMORY_CONSERVE</span> <span class="o">^</span> <span class="n">MEMORY_NO_LIKELIHOOD</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span>
                <span class="s1">'conserve_memory'</span><span class="p">,</span>
                <span class="n">MEMORY_CONSERVE</span> <span class="o">^</span> <span class="p">(</span><span class="n">MEMORY_NO_FORECAST</span> <span class="o">|</span> <span class="n">MEMORY_NO_LIKELIHOOD</span><span class="p">))</span>
        <span class="n">kfilter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filter</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">llf_obs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">kfilter</span><span class="o">.</span><span class="n">loglikelihood</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">loglikelihood_burn</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">'loglikelihood_burn'</span><span class="p">,</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">loglikelihood_burn</span><span class="p">)</span>

        <span class="c1"># If the scale was concentrated out of the log-likelihood function,</span>
        <span class="c1"># then the llf_obs above is:</span>
        <span class="c1"># -0.5 * k_endog * log 2 * pi - 0.5 * log |F_t|</span>
        <span class="c1"># and we need to add in the effect of the scale:</span>
        <span class="c1"># -0.5 * k_endog * log scale - 0.5 v' F_t^{-1} v / scale</span>
        <span class="c1"># and note that v' F_t^{-1} is in the _kalman_filter.scale array</span>
        <span class="c1"># Also note that we need to adjust the nobs and k_endog in both the</span>
        <span class="c1"># denominator of the scale computation and in the llf_obs adjustment</span>
        <span class="c1"># to take into account missing values.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_method</span> <span class="o">&amp;</span> <span class="n">FILTER_CONCENTRATED</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">loglikelihood_burn</span><span class="p">,</span> <span class="n">kfilter</span><span class="o">.</span><span class="n">nobs_diffuse</span><span class="p">)</span>
            <span class="n">nmissing</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_statespace</span><span class="o">.</span><span class="n">nmissing</span><span class="p">)</span>
            <span class="n">nobs_k_endog</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span> <span class="o">-</span> <span class="n">nmissing</span><span class="p">[</span><span class="n">d</span><span class="p">:])</span>

            <span class="c1"># In the univariate case, we need to subtract observations</span>
            <span class="c1"># associated with a singular forecast error covariance matrix</span>
            <span class="n">nobs_k_endog</span> <span class="o">-=</span> <span class="n">kfilter</span><span class="o">.</span><span class="n">nobs_kendog_univariate_singular</span>

            <span class="n">scale</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">kfilter</span><span class="o">.</span><span class="n">scale</span><span class="p">[</span><span class="n">d</span><span class="p">:])</span> <span class="o">/</span> <span class="n">nobs_k_endog</span>

            <span class="c1"># Need to modify this for diffuse initialization, since for</span>
            <span class="c1"># diffuse periods we only need to add in the scale value if the</span>
            <span class="c1"># diffuse forecast error covariance matrix element was singular</span>
            <span class="n">nsingular</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="n">kfilter</span><span class="o">.</span><span class="n">nobs_diffuse</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">kfilter</span><span class="o">.</span><span class="n">nobs_diffuse</span>
                <span class="n">Finf</span> <span class="o">=</span> <span class="n">kfilter</span><span class="o">.</span><span class="n">forecast_error_diffuse_cov</span>
                <span class="n">singular</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diagonal</span><span class="p">(</span><span class="n">Finf</span><span class="p">)</span><span class="o">.</span><span class="n">real</span> <span class="o">&lt;=</span> <span class="n">kfilter</span><span class="o">.</span><span class="n">tolerance_diffuse</span>
                <span class="n">nsingular</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">~</span><span class="n">singular</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

            <span class="n">scale_obs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">kfilter</span><span class="o">.</span><span class="n">scale</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">llf_obs</span> <span class="o">+=</span> <span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span>
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span> <span class="o">-</span> <span class="n">nmissing</span> <span class="o">-</span> <span class="n">nsingular</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">scale</span><span class="p">)</span> <span class="o">+</span>
                <span class="n">scale_obs</span> <span class="o">/</span> <span class="n">scale</span><span class="p">)</span>

        <span class="c1"># Set any burned observations to have zero likelihood</span>
        <span class="n">llf_obs</span><span class="p">[:</span><span class="n">loglikelihood_burn</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">return</span> <span class="n">llf_obs</span></div>

<div class="viewcode-block" id="KalmanFilter.simulate"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.kalman_filter.KalmanFilter.simulate.html#statsmodels.tsa.statespace.simulation_smoother.KalmanFilter.simulate">[docs]</a>    <span class="k">def</span> <span class="nf">simulate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nsimulations</span><span class="p">,</span> <span class="n">measurement_shocks</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">state_shocks</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">initial_state</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">"""</span>
<span class="sd">        Simulate a new time series following the state space model</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nsimulations : int</span>
<span class="sd">            The number of observations to simulate. If the model is</span>
<span class="sd">            time-invariant this can be any number. If the model is</span>
<span class="sd">            time-varying, then this number must be less than or equal to the</span>
<span class="sd">            number</span>
<span class="sd">        measurement_shocks : array_like, optional</span>
<span class="sd">            If specified, these are the shocks to the measurement equation,</span>
<span class="sd">            :math:`\varepsilon_t`. If unspecified, these are automatically</span>
<span class="sd">            generated using a pseudo-random number generator. If specified,</span>
<span class="sd">            must be shaped `nsimulations` x `k_endog`, where `k_endog` is the</span>
<span class="sd">            same as in the state space model.</span>
<span class="sd">        state_shocks : array_like, optional</span>
<span class="sd">            If specified, these are the shocks to the state equation,</span>
<span class="sd">            :math:`\eta_t`. If unspecified, these are automatically</span>
<span class="sd">            generated using a pseudo-random number generator. If specified,</span>
<span class="sd">            must be shaped `nsimulations` x `k_posdef` where `k_posdef` is the</span>
<span class="sd">            same as in the state space model.</span>
<span class="sd">        initial_state : array_like, optional</span>
<span class="sd">            If specified, this is the state vector at time zero, which should</span>
<span class="sd">            be shaped (`k_states` x 1), where `k_states` is the same as in the</span>
<span class="sd">            state space model. If unspecified, but the model has been</span>
<span class="sd">            initialized, then that initialization is used. If unspecified and</span>
<span class="sd">            the model has not been initialized, then a vector of zeros is used.</span>
<span class="sd">            Note that this is not included in the returned `simulated_states`</span>
<span class="sd">            array.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        simulated_obs : ndarray</span>
<span class="sd">            An (nsimulations x k_endog) array of simulated observations.</span>
<span class="sd">        simulated_states : ndarray</span>
<span class="sd">            An (nsimulations x k_states) array of simulated states.</span>
<span class="sd">        """</span>
        <span class="n">time_invariant</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_invariant</span>
        <span class="c1"># Check for valid number of simulations</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">time_invariant</span> <span class="ow">and</span> <span class="n">nsimulations</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'In a time-varying model, cannot create more'</span>
                             <span class="s1">' simulations than there are observations.'</span><span class="p">)</span>

        <span class="c1"># Check / generate measurement shocks</span>
        <span class="k">if</span> <span class="n">measurement_shocks</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">measurement_shocks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">measurement_shocks</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">measurement_shocks</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">measurement_shocks</span> <span class="o">=</span> <span class="n">measurement_shocks</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">measurement_shocks</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">measurement_shocks</span> <span class="o">=</span> <span class="n">measurement_shocks</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
            <span class="n">required_shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">nsimulations</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">measurement_shocks</span> <span class="o">=</span> <span class="n">measurement_shocks</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">required_shape</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'Provided measurement shocks are not of the'</span>
                                 <span class="s1">' appropriate shape. Required </span><span class="si">%s</span><span class="s1">, got </span><span class="si">%s</span><span class="s1">.'</span>
                                 <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">required_shape</span><span class="p">),</span>
                                    <span class="nb">str</span><span class="p">(</span><span class="n">measurement_shocks</span><span class="o">.</span><span class="n">shape</span><span class="p">)))</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">shapes</span><span class="p">[</span><span class="s1">'obs_cov'</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">measurement_shocks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">multivariate_normal</span><span class="p">(</span>
                <span class="n">mean</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">),</span> <span class="n">cov</span><span class="o">=</span><span class="bp">self</span><span class="p">[</span><span class="s1">'obs_cov'</span><span class="p">],</span>
                <span class="n">size</span><span class="o">=</span><span class="n">nsimulations</span><span class="p">)</span>

        <span class="c1"># Check / generate state shocks</span>
        <span class="k">if</span> <span class="n">state_shocks</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">state_shocks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">state_shocks</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">state_shocks</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">state_shocks</span> <span class="o">=</span> <span class="n">state_shocks</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">state_shocks</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">state_shocks</span> <span class="o">=</span> <span class="n">state_shocks</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
            <span class="n">required_shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">nsimulations</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_posdef</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">state_shocks</span> <span class="o">=</span> <span class="n">state_shocks</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">required_shape</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'Provided state shocks are not of the'</span>
                                 <span class="s1">' appropriate shape. Required </span><span class="si">%s</span><span class="s1">, got </span><span class="si">%s</span><span class="s1">.'</span>
                                 <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">required_shape</span><span class="p">),</span>
                                    <span class="nb">str</span><span class="p">(</span><span class="n">state_shocks</span><span class="o">.</span><span class="n">shape</span><span class="p">)))</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">shapes</span><span class="p">[</span><span class="s1">'state_cov'</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">state_shocks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">multivariate_normal</span><span class="p">(</span>
                <span class="n">mean</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_posdef</span><span class="p">),</span> <span class="n">cov</span><span class="o">=</span><span class="bp">self</span><span class="p">[</span><span class="s1">'state_cov'</span><span class="p">],</span>
                <span class="n">size</span><span class="o">=</span><span class="n">nsimulations</span><span class="p">)</span>

        <span class="c1"># Handle time-varying case</span>
        <span class="n">tvp</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shapes</span><span class="p">[</span><span class="s1">'obs_cov'</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">or</span>
               <span class="bp">self</span><span class="o">.</span><span class="n">shapes</span><span class="p">[</span><span class="s1">'state_cov'</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">tvp</span> <span class="ow">and</span> <span class="n">measurement_shocks</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">measurement_shocks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nsimulations</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nsimulations</span><span class="p">):</span>
                <span class="n">measurement_shocks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">multivariate_normal</span><span class="p">(</span>
                    <span class="n">mean</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">),</span>
                    <span class="n">cov</span><span class="o">=</span><span class="bp">self</span><span class="p">[</span><span class="s1">'obs_cov'</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">i</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">tvp</span> <span class="ow">and</span> <span class="n">state_shocks</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">state_shocks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nsimulations</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_posdef</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nsimulations</span><span class="p">):</span>
                <span class="n">state_shocks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">multivariate_normal</span><span class="p">(</span>
                    <span class="n">mean</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_posdef</span><span class="p">),</span>
                    <span class="n">cov</span><span class="o">=</span><span class="bp">self</span><span class="p">[</span><span class="s1">'state_cov'</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">i</span><span class="p">])</span>

        <span class="c1"># Get the initial states</span>
        <span class="k">if</span> <span class="n">initial_state</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">initial_state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">initial_state</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">initial_state</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">initial_state</span> <span class="o">=</span> <span class="n">initial_state</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
            <span class="k">elif</span> <span class="p">(</span><span class="n">initial_state</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span>
                  <span class="ow">not</span> <span class="n">initial_state</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_states</span><span class="p">,</span> <span class="mi">1</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'Invalid shape of provided initial state'</span>
                                 <span class="s1">' vector. Required (</span><span class="si">%d</span><span class="s1">, 1)'</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_states</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">initialization</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">initialization</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>
            <span class="n">initial_state</span> <span class="o">=</span> <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">multivariate_normal</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># TODO: deprecate this, since we really should not be simulating</span>
            <span class="c1"># unless we have an initialization.</span>
            <span class="n">initial_state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_states</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_simulate</span><span class="p">(</span><span class="n">nsimulations</span><span class="p">,</span> <span class="n">measurement_shocks</span><span class="p">,</span> <span class="n">state_shocks</span><span class="p">,</span>
                              <span class="n">initial_state</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_simulate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nsimulations</span><span class="p">,</span> <span class="n">measurement_shocks</span><span class="p">,</span> <span class="n">state_shocks</span><span class="p">,</span>
                  <span class="n">initial_state</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">'Simulation only available through'</span>
                                  <span class="s1">' the simulation smoother.'</span><span class="p">)</span>

<div class="viewcode-block" id="KalmanFilter.impulse_responses"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.kalman_filter.KalmanFilter.impulse_responses.html#statsmodels.tsa.statespace.simulation_smoother.KalmanFilter.impulse_responses">[docs]</a>    <span class="k">def</span> <span class="nf">impulse_responses</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">steps</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">impulse</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">orthogonalized</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                          <span class="n">cumulative</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">direct</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">"""</span>
<span class="sd">        Impulse response function</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        steps : int, optional</span>
<span class="sd">            The number of steps for which impulse responses are calculated.</span>
<span class="sd">            Default is 10. Note that the initial impulse is not counted as a</span>
<span class="sd">            step, so if `steps=1`, the output will have 2 entries.</span>
<span class="sd">        impulse : int or array_like</span>
<span class="sd">            If an integer, the state innovation to pulse; must be between 0</span>
<span class="sd">            and `k_posdef-1` where `k_posdef` is the same as in the state</span>
<span class="sd">            space model. Alternatively, a custom impulse vector may be</span>
<span class="sd">            provided; must be a column vector with shape `(k_posdef, 1)`.</span>
<span class="sd">        orthogonalized : bool, optional</span>
<span class="sd">            Whether or not to perform impulse using orthogonalized innovations.</span>
<span class="sd">            Note that this will also affect custum `impulse` vectors. Default</span>
<span class="sd">            is False.</span>
<span class="sd">        cumulative : bool, optional</span>
<span class="sd">            Whether or not to return cumulative impulse responses. Default is</span>
<span class="sd">            False.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        impulse_responses : ndarray</span>
<span class="sd">            Responses for each endogenous variable due to the impulse</span>
<span class="sd">            given by the `impulse` argument. A (steps + 1 x k_endog) array.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Intercepts in the measurement and state equation are ignored when</span>
<span class="sd">        calculating impulse responses.</span>

<span class="sd">        TODO: add note about how for time-varying systems this is - perhaps</span>
<span class="sd">        counter-intuitively - returning the impulse response within the given</span>
<span class="sd">        model (i.e. starting at period 0 defined by the model) and it is *not*</span>
<span class="sd">        doing impulse responses after the end of the model. To compute impulse</span>
<span class="sd">        responses from arbitrary time points, it is necessary to clone a new</span>
<span class="sd">        model with the appropriate system matrices.</span>
<span class="sd">        """</span>
        <span class="c1"># We need to add an additional step, since the first simulated value</span>
        <span class="c1"># will always be zeros (note that we take this value out at the end).</span>
        <span class="n">steps</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># For time-invariant models, add an additional `step`. This is the</span>
        <span class="c1"># default for time-invariant models based on the expected behavior for</span>
        <span class="c1"># ARIMA and VAR models: we want to record the initial impulse and also</span>
        <span class="c1"># `steps` values of the responses afterwards.</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_design</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transition</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_selection</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">steps</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># Check for what kind of impulse we want</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">impulse</span><span class="p">)</span> <span class="o">==</span> <span class="nb">int</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">impulse</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_posdef</span> <span class="ow">or</span> <span class="n">impulse</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'Invalid value for `impulse`. Must be the'</span>
                                 <span class="s1">' index of one of the state innovations.'</span><span class="p">)</span>

            <span class="c1"># Create the (non-orthogonalized) impulse vector</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">impulse</span>
            <span class="n">impulse</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_posdef</span><span class="p">)</span>
            <span class="n">impulse</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">impulse</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">impulse</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">impulse</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">impulse</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">impulse</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">impulse</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_posdef</span><span class="p">,):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'Invalid impulse vector. Must be shaped'</span>
                                 <span class="s1">' (</span><span class="si">%d</span><span class="s1">,)'</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_posdef</span><span class="p">)</span>

        <span class="c1"># Orthogonalize the impulses, if requested, using Cholesky on the</span>
        <span class="c1"># first state covariance matrix</span>
        <span class="k">if</span> <span class="n">orthogonalized</span><span class="p">:</span>
            <span class="n">state_chol</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">cholesky</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state_cov</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">])</span>
            <span class="n">impulse</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">state_chol</span><span class="p">,</span> <span class="n">impulse</span><span class="p">)</span>

        <span class="c1"># If we have time-varying design, transition, or selection matrices,</span>
        <span class="c1"># then we can't produce more IRFs than we have time points</span>
        <span class="n">time_invariant_irf</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_design</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transition</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_selection</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Note: to generate impulse responses following the end of a</span>
        <span class="c1"># time-varying model, one should `clone` the state space model with the</span>
        <span class="c1"># new time-varying model, and then compute the IRFs using the cloned</span>
        <span class="c1"># model</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">time_invariant_irf</span> <span class="ow">and</span> <span class="n">steps</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'In a time-varying model, cannot create more'</span>
                             <span class="s1">' impulse responses than there are'</span>
                             <span class="s1">' observations'</span><span class="p">)</span>

        <span class="c1"># Impulse responses only depend on the design, transition, and</span>
        <span class="c1"># selection matrices. We set the others to zeros because they must be</span>
        <span class="c1"># set in the call to `clone`.</span>
        <span class="c1"># Note: we don't even need selection after the first point, because</span>
        <span class="c1"># the state shocks will be zeros in every period except the first.</span>
        <span class="n">sim_model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span>
            <span class="n">endog</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">steps</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">),</span>
            <span class="n">obs_intercept</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">),</span>
            <span class="n">design</span><span class="o">=</span><span class="bp">self</span><span class="p">[</span><span class="s1">'design'</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="p">:</span><span class="n">steps</span><span class="p">],</span>
            <span class="n">obs_cov</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">)),</span>
            <span class="n">state_intercept</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_states</span><span class="p">),</span>
            <span class="n">transition</span><span class="o">=</span><span class="bp">self</span><span class="p">[</span><span class="s1">'transition'</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="p">:</span><span class="n">steps</span><span class="p">],</span>
            <span class="n">selection</span><span class="o">=</span><span class="bp">self</span><span class="p">[</span><span class="s1">'selection'</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="p">:</span><span class="n">steps</span><span class="p">],</span>
            <span class="n">state_cov</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">k_posdef</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_posdef</span><span class="p">)))</span>

        <span class="c1"># Get the impulse response function via simulation of the state</span>
        <span class="c1"># space model, but with other shocks set to zero</span>
        <span class="n">measurement_shocks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">steps</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">))</span>
        <span class="n">state_shocks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">steps</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_posdef</span><span class="p">))</span>
        <span class="n">state_shocks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">impulse</span>
        <span class="n">initial_state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">k_states</span><span class="p">,))</span>
        <span class="n">irf</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">sim_model</span><span class="o">.</span><span class="n">simulate</span><span class="p">(</span>
            <span class="n">steps</span><span class="p">,</span> <span class="n">measurement_shocks</span><span class="o">=</span><span class="n">measurement_shocks</span><span class="p">,</span>
            <span class="n">state_shocks</span><span class="o">=</span><span class="n">state_shocks</span><span class="p">,</span> <span class="n">initial_state</span><span class="o">=</span><span class="n">initial_state</span><span class="p">)</span>

        <span class="c1"># Get the cumulative response if requested</span>
        <span class="k">if</span> <span class="n">cumulative</span><span class="p">:</span>
            <span class="n">irf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">irf</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Here we ignore the first value, because it is always zeros (we added</span>
        <span class="c1"># an additional `step` at the top to account for this).</span>
        <span class="k">return</span> <span class="n">irf</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span></div></div>


<div class="viewcode-block" id="FilterResults"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.kalman_filter.FilterResults.html#statsmodels.tsa.statespace.simulation_smoother.FilterResults">[docs]</a><span class="k">class</span> <span class="nc">FilterResults</span><span class="p">(</span><span class="n">FrozenRepresentation</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    Results from applying the Kalman filter to a state space model.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    model : Representation</span>
<span class="sd">        A Statespace representation</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    nobs : int</span>
<span class="sd">        Number of observations.</span>
<span class="sd">    nobs_diffuse : int</span>
<span class="sd">        Number of observations under the diffuse Kalman filter.</span>
<span class="sd">    k_endog : int</span>
<span class="sd">        The dimension of the observation series.</span>
<span class="sd">    k_states : int</span>
<span class="sd">        The dimension of the unobserved state process.</span>
<span class="sd">    k_posdef : int</span>
<span class="sd">        The dimension of a guaranteed positive definite</span>
<span class="sd">        covariance matrix describing the shocks in the</span>
<span class="sd">        measurement equation.</span>
<span class="sd">    dtype : dtype</span>
<span class="sd">        Datatype of representation matrices</span>
<span class="sd">    prefix : str</span>
<span class="sd">        BLAS prefix of representation matrices</span>
<span class="sd">    shapes : dictionary of name,tuple</span>
<span class="sd">        A dictionary recording the shapes of each of the</span>
<span class="sd">        representation matrices as tuples.</span>
<span class="sd">    endog : ndarray</span>
<span class="sd">        The observation vector.</span>
<span class="sd">    design : ndarray</span>
<span class="sd">        The design matrix, :math:`Z`.</span>
<span class="sd">    obs_intercept : ndarray</span>
<span class="sd">        The intercept for the observation equation, :math:`d`.</span>
<span class="sd">    obs_cov : ndarray</span>
<span class="sd">        The covariance matrix for the observation equation :math:`H`.</span>
<span class="sd">    transition : ndarray</span>
<span class="sd">        The transition matrix, :math:`T`.</span>
<span class="sd">    state_intercept : ndarray</span>
<span class="sd">        The intercept for the transition equation, :math:`c`.</span>
<span class="sd">    selection : ndarray</span>
<span class="sd">        The selection matrix, :math:`R`.</span>
<span class="sd">    state_cov : ndarray</span>
<span class="sd">        The covariance matrix for the state equation :math:`Q`.</span>
<span class="sd">    missing : array of bool</span>
<span class="sd">        An array of the same size as `endog`, filled</span>
<span class="sd">        with boolean values that are True if the</span>
<span class="sd">        corresponding entry in `endog` is NaN and False</span>
<span class="sd">        otherwise.</span>
<span class="sd">    nmissing : array of int</span>
<span class="sd">        An array of size `nobs`, where the ith entry</span>
<span class="sd">        is the number (between 0 and `k_endog`) of NaNs in</span>
<span class="sd">        the ith row of the `endog` array.</span>
<span class="sd">    time_invariant : bool</span>
<span class="sd">        Whether or not the representation matrices are time-invariant</span>
<span class="sd">    initialization : str</span>
<span class="sd">        Kalman filter initialization method.</span>
<span class="sd">    initial_state : array_like</span>
<span class="sd">        The state vector used to initialize the Kalamn filter.</span>
<span class="sd">    initial_state_cov : array_like</span>
<span class="sd">        The state covariance matrix used to initialize the Kalamn filter.</span>
<span class="sd">    initial_diffuse_state_cov : array_like</span>
<span class="sd">        Diffuse state covariance matrix used to initialize the Kalamn filter.</span>
<span class="sd">    filter_method : int</span>
<span class="sd">        Bitmask representing the Kalman filtering method</span>
<span class="sd">    inversion_method : int</span>
<span class="sd">        Bitmask representing the method used to</span>
<span class="sd">        invert the forecast error covariance matrix.</span>
<span class="sd">    stability_method : int</span>
<span class="sd">        Bitmask representing the methods used to promote</span>
<span class="sd">        numerical stability in the Kalman filter</span>
<span class="sd">        recursions.</span>
<span class="sd">    conserve_memory : int</span>
<span class="sd">        Bitmask representing the selected memory conservation method.</span>
<span class="sd">    filter_timing : int</span>
<span class="sd">        Whether or not to use the alternate timing convention.</span>
<span class="sd">    tolerance : float</span>
<span class="sd">        The tolerance at which the Kalman filter</span>
<span class="sd">        determines convergence to steady-state.</span>
<span class="sd">    loglikelihood_burn : int</span>
<span class="sd">        The number of initial periods during which</span>
<span class="sd">        the loglikelihood is not recorded.</span>
<span class="sd">    converged : bool</span>
<span class="sd">        Whether or not the Kalman filter converged.</span>
<span class="sd">    period_converged : int</span>
<span class="sd">        The time period in which the Kalman filter converged.</span>
<span class="sd">    filtered_state : ndarray</span>
<span class="sd">        The filtered state vector at each time period.</span>
<span class="sd">    filtered_state_cov : ndarray</span>
<span class="sd">        The filtered state covariance matrix at each time period.</span>
<span class="sd">    predicted_state : ndarray</span>
<span class="sd">        The predicted state vector at each time period.</span>
<span class="sd">    predicted_state_cov : ndarray</span>
<span class="sd">        The predicted state covariance matrix at each time period.</span>
<span class="sd">    forecast_error_diffuse_cov : ndarray</span>
<span class="sd">        Diffuse forecast error covariance matrix at each time period.</span>
<span class="sd">    predicted_diffuse_state_cov : ndarray</span>
<span class="sd">        The predicted diffuse state covariance matrix at each time period.</span>
<span class="sd">    kalman_gain : ndarray</span>
<span class="sd">        The Kalman gain at each time period.</span>
<span class="sd">    forecasts : ndarray</span>
<span class="sd">        The one-step-ahead forecasts of observations at each time period.</span>
<span class="sd">    forecasts_error : ndarray</span>
<span class="sd">        The forecast errors at each time period.</span>
<span class="sd">    forecasts_error_cov : ndarray</span>
<span class="sd">        The forecast error covariance matrices at each time period.</span>
<span class="sd">    llf_obs : ndarray</span>
<span class="sd">        The loglikelihood values at each time period.</span>
<span class="sd">    """</span>
    <span class="n">_filter_attributes</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s1">'filter_method'</span><span class="p">,</span> <span class="s1">'inversion_method'</span><span class="p">,</span> <span class="s1">'stability_method'</span><span class="p">,</span>
        <span class="s1">'conserve_memory'</span><span class="p">,</span> <span class="s1">'filter_timing'</span><span class="p">,</span> <span class="s1">'tolerance'</span><span class="p">,</span> <span class="s1">'loglikelihood_burn'</span><span class="p">,</span>
        <span class="s1">'converged'</span><span class="p">,</span> <span class="s1">'period_converged'</span><span class="p">,</span> <span class="s1">'filtered_state'</span><span class="p">,</span>
        <span class="s1">'filtered_state_cov'</span><span class="p">,</span> <span class="s1">'predicted_state'</span><span class="p">,</span> <span class="s1">'predicted_state_cov'</span><span class="p">,</span>
        <span class="s1">'forecasts_error_diffuse_cov'</span><span class="p">,</span> <span class="s1">'predicted_diffuse_state_cov'</span><span class="p">,</span>
        <span class="s1">'tmp1'</span><span class="p">,</span> <span class="s1">'tmp2'</span><span class="p">,</span> <span class="s1">'tmp3'</span><span class="p">,</span> <span class="s1">'tmp4'</span><span class="p">,</span> <span class="s1">'forecasts'</span><span class="p">,</span>
        <span class="s1">'forecasts_error'</span><span class="p">,</span> <span class="s1">'forecasts_error_cov'</span><span class="p">,</span> <span class="s1">'llf'</span><span class="p">,</span> <span class="s1">'llf_obs'</span><span class="p">,</span>
        <span class="s1">'collapsed_forecasts'</span><span class="p">,</span> <span class="s1">'collapsed_forecasts_error'</span><span class="p">,</span>
        <span class="s1">'collapsed_forecasts_error_cov'</span><span class="p">,</span> <span class="s1">'scale'</span>
    <span class="p">]</span>

    <span class="n">_filter_options</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">KalmanFilter</span><span class="o">.</span><span class="n">filter_methods</span> <span class="o">+</span> <span class="n">KalmanFilter</span><span class="o">.</span><span class="n">stability_methods</span> <span class="o">+</span>
        <span class="n">KalmanFilter</span><span class="o">.</span><span class="n">inversion_methods</span> <span class="o">+</span> <span class="n">KalmanFilter</span><span class="o">.</span><span class="n">memory_options</span>
    <span class="p">)</span>

    <span class="n">_attributes</span> <span class="o">=</span> <span class="n">FrozenRepresentation</span><span class="o">.</span><span class="n">_model_attributes</span> <span class="o">+</span> <span class="n">_filter_attributes</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">FilterResults</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>

        <span class="c1"># Setup caches for uninitialized objects</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_kalman_gain</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_standardized_forecasts_error</span> <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="FilterResults.update_representation"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.kalman_filter.FilterResults.update_representation.html#statsmodels.tsa.statespace.simulation_smoother.FilterResults.update_representation">[docs]</a>    <span class="k">def</span> <span class="nf">update_representation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">only_options</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Update the results to match a given model</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        model : Representation</span>
<span class="sd">            The model object from which to take the updated values.</span>
<span class="sd">        only_options : bool, optional</span>
<span class="sd">            If set to true, only the filter options are updated, and the state</span>
<span class="sd">            space representation is not updated. Default is False.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method is rarely required except for internal usage.</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">only_options</span><span class="p">:</span>
            <span class="nb">super</span><span class="p">(</span><span class="n">FilterResults</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">update_representation</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>

        <span class="c1"># Save the options as boolean variables</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filter_options</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span></div>

<div class="viewcode-block" id="FilterResults.update_filter"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.kalman_filter.FilterResults.update_filter.html#statsmodels.tsa.statespace.simulation_smoother.FilterResults.update_filter">[docs]</a>    <span class="k">def</span> <span class="nf">update_filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kalman_filter</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Update the filter results</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        kalman_filter : statespace.kalman_filter.KalmanFilter</span>
<span class="sd">            The model object from which to take the updated values.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method is rarely required except for internal usage.</span>
<span class="sd">        """</span>
        <span class="c1"># State initialization</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initial_state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="n">kalman_filter</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">initial_state</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initial_state_cov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="n">kalman_filter</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">initial_state_cov</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>

        <span class="c1"># Save Kalman filter parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filter_method</span> <span class="o">=</span> <span class="n">kalman_filter</span><span class="o">.</span><span class="n">filter_method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inversion_method</span> <span class="o">=</span> <span class="n">kalman_filter</span><span class="o">.</span><span class="n">inversion_method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stability_method</span> <span class="o">=</span> <span class="n">kalman_filter</span><span class="o">.</span><span class="n">stability_method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">conserve_memory</span> <span class="o">=</span> <span class="n">kalman_filter</span><span class="o">.</span><span class="n">conserve_memory</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filter_timing</span> <span class="o">=</span> <span class="n">kalman_filter</span><span class="o">.</span><span class="n">filter_timing</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tolerance</span> <span class="o">=</span> <span class="n">kalman_filter</span><span class="o">.</span><span class="n">tolerance</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loglikelihood_burn</span> <span class="o">=</span> <span class="n">kalman_filter</span><span class="o">.</span><span class="n">loglikelihood_burn</span>

        <span class="c1"># Save Kalman filter output</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">converged</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">kalman_filter</span><span class="o">.</span><span class="n">converged</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">period_converged</span> <span class="o">=</span> <span class="n">kalman_filter</span><span class="o">.</span><span class="n">period_converged</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">filtered_state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">kalman_filter</span><span class="o">.</span><span class="n">filtered_state</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filtered_state_cov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="n">kalman_filter</span><span class="o">.</span><span class="n">filtered_state_cov</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">predicted_state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="n">kalman_filter</span><span class="o">.</span><span class="n">predicted_state</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">predicted_state_cov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="n">kalman_filter</span><span class="o">.</span><span class="n">predicted_state_cov</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>

        <span class="c1"># Reset caches</span>
        <span class="n">has_missing</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nmissing</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">memory_no_std_forecast</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">invert_lu</span> <span class="ow">or</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">solve_lu</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_collapsed</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">has_missing</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_standardized_forecasts_error</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                    <span class="n">reorder_missing_vector</span><span class="p">(</span>
                        <span class="n">kalman_filter</span><span class="o">.</span><span class="n">standardized_forecast_error</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">missing</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">prefix</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_standardized_forecasts_error</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                    <span class="n">kalman_filter</span><span class="o">.</span><span class="n">standardized_forecast_error</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_standardized_forecasts_error</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># In the partially missing data case, all entries will</span>
        <span class="c1"># be in the upper left submatrix rather than the correct placement</span>
        <span class="c1"># Re-ordering does not make sense in the collapsed case.</span>
        <span class="k">if</span> <span class="n">has_missing</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">memory_no_gain</span> <span class="ow">and</span>
                            <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_collapsed</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_kalman_gain</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">reorder_missing_matrix</span><span class="p">(</span>
                <span class="n">kalman_filter</span><span class="o">.</span><span class="n">kalman_gain</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">missing</span><span class="p">,</span> <span class="n">reorder_cols</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">prefix</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">prefix</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tmp1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">reorder_missing_matrix</span><span class="p">(</span>
                <span class="n">kalman_filter</span><span class="o">.</span><span class="n">tmp1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">missing</span><span class="p">,</span> <span class="n">reorder_cols</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">prefix</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">prefix</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tmp2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">reorder_missing_vector</span><span class="p">(</span>
                <span class="n">kalman_filter</span><span class="o">.</span><span class="n">tmp2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">missing</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">prefix</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tmp3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">reorder_missing_matrix</span><span class="p">(</span>
                <span class="n">kalman_filter</span><span class="o">.</span><span class="n">tmp3</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">missing</span><span class="p">,</span> <span class="n">reorder_rows</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">prefix</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">prefix</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tmp4</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">reorder_missing_matrix</span><span class="p">(</span>
                <span class="n">kalman_filter</span><span class="o">.</span><span class="n">tmp4</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">missing</span><span class="p">,</span> <span class="n">reorder_cols</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">reorder_rows</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">prefix</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">memory_no_gain</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_kalman_gain</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                    <span class="n">kalman_filter</span><span class="o">.</span><span class="n">kalman_gain</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tmp1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">kalman_filter</span><span class="o">.</span><span class="n">tmp1</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tmp2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">kalman_filter</span><span class="o">.</span><span class="n">tmp2</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tmp3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">kalman_filter</span><span class="o">.</span><span class="n">tmp3</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tmp4</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">kalman_filter</span><span class="o">.</span><span class="n">tmp4</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">kalman_filter</span><span class="o">.</span><span class="n">M</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">M_diffuse</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">kalman_filter</span><span class="o">.</span><span class="n">M_inf</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Note: use forecasts rather than forecast, so as not to interfer</span>
        <span class="c1"># with the `forecast` methods in subclasses</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">forecasts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">kalman_filter</span><span class="o">.</span><span class="n">forecast</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">forecasts_error</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="n">kalman_filter</span><span class="o">.</span><span class="n">forecast_error</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">forecasts_error_cov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="n">kalman_filter</span><span class="o">.</span><span class="n">forecast_error_cov</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>
        <span class="c1"># Note: below we will set self.llf, and in the memory_no_likelihood</span>
        <span class="c1"># case we will replace self.llf_obs = None at that time.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">llf_obs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">kalman_filter</span><span class="o">.</span><span class="n">loglikelihood</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Diffuse objects</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nobs_diffuse</span> <span class="o">=</span> <span class="n">kalman_filter</span><span class="o">.</span><span class="n">nobs_diffuse</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initial_diffuse_state_cov</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">forecasts_error_diffuse_cov</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">predicted_diffuse_state_cov</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs_diffuse</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">initial_diffuse_state_cov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="n">kalman_filter</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">initial_diffuse_state_cov</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">predicted_diffuse_state_cov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                    <span class="n">kalman_filter</span><span class="o">.</span><span class="n">predicted_diffuse_state_cov</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">has_missing</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_collapsed</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">forecasts_error_diffuse_cov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                    <span class="n">reorder_missing_matrix</span><span class="p">(</span>
                        <span class="n">kalman_filter</span><span class="o">.</span><span class="n">forecast_error_diffuse_cov</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">missing</span><span class="p">,</span> <span class="n">reorder_cols</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">reorder_rows</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                        <span class="n">prefix</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">prefix</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">forecasts_error_diffuse_cov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                    <span class="n">kalman_filter</span><span class="o">.</span><span class="n">forecast_error_diffuse_cov</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># If there was missing data, save the original values from the Kalman</span>
        <span class="c1"># filter output, since below will set the values corresponding to</span>
        <span class="c1"># the missing observations to nans.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">missing_forecasts</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">missing_forecasts_error</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">missing_forecasts_error_cov</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nmissing</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Copy the provided arrays (which are as the Kalman filter dataset)</span>
            <span class="c1"># into new variables</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">missing_forecasts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">forecasts</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">missing_forecasts_error</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">forecasts_error</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">missing_forecasts_error_cov</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">forecasts_error_cov</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="c1"># Save the collapsed values</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">collapsed_forecasts</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">collapsed_forecasts_error</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">collapsed_forecasts_error_cov</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_collapsed</span><span class="p">:</span>
            <span class="c1"># Copy the provided arrays (which are from the collapsed dataset)</span>
            <span class="c1"># into new variables</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">collapsed_forecasts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">forecasts</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">k_states</span><span class="p">,</span> <span class="p">:]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">collapsed_forecasts_error</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">forecasts_error</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">k_states</span><span class="p">,</span> <span class="p">:]</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">collapsed_forecasts_error_cov</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">forecasts_error_cov</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">k_states</span><span class="p">,</span> <span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">k_states</span><span class="p">,</span> <span class="p">:]</span>
            <span class="p">)</span>
            <span class="c1"># Recreate the original arrays (which should be from the original</span>
            <span class="c1"># dataset) in the appropriate dimension</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">collapsed_forecasts</span><span class="o">.</span><span class="n">dtype</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">forecasts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">forecasts_error</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="p">),</span>
                                            <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">forecasts_error_cov</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="c1"># Fill in missing values in the forecast, forecast error, and</span>
        <span class="c1"># forecast error covariance matrix (this is required due to how the</span>
        <span class="c1"># Kalman filter implements observations that are either partly or</span>
        <span class="c1"># completely missing)</span>
        <span class="c1"># Construct the predictions, forecasts</span>
        <span class="n">can_compute_mean</span> <span class="o">=</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">memory_no_forecast_mean</span> <span class="ow">or</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">memory_no_predicted_mean</span><span class="p">)</span>
        <span class="n">can_compute_cov</span> <span class="o">=</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">memory_no_forecast_cov</span> <span class="ow">or</span>
                               <span class="bp">self</span><span class="o">.</span><span class="n">memory_no_predicted_cov</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">can_compute_mean</span> <span class="ow">or</span> <span class="n">can_compute_cov</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="p">):</span>
                <span class="n">design_t</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">design</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">t</span>
                <span class="n">obs_cov_t</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">obs_cov</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">t</span>
                <span class="n">obs_intercept_t</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">obs_intercept</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">t</span>

                <span class="c1"># For completely missing observations, the Kalman filter will</span>
                <span class="c1"># produce forecasts, but forecast errors and the forecast</span>
                <span class="c1"># error covariance matrix will be zeros - make them nan to</span>
                <span class="c1"># improve clarity of results.</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nmissing</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">mask</span> <span class="o">=</span> <span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">missing</span><span class="p">[:,</span> <span class="n">t</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>
                    <span class="c1"># We can recover forecasts</span>
                    <span class="c1"># For partially missing observations, the Kalman filter</span>
                    <span class="c1"># will produce all elements (forecasts, forecast errors,</span>
                    <span class="c1"># forecast error covariance matrices) as usual, but their</span>
                    <span class="c1"># dimension will only be equal to the number of non-missing</span>
                    <span class="c1"># elements, and their location in memory will be in the</span>
                    <span class="c1"># first blocks (e.g. for the forecasts_error, the first</span>
                    <span class="c1"># k_endog - nmissing[t] columns will be filled in),</span>
                    <span class="c1"># regardless of which endogenous variables they refer to</span>
                    <span class="c1"># (i.e. the non- missing endogenous variables for that</span>
                    <span class="c1"># observation). Furthermore, the forecast error covariance</span>
                    <span class="c1"># matrix is only valid for those elements. What is done is</span>
                    <span class="c1"># to set all elements to nan for these observations so that</span>
                    <span class="c1"># they are flagged as missing. The variables</span>
                    <span class="c1"># missing_forecasts, etc. then provide the forecasts, etc.</span>
                    <span class="c1"># provided by the Kalman filter, from which the data can be</span>
                    <span class="c1"># retrieved if desired.</span>
                    <span class="k">if</span> <span class="n">can_compute_mean</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">forecasts</span><span class="p">[:,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">design</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">design_t</span><span class="p">],</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">predicted_state</span><span class="p">[:,</span> <span class="n">t</span><span class="p">]</span>
                        <span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">obs_intercept</span><span class="p">[:,</span> <span class="n">obs_intercept_t</span><span class="p">]</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">forecasts_error</span><span class="p">[:,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">forecasts_error</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">endog</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">forecasts</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span> <span class="n">t</span><span class="p">])</span>
                    <span class="c1"># TODO: We should only fill in the non-masked elements of</span>
                    <span class="c1"># this array. Also, this will give the multivariate version</span>
                    <span class="c1"># even if univariate filtering was selected. Instead, we</span>
                    <span class="c1"># should use the reordering methods and then replace the</span>
                    <span class="c1"># masked values with NaNs</span>
                    <span class="k">if</span> <span class="n">can_compute_cov</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">forecasts_error_cov</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
                            <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">design</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">design_t</span><span class="p">],</span>
                                   <span class="bp">self</span><span class="o">.</span><span class="n">predicted_state_cov</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">t</span><span class="p">]),</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">design</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">design_t</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>
                        <span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">obs_cov</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">obs_cov_t</span><span class="p">]</span>
                <span class="c1"># In the collapsed case, everything just needs to be rebuilt</span>
                <span class="c1"># for the original observed data, since the Kalman filter</span>
                <span class="c1"># produced these values for the collapsed data.</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_collapsed</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">can_compute_mean</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">forecasts</span><span class="p">[:,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">design</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">design_t</span><span class="p">],</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">predicted_state</span><span class="p">[:,</span> <span class="n">t</span><span class="p">]</span>
                        <span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">obs_intercept</span><span class="p">[:,</span> <span class="n">obs_intercept_t</span><span class="p">]</span>

                        <span class="bp">self</span><span class="o">.</span><span class="n">forecasts_error</span><span class="p">[:,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">endog</span><span class="p">[:,</span> <span class="n">t</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">forecasts</span><span class="p">[:,</span> <span class="n">t</span><span class="p">]</span>
                        <span class="p">)</span>

                    <span class="k">if</span> <span class="n">can_compute_cov</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">forecasts_error_cov</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
                            <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">design</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">design_t</span><span class="p">],</span>
                                   <span class="bp">self</span><span class="o">.</span><span class="n">predicted_state_cov</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">t</span><span class="p">]),</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">design</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">design_t</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>
                        <span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">obs_cov</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">obs_cov_t</span><span class="p">]</span>

        <span class="c1"># Note: if we concentrated out the scale, need to adjust the</span>
        <span class="c1"># loglikelihood values and all of the covariance matrices and the</span>
        <span class="c1"># values that depend on the covariance matrices</span>
        <span class="c1"># Note: concentrated computation is not permitted with collapsed</span>
        <span class="c1"># version, so we do not need to modify collapsed arrays.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scale</span> <span class="o">=</span> <span class="mf">1.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_concentrated</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">_scale</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loglikelihood_burn</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs_diffuse</span><span class="p">)</span>
            <span class="c1"># Compute the scale</span>
            <span class="n">nmissing</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">kalman_filter</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">nmissing</span><span class="p">)</span>
            <span class="n">nobs_k_endog</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span> <span class="o">-</span> <span class="n">nmissing</span><span class="p">[</span><span class="n">d</span><span class="p">:])</span>

            <span class="c1"># In the univariate case, we need to subtract observations</span>
            <span class="c1"># associated with a singular forecast error covariance matrix</span>
            <span class="n">nobs_k_endog</span> <span class="o">-=</span> <span class="n">kalman_filter</span><span class="o">.</span><span class="n">nobs_kendog_univariate_singular</span>

            <span class="n">scale_obs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">kalman_filter</span><span class="o">.</span><span class="n">scale</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">memory_no_likelihood</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">scale</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">scale_obs</span><span class="p">[</span><span class="n">d</span><span class="p">:])</span> <span class="o">/</span> <span class="n">nobs_k_endog</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">scale</span> <span class="o">=</span> <span class="n">scale_obs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">nobs_k_endog</span>

            <span class="c1"># Need to modify this for diffuse initialization, since for</span>
            <span class="c1"># diffuse periods we only need to add in the scale value if the</span>
            <span class="c1"># diffuse forecast error covariance matrix element was singular</span>
            <span class="n">nsingular</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="n">kalman_filter</span><span class="o">.</span><span class="n">nobs_diffuse</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">Finf</span> <span class="o">=</span> <span class="n">kalman_filter</span><span class="o">.</span><span class="n">forecast_error_diffuse_cov</span>
                <span class="n">singular</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diagonal</span><span class="p">(</span><span class="n">Finf</span><span class="p">)</span><span class="o">.</span><span class="n">real</span> <span class="o">&lt;=</span>
                            <span class="n">kalman_filter</span><span class="o">.</span><span class="n">tolerance_diffuse</span><span class="p">)</span>
                <span class="n">nsingular</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">~</span><span class="n">singular</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

            <span class="c1"># Adjust the loglikelihood obs (see `KalmanFilter.loglikeobs` for</span>
            <span class="c1"># defaults on the adjustment)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">memory_no_likelihood</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">llf_obs</span> <span class="o">+=</span> <span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span>
                    <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span> <span class="o">-</span> <span class="n">nmissing</span> <span class="o">-</span> <span class="n">nsingular</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">)</span>
                    <span class="o">+</span> <span class="n">scale_obs</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">llf_obs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                    <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span> <span class="o">-</span> <span class="n">nmissing</span> <span class="o">-</span> <span class="n">nsingular</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">))</span>
                    <span class="o">+</span> <span class="n">scale_obs</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">)</span>

            <span class="c1"># Scale the filter output</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">obs_cov</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">obs_cov</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">state_cov</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">state_cov</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">initial_state_cov</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">initial_state_cov</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">predicted_state_cov</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predicted_state_cov</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">filtered_state_cov</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filtered_state_cov</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">forecasts_error_cov</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">forecasts_error_cov</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">missing_forecasts_error_cov</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">missing_forecasts_error_cov</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">missing_forecasts_error_cov</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">)</span>

            <span class="c1"># Note: do not have to adjust the Kalman gain or tmp4</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tmp1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tmp1</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tmp2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tmp2</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tmp3</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tmp3</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">memory_no_std_forecast</span> <span class="ow">or</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">invert_lu</span> <span class="ow">or</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">solve_lu</span> <span class="ow">or</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">filter_collapsed</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_standardized_forecasts_error</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_standardized_forecasts_error</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="o">**</span><span class="mf">0.5</span><span class="p">)</span>
        <span class="c1"># The self.model._scale value is only not None within a fixed_scale</span>
        <span class="c1"># context, in which case it is set and indicates that we should</span>
        <span class="c1"># generally view this results object as using a concentrated scale</span>
        <span class="c1"># (e.g. for d.o.f. computations), but because the fixed scale was</span>
        <span class="c1"># actually applied to the model prior to filtering, we do not need to</span>
        <span class="c1"># make any adjustments to the filter output, etc.</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">_scale</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">filter_concentrated</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">_scale</span>

        <span class="c1"># Now, save self.llf, and handle the memory_no_likelihood case</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">memory_no_likelihood</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">llf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">llf_obs</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">loglikelihood_burn</span><span class="p">:])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">llf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">llf_obs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">llf_obs</span> <span class="o">=</span> <span class="kc">None</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">kalman_gain</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Kalman gain matrices</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kalman_gain</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># k x n</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_kalman_gain</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_states</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="p">):</span>
                <span class="c1"># In the case of entirely missing observations, let the Kalman</span>
                <span class="c1"># gain be zeros.</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nmissing</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="n">design_t</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">design</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">t</span>
                <span class="n">transition_t</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">transition</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">t</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nmissing</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_kalman_gain</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">transition</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">transition_t</span><span class="p">],</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">predicted_state_cov</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">t</span><span class="p">]</span>
                        <span class="p">),</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
                            <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">design</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">design_t</span><span class="p">]),</span>
                            <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">forecasts_error_cov</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">t</span><span class="p">])</span>
                        <span class="p">)</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">mask</span> <span class="o">=</span> <span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">missing</span><span class="p">[:,</span> <span class="n">t</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>
                    <span class="n">F</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">forecasts_error_cov</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="p">[</span><span class="n">t</span><span class="p">])]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_kalman_gain</span><span class="p">[:,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">transition</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">transition_t</span><span class="p">],</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">predicted_state_cov</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">t</span><span class="p">]</span>
                        <span class="p">),</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
                            <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">design</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span> <span class="p">:,</span> <span class="n">design_t</span><span class="p">]),</span>
                            <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">F</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">])</span>
                        <span class="p">)</span>
                    <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kalman_gain</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">standardized_forecasts_error</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">"""</span>
<span class="sd">        Standardized forecast errors</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The forecast errors produced by the Kalman filter are</span>

<span class="sd">        .. math::</span>

<span class="sd">            v_t \sim N(0, F_t)</span>

<span class="sd">        Hypothesis tests are usually applied to the standardized residuals</span>

<span class="sd">        .. math::</span>

<span class="sd">            v_t^s = B_t v_t \sim N(0, I)</span>

<span class="sd">        where :math:`B_t = L_t^{-1}` and :math:`F_t = L_t L_t'`; then</span>
<span class="sd">        :math:`F_t^{-1} = (L_t')^{-1} L_t^{-1} = B_t' B_t`; :math:`B_t`</span>
<span class="sd">        and :math:`L_t` are lower triangular. Finally,</span>
<span class="sd">        :math:`B_t v_t \sim N(0, B_t F_t B_t')` and</span>
<span class="sd">        :math:`B_t F_t B_t' = L_t^{-1} L_t L_t' (L_t')^{-1} = I`.</span>

<span class="sd">        Thus we can rewrite :math:`v_t^s = L_t^{-1} v_t` or</span>
<span class="sd">        :math:`L_t v_t^s = v_t`; the latter equation is the form required to</span>
<span class="sd">        use a linear solver to recover :math:`v_t^s`. Since :math:`L_t` is</span>
<span class="sd">        lower triangular, we can use a triangular solver (?TRTRS).</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_standardized_forecasts_error</span> <span class="ow">is</span> <span class="kc">None</span>
                <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">memory_no_forecast</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_standardized_forecasts_error</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">forecasts_error</span> <span class="o">/</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">forecasts_error_cov</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:]</span><span class="o">**</span><span class="mf">0.5</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">linalg</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_standardized_forecasts_error</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">forecasts_error</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">forecasts_error_cov</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]):</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nmissing</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_standardized_forecasts_error</span><span class="p">[:,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nmissing</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">:</span>
                        <span class="n">mask</span> <span class="o">=</span> <span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">missing</span><span class="p">[:,</span> <span class="n">t</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>
                        <span class="n">F</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">forecasts_error_cov</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="p">[</span><span class="n">t</span><span class="p">])]</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="n">upper</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">cho_factor</span><span class="p">(</span><span class="n">F</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">])</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_standardized_forecasts_error</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                                <span class="n">linalg</span><span class="o">.</span><span class="n">solve_triangular</span><span class="p">(</span>
                                    <span class="n">upper</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">forecasts_error</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span> <span class="n">t</span><span class="p">],</span>
                                    <span class="n">trans</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
                        <span class="k">except</span> <span class="n">linalg</span><span class="o">.</span><span class="n">LinAlgError</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_standardized_forecasts_error</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                                <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_standardized_forecasts_error</span>

<div class="viewcode-block" id="FilterResults.predict"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.kalman_filter.FilterResults.predict.html#statsmodels.tsa.statespace.simulation_smoother.FilterResults.predict">[docs]</a>    <span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dynamic</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">"""</span>
<span class="sd">        In-sample and out-of-sample prediction for state space models generally</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        start : int, optional</span>
<span class="sd">            Zero-indexed observation number at which to start prediction, i.e.,</span>
<span class="sd">            the first prediction will be at start.</span>
<span class="sd">        end : int, optional</span>
<span class="sd">            Zero-indexed observation number at which to end prediction, i.e.,</span>
<span class="sd">            the last prediction will be at end.</span>
<span class="sd">        dynamic : int, optional</span>
<span class="sd">            Offset relative to `start` at which to begin dynamic prediction.</span>
<span class="sd">            Prior to this observation, true endogenous values will be used for</span>
<span class="sd">            prediction; starting with this observation and continuing through</span>
<span class="sd">            the end of prediction, predicted endogenous values will be used</span>
<span class="sd">            instead.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            If the prediction range is outside of the sample range, any</span>
<span class="sd">            of the state space representation matrices that are time-varying</span>
<span class="sd">            must have updated values provided for the out-of-sample range.</span>
<span class="sd">            For example, of `obs_intercept` is a time-varying component and</span>
<span class="sd">            the prediction range extends 10 periods beyond the end of the</span>
<span class="sd">            sample, a (`k_endog` x 10) matrix must be provided with the new</span>
<span class="sd">            intercept values.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        results : kalman_filter.PredictionResults</span>
<span class="sd">            A PredictionResults object.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        All prediction is performed by applying the deterministic part of the</span>
<span class="sd">        measurement equation using the predicted state variables.</span>

<span class="sd">        Out-of-sample prediction first applies the Kalman filter to missing</span>
<span class="sd">        data for the number of periods desired to obtain the predicted states.</span>
<span class="sd">        """</span>
        <span class="c1"># Get the start and the end of the entire prediction range</span>
        <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">elif</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'Cannot predict values previous to the sample.'</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">end</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span>

        <span class="c1"># Prediction and forecasting is performed by iterating the Kalman</span>
        <span class="c1"># Kalman filter through the entire range [0, end]</span>
        <span class="c1"># Then, everything is returned corresponding to the range [start, end].</span>
        <span class="c1"># In order to perform the calculations, the range is separately split</span>
        <span class="c1"># up into the following categories:</span>
        <span class="c1"># - static:   (in-sample) the Kalman filter is run as usual</span>
        <span class="c1"># - dynamic:  (in-sample) the Kalman filter is run, but on missing data</span>
        <span class="c1"># - forecast: (out-of-sample) the Kalman filter is run, but on missing</span>
        <span class="c1">#             data</span>

        <span class="c1"># Short-circuit if end is before start</span>
        <span class="k">if</span> <span class="n">end</span> <span class="o">&lt;=</span> <span class="n">start</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'End of prediction must be after start.'</span><span class="p">)</span>

        <span class="c1"># Get the number of forecasts to make after the end of the sample</span>
        <span class="n">nforecast</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">end</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="p">)</span>

        <span class="c1"># Get the number of dynamic prediction periods</span>

        <span class="c1"># If `dynamic=True`, then assume that we want to begin dynamic</span>
        <span class="c1"># prediction at the start of the sample prediction.</span>
        <span class="k">if</span> <span class="n">dynamic</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">dynamic</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># If `dynamic=False`, then assume we want no dynamic prediction</span>
        <span class="k">if</span> <span class="n">dynamic</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">dynamic</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Check validity of dynamic and warn or error if issues</span>
        <span class="n">dynamic</span><span class="p">,</span> <span class="n">ndynamic</span> <span class="o">=</span> <span class="n">_check_dynamic</span><span class="p">(</span><span class="n">dynamic</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="p">)</span>

        <span class="c1"># Get the number of in-sample static predictions</span>
        <span class="k">if</span> <span class="n">dynamic</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">nstatic</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">end</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="p">)</span> <span class="o">-</span> <span class="nb">min</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># (use max(., 0), since dynamic can be prior to start)</span>
            <span class="n">nstatic</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">dynamic</span> <span class="o">-</span> <span class="n">start</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Cannot do in-sample prediction if we do not have appropriate</span>
        <span class="c1"># arrays (we can do out-of-sample forecasting, however)</span>
        <span class="k">if</span> <span class="n">nstatic</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">memory_no_forecast_mean</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'In-sample prediction is not available if memory'</span>
                             <span class="s1">' conservation has been used to avoid storing'</span>
                             <span class="s1">' forecast means.'</span><span class="p">)</span>
        <span class="c1"># Cannot do dynamic in-sample prediction if we do not have appropriate</span>
        <span class="c1"># arrays (we can do out-of-sample forecasting, however)</span>
        <span class="k">if</span> <span class="n">ndynamic</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">memory_no_predicted</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'In-sample dynamic prediction is not available if'</span>
                             <span class="s1">' memory conservation has been used to avoid'</span>
                             <span class="s1">' storing forecasted or predicted state means'</span>
                             <span class="s1">' or covariances.'</span><span class="p">)</span>

        <span class="c1"># Construct the predicted state and covariance matrix for each time</span>
        <span class="c1"># period depending on whether that time period corresponds to</span>
        <span class="c1"># one-step-ahead prediction, dynamic prediction, or out-of-sample</span>
        <span class="c1"># forecasting.</span>

        <span class="c1"># If we only have simple prediction, then we can use the already saved</span>
        <span class="c1"># Kalman filter output</span>
        <span class="k">if</span> <span class="n">ndynamic</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">nforecast</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">results</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="c1"># If we have dynamic prediction or forecasting, then we need to</span>
        <span class="c1"># re-apply the Kalman filter</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Figure out the period for which we need to run the Kalman filter</span>
            <span class="k">if</span> <span class="n">dynamic</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">kf_start</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">dynamic</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">kf_start</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="p">)</span>
            <span class="n">kf_end</span> <span class="o">=</span> <span class="n">end</span>

            <span class="c1"># Make start, end consistent with the results that we're generating</span>
            <span class="n">start</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">start</span> <span class="o">-</span> <span class="n">kf_start</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">end</span> <span class="o">=</span> <span class="n">kf_end</span> <span class="o">-</span> <span class="n">kf_start</span>

            <span class="c1"># We must at least store forecasts and predictions</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">'conserve_memory'</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">conserve_memory</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">MEMORY_NO_FORECAST</span> <span class="o">&amp;</span>
                <span class="o">~</span><span class="n">MEMORY_NO_PREDICTED</span><span class="p">)</span>

            <span class="c1"># Can't use Chandrasekhar recursions for prediction</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">'filter_method'</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">filter_method</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">FILTER_CHANDRASEKHAR</span><span class="p">)</span>

            <span class="c1"># Even if we have not stored all predicted values (means and covs),</span>
            <span class="c1"># we can still do pure out-of-sample forecasting because we will</span>
            <span class="c1"># always have stored the last predicted values. In this case, we</span>
            <span class="c1"># will initialize the forecasting filter with these values</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">memory_no_predicted</span><span class="p">:</span>
                <span class="n">constant</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predicted_state</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">stationary_cov</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predicted_state_cov</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="c1"># Otherwise initialize with the predicted state / cov from the</span>
            <span class="c1"># existing results, at index kf_start (note that the time</span>
            <span class="c1"># dimension of predicted_state and predicted_state_cov is</span>
            <span class="c1"># self.nobs + 1; so e.g. in the case of pure forecasting we should</span>
            <span class="c1"># be using the very last predicted state and predicted state cov</span>
            <span class="c1"># elements, and kf_start will equal self.nobs which is correct)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">constant</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predicted_state</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">kf_start</span><span class="p">]</span>
                <span class="n">stationary_cov</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predicted_state_cov</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">kf_start</span><span class="p">]</span>

            <span class="n">kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s1">'initialization'</span><span class="p">:</span> <span class="s1">'known'</span><span class="p">,</span>
                           <span class="s1">'constant'</span><span class="p">:</span> <span class="n">constant</span><span class="p">,</span>
                           <span class="s1">'stationary_cov'</span><span class="p">:</span> <span class="n">stationary_cov</span><span class="p">})</span>

            <span class="c1"># Construct the new endogenous array.</span>
            <span class="n">endog</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nforecast</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
                <span class="n">endog</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="n">kf_start</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="n">kf_end</span> <span class="o">-</span> <span class="n">nforecast</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="c1"># Have to retroactively modify the model's endog</span>
            <span class="k">if</span> <span class="n">ndynamic</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">model</span><span class="o">.</span><span class="n">endog</span><span class="p">[:,</span> <span class="o">-</span><span class="p">(</span><span class="n">ndynamic</span> <span class="o">+</span> <span class="n">nforecast</span><span class="p">):]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

            <span class="k">with</span> <span class="n">model</span><span class="o">.</span><span class="n">fixed_scale</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">):</span>
                <span class="n">results</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">filter</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">PredictionResults</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">nstatic</span><span class="p">,</span> <span class="n">ndynamic</span><span class="p">,</span>
                                 <span class="n">nforecast</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="PredictionResults"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.kalman_filter.PredictionResults.html#statsmodels.tsa.statespace.simulation_smoother.PredictionResults">[docs]</a><span class="k">class</span> <span class="nc">PredictionResults</span><span class="p">(</span><span class="n">FilterResults</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">"""</span>
<span class="sd">    Results of in-sample and out-of-sample prediction for state space models</span>
<span class="sd">    generally</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    results : FilterResults</span>
<span class="sd">        Output from filtering, corresponding to the prediction desired</span>
<span class="sd">    start : int</span>
<span class="sd">        Zero-indexed observation number at which to start forecasting,</span>
<span class="sd">        i.e., the first forecast will be at start.</span>
<span class="sd">    end : int</span>
<span class="sd">        Zero-indexed observation number at which to end forecasting, i.e.,</span>
<span class="sd">        the last forecast will be at end.</span>
<span class="sd">    nstatic : int</span>
<span class="sd">        Number of in-sample static predictions (these are always the first</span>
<span class="sd">        elements of the prediction output).</span>
<span class="sd">    ndynamic : int</span>
<span class="sd">        Number of in-sample dynamic predictions (these always follow the static</span>
<span class="sd">        predictions directly, and are directly followed by the forecasts).</span>
<span class="sd">    nforecast : int</span>
<span class="sd">        Number of in-sample forecasts (these always follow the dynamic</span>
<span class="sd">        predictions directly).</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    npredictions : int</span>
<span class="sd">        Number of observations in the predicted series; this is not necessarily</span>
<span class="sd">        the same as the number of observations in the original model from which</span>
<span class="sd">        prediction was performed.</span>
<span class="sd">    start : int</span>
<span class="sd">        Zero-indexed observation number at which to start prediction,</span>
<span class="sd">        i.e., the first predict will be at `start`; this is relative to the</span>
<span class="sd">        original model from which prediction was performed.</span>
<span class="sd">    end : int</span>
<span class="sd">        Zero-indexed observation number at which to end prediction,</span>
<span class="sd">        i.e., the last predict will be at `end`; this is relative to the</span>
<span class="sd">        original model from which prediction was performed.</span>
<span class="sd">    nstatic : int</span>
<span class="sd">        Number of in-sample static predictions.</span>
<span class="sd">    ndynamic : int</span>
<span class="sd">        Number of in-sample dynamic predictions.</span>
<span class="sd">    nforecast : int</span>
<span class="sd">        Number of in-sample forecasts.</span>
<span class="sd">    endog : ndarray</span>
<span class="sd">        The observation vector.</span>
<span class="sd">    design : ndarray</span>
<span class="sd">        The design matrix, :math:`Z`.</span>
<span class="sd">    obs_intercept : ndarray</span>
<span class="sd">        The intercept for the observation equation, :math:`d`.</span>
<span class="sd">    obs_cov : ndarray</span>
<span class="sd">        The covariance matrix for the observation equation :math:`H`.</span>
<span class="sd">    transition : ndarray</span>
<span class="sd">        The transition matrix, :math:`T`.</span>
<span class="sd">    state_intercept : ndarray</span>
<span class="sd">        The intercept for the transition equation, :math:`c`.</span>
<span class="sd">    selection : ndarray</span>
<span class="sd">        The selection matrix, :math:`R`.</span>
<span class="sd">    state_cov : ndarray</span>
<span class="sd">        The covariance matrix for the state equation :math:`Q`.</span>
<span class="sd">    filtered_state : ndarray</span>
<span class="sd">        The filtered state vector at each time period.</span>
<span class="sd">    filtered_state_cov : ndarray</span>
<span class="sd">        The filtered state covariance matrix at each time period.</span>
<span class="sd">    predicted_state : ndarray</span>
<span class="sd">        The predicted state vector at each time period.</span>
<span class="sd">    predicted_state_cov : ndarray</span>
<span class="sd">        The predicted state covariance matrix at each time period.</span>
<span class="sd">    forecasts : ndarray</span>
<span class="sd">        The one-step-ahead forecasts of observations at each time period.</span>
<span class="sd">    forecasts_error : ndarray</span>
<span class="sd">        The forecast errors at each time period.</span>
<span class="sd">    forecasts_error_cov : ndarray</span>
<span class="sd">        The forecast error covariance matrices at each time period.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The provided ranges must be conformable, meaning that it must be that</span>
<span class="sd">    `end - start == nstatic + ndynamic + nforecast`.</span>

<span class="sd">    This class is essentially a view to the FilterResults object, but</span>
<span class="sd">    returning the appropriate ranges for everything.</span>
<span class="sd">    """</span>
    <span class="n">representation_attributes</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s1">'endog'</span><span class="p">,</span> <span class="s1">'design'</span><span class="p">,</span> <span class="s1">'design'</span><span class="p">,</span> <span class="s1">'obs_intercept'</span><span class="p">,</span>
        <span class="s1">'obs_cov'</span><span class="p">,</span> <span class="s1">'transition'</span><span class="p">,</span> <span class="s1">'state_intercept'</span><span class="p">,</span> <span class="s1">'selection'</span><span class="p">,</span>
        <span class="s1">'state_cov'</span>
    <span class="p">]</span>
    <span class="n">filter_attributes</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s1">'filtered_state'</span><span class="p">,</span> <span class="s1">'filtered_state_cov'</span><span class="p">,</span>
        <span class="s1">'predicted_state'</span><span class="p">,</span> <span class="s1">'predicted_state_cov'</span><span class="p">,</span>
        <span class="s1">'forecasts'</span><span class="p">,</span> <span class="s1">'forecasts_error'</span><span class="p">,</span> <span class="s1">'forecasts_error_cov'</span>
    <span class="p">]</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">results</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">nstatic</span><span class="p">,</span> <span class="n">ndynamic</span><span class="p">,</span> <span class="n">nforecast</span><span class="p">):</span>
        <span class="c1"># Save the filter results object</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">results</span> <span class="o">=</span> <span class="n">results</span>

        <span class="c1"># Save prediction ranges</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">npredictions</span> <span class="o">=</span> <span class="n">start</span> <span class="o">-</span> <span class="n">end</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">start</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">end</span> <span class="o">=</span> <span class="n">end</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nstatic</span> <span class="o">=</span> <span class="n">nstatic</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ndynamic</span> <span class="o">=</span> <span class="n">ndynamic</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nforecast</span> <span class="o">=</span> <span class="n">nforecast</span>

<div class="viewcode-block" id="PredictionResults.clear"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.kalman_filter.PredictionResults.clear.html#statsmodels.tsa.statespace.simulation_smoother.PredictionResults.clear">[docs]</a>    <span class="k">def</span> <span class="nf">clear</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">attributes</span> <span class="o">=</span> <span class="p">([</span><span class="s1">'endog'</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">representation_attributes</span>
                      <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_attributes</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">attributes</span><span class="p">:</span>
            <span class="n">_attr</span> <span class="o">=</span> <span class="s1">'_'</span> <span class="o">+</span> <span class="n">attr</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_attr</span><span class="p">):</span>
                <span class="nb">delattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_attr</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Provide access to the representation and filtered output in the</span>
<span class="sd">        appropriate range (`start` - `end`).</span>
<span class="sd">        """</span>
        <span class="c1"># Prevent infinite recursive lookups</span>
        <span class="k">if</span> <span class="n">attr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">'_'</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">"'</span><span class="si">%s</span><span class="s2">' object has no attribute '</span><span class="si">%s</span><span class="s2">'"</span> <span class="o">%</span>
                                 <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">attr</span><span class="p">))</span>

        <span class="n">_attr</span> <span class="o">=</span> <span class="s1">'_'</span> <span class="o">+</span> <span class="n">attr</span>

        <span class="c1"># Cache the attribute</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_attr</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">attr</span> <span class="o">==</span> <span class="s1">'endog'</span> <span class="ow">or</span> <span class="n">attr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_attributes</span><span class="p">:</span>
                <span class="c1"># Get a copy</span>
                <span class="n">value</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="c1"># Subset to the correct time frame</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">end</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">attr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">representation_attributes</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="c1"># If a time-invariant matrix, return it. Otherwise, subset to</span>
                <span class="c1"># the correct period.</span>
                <span class="k">if</span> <span class="n">value</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">end</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">"'</span><span class="si">%s</span><span class="s2">' object has no attribute '</span><span class="si">%s</span><span class="s2">'"</span> <span class="o">%</span>
                                     <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">attr</span><span class="p">))</span>

            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_attr</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_attr</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">_check_dynamic</span><span class="p">(</span><span class="n">dynamic</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">nobs</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    Verify dynamic and warn or error if issues</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    dynamic : {int, None}</span>
<span class="sd">        The offset relative to start of the dynamic forecasts. None if no</span>
<span class="sd">        dynamic forecasts are required.</span>
<span class="sd">    start : int</span>
<span class="sd">        The location of the first forecast.</span>
<span class="sd">    end : int</span>
<span class="sd">        The location of the final forecast (inclusive).</span>
<span class="sd">    nobs : int</span>
<span class="sd">        The number of observations in the time series.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dynamic : {int, None}</span>
<span class="sd">        The start location of the first dynamic forecast. None if there</span>
<span class="sd">        are no in-sample dynamic forecasts.</span>
<span class="sd">    ndynamic : int</span>
<span class="sd">        The number of dynamic forecasts</span>
<span class="sd">    """</span>
    <span class="k">if</span> <span class="n">dynamic</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">dynamic</span><span class="p">,</span> <span class="mi">0</span>

    <span class="c1"># Replace the relative dynamic offset with an absolute offset</span>
    <span class="n">dynamic</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">dynamic</span>

    <span class="c1"># Validate the `dynamic` parameter</span>
    <span class="k">if</span> <span class="n">dynamic</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'Dynamic prediction cannot begin prior to the'</span>
                         <span class="s1">' first observation in the sample.'</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">dynamic</span> <span class="o">&gt;</span> <span class="n">end</span><span class="p">:</span>
        <span class="n">warn</span><span class="p">(</span><span class="s1">'Dynamic prediction specified to begin after the end of'</span>
             <span class="s1">' prediction, and so has no effect.'</span><span class="p">,</span> <span class="n">ValueWarning</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="mi">0</span>
    <span class="k">elif</span> <span class="n">dynamic</span> <span class="o">&gt;</span> <span class="n">nobs</span><span class="p">:</span>
        <span class="n">warn</span><span class="p">(</span><span class="s1">'Dynamic prediction specified to begin during'</span>
             <span class="s1">' out-of-sample forecasting period, and so has no'</span>
             <span class="s1">' effect.'</span><span class="p">,</span> <span class="n">ValueWarning</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="mi">0</span>

    <span class="c1"># Get the total size of the desired dynamic forecasting component</span>
    <span class="c1"># Note: the first `dynamic` periods of prediction are actually</span>
    <span class="c1"># *not* dynamic, because dynamic prediction begins at observation</span>
    <span class="c1"># `dynamic`.</span>
    <span class="n">ndynamic</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">end</span><span class="p">,</span> <span class="n">nobs</span><span class="p">)</span> <span class="o">-</span> <span class="n">dynamic</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">dynamic</span><span class="p">,</span> <span class="n">ndynamic</span>
</pre></div>

          </article>
        </div>
      </div>
    </main>
  </div>
  <footer class="md-footer">
    <div class="md-footer-nav">
      <nav class="md-footer-nav__inner md-grid">
          
          
        </a>
        
      </nav>
    </div>
    <div class="md-footer-meta md-typeset">
      <div class="md-footer-meta__inner md-grid">
        <div class="md-footer-copyright">
          <div class="md-footer-copyright__highlight">
              &#169; Copyright 2009-2019, Josef Perktold, Skipper Seabold, Jonathan Taylor, statsmodels-developers.
              
          </div>
            Last updated on
              Nov 02, 2022.
            <br/>
            Created using
            <a href="http://www.sphinx-doc.org/">Sphinx</a> 5.3.0.
             and
            <a href="https://github.com/bashtage/sphinx-material/">Material for
              Sphinx</a>
        </div>
      </div>
    </div>
  </footer>
  <script src="../../../../_static/javascripts/application.js"></script>
  <script>app.initialize({version: "1.0.4", url: {base: ".."}})</script>
  </body>
</html>