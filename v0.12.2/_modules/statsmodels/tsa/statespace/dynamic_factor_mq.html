

<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <meta name="lang:clipboard.copy" content="Copy to clipboard">
  <meta name="lang:clipboard.copied" content="Copied to clipboard">
  <meta name="lang:search.language" content="en">
  <meta name="lang:search.pipeline.stopwords" content="True">
  <meta name="lang:search.pipeline.trimmer" content="True">
  <meta name="lang:search.result.none" content="No matching documents">
  <meta name="lang:search.result.one" content="1 matching document">
  <meta name="lang:search.result.other" content="# matching documents">
  <meta name="lang:search.tokenizer" content="[\s\-]+">

  
    <link href="https://fonts.gstatic.com/" rel="preconnect" crossorigin>
    <link href="https://fonts.googleapis.com/css?family=Roboto+Mono:400,500,700|Roboto:300,400,400i,700&display=fallback" rel="stylesheet">

    <style>
      body,
      input {
        font-family: "Roboto", "Helvetica Neue", Helvetica, Arial, sans-serif
      }

      code,
      kbd,
      pre {
        font-family: "Roboto Mono", "Courier New", Courier, monospace
      }
    </style>
  

  <link rel="stylesheet" href="../../../../_static/stylesheets/application.css"/>
  <link rel="stylesheet" href="../../../../_static/stylesheets/application-palette.css"/>
  <link rel="stylesheet" href="../../../../_static/stylesheets/application-fixes.css"/>
  
  <link rel="stylesheet" href="../../../../_static/fonts/material-icons.css"/>
  
  <meta name="theme-color" content="#3f51b5">
  <script src="../../../../_static/javascripts/modernizr.js"></script>
  
  
  
    <title>statsmodels.tsa.statespace.dynamic_factor_mq &#8212; statsmodels</title>
  <link rel="icon" type="image/png" sizes="32x32" href="../../../../_static/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="../../../../_static/icons/favicon-16x16.png">
  <link rel="manifest" href="../../../../_static/icons/site.webmanifest">
  <link rel="mask-icon" href="../../../../_static/icons/safari-pinned-tab.svg" color="#919191">
  <meta name="msapplication-TileColor" content="#2b5797">
  <meta name="msapplication-config" content="../../../../_static/icons/browserconfig.xml">
  <link rel="stylesheet" href="../../../../_static/stylesheets/examples.css">
  <link rel="stylesheet" href="../../../../_static/stylesheets/deprecation.css">
    <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/material.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/graphviz.css" />
    <script id="documentation_options" data-url_root="../../../../" src="../../../../_static/documentation_options.js"></script>
    <script src="../../../../_static/jquery.js"></script>
    <script src="../../../../_static/underscore.js"></script>
    <script src="../../../../_static/doctools.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
    <link rel="shortcut icon" href="../../../../_static/favicon.ico"/>
    <link rel="author" title="About these documents" href="../../../../about.html" />
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
  
   

  </head>
  <body dir=ltr
        data-md-color-primary=indigo data-md-color-accent=blue>
  
  <svg class="md-svg">
    <defs data-children-count="0">
      
      <svg xmlns="http://www.w3.org/2000/svg" width="416" height="448" viewBox="0 0 416 448" id="__github"><path fill="currentColor" d="M160 304q0 10-3.125 20.5t-10.75 19T128 352t-18.125-8.5-10.75-19T96 304t3.125-20.5 10.75-19T128 256t18.125 8.5 10.75 19T160 304zm160 0q0 10-3.125 20.5t-10.75 19T288 352t-18.125-8.5-10.75-19T256 304t3.125-20.5 10.75-19T288 256t18.125 8.5 10.75 19T320 304zm40 0q0-30-17.25-51T296 232q-10.25 0-48.75 5.25Q229.5 240 208 240t-39.25-2.75Q130.75 232 120 232q-29.5 0-46.75 21T56 304q0 22 8 38.375t20.25 25.75 30.5 15 35 7.375 37.25 1.75h42q20.5 0 37.25-1.75t35-7.375 30.5-15 20.25-25.75T360 304zm56-44q0 51.75-15.25 82.75-9.5 19.25-26.375 33.25t-35.25 21.5-42.5 11.875-42.875 5.5T212 416q-19.5 0-35.5-.75t-36.875-3.125-38.125-7.5-34.25-12.875T37 371.5t-21.5-28.75Q0 312 0 260q0-59.25 34-99-6.75-20.5-6.75-42.5 0-29 12.75-54.5 27 0 47.5 9.875t47.25 30.875Q171.5 96 212 96q37 0 70 8 26.25-20.5 46.75-30.25T376 64q12.75 25.5 12.75 54.5 0 21.75-6.75 42 34 40 34 99.5z"/></svg>
      
    </defs>
  </svg>
  
  <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer">
  <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search">
  <label class="md-overlay" data-md-component="overlay" for="__drawer"></label>
  <a href="#_modules/statsmodels/tsa/statespace/dynamic_factor_mq" tabindex="1" class="md-skip"> Skip to content </a>
  <header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid">
    <div class="md-flex navheader">
      <div class="md-flex__cell md-flex__cell--shrink">
        <a href="../../../../index.html" title="statsmodels"
           class="md-header-nav__button md-logo">
          
              <img src="../../../../_static/statsmodels-logo-v2-bw.svg" height="26"
                   alt="statsmodels logo">
          
        </a>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        <label class="md-icon md-icon--menu md-header-nav__button" for="__drawer"></label>
      </div>
      <div class="md-flex__cell md-flex__cell--stretch">
        <div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
          <span class="md-header-nav__topic">statsmodels v0.12.2</span>
          <span class="md-header-nav__topic"> statsmodels.tsa.statespace.dynamic_factor_mq </span>
        </div>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        <label class="md-icon md-icon--search md-header-nav__button" for="__search"></label>
        
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" action="../../../../search.html" method="GET" name="search">
      <input type="text" class="md-search__input" name="q" placeholder="Search"
             autocapitalize="off" autocomplete="off" spellcheck="false"
             data-md-component="query" data-md-state="active">
      <label class="md-icon md-search__icon" for="__search"></label>
      <button type="reset" class="md-icon md-search__icon" data-md-component="reset" tabindex="-1">
        &#xE5CD;
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="result">
          <div class="md-search-result__meta">
            Type to start searching
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>

      </div>
      
        <div class="md-flex__cell md-flex__cell--shrink">
          <div class="md-header-nav__source">
            <a href="https://github.com/statsmodels/statsmodels" title="Go to repository" class="md-source" data-md-source="github">

    <div class="md-source__icon">
      <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24" width="28" height="28">
        <use xlink:href="#__github" width="24" height="24"></use>
      </svg>
    </div>
  
  <div class="md-source__repository">
    statsmodels
  </div>
</a>
          </div>
        </div>
      
      
  
  <script src="../../../../_static/javascripts/version_dropdown.js"></script>
  <script>
    var json_loc = "../../../../_static/versions.json",
        target_loc = "../../../../../",
        text = "Versions";
    $( document ).ready( add_version_dropdown(json_loc, target_loc, text));
  </script>
  

    </div>
  </nav>
</header>

  
  <div class="md-container">
    
    
    
  <nav class="md-tabs" data-md-component="tabs">
    <div class="md-tabs__inner md-grid">
      <ul class="md-tabs__list">
          <li class="md-tabs__item"><a href="../../../index.html" class="md-tabs__link">Module code</a></li>
      </ul>
    </div>
  </nav>
    <main class="md-main">
      <div class="md-main__inner md-grid" data-md-component="container">
        
          <div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
            <div class="md-sidebar__scrollwrap">
              <div class="md-sidebar__inner">
                <nav class="md-nav md-nav--primary" data-md-level="0">
  <label class="md-nav__title md-nav__title--site" for="__drawer">
    <a href="../../../../index.html" title="statsmodels" class="md-nav__button md-logo">
      
        <img src="../../../../_static/statsmodels-logo-v2-bw.svg" alt=" logo" width="48" height="48">
      
    </a>
    <a href="../../../../index.html"
       title="statsmodels">statsmodels v0.12.2</a>
  </label>
    <div class="md-nav__source">
      <a href="https://github.com/statsmodels/statsmodels" title="Go to repository" class="md-source" data-md-source="github">

    <div class="md-source__icon">
      <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24" width="28" height="28">
        <use xlink:href="#__github" width="24" height="24"></use>
      </svg>
    </div>
  
  <div class="md-source__repository">
    statsmodels
  </div>
</a>
    </div>
  
  

  
  <ul class="md-nav__list">
    <li class="md-nav__item">
    
    
      <a href="../../../../install.html" class="md-nav__link">Installing statsmodels</a>
      
    
    </li>
    <li class="md-nav__item">
    
    
      <a href="../../../../gettingstarted.html" class="md-nav__link">Getting started</a>
      
    
    </li>
    <li class="md-nav__item">
    
    
      <a href="../../../../user-guide.html" class="md-nav__link">User Guide</a>
      
    
    </li>
    <li class="md-nav__item">
    
    
      <a href="../../../../examples/index.html" class="md-nav__link">Examples</a>
      
    
    </li>
    <li class="md-nav__item">
    
    
      <a href="../../../../api.html" class="md-nav__link">API Reference</a>
      
    
    </li>
    <li class="md-nav__item">
    
    
      <a href="../../../../about.html" class="md-nav__link">About statsmodels</a>
      
    
    </li>
    <li class="md-nav__item">
    
    
      <a href="../../../../dev/index.html" class="md-nav__link">Developer Page</a>
      
    
    </li>
    <li class="md-nav__item">
    
    
      <a href="../../../../release/index.html" class="md-nav__link">Release Notes</a>
      
    
    </li>
  </ul>
  

</nav>
              </div>
            </div>
          </div>
          <div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
            <div class="md-sidebar__scrollwrap">
              <div class="md-sidebar__inner">
                
<nav class="md-nav md-nav--secondary">
  <ul class="md-nav__list" data-md-scrollfix="">
    

<li id="searchbox" class="md-nav__item"></li>

  </ul>
</nav>
              </div>
            </div>
          </div>
        
        <div class="md-content">
          <article class="md-content__inner md-typeset" role="main">
            
  <h1 id="modules-statsmodels-tsa-statespace-dynamic-factor-mq--page-root">Source code for statsmodels.tsa.statespace.dynamic_factor_mq</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">"""</span>
<span class="sd">Dynamic factor model.</span>

<span class="sd">Author: Chad Fulton</span>
<span class="sd">License: BSD-3</span>
<span class="sd">"""</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">OrderedDict</span>
<span class="kn">from</span> <span class="nn">warnings</span> <span class="kn">import</span> <span class="n">warn</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">cho_factor</span><span class="p">,</span> <span class="n">cho_solve</span><span class="p">,</span> <span class="n">LinAlgError</span>

<span class="kn">from</span> <span class="nn">statsmodels.tools.data</span> <span class="kn">import</span> <span class="n">_is_using_pandas</span>
<span class="kn">from</span> <span class="nn">statsmodels.tools.validation</span> <span class="kn">import</span> <span class="n">int_like</span>
<span class="kn">from</span> <span class="nn">statsmodels.tools.decorators</span> <span class="kn">import</span> <span class="n">cache_readonly</span>
<span class="kn">from</span> <span class="nn">statsmodels.regression.linear_model</span> <span class="kn">import</span> <span class="n">OLS</span>
<span class="kn">from</span> <span class="nn">statsmodels.genmod.generalized_linear_model</span> <span class="kn">import</span> <span class="n">GLM</span>
<span class="kn">from</span> <span class="nn">statsmodels.multivariate.pca</span> <span class="kn">import</span> <span class="n">PCA</span>

<span class="kn">from</span> <span class="nn">statsmodels.tsa.statespace.sarimax</span> <span class="kn">import</span> <span class="n">SARIMAX</span>
<span class="kn">from</span> <span class="nn">statsmodels.tsa.statespace._quarterly_ar1</span> <span class="kn">import</span> <span class="n">QuarterlyAR1</span>
<span class="kn">from</span> <span class="nn">statsmodels.tsa.vector_ar.var_model</span> <span class="kn">import</span> <span class="n">VAR</span>
<span class="kn">from</span> <span class="nn">statsmodels.tools.tools</span> <span class="kn">import</span> <span class="n">Bunch</span>
<span class="kn">from</span> <span class="nn">statsmodels.tools.validation</span> <span class="kn">import</span> <span class="n">string_like</span>
<span class="kn">from</span> <span class="nn">statsmodels.tsa.tsatools</span> <span class="kn">import</span> <span class="n">lagmat</span>
<span class="kn">from</span> <span class="nn">statsmodels.tsa.statespace</span> <span class="kn">import</span> <span class="n">mlemodel</span><span class="p">,</span> <span class="n">initialization</span>
<span class="kn">from</span> <span class="nn">statsmodels.tsa.statespace.tools</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">companion_matrix</span><span class="p">,</span> <span class="n">is_invertible</span><span class="p">,</span> <span class="n">constrain_stationary_univariate</span><span class="p">,</span>
    <span class="n">constrain_stationary_multivariate</span><span class="p">,</span> <span class="n">unconstrain_stationary_univariate</span><span class="p">,</span>
    <span class="n">unconstrain_stationary_multivariate</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">statsmodels.tsa.statespace.kalman_smoother</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">SMOOTHER_STATE</span><span class="p">,</span> <span class="n">SMOOTHER_STATE_COV</span><span class="p">,</span> <span class="n">SMOOTHER_STATE_AUTOCOV</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">statsmodels.base.data</span> <span class="kn">import</span> <span class="n">PandasData</span>

<span class="kn">from</span> <span class="nn">statsmodels.iolib.table</span> <span class="kn">import</span> <span class="n">SimpleTable</span>
<span class="kn">from</span> <span class="nn">statsmodels.iolib.summary</span> <span class="kn">import</span> <span class="n">Summary</span>
<span class="kn">from</span> <span class="nn">statsmodels.iolib.tableformatting</span> <span class="kn">import</span> <span class="n">fmt_params</span>


<span class="k">class</span> <span class="nc">FactorBlock</span><span class="p">(</span><span class="nb">dict</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    Helper class for describing and indexing a block of factors.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    factor_names : tuple of str</span>
<span class="sd">        Tuple of factor names in the block (in the order that they will appear</span>
<span class="sd">        in the state vector).</span>
<span class="sd">    factor_order : int</span>
<span class="sd">        Order of the vector autoregression governing the factor block dynamics.</span>
<span class="sd">    endog_factor_map : pd.DataFrame</span>
<span class="sd">        Mapping from endog variable names to factor names.</span>
<span class="sd">    state_offset : int</span>
<span class="sd">        Offset of this factor block in the state vector.</span>
<span class="sd">    has_endog_Q : bool</span>
<span class="sd">        Flag if the model contains quarterly data.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The goal of this class is, in particular, to make it easier to retrieve</span>
<span class="sd">    indexes of subsets of the state vector that are associated with a</span>
<span class="sd">    particular block of factors.</span>

<span class="sd">    - `factors_ix` is a matrix of indices, with rows corresponding to factors</span>
<span class="sd">      in the block and columns corresponding to lags</span>
<span class="sd">    - `factors` is vec(factors_ix) (i.e. it stacks columns, so that it is</span>
<span class="sd">      `factors_ix.ravel(order='F')`). Thinking about a VAR system, the first</span>
<span class="sd">       k*p elements correspond to the equation for the first variable. The next</span>
<span class="sd">       k*p elements correspond to the equation for the second variable, and so</span>
<span class="sd">       on. It contains all of the lags in the state vector, which is max(5, p)</span>
<span class="sd">    - `factors_ar` is the subset of `factors` that have nonzero coefficients,</span>
<span class="sd">      so it contains lags up to p.</span>
<span class="sd">    - `factors_L1` only contains the first lag of the factors</span>
<span class="sd">    - `factors_L1_5` contains the first - fifth lags of the factors</span>

<span class="sd">    """</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">factor_names</span><span class="p">,</span> <span class="n">factor_order</span><span class="p">,</span> <span class="n">endog_factor_map</span><span class="p">,</span>
                 <span class="n">state_offset</span><span class="p">,</span> <span class="n">k_endog_Q</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">factor_names</span> <span class="o">=</span> <span class="n">factor_names</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k_factors</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">factor_names</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">factor_order</span> <span class="o">=</span> <span class="n">factor_order</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">endog_factor_map</span> <span class="o">=</span> <span class="n">endog_factor_map</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">factor_names</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state_offset</span> <span class="o">=</span> <span class="n">state_offset</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k_endog_Q</span> <span class="o">=</span> <span class="n">k_endog_Q</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog_Q</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_factor_order</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">factor_order</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_factor_order</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">factor_order</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k_states</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_factors</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_factor_order</span>

        <span class="c1"># Save items</span>
        <span class="bp">self</span><span class="p">[</span><span class="s1">'factors'</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">factors</span>
        <span class="bp">self</span><span class="p">[</span><span class="s1">'factors_ar'</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">factors_ar</span>
        <span class="bp">self</span><span class="p">[</span><span class="s1">'factors_ix'</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">factors_ix</span>
        <span class="bp">self</span><span class="p">[</span><span class="s1">'factors_L1'</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">factors_L1</span>
        <span class="bp">self</span><span class="p">[</span><span class="s1">'factors_L1_5'</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">factors_L1_5</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">factors_ix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""Factor state index array, shaped (k_factors, lags)."""</span>
        <span class="c1"># i.e. the position in the state vector of the second lag of the third</span>
        <span class="c1"># factor is factors_ix[2, 1]</span>
        <span class="c1"># ravel(order='F') gives e.g (f0.L1, f1.L1, f0.L2, f1.L2, f0.L3, ...)</span>
        <span class="c1"># while</span>
        <span class="c1"># ravel(order='C') gives e.g (f0.L1, f0.L2, f0.L3, f1.L1, f1.L2, ...)</span>
        <span class="n">o</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">state_offset</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">o</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_factors</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_factor_order</span><span class="p">),</span>
                          <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_factor_order</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_factors</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">factors</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""Factors and all lags in the state vector (max(5, p))."""</span>
        <span class="c1"># Note that this is equivalent to factors_ix with ravel(order='F')</span>
        <span class="n">o</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">state_offset</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">s_</span><span class="p">[</span><span class="n">o</span><span class="p">:</span><span class="n">o</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_factors</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_factor_order</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">factors_ar</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""Factors and all lags used in the factor autoregression (p)."""</span>
        <span class="n">o</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">state_offset</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">s_</span><span class="p">[</span><span class="n">o</span><span class="p">:</span><span class="n">o</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_factors</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">factor_order</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">factors_L1</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""Factors (first block / lag only)."""</span>
        <span class="n">o</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">state_offset</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">s_</span><span class="p">[</span><span class="n">o</span><span class="p">:</span><span class="n">o</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_factors</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">factors_L1_5</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""Factors plus four lags."""</span>
        <span class="n">o</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">state_offset</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">s_</span><span class="p">[</span><span class="n">o</span><span class="p">:</span><span class="n">o</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_factors</span> <span class="o">*</span> <span class="mi">5</span><span class="p">]</span>


<span class="k">class</span> <span class="nc">DynamicFactorMQStates</span><span class="p">(</span><span class="nb">dict</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    Helper class for describing and indexing the state vector.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    k_endog_M : int</span>
<span class="sd">        Number of monthly (or non-time-specific, if k_endog_Q=0) variables.</span>
<span class="sd">    k_endog_Q : int</span>
<span class="sd">        Number of quarterly variables.</span>
<span class="sd">    endog_names : list</span>
<span class="sd">        Names of the endogenous variables.</span>
<span class="sd">    factors : int, list, or dict</span>
<span class="sd">        Integer giving the number of (global) factors, a list with the names of</span>
<span class="sd">        (global) factors, or a dictionary with:</span>

<span class="sd">        - keys : names of endogenous variables</span>
<span class="sd">        - values : lists of factor names.</span>

<span class="sd">        If this is an integer, then the factor names will be 0, 1, ....</span>
<span class="sd">    factor_orders : int or dict</span>
<span class="sd">        Integer describing the order of the vector autoregression (VAR)</span>
<span class="sd">        governing all factor block dynamics or dictionary with:</span>

<span class="sd">        - keys : factor name or tuples of factor names in a block</span>
<span class="sd">        - values : integer describing the VAR order for that factor block</span>

<span class="sd">        If a dictionary, this defines the order of the factor blocks in the</span>
<span class="sd">        state vector. Otherwise, factors are ordered so that factors that load</span>
<span class="sd">        on more variables come first (and then alphabetically, to break ties).</span>
<span class="sd">    factor_multiplicities : int or dict</span>
<span class="sd">        This argument provides a convenient way to specify multiple factors</span>
<span class="sd">        that load identically on variables. For example, one may want two</span>
<span class="sd">        "global" factors (factors that load on all variables) that evolve</span>
<span class="sd">        jointly according to a VAR. One could specify two global factors in the</span>
<span class="sd">        `factors` argument and specify that they are in the same block in the</span>
<span class="sd">        `factor_orders` argument, but it is easier to specify a single global</span>
<span class="sd">        factor in the `factors` argument, and set the order in the</span>
<span class="sd">        `factor_orders` argument, and then set the factor multiplicity to 2.</span>

<span class="sd">        This argument must be an integer describing the factor multiplicity for</span>
<span class="sd">        all factors or dictionary with:</span>

<span class="sd">        - keys : factor name</span>
<span class="sd">        - values : integer describing the factor multiplicity for the factors</span>
<span class="sd">          in the given block</span>
<span class="sd">    idiosyncratic_ar1 : bool</span>
<span class="sd">        Whether or not to model the idiosyncratic component for each series as</span>
<span class="sd">        an AR(1) process. If False, the idiosyncratic component is instead</span>
<span class="sd">        modeled as white noise.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    k_endog : int</span>
<span class="sd">        Total number of endogenous variables.</span>
<span class="sd">    k_states : int</span>
<span class="sd">        Total number of state variables (those associated with the factors and</span>
<span class="sd">        those associated with the idiosyncratic disturbances).</span>
<span class="sd">    k_posdef : int</span>
<span class="sd">        Total number of state disturbance terms (those associated with the</span>
<span class="sd">        factors and those associated with the idiosyncratic disturbances).</span>
<span class="sd">    k_endog_M : int</span>
<span class="sd">        Number of monthly (or non-time-specific, if k_endog_Q=0) variables.</span>
<span class="sd">    k_endog_Q : int</span>
<span class="sd">        Number of quarterly variables.</span>
<span class="sd">    k_factors : int</span>
<span class="sd">        Total number of factors. Note that factor multiplicities will have</span>
<span class="sd">        already been expanded.</span>
<span class="sd">    k_states_factors : int</span>
<span class="sd">        The number of state variables associated with factors (includes both</span>
<span class="sd">        factors and lags of factors included in the state vector).</span>
<span class="sd">    k_posdef_factors : int</span>
<span class="sd">        The number of state disturbance terms associated with factors.</span>
<span class="sd">    k_states_idio : int</span>
<span class="sd">        Total number of state variables associated with idiosyncratic</span>
<span class="sd">        disturbances.</span>
<span class="sd">    k_posdef_idio : int</span>
<span class="sd">        Total number of state disturbance terms associated with idiosyncratic</span>
<span class="sd">        disturbances.</span>
<span class="sd">    k_states_idio_M : int</span>
<span class="sd">        The number of state variables associated with idiosyncratic</span>
<span class="sd">        disturbances for monthly (or non-time-specific if there are no</span>
<span class="sd">        quarterly variables) variables. If the disturbances are AR(1), then</span>
<span class="sd">        this will be equal to `k_endog_M`, otherwise it will be equal to zero.</span>
<span class="sd">    k_states_idio_Q : int</span>
<span class="sd">        The number of state variables associated with idiosyncratic</span>
<span class="sd">        disturbances for quarterly variables. This will always be equal to</span>
<span class="sd">        `k_endog_Q * 5`, even if the disturbances are not AR(1).</span>
<span class="sd">    k_posdef_idio_M : int</span>
<span class="sd">        The number of state disturbance terms associated with idiosyncratic</span>
<span class="sd">        disturbances for monthly (or non-time-specific if there are no</span>
<span class="sd">        quarterly variables) variables. If the disturbances are AR(1), then</span>
<span class="sd">        this will be equal to `k_endog_M`, otherwise it will be equal to zero.</span>
<span class="sd">    k_posdef_idio_Q : int</span>
<span class="sd">        The number of state disturbance terms associated with idiosyncratic</span>
<span class="sd">        disturbances for quarterly variables. This will always be equal to</span>
<span class="sd">        `k_endog_Q`, even if the disturbances are not AR(1).</span>
<span class="sd">    idiosyncratic_ar1 : bool</span>
<span class="sd">        Whether or not to model the idiosyncratic component for each series as</span>
<span class="sd">        an AR(1) process.</span>
<span class="sd">    factor_blocks : list of FactorBlock</span>
<span class="sd">        List of `FactorBlock` helper instances for each factor block.</span>
<span class="sd">    factor_names : list of str</span>
<span class="sd">        List of factor names.</span>
<span class="sd">    factors : dict</span>
<span class="sd">        Dictionary with:</span>

<span class="sd">        - keys : names of endogenous variables</span>
<span class="sd">        - values : lists of factor names.</span>

<span class="sd">        Note that factor multiplicities will have already been expanded.</span>
<span class="sd">    factor_orders : dict</span>
<span class="sd">        Dictionary with:</span>

<span class="sd">        - keys : tuple of factor names</span>
<span class="sd">        - values : integer describing autoregression order</span>

<span class="sd">        Note that factor multiplicities will have already been expanded.</span>
<span class="sd">    max_factor_order : int</span>
<span class="sd">        Maximum autoregression order across all factor blocks.</span>
<span class="sd">    factor_block_orders : pd.Series</span>
<span class="sd">        Series containing lag orders, with the factor block (a tuple of factor</span>
<span class="sd">        names) as the index.</span>
<span class="sd">    factor_multiplicities : dict</span>
<span class="sd">        Dictionary with:</span>

<span class="sd">        - keys : factor name</span>
<span class="sd">        - values : integer describing the factor multiplicity for the factors</span>
<span class="sd">          in the given block</span>
<span class="sd">    endog_factor_map : dict</span>
<span class="sd">        Dictionary with:</span>

<span class="sd">        - keys : endog name</span>
<span class="sd">        - values : list of factor names</span>
<span class="sd">    loading_counts : pd.Series</span>
<span class="sd">        Series containing number of endogenous variables loading on each</span>
<span class="sd">        factor, with the factor name as the index.</span>
<span class="sd">    block_loading_counts : dict</span>
<span class="sd">        Dictionary with:</span>

<span class="sd">        - keys : tuple of factor names</span>
<span class="sd">        - values : average number of endogenous variables loading on the block</span>
<span class="sd">          (note that average is over the factors in the block)</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The goal of this class is, in particular, to make it easier to retrieve</span>
<span class="sd">    indexes of subsets of the state vector.</span>

<span class="sd">    Note that the ordering of the factor blocks in the state vector is</span>
<span class="sd">    determined by the `factor_orders` argument if a dictionary. Otherwise,</span>
<span class="sd">    factors are ordered so that factors that load on more variables come first</span>
<span class="sd">    (and then alphabetically, to break ties).</span>

<span class="sd">    - `factors_L1` is an array with the indexes of first lag of the factors</span>
<span class="sd">      from each block. Ordered first by block, and then by lag.</span>
<span class="sd">    - `factors_L1_5` is an array with the indexes contains the first - fifth</span>
<span class="sd">      lags of the factors from each block. Ordered first by block, and then by</span>
<span class="sd">      lag.</span>
<span class="sd">    - `factors_L1_5_ix` is an array shaped (5, k_factors) with the indexes</span>
<span class="sd">      of the first - fifth lags of the factors from each block.</span>
<span class="sd">    - `idio_ar_L1` is an array with the indexes of the first lag of the</span>
<span class="sd">      idiosyncratic AR states, both monthly (if appliable) and quarterly.</span>
<span class="sd">    - `idio_ar_M` is a slice with the indexes of the idiosyncratic disturbance</span>
<span class="sd">      states for the monthly (or non-time-specific if there are no quarterly</span>
<span class="sd">      variables) variables. It is an empty slice if</span>
<span class="sd">      `idiosyncratic_ar1 = False`.</span>
<span class="sd">    - `idio_ar_Q` is a slice with the indexes of the idiosyncratic disturbance</span>
<span class="sd">      states and all lags, for the quarterly variables. It is an empty slice if</span>
<span class="sd">      there are no quarterly variable.</span>
<span class="sd">    - `idio_ar_Q_ix` is an array shaped (k_endog_Q, 5) with the indexes of the</span>
<span class="sd">      first - fifth lags of the idiosyncratic disturbance states for the</span>
<span class="sd">      quarterly variables.</span>
<span class="sd">    - `endog_factor_iloc` is a list of lists, with entries for each endogenous</span>
<span class="sd">      variable. The entry for variable `i`, `endog_factor_iloc[i]` is a list of</span>
<span class="sd">      indexes of the factors that variable `i` loads on. This does not include</span>
<span class="sd">      any lags, but it can be used with e.g. `factors_L1_5_ix` to get lags.</span>

<span class="sd">    """</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k_endog_M</span><span class="p">,</span> <span class="n">k_endog_Q</span><span class="p">,</span> <span class="n">endog_names</span><span class="p">,</span> <span class="n">factors</span><span class="p">,</span>
                 <span class="n">factor_orders</span><span class="p">,</span> <span class="n">factor_multiplicities</span><span class="p">,</span> <span class="n">idiosyncratic_ar1</span><span class="p">):</span>
        <span class="c1"># Save model parameterization</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k_endog_M</span> <span class="o">=</span> <span class="n">k_endog_M</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k_endog_Q</span> <span class="o">=</span> <span class="n">k_endog_Q</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog_M</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog_Q</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">idiosyncratic_ar1</span> <span class="o">=</span> <span class="n">idiosyncratic_ar1</span>

        <span class="c1"># Validate factor-related inputs</span>
        <span class="n">factors_is_int</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">factors</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)</span>
        <span class="n">factors_is_list</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">factors</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">))</span>
        <span class="n">orders_is_int</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">factor_orders</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">factor_multiplicities</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">factor_multiplicities</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">mult_is_int</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">factor_multiplicities</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">factors_is_int</span> <span class="ow">or</span> <span class="n">factors_is_list</span> <span class="ow">or</span>
                <span class="nb">isinstance</span><span class="p">(</span><span class="n">factors</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'`factors` argument must an integer number of'</span>
                             <span class="s1">' factors, a list of global factor names, or a'</span>
                             <span class="s1">' dictionary, mapping observed variables to'</span>
                             <span class="s1">' factors.'</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">orders_is_int</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">factor_orders</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'`factor_orders` argument must either be an'</span>
                             <span class="s1">' integer or a dictionary.'</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">mult_is_int</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">factor_multiplicities</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'`factor_multiplicities` argument must either be'</span>
                             <span class="s1">' an integer or a dictionary.'</span><span class="p">)</span>

        <span class="c1"># Expand integers</span>
        <span class="c1"># If `factors` is an integer, we assume that it denotes the number of</span>
        <span class="c1"># global factors (factors that load on each variable)</span>
        <span class="k">if</span> <span class="n">factors_is_int</span> <span class="ow">or</span> <span class="n">factors_is_list</span><span class="p">:</span>
            <span class="c1"># Validate this here for a more informative error message</span>
            <span class="k">if</span> <span class="p">((</span><span class="n">factors_is_int</span> <span class="ow">and</span> <span class="n">factors</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span>
                    <span class="p">(</span><span class="n">factors_is_list</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">factors</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'The model must contain at least one factor.'</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">factors_is_list</span><span class="p">:</span>
                <span class="n">factor_names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">factors</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">factor_names</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s1">'</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">'</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">factors</span><span class="p">)]</span>
            <span class="n">factors</span> <span class="o">=</span> <span class="p">{</span><span class="n">name</span><span class="p">:</span> <span class="n">factor_names</span><span class="p">[:]</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">endog_names</span><span class="p">}</span>
        <span class="n">factor_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">factors</span><span class="o">.</span><span class="n">values</span><span class="p">())))</span>
        <span class="k">if</span> <span class="n">orders_is_int</span><span class="p">:</span>
            <span class="n">factor_orders</span> <span class="o">=</span> <span class="p">{</span><span class="n">factor_name</span><span class="p">:</span> <span class="n">factor_orders</span>
                             <span class="k">for</span> <span class="n">factor_name</span> <span class="ow">in</span> <span class="n">factor_names</span><span class="p">}</span>
        <span class="k">if</span> <span class="n">mult_is_int</span><span class="p">:</span>
            <span class="n">factor_multiplicities</span> <span class="o">=</span> <span class="p">{</span><span class="n">factor_name</span><span class="p">:</span> <span class="n">factor_multiplicities</span>
                                     <span class="k">for</span> <span class="n">factor_name</span> <span class="ow">in</span> <span class="n">factor_names</span><span class="p">}</span>

        <span class="c1"># Apply the factor multiplities</span>
        <span class="n">factors</span><span class="p">,</span> <span class="n">factor_orders</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_factor_multiplicities</span><span class="p">(</span>
            <span class="n">factors</span><span class="p">,</span> <span class="n">factor_orders</span><span class="p">,</span> <span class="n">factor_multiplicities</span><span class="p">)</span>

        <span class="c1"># Save the (potentially expanded) variables</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">factors</span> <span class="o">=</span> <span class="n">factors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">factor_orders</span> <span class="o">=</span> <span class="n">factor_orders</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">factor_multiplicities</span> <span class="o">=</span> <span class="n">factor_multiplicities</span>

        <span class="c1"># Get the mapping between endog and factors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">endog_factor_map</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_construct_endog_factor_map</span><span class="p">(</span>
            <span class="n">factors</span><span class="p">,</span> <span class="n">endog_names</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k_factors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">endog_factor_map</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Validate number of factors</span>
        <span class="c1"># TODO: could do more extensive validation here.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_factors</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog_M</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">'Number of factors (</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">k_factors</span><span class="si">}</span><span class="s1">) cannot be'</span>
                             <span class="s1">' greater than the number of monthly endogenous'</span>
                             <span class="sa">f</span><span class="s1">' variables (</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">k_endog_M</span><span class="si">}</span><span class="s1">).'</span><span class="p">)</span>

        <span class="c1"># Get `loading_counts`: factor -&gt; # endog loading on the factor</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loading_counts</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">endog_factor_map</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s1">'count'</span><span class="p">)</span>
                <span class="o">.</span><span class="n">reset_index</span><span class="p">()</span><span class="o">.</span><span class="n">sort_values</span><span class="p">([</span><span class="s1">'count'</span><span class="p">,</span> <span class="s1">'factor'</span><span class="p">],</span>
                                           <span class="n">ascending</span><span class="o">=</span><span class="p">[</span><span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">])</span>
                <span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s1">'factor'</span><span class="p">))</span>
        <span class="c1"># `block_loading_counts`: block -&gt; average of (# loading on factor)</span>
        <span class="c1"># across each factor in the block</span>
        <span class="n">block_loading_counts</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">block</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">loading_counts</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">block</span><span class="p">),</span> <span class="s1">'count'</span><span class="p">])</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="n">factor_orders</span><span class="o">.</span><span class="n">keys</span><span class="p">()}</span>
        <span class="n">ix</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">(</span><span class="n">block_loading_counts</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span> <span class="n">tupleize_cols</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                      <span class="n">name</span><span class="o">=</span><span class="s1">'block'</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">block_loading_counts</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span>
            <span class="nb">list</span><span class="p">(</span><span class="n">block_loading_counts</span><span class="o">.</span><span class="n">values</span><span class="p">()),</span>
            <span class="n">index</span><span class="o">=</span><span class="n">ix</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">'count'</span><span class="p">)</span><span class="o">.</span><span class="n">to_frame</span><span class="p">()</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span>
                <span class="p">[</span><span class="s1">'count'</span><span class="p">,</span> <span class="s1">'block'</span><span class="p">],</span> <span class="n">ascending</span><span class="o">=</span><span class="p">[</span><span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">])[</span><span class="s1">'count'</span><span class="p">]</span>

        <span class="c1"># Get the mapping between factor blocks and VAR order</span>

        <span class="c1"># `factor_block_orders`: pd.Series of factor block -&gt; lag order</span>
        <span class="n">ix</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">(</span><span class="n">factor_orders</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span> <span class="n">tupleize_cols</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">'block'</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">factor_block_orders</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span>
            <span class="nb">list</span><span class="p">(</span><span class="n">factor_orders</span><span class="o">.</span><span class="n">values</span><span class="p">()),</span> <span class="n">index</span><span class="o">=</span><span class="n">ix</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">'order'</span><span class="p">)</span>

        <span class="c1"># If the `factor_orders` variable was an integer, then it did not</span>
        <span class="c1"># define an ordering for the factor blocks. In this case, we use the</span>
        <span class="c1"># loading counts to do so. This ensures that e.g. global factors are</span>
        <span class="c1"># listed first.</span>
        <span class="k">if</span> <span class="n">orders_is_int</span><span class="p">:</span>
            <span class="n">keys</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">block_loading_counts</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">factor_block_orders</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">factor_block_orders</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">keys</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">factor_block_orders</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">'block'</span>

        <span class="c1"># Define factor_names based on factor_block_orders (instead of on those</span>
        <span class="c1"># from `endog_factor_map`) to (a) make sure that factors are allocated</span>
        <span class="c1"># to only one block, and (b) order the factor names to be consistent</span>
        <span class="c1"># with the block definitions.</span>
        <span class="n">factor_names</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">factor_block_orders</span><span class="o">.</span><span class="n">index</span><span class="p">)))</span>
        <span class="n">missing</span> <span class="o">=</span> <span class="p">[</span><span class="n">name</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">endog_factor_map</span><span class="o">.</span><span class="n">columns</span>
                   <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">factor_names</span><span class="o">.</span><span class="n">tolist</span><span class="p">()]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">missing</span><span class="p">):</span>
            <span class="n">ix</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">([(</span><span class="n">factor_name</span><span class="p">,)</span> <span class="k">for</span> <span class="n">factor_name</span> <span class="ow">in</span> <span class="n">missing</span><span class="p">],</span>
                          <span class="n">tupleize_cols</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">'block'</span><span class="p">)</span>
            <span class="n">default_block_orders</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ix</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">),</span>
                                             <span class="n">index</span><span class="o">=</span><span class="n">ix</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">'order'</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">factor_block_orders</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">factor_block_orders</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">default_block_orders</span><span class="p">))</span>
            <span class="n">factor_names</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">factor_block_orders</span><span class="o">.</span><span class="n">index</span><span class="p">)))</span>
        <span class="n">duplicates</span> <span class="o">=</span> <span class="n">factor_names</span><span class="o">.</span><span class="n">duplicated</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">duplicates</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="n">duplicate_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">factor_names</span><span class="p">[</span><span class="n">duplicates</span><span class="p">])</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'Each factor can be assigned to at most one'</span>
                             <span class="s1">' block of factors in `factor_orders`.'</span>
                             <span class="sa">f</span><span class="s1">' Duplicate entries for </span><span class="si">{</span><span class="n">duplicate_names</span><span class="si">}</span><span class="s1">'</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">factor_names</span> <span class="o">=</span> <span class="n">factor_names</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_factor_order</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">factor_block_orders</span><span class="p">)</span>

        <span class="c1"># Re-order the columns of the endog factor mapping to reflect the</span>
        <span class="c1"># orderings of endog_names and factor_names</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">endog_factor_map</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">endog_factor_map</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">endog_names</span><span class="p">,</span> <span class="n">factor_names</span><span class="p">])</span>

        <span class="c1"># Create factor block helpers, and get factor-related state and posdef</span>
        <span class="c1"># dimensions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k_states_factors</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k_posdef_factors</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">state_offset</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">factor_blocks</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">factor_names</span><span class="p">,</span> <span class="n">factor_order</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">factor_block_orders</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">block</span> <span class="o">=</span> <span class="n">FactorBlock</span><span class="p">(</span><span class="n">factor_names</span><span class="p">,</span> <span class="n">factor_order</span><span class="p">,</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">endog_factor_map</span><span class="p">,</span> <span class="n">state_offset</span><span class="p">,</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">k_endog_Q</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">k_states_factors</span> <span class="o">+=</span> <span class="n">block</span><span class="o">.</span><span class="n">k_states</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">k_posdef_factors</span> <span class="o">+=</span> <span class="n">block</span><span class="o">.</span><span class="n">k_factors</span>
            <span class="n">state_offset</span> <span class="o">+=</span> <span class="n">block</span><span class="o">.</span><span class="n">k_states</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">factor_blocks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">block</span><span class="p">)</span>

        <span class="c1"># Idiosyncratic state dimensions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k_states_idio_M</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog_M</span> <span class="k">if</span> <span class="n">idiosyncratic_ar1</span> <span class="k">else</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k_states_idio_Q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog_Q</span> <span class="o">*</span> <span class="mi">5</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k_states_idio</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_states_idio_M</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_states_idio_Q</span>

        <span class="c1"># Idiosyncratic posdef dimensions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k_posdef_idio_M</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog_M</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">idiosyncratic_ar1</span> <span class="k">else</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k_posdef_idio_Q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog_Q</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k_posdef_idio</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_posdef_idio_M</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_posdef_idio_Q</span>

        <span class="c1"># Total states, posdef</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k_states</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_states_factors</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_states_idio</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k_posdef</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_posdef_factors</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_posdef_idio</span>

        <span class="c1"># Cache</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_endog_factor_iloc</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_apply_factor_multiplicities</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">factors</span><span class="p">,</span> <span class="n">factor_orders</span><span class="p">,</span>
                                     <span class="n">factor_multiplicities</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Expand `factors` and `factor_orders` to account for factor multiplity.</span>

<span class="sd">        For example, if there is a `global` factor with multiplicity 2, then</span>
<span class="sd">        this method expands that into `global.1` and `global.2` in both the</span>
<span class="sd">        `factors` and `factor_orders` dictionaries.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        factors : dict</span>
<span class="sd">            Dictionary of {endog_name: list of factor names}</span>
<span class="sd">        factor_orders : dict</span>
<span class="sd">            Dictionary of {tuple of factor names: factor order}</span>
<span class="sd">        factor_multiplicities : dict</span>
<span class="sd">            Dictionary of {factor name: factor multiplicity}</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        new_factors : dict</span>
<span class="sd">            Dictionary of {endog_name: list of factor names}, with factor names</span>
<span class="sd">            expanded to incorporate multiplicities.</span>
<span class="sd">        new_factors : dict</span>
<span class="sd">            Dictionary of {tuple of factor names: factor order}, with factor</span>
<span class="sd">            names in each tuple expanded to incorporate multiplicities.</span>
<span class="sd">        """</span>
        <span class="c1"># Expand the factors to account for the multiplicities</span>
        <span class="n">new_factors</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">endog_name</span><span class="p">,</span> <span class="n">factors_list</span> <span class="ow">in</span> <span class="n">factors</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">new_factor_list</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">factor_name</span> <span class="ow">in</span> <span class="n">factors_list</span><span class="p">:</span>
                <span class="n">n</span> <span class="o">=</span> <span class="n">factor_multiplicities</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">factor_name</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">new_factor_list</span> <span class="o">+=</span> <span class="p">[</span><span class="sa">f</span><span class="s1">'</span><span class="si">{</span><span class="n">factor_name</span><span class="si">}</span><span class="s1">.</span><span class="si">{</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="si">}</span><span class="s1">'</span>
                                        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">new_factor_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">factor_name</span><span class="p">)</span>
            <span class="n">new_factors</span><span class="p">[</span><span class="n">endog_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_factor_list</span>

        <span class="c1"># Expand the factor orders to account for the multiplicities</span>
        <span class="n">new_factor_orders</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">block</span><span class="p">,</span> <span class="n">factor_order</span> <span class="ow">in</span> <span class="n">factor_orders</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                <span class="n">block</span> <span class="o">=</span> <span class="p">(</span><span class="n">block</span><span class="p">,)</span>
            <span class="n">new_block</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">factor_name</span> <span class="ow">in</span> <span class="n">block</span><span class="p">:</span>
                <span class="n">n</span> <span class="o">=</span> <span class="n">factor_multiplicities</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">factor_name</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">new_block</span> <span class="o">+=</span> <span class="p">[</span><span class="sa">f</span><span class="s1">'</span><span class="si">{</span><span class="n">factor_name</span><span class="si">}</span><span class="s1">.</span><span class="si">{</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="si">}</span><span class="s1">'</span>
                                  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">new_block</span> <span class="o">+=</span> <span class="p">[</span><span class="n">factor_name</span><span class="p">]</span>
            <span class="n">new_factor_orders</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">new_block</span><span class="p">)]</span> <span class="o">=</span> <span class="n">factor_order</span>

        <span class="k">return</span> <span class="n">new_factors</span><span class="p">,</span> <span class="n">new_factor_orders</span>

    <span class="k">def</span> <span class="nf">_construct_endog_factor_map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">factors</span><span class="p">,</span> <span class="n">endog_names</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Construct mapping of observed variables to factors.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        factors : dict</span>
<span class="sd">            Dictionary of {endog_name: list of factor names}</span>
<span class="sd">        endog_names : list of str</span>
<span class="sd">            List of the names of the observed variables.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        endog_factor_map : pd.DataFrame</span>
<span class="sd">            Boolean dataframe with `endog_names` as the index and the factor</span>
<span class="sd">            names (computed from the `factors` input) as the columns. Each cell</span>
<span class="sd">            is True if the associated factor is allowed to load on the</span>
<span class="sd">            associated observed variable.</span>

<span class="sd">        """</span>
        <span class="c1"># Validate that all entries in the factors dictionary have associated</span>
        <span class="c1"># factors</span>
        <span class="n">missing</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">factors</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">))</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">missing</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">missing</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'Each observed variable must be mapped to at'</span>
                             <span class="s1">' least one factor in the `factors` dictionary.'</span>
                             <span class="sa">f</span><span class="s1">' Variables missing factors are: </span><span class="si">{</span><span class="n">missing</span><span class="si">}</span><span class="s1">.'</span><span class="p">)</span>

        <span class="c1"># Validate that we have been told about the factors for each endog</span>
        <span class="c1"># variable. This is because it doesn't make sense to include an</span>
        <span class="c1"># observed variable that doesn't load on any factor</span>
        <span class="n">missing</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">endog_names</span><span class="p">)</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">factors</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">missing</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'If a `factors` dictionary is provided, then'</span>
                             <span class="s1">' it must include entries for each observed'</span>
                             <span class="sa">f</span><span class="s1">' variable. Missing variables are: </span><span class="si">{</span><span class="n">missing</span><span class="si">}</span><span class="s1">.'</span><span class="p">)</span>

        <span class="c1"># Figure out the set of factor names</span>
        <span class="c1"># (0 is just a dummy value for the dict - we just do it this way to</span>
        <span class="c1"># collect the keys, in order, without duplicates.)</span>
        <span class="n">factor_names</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">factors</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">factor_names</span><span class="p">[</span><span class="n">value</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">factor_names</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">v</span><span class="p">:</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">value</span><span class="p">})</span>
        <span class="n">factor_names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">factor_names</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">k_factors</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">factor_names</span><span class="p">)</span>

        <span class="n">endog_factor_map</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">,</span> <span class="n">k_factors</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">),</span>
            <span class="n">index</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">(</span><span class="n">endog_names</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">'endog'</span><span class="p">),</span>
            <span class="n">columns</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">(</span><span class="n">factor_names</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">'factor'</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">factors</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">endog_factor_map</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">return</span> <span class="n">endog_factor_map</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">factors_L1</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""Factors."""</span>
        <span class="n">ix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_states_factors</span><span class="p">)</span>
        <span class="n">iloc</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">ix</span><span class="p">[</span><span class="n">block</span><span class="o">.</span><span class="n">factors_L1</span><span class="p">]</span> <span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">factor_blocks</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">iloc</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">factors_L1_5_ix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""Factors plus any lags, index shaped (5, k_factors)."""</span>
        <span class="n">ix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_states_factors</span><span class="p">)</span>
        <span class="n">iloc</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">factor_blocks</span><span class="p">:</span>
            <span class="n">iloc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ix</span><span class="p">[</span><span class="n">block</span><span class="o">.</span><span class="n">factors_L1_5</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">block</span><span class="o">.</span><span class="n">k_factors</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">iloc</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">idio_ar_L1</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""Idiosyncratic AR states, (first block / lag only)."""</span>
        <span class="n">ix1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_states_factors</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">idiosyncratic_ar1</span><span class="p">:</span>
            <span class="n">ix2</span> <span class="o">=</span> <span class="n">ix1</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ix2</span> <span class="o">=</span> <span class="n">ix1</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog_Q</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">s_</span><span class="p">[</span><span class="n">ix1</span><span class="p">:</span><span class="n">ix2</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">idio_ar_M</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""Idiosyncratic AR states for monthly variables."""</span>
        <span class="n">ix1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_states_factors</span>
        <span class="n">ix2</span> <span class="o">=</span> <span class="n">ix1</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">idiosyncratic_ar1</span><span class="p">:</span>
            <span class="n">ix2</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog_M</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">s_</span><span class="p">[</span><span class="n">ix1</span><span class="p">:</span><span class="n">ix2</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">idio_ar_Q</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""Idiosyncratic AR states and all lags for quarterly variables."""</span>
        <span class="c1"># Note that this is equivalent to idio_ar_Q_ix with ravel(order='F')</span>
        <span class="n">ix1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_states_factors</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">idiosyncratic_ar1</span><span class="p">:</span>
            <span class="n">ix1</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog_M</span>
        <span class="n">ix2</span> <span class="o">=</span> <span class="n">ix1</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog_Q</span> <span class="o">*</span> <span class="mi">5</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">s_</span><span class="p">[</span><span class="n">ix1</span><span class="p">:</span><span class="n">ix2</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">idio_ar_Q_ix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""Idiosyncratic AR (quarterly) state index, (k_endog_Q, lags)."""</span>
        <span class="c1"># i.e. the position in the state vector of the second lag of the third</span>
        <span class="c1"># quarterly variable is idio_ar_Q_ix[2, 1]</span>
        <span class="c1"># ravel(order='F') gives e.g (y1.L1, y2.L1, y1.L2, y2.L3, y1.L3, ...)</span>
        <span class="c1"># while</span>
        <span class="c1"># ravel(order='C') gives e.g (y1.L1, y1.L2, y1.L3, y2.L1, y2.L2, ...)</span>
        <span class="n">start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_states_factors</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">idiosyncratic_ar1</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog_M</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog_Q</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog_Q</span><span class="p">))</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">endog_factor_iloc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""List of list of int, factor indexes for each observed variable."""</span>
        <span class="c1"># i.e. endog_factor_iloc[i] is a list of integer locations of the</span>
        <span class="c1"># factors that load on the ith observed variable</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_endog_factor_iloc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ilocs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">):</span>
                <span class="n">ilocs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endog_factor_map</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">i</span><span class="p">])[</span><span class="mi">0</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_endog_factor_iloc</span> <span class="o">=</span> <span class="n">ilocs</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_endog_factor_iloc</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Use square brackets to access index / slice elements.</span>

<span class="sd">        This is convenient in highlighting the indexing / slice quality of</span>
<span class="sd">        these attributes in the code below.</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">'factors_L1'</span><span class="p">,</span> <span class="s1">'factors_L1_5_ix'</span><span class="p">,</span> <span class="s1">'idio_ar_L1'</span><span class="p">,</span> <span class="s1">'idio_ar_M'</span><span class="p">,</span>
                   <span class="s1">'idio_ar_Q'</span><span class="p">,</span> <span class="s1">'idio_ar_Q_ix'</span><span class="p">]:</span>
            <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>


<div class="viewcode-block" id="DynamicFactorMQ"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.dynamic_factor_mq.DynamicFactorMQ.html#statsmodels.tsa.statespace.dynamic_factor_mq.DynamicFactorMQ">[docs]</a><span class="k">class</span> <span class="nc">DynamicFactorMQ</span><span class="p">(</span><span class="n">mlemodel</span><span class="o">.</span><span class="n">MLEModel</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">"""</span>
<span class="sd">    Dynamic factor model with EM algorithm; option for monthly/quarterly data.</span>

<span class="sd">    Implementation of the dynamic factor model of Bańbura and Modugno (2014)</span>
<span class="sd">    ([1]_) and Bańbura, Giannone, and Reichlin (2011) ([2]_). Uses the EM</span>
<span class="sd">    algorithm for parameter fitting, and so can accommodate a large number of</span>
<span class="sd">    left-hand-side variables. Specifications can include any collection of</span>
<span class="sd">    blocks of factors, including different factor autoregression orders, and</span>
<span class="sd">    can include AR(1) processes for idiosyncratic disturbances. Can</span>
<span class="sd">    incorporate monthly/quarterly mixed frequency data along the lines of</span>
<span class="sd">    Mariano and Murasawa (2011) ([4]_). A special case of this model is the</span>
<span class="sd">    Nowcasting model of Bok et al. (2017) ([3]_). Moreover, this model can be</span>
<span class="sd">    used to compute the news associated with updated data releases.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    endog : array_like</span>
<span class="sd">        Observed time-series process :math:`y`. See the "Notes" section for</span>
<span class="sd">        details on how to set up a model with monthly/quarterly mixed frequency</span>
<span class="sd">        data.</span>
<span class="sd">    k_endog_monthly : int, optional</span>
<span class="sd">        If specifying a monthly/quarterly mixed frequency model in which the</span>
<span class="sd">        provided `endog` dataset contains both the monthly and quarterly data,</span>
<span class="sd">        this variable should be used to indicate how many of the variables</span>
<span class="sd">        are monthly. Note that when using the `k_endog_monthly` argument, the</span>
<span class="sd">        columns with monthly variables in `endog` should be ordered first, and</span>
<span class="sd">        the columns with quarterly variables should come afterwards. See the</span>
<span class="sd">        "Notes" section for details on how to set up a model with</span>
<span class="sd">        monthly/quarterly mixed frequency data.</span>
<span class="sd">    factors : int, list, or dict, optional</span>
<span class="sd">        Integer giving the number of (global) factors, a list with the names of</span>
<span class="sd">        (global) factors, or a dictionary with:</span>

<span class="sd">        - keys : names of endogenous variables</span>
<span class="sd">        - values : lists of factor names.</span>

<span class="sd">        If this is an integer, then the factor names will be 0, 1, .... The</span>
<span class="sd">        default is a single factor that loads on all variables. Note that there</span>
<span class="sd">        cannot be more factors specified than there are monthly variables.</span>
<span class="sd">    factor_orders : int or dict, optional</span>
<span class="sd">        Integer describing the order of the vector autoregression (VAR)</span>
<span class="sd">        governing all factor block dynamics or dictionary with:</span>

<span class="sd">        - keys : factor name or tuples of factor names in a block</span>
<span class="sd">        - values : integer describing the VAR order for that factor block</span>

<span class="sd">        If a dictionary, this defines the order of the factor blocks in the</span>
<span class="sd">        state vector. Otherwise, factors are ordered so that factors that load</span>
<span class="sd">        on more variables come first (and then alphabetically, to break ties).</span>
<span class="sd">    factor_multiplicities : int or dict, optional</span>
<span class="sd">        This argument provides a convenient way to specify multiple factors</span>
<span class="sd">        that load identically on variables. For example, one may want two</span>
<span class="sd">        "global" factors (factors that load on all variables) that evolve</span>
<span class="sd">        jointly according to a VAR. One could specify two global factors in the</span>
<span class="sd">        `factors` argument and specify that they are in the same block in the</span>
<span class="sd">        `factor_orders` argument, but it is easier to specify a single global</span>
<span class="sd">        factor in the `factors` argument, and set the order in the</span>
<span class="sd">        `factor_orders` argument, and then set the factor multiplicity to 2.</span>

<span class="sd">        This argument must be an integer describing the factor multiplicity for</span>
<span class="sd">        all factors or dictionary with:</span>

<span class="sd">        - keys : factor name</span>
<span class="sd">        - values : integer describing the factor multiplicity for the factors</span>
<span class="sd">          in the given block</span>

<span class="sd">    idiosyncratic_ar1 : bool</span>
<span class="sd">        Whether or not to model the idiosyncratic component for each series as</span>
<span class="sd">        an AR(1) process. If False, the idiosyncratic component is instead</span>
<span class="sd">        modeled as white noise.</span>
<span class="sd">    standardize : bool or tuple, optional</span>
<span class="sd">        If a boolean, whether or not to standardize each endogenous variable to</span>
<span class="sd">        have mean zero and standard deviation 1 before fitting the model. See</span>
<span class="sd">        "Notes" for details about how this option works with postestimation</span>
<span class="sd">        output. If a tuple (usually only used internally), then the tuple must</span>
<span class="sd">        have length 2, with each element containing a Pandas series with index</span>
<span class="sd">        equal to the names of the endogenous variables. The first element</span>
<span class="sd">        should contain the mean values and the second element should contain</span>
<span class="sd">        the standard deviations. Default is True.</span>
<span class="sd">    endog_quarterly : pandas.Series or pandas.DataFrame</span>
<span class="sd">        Observed quarterly variables. If provided, must be a Pandas Series or</span>
<span class="sd">        DataFrame with a DatetimeIndex or PeriodIndex at the quarterly</span>
<span class="sd">        frequency. See the "Notes" section for details on how to set up a model</span>
<span class="sd">        with monthly/quarterly mixed frequency data.</span>
<span class="sd">    init_t0 : bool, optional</span>
<span class="sd">        If True, this option initializes the Kalman filter with the</span>
<span class="sd">        distribution for :math:`\alpha_0` rather than :math:`\alpha_1`. See</span>
<span class="sd">        the "Notes" section for more details. This option is rarely used except</span>
<span class="sd">        for testing. Default is False.</span>
<span class="sd">    obs_cov_diag : bool, optional</span>
<span class="sd">        If True and if `idiosyncratic_ar1 is True`, then this option puts small</span>
<span class="sd">        positive values in the observation disturbance covariance matrix. This</span>
<span class="sd">        is not required for estimation and is rarely used except for testing.</span>
<span class="sd">        (It is sometimes used to prevent numerical errors, for example those</span>
<span class="sd">        associated with a positive semi-definite forecast error covariance</span>
<span class="sd">        matrix at the first time step when using EM initialization, but state</span>
<span class="sd">        space models in Statsmodels switch to the univariate approach in those</span>
<span class="sd">        cases, and so do not need to use this trick). Default is False.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The basic model is:</span>

<span class="sd">    .. math::</span>

<span class="sd">        y_t &amp; = \Lambda f_t + \epsilon_t \\</span>
<span class="sd">        f_t &amp; = A_1 f_{t-1} + \dots + A_p f_{t-p} + u_t</span>

<span class="sd">    where:</span>

<span class="sd">    - :math:`y_t` is observed data at time t</span>
<span class="sd">    - :math:`\epsilon_t` is idiosyncratic disturbance at time t (see below for</span>
<span class="sd">      details, including modeling serial correlation in this term)</span>
<span class="sd">    - :math:`f_t` is the unobserved factor at time t</span>
<span class="sd">    - :math:`u_t \sim N(0, Q)` is the factor disturbance at time t</span>

<span class="sd">    and:</span>

<span class="sd">    - :math:`\Lambda` is referred to as the matrix of factor loadings</span>
<span class="sd">    - :math:`A_i` are matrices of autoregression coefficients</span>

<span class="sd">    Furthermore, we allow the idiosyncratic disturbances to be serially</span>
<span class="sd">    correlated, so that, if `idiosyncratic_ar1=True`,</span>
<span class="sd">    :math:`\epsilon_{i,t} = \rho_i \epsilon_{i,t-1} + e_{i,t}`, where</span>
<span class="sd">    :math:`e_{i,t} \sim N(0, \sigma_i^2)`. If `idiosyncratic_ar1=False`,</span>
<span class="sd">    then we instead have :math:`\epsilon_{i,t} = e_{i,t}`.</span>

<span class="sd">    This basic setup can be found in [1]_, [2]_, [3]_, and [4]_.</span>

<span class="sd">    We allow for two generalizations of this model:</span>

<span class="sd">    1. Following [2]_, we allow multiple "blocks" of factors, which are</span>
<span class="sd">       independent from the other blocks of factors. Different blocks can be</span>
<span class="sd">       set to load on different subsets of the observed variables, and can be</span>
<span class="sd">       specified with different lag orders.</span>
<span class="sd">    2. Following [4]_ and [2]_, we allow mixed frequency models in which both</span>
<span class="sd">       monthly and quarterly data are used. See the section on "Mixed frequency</span>
<span class="sd">       models", below, for more details.</span>

<span class="sd">    Additional notes:</span>

<span class="sd">    - The observed data may contain arbitrary patterns of missing entries.</span>

<span class="sd">    **EM algorithm**</span>

<span class="sd">    This model contains a potentially very large number of parameters, and it</span>
<span class="sd">    can be difficult and take a prohibitively long time to numerically optimize</span>
<span class="sd">    the likelihood function using quasi-Newton methods. Instead, the default</span>
<span class="sd">    fitting method in this model uses the EM algorithm, as detailed in [1]_.</span>
<span class="sd">    As a result, the model can accommodate datasets with hundreds of</span>
<span class="sd">    observed variables.</span>

<span class="sd">    **Mixed frequency data**</span>

<span class="sd">    This model can handle mixed frequency data in two ways. In this section,</span>
<span class="sd">    we only briefly describe this, and refer readers to [2]_ and [4]_ for all</span>
<span class="sd">    details.</span>

<span class="sd">    First, because there can be arbitrary patterns of missing data in the</span>
<span class="sd">    observed vector, one can simply include lower frequency variables as</span>
<span class="sd">    observed in a particular higher frequency period, and missing otherwise.</span>
<span class="sd">    For example, in a monthly model, one could include quarterly data as</span>
<span class="sd">    occurring on the third month of each quarter. To use this method, one</span>
<span class="sd">    simply needs to combine the data into a single dataset at the higher</span>
<span class="sd">    frequency that can be passed to this model as the `endog` argument.</span>
<span class="sd">    However, depending on the type of variables used in the analysis and the</span>
<span class="sd">    assumptions about the data generating process, this approach may not be</span>
<span class="sd">    valid.</span>

<span class="sd">    For example, suppose that we are interested in the growth rate of real GDP,</span>
<span class="sd">    which is measured at a quarterly frequency. If the basic factor model is</span>
<span class="sd">    specified at a monthly frequency, then the quarterly growth rate in the</span>
<span class="sd">    third month of each quarter -- which is what we actually observe -- is</span>
<span class="sd">    approximated by a particular weighted average of unobserved monthly growth</span>
<span class="sd">    rates. We need to take this particular weight moving average into account</span>
<span class="sd">    in constructing our model, and this is what the second approach does.</span>

<span class="sd">    The second approach follows [2]_ and [4]_ in constructing a state space</span>
<span class="sd">    form to explicitly model the quarterly growth rates in terms of the</span>
<span class="sd">    unobserved monthly growth rates. To use this approach, there are two</span>
<span class="sd">    methods:</span>

<span class="sd">    1. Combine the monthly and quarterly data into a single dataset at the</span>
<span class="sd">       monthly frequency, with the monthly data in the first columns and the</span>
<span class="sd">       quarterly data in the last columns. Pass this dataset to the model as</span>
<span class="sd">       the `endog` argument and give the number of the variables that are</span>
<span class="sd">       monthly as the `k_endog_monthly` argument.</span>
<span class="sd">    2. Construct a monthly dataset as a Pandas DataFrame with a DatetimeIndex</span>
<span class="sd">       or PeriodIndex at the monthly frequency and separately construct a</span>
<span class="sd">       quarterly dataset as a Pandas DataFrame with a DatetimeIndex or</span>
<span class="sd">       PeriodIndex at the quarterly frequency. Pass the monthly DataFrame to</span>
<span class="sd">       the model as the `endog` argument and pass the quarterly DataFrame to</span>
<span class="sd">       the model as the `endog_quarterly` argument.</span>

<span class="sd">    Note that this only incorporates one particular type of mixed frequency</span>
<span class="sd">    data. See also Banbura et al. (2013). "Now-Casting and the Real-Time Data</span>
<span class="sd">    Flow." for discussion about other types of mixed frequency data that are</span>
<span class="sd">    not supported by this framework.</span>

<span class="sd">    **Nowcasting and the news**</span>

<span class="sd">    Through its support for monthly/quarterly mixed frequency data, this model</span>
<span class="sd">    can allow for the nowcasting of quarterly variables based on monthly</span>
<span class="sd">    observations. In particular, [2]_ and [3]_ use this model to construct</span>
<span class="sd">    nowcasts of real GDP and analyze the impacts of "the news", derived from</span>
<span class="sd">    incoming data on a real-time basis. This latter functionality can be</span>
<span class="sd">    accessed through the `news` method of the results object.</span>

<span class="sd">    **Standardizing data**</span>

<span class="sd">    As is often the case in formulating a dynamic factor model, we do not</span>
<span class="sd">    explicitly account for the mean of each observed variable. Instead, the</span>
<span class="sd">    default behavior is to standardize each variable prior to estimation. Thus</span>
<span class="sd">    if :math:`y_t` are the given observed data, the dynamic factor model is</span>
<span class="sd">    actually estimated on the standardized data defined by:</span>

<span class="sd">    .. math::</span>

<span class="sd">        x_{i, t} = (y_{i, t} - \bar y_i) / s_i</span>

<span class="sd">    where :math:`\bar y_i` is the sample mean and :math:`s_i` is the sample</span>
<span class="sd">    standard deviation.</span>

<span class="sd">    By default, if standardization is applied prior to estimation, results such</span>
<span class="sd">    as in-sample predictions, out-of-sample forecasts, and the computation of</span>
<span class="sd">    the "news"  are reported in the scale of the original data (i.e. the model</span>
<span class="sd">    output has the reverse transformation applied before it is returned to the</span>
<span class="sd">    user).</span>

<span class="sd">    Standardization can be disabled by passing `standardization=False` to the</span>
<span class="sd">    model constructor.</span>

<span class="sd">    **Identification of factors and loadings**</span>

<span class="sd">    The estimated factors and the factor loadings in this model are only</span>
<span class="sd">    identified up to an invertible transformation. As described in (the working</span>
<span class="sd">    paper version of) [2]_, while it is possible to impose normalizations to</span>
<span class="sd">    achieve identification, the EM algorithm does will converge regardless.</span>
<span class="sd">    Moreover, for nowcasting and forecasting purposes, identification is not</span>
<span class="sd">    required. This model does not impose any normalization to identify the</span>
<span class="sd">    factors and the factor loadings.</span>

<span class="sd">    **Miscellaneous**</span>

<span class="sd">    There are two arguments available in the model constructor that are rarely</span>
<span class="sd">    used but which deserve a brief mention: `init_t0` and `obs_cov_diag`. These</span>
<span class="sd">    arguments are provided to allow exactly matching the output of other</span>
<span class="sd">    packages that have slight differences in how the underlying state space</span>
<span class="sd">    model is set up / applied.</span>

<span class="sd">    - `init_t0`: state space models in Statsmodels follow Durbin and Koopman in</span>
<span class="sd">      initializing the model with :math:`\alpha_1 \sim N(a_1, P_1)`. Other</span>
<span class="sd">      implementations sometimes initialize instead with</span>
<span class="sd">      :math:`\alpha_0 \sim N(a_0, P_0)`. We can accommodate this by prepending</span>
<span class="sd">      a row of NaNs to the observed dataset.</span>
<span class="sd">    - `obs_cov_diag`: the state space form in [1]_ incorporates non-zero (but</span>
<span class="sd">      very small) diagonal elements for the observation disturbance covariance</span>
<span class="sd">      matrix.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Constructing and fitting a `DynamicFactorMQ` model.</span>

<span class="sd">    &gt;&gt;&gt; data = sm.datasets.macrodata.load_pandas().data.iloc[-100:]</span>
<span class="sd">    &gt;&gt;&gt; data.index = pd.period_range(start='1984Q4', end='2009Q3', freq='Q')</span>
<span class="sd">    &gt;&gt;&gt; endog = data[['infl', 'tbilrate']].resample('M').last()</span>
<span class="sd">    &gt;&gt;&gt; endog_Q = np.log(data[['realgdp', 'realcons']]).diff().iloc[1:] * 400</span>

<span class="sd">    **Basic usage**</span>

<span class="sd">    In the simplest case, passing only the `endog` argument results in a model</span>
<span class="sd">    with a single factor that follows an AR(1) process. Note that because we</span>
<span class="sd">    are not also providing an `endog_quarterly` dataset, `endog` can be a numpy</span>
<span class="sd">    array or Pandas DataFrame with any index (it does not have to be monthly).</span>

<span class="sd">    The `summary` method can be useful in checking the model specification.</span>

<span class="sd">    &gt;&gt;&gt; mod = sm.tsa.DynamicFactorMQ(endog)</span>
<span class="sd">    &gt;&gt;&gt; print(mod.summary())</span>
<span class="sd">                        Model Specification: Dynamic Factor Model</span>
<span class="sd">    ==========================================================================</span>
<span class="sd">    Model:         Dynamic Factor Model   # of monthly variables:          2</span>
<span class="sd">                + 1 factors in 1 blocks   # of factors:                    1</span>
<span class="sd">                  + AR(1) idiosyncratic   Idiosyncratic disturbances:  AR(1)</span>
<span class="sd">    Sample:                     1984-10   Standardize variables:        True</span>
<span class="sd">                              - 2009-09</span>
<span class="sd">    Observed variables / factor loadings</span>
<span class="sd">    ========================</span>
<span class="sd">    Dep. variable          0</span>
<span class="sd">    ------------------------</span>
<span class="sd">             infl          X</span>
<span class="sd">         tbilrate          X</span>
<span class="sd">        Factor blocks:</span>
<span class="sd">    =====================</span>
<span class="sd">         block      order</span>
<span class="sd">    ---------------------</span>
<span class="sd">             0          1</span>
<span class="sd">    =====================</span>

<span class="sd">    **Factors**</span>

<span class="sd">    With `factors=2`, there will be two independent factors that will each</span>
<span class="sd">    evolve according to separate AR(1) processes.</span>

<span class="sd">    &gt;&gt;&gt; mod = sm.tsa.DynamicFactorMQ(endog, factors=2)</span>
<span class="sd">    &gt;&gt;&gt; print(mod.summary())</span>
<span class="sd">                        Model Specification: Dynamic Factor Model</span>
<span class="sd">    ==========================================================================</span>
<span class="sd">    Model:         Dynamic Factor Model   # of monthly variables:          2</span>
<span class="sd">                + 2 factors in 2 blocks   # of factors:                    2</span>
<span class="sd">                  + AR(1) idiosyncratic   Idiosyncratic disturbances:  AR(1)</span>
<span class="sd">    Sample:                     1984-10   Standardize variables:        True</span>
<span class="sd">                              - 2009-09</span>
<span class="sd">    Observed variables / factor loadings</span>
<span class="sd">    ===================================</span>
<span class="sd">    Dep. variable          0          1</span>
<span class="sd">    -----------------------------------</span>
<span class="sd">             infl          X          X</span>
<span class="sd">         tbilrate          X          X</span>
<span class="sd">        Factor blocks:</span>
<span class="sd">    =====================</span>
<span class="sd">         block      order</span>
<span class="sd">    ---------------------</span>
<span class="sd">             0          1</span>
<span class="sd">             1          1</span>
<span class="sd">    =====================</span>

<span class="sd">    **Factor multiplicities**</span>

<span class="sd">    By instead specifying `factor_multiplicities=2`, we would still have two</span>
<span class="sd">    factors, but they would be dependent and would evolve jointly according</span>
<span class="sd">    to a VAR(1) process.</span>

<span class="sd">    &gt;&gt;&gt; mod = sm.tsa.DynamicFactorMQ(endog, factor_multiplicities=2)</span>
<span class="sd">    &gt;&gt;&gt; print(mod.summary())</span>
<span class="sd">                        Model Specification: Dynamic Factor Model</span>
<span class="sd">    ==========================================================================</span>
<span class="sd">    Model:         Dynamic Factor Model   # of monthly variables:          2</span>
<span class="sd">                + 2 factors in 1 blocks   # of factors:                    2</span>
<span class="sd">                  + AR(1) idiosyncratic   Idiosyncratic disturbances:  AR(1)</span>
<span class="sd">    Sample:                     1984-10   Standardize variables:        True</span>
<span class="sd">                              - 2009-09</span>
<span class="sd">    Observed variables / factor loadings</span>
<span class="sd">    ===================================</span>
<span class="sd">    Dep. variable        0.1        0.2</span>
<span class="sd">    -----------------------------------</span>
<span class="sd">             infl         X          X</span>
<span class="sd">         tbilrate         X          X</span>
<span class="sd">        Factor blocks:</span>
<span class="sd">    =====================</span>
<span class="sd">         block      order</span>
<span class="sd">    ---------------------</span>
<span class="sd">      0.1, 0.2          1</span>
<span class="sd">    =====================</span>

<span class="sd">    **Factor orders**</span>

<span class="sd">    In either of the above cases, we could extend the order of the (vector)</span>
<span class="sd">    autoregressions by using the `factor_orders` argument. For example, the</span>
<span class="sd">    below model would contain two independent factors that each evolve</span>
<span class="sd">    according to a separate AR(2) process:</span>

<span class="sd">    &gt;&gt;&gt; mod = sm.tsa.DynamicFactorMQ(endog, factors=2, factor_orders=2)</span>
<span class="sd">    &gt;&gt;&gt; print(mod.summary())</span>
<span class="sd">                        Model Specification: Dynamic Factor Model</span>
<span class="sd">    ==========================================================================</span>
<span class="sd">    Model:         Dynamic Factor Model   # of monthly variables:          2</span>
<span class="sd">                + 2 factors in 2 blocks   # of factors:                    2</span>
<span class="sd">                  + AR(1) idiosyncratic   Idiosyncratic disturbances:  AR(1)</span>
<span class="sd">    Sample:                     1984-10   Standardize variables:        True</span>
<span class="sd">                              - 2009-09</span>
<span class="sd">    Observed variables / factor loadings</span>
<span class="sd">    ===================================</span>
<span class="sd">    Dep. variable          0          1</span>
<span class="sd">    -----------------------------------</span>
<span class="sd">             infl          X          X</span>
<span class="sd">         tbilrate          X          X</span>
<span class="sd">        Factor blocks:</span>
<span class="sd">    =====================</span>
<span class="sd">         block      order</span>
<span class="sd">    ---------------------</span>
<span class="sd">             0          2</span>
<span class="sd">             1          2</span>
<span class="sd">    =====================</span>

<span class="sd">    **Serial correlation in the idiosyncratic disturbances**</span>

<span class="sd">    By default, the model allows each idiosyncratic disturbance terms to evolve</span>
<span class="sd">    according to an AR(1) process. If preferred, they can instead be specified</span>
<span class="sd">    to be serially independent by passing `ididosyncratic_ar1=False`.</span>

<span class="sd">    &gt;&gt;&gt; mod = sm.tsa.DynamicFactorMQ(endog, idiosyncratic_ar1=False)</span>
<span class="sd">    &gt;&gt;&gt; print(mod.summary())</span>
<span class="sd">                        Model Specification: Dynamic Factor Model</span>
<span class="sd">    ==========================================================================</span>
<span class="sd">    Model:         Dynamic Factor Model   # of monthly variables:          2</span>
<span class="sd">                + 1 factors in 1 blocks   # of factors:                    1</span>
<span class="sd">                    + iid idiosyncratic   Idiosyncratic disturbances:    iid</span>
<span class="sd">    Sample:                     1984-10   Standardize variables:        True</span>
<span class="sd">                              - 2009-09</span>
<span class="sd">    Observed variables / factor loadings</span>
<span class="sd">    ========================</span>
<span class="sd">    Dep. variable          0</span>
<span class="sd">    ------------------------</span>
<span class="sd">             infl          X</span>
<span class="sd">         tbilrate          X</span>
<span class="sd">        Factor blocks:</span>
<span class="sd">    =====================</span>
<span class="sd">         block      order</span>
<span class="sd">    ---------------------</span>
<span class="sd">             0          1</span>
<span class="sd">    =====================</span>

<span class="sd">    *Monthly / Quarterly mixed frequency*</span>

<span class="sd">    To specify a monthly / quarterly mixed frequency model see the (Notes</span>
<span class="sd">    section for more details about these models):</span>

<span class="sd">    &gt;&gt;&gt; mod = sm.tsa.DynamicFactorMQ(endog, endog_quarterly=endog_Q)</span>
<span class="sd">    &gt;&gt;&gt; print(mod.summary())</span>
<span class="sd">                        Model Specification: Dynamic Factor Model</span>
<span class="sd">    ==========================================================================</span>
<span class="sd">    Model:         Dynamic Factor Model   # of monthly variables:          2</span>
<span class="sd">                + 1 factors in 1 blocks   # of quarterly variables:        2</span>
<span class="sd">                + Mixed frequency (M/Q)   # of factors:                    1</span>
<span class="sd">                  + AR(1) idiosyncratic   Idiosyncratic disturbances:  AR(1)</span>
<span class="sd">    Sample:                     1984-10   Standardize variables:        True</span>
<span class="sd">                              - 2009-09</span>
<span class="sd">    Observed variables / factor loadings</span>
<span class="sd">    ========================</span>
<span class="sd">    Dep. variable          0</span>
<span class="sd">    ------------------------</span>
<span class="sd">             infl          X</span>
<span class="sd">         tbilrate          X</span>
<span class="sd">          realgdp          X</span>
<span class="sd">         realcons          X</span>
<span class="sd">        Factor blocks:</span>
<span class="sd">    =====================</span>
<span class="sd">         block      order</span>
<span class="sd">    ---------------------</span>
<span class="sd">             0          1</span>
<span class="sd">    =====================</span>

<span class="sd">    *Customize observed variable / factor loadings*</span>

<span class="sd">    To specify that certain that certain observed variables only load on</span>
<span class="sd">    certain factors, it is possible to pass a dictionary to the `factors`</span>
<span class="sd">    argument.</span>

<span class="sd">    &gt;&gt;&gt; factors = {'infl': ['global']</span>
<span class="sd">    ...            'tbilrate': ['global']</span>
<span class="sd">    ...            'realgdp': ['global', 'real']</span>
<span class="sd">    ...            'realcons': ['global', 'real']}</span>
<span class="sd">    &gt;&gt;&gt; mod = sm.tsa.DynamicFactorMQ(endog, endog_quarterly=endog_Q)</span>
<span class="sd">    &gt;&gt;&gt; print(mod.summary())</span>
<span class="sd">                        Model Specification: Dynamic Factor Model</span>
<span class="sd">    ==========================================================================</span>
<span class="sd">    Model:         Dynamic Factor Model   # of monthly variables:          2</span>
<span class="sd">                + 2 factors in 2 blocks   # of quarterly variables:        2</span>
<span class="sd">                + Mixed frequency (M/Q)   # of factor blocks:              2</span>
<span class="sd">                  + AR(1) idiosyncratic   Idiosyncratic disturbances:  AR(1)</span>
<span class="sd">    Sample:                     1984-10   Standardize variables:        True</span>
<span class="sd">                              - 2009-09</span>
<span class="sd">    Observed variables / factor loadings</span>
<span class="sd">    ===================================</span>
<span class="sd">    Dep. variable     global       real</span>
<span class="sd">    -----------------------------------</span>
<span class="sd">             infl       X</span>
<span class="sd">         tbilrate       X</span>
<span class="sd">          realgdp       X           X</span>
<span class="sd">         realcons       X           X</span>
<span class="sd">        Factor blocks:</span>
<span class="sd">    =====================</span>
<span class="sd">         block      order</span>
<span class="sd">    ---------------------</span>
<span class="sd">        global          1</span>
<span class="sd">          real          1</span>
<span class="sd">    =====================</span>

<span class="sd">    **Fitting parameters**</span>

<span class="sd">    To fit the model, use the `fit` method. This method uses the EM algorithm</span>
<span class="sd">    by default.</span>

<span class="sd">    &gt;&gt;&gt; mod = sm.tsa.DynamicFactorMQ(endog)</span>
<span class="sd">    &gt;&gt;&gt; res = mod.fit()</span>
<span class="sd">    &gt;&gt;&gt; print(res.summary())</span>
<span class="sd">                              Dynamic Factor Results</span>
<span class="sd">    ==========================================================================</span>
<span class="sd">    Dep. Variable:      ['infl', 'tbilrate']   No. Observations:         300</span>
<span class="sd">    Model:              Dynamic Factor Model   Log Likelihood       -127.909</span>
<span class="sd">                     + 1 factors in 1 blocks   AIC                   271.817</span>
<span class="sd">                       + AR(1) idiosyncratic   BIC                   301.447</span>
<span class="sd">    Date:                   Tue, 04 Aug 2020   HQIC                  283.675</span>
<span class="sd">    Time:                           15:59:11   EM Iterations              83</span>
<span class="sd">    Sample:                       10-31-1984</span>
<span class="sd">                                - 09-30-2009</span>
<span class="sd">    Covariance Type:            Not computed</span>
<span class="sd">                        Observation equation:</span>
<span class="sd">    ==============================================================</span>
<span class="sd">    Factor loadings:          0    idiosyncratic: AR(1)       var.</span>
<span class="sd">    --------------------------------------------------------------</span>
<span class="sd">                infl      -0.67                    0.39       0.73</span>
<span class="sd">            tbilrate      -0.63                    0.99       0.01</span>
<span class="sd">           Transition: Factor block 0</span>
<span class="sd">    =======================================</span>
<span class="sd">                     L1.0    error variance</span>
<span class="sd">    ---------------------------------------</span>
<span class="sd">             0       0.98              0.01</span>
<span class="sd">    =======================================</span>
<span class="sd">    Warnings:</span>
<span class="sd">    [1] Covariance matrix not calculated.</span>

<span class="sd">    *Displaying iteration progress*</span>

<span class="sd">    To display information about the EM iterations, use the `disp` argument.</span>

<span class="sd">    &gt;&gt;&gt; mod = sm.tsa.DynamicFactorMQ(endog)</span>
<span class="sd">    &gt;&gt;&gt; res = mod.fit(disp=10)</span>
<span class="sd">    EM start iterations, llf=-291.21</span>
<span class="sd">    EM iteration 10, llf=-157.17, convergence criterion=0.053801</span>
<span class="sd">    EM iteration 20, llf=-128.99, convergence criterion=0.0035545</span>
<span class="sd">    EM iteration 30, llf=-127.97, convergence criterion=0.00010224</span>
<span class="sd">    EM iteration 40, llf=-127.93, convergence criterion=1.3281e-05</span>
<span class="sd">    EM iteration 50, llf=-127.92, convergence criterion=5.4725e-06</span>
<span class="sd">    EM iteration 60, llf=-127.91, convergence criterion=2.8665e-06</span>
<span class="sd">    EM iteration 70, llf=-127.91, convergence criterion=1.6999e-06</span>
<span class="sd">    EM iteration 80, llf=-127.91, convergence criterion=1.1085e-06</span>
<span class="sd">    EM converged at iteration 83, llf=-127.91,</span>
<span class="sd">       convergence criterion=9.9004e-07 &lt; tolerance=1e-06</span>

<span class="sd">    **Results: forecasting, impulse responses, and more**</span>

<span class="sd">    One the model is fitted, there are a number of methods available from the</span>
<span class="sd">    results object. Some examples include:</span>

<span class="sd">    *Forecasting*</span>

<span class="sd">    &gt;&gt;&gt; mod = sm.tsa.DynamicFactorMQ(endog)</span>
<span class="sd">    &gt;&gt;&gt; res = mod.fit()</span>
<span class="sd">    &gt;&gt;&gt; print(res.forecast(steps=5))</span>
<span class="sd">                 infl  tbilrate</span>
<span class="sd">    2009-10  1.784169  0.260401</span>
<span class="sd">    2009-11  1.735848  0.305981</span>
<span class="sd">    2009-12  1.730674  0.350968</span>
<span class="sd">    2010-01  1.742110  0.395369</span>
<span class="sd">    2010-02  1.759786  0.439194</span>

<span class="sd">    *Impulse responses*</span>

<span class="sd">    &gt;&gt;&gt; mod = sm.tsa.DynamicFactorMQ(endog)</span>
<span class="sd">    &gt;&gt;&gt; res = mod.fit()</span>
<span class="sd">    &gt;&gt;&gt; print(res.impulse_responses(steps=5))</span>
<span class="sd">           infl  tbilrate</span>
<span class="sd">    0 -1.511956 -1.341498</span>
<span class="sd">    1 -1.483172 -1.315960</span>
<span class="sd">    2 -1.454937 -1.290908</span>
<span class="sd">    3 -1.427240 -1.266333</span>
<span class="sd">    4 -1.400069 -1.242226</span>
<span class="sd">    5 -1.373416 -1.218578</span>

<span class="sd">    For other available methods (including in-sample prediction, simulation of</span>
<span class="sd">    time series, extending the results to incorporate new data, and the news),</span>
<span class="sd">    see the documentation for state space models.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Bańbura, Marta, and Michele Modugno.</span>
<span class="sd">           "Maximum likelihood estimation of factor models on datasets with</span>
<span class="sd">           arbitrary pattern of missing data."</span>
<span class="sd">           Journal of Applied Econometrics 29, no. 1 (2014): 133-160.</span>
<span class="sd">    .. [2] Bańbura, Marta, Domenico Giannone, and Lucrezia Reichlin.</span>
<span class="sd">           "Nowcasting."</span>
<span class="sd">           The Oxford Handbook of Economic Forecasting. July 8, 2011.</span>
<span class="sd">    .. [3] Bok, Brandyn, Daniele Caratelli, Domenico Giannone,</span>
<span class="sd">           Argia M. Sbordone, and Andrea Tambalotti. 2018.</span>
<span class="sd">           "Macroeconomic Nowcasting and Forecasting with Big Data."</span>
<span class="sd">           Annual Review of Economics 10 (1): 615-43.</span>
<span class="sd">           https://doi.org/10.1146/annurev-economics-080217-053214.</span>
<span class="sd">    .. [4] Mariano, Roberto S., and Yasutomo Murasawa.</span>
<span class="sd">           "A coincident index, common factors, and monthly real GDP."</span>
<span class="sd">           Oxford Bulletin of Economics and Statistics 72, no. 1 (2010): 27-46.</span>

<span class="sd">    """</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">endog</span><span class="p">,</span> <span class="n">k_endog_monthly</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">factors</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">factor_orders</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                 <span class="n">factor_multiplicities</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">idiosyncratic_ar1</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">standardize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">endog_quarterly</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">init_t0</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">obs_cov_diag</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># Handle endog variables</span>
        <span class="k">if</span> <span class="n">endog_quarterly</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">k_endog_monthly</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'If `endog_quarterly` is specified, then'</span>
                                 <span class="s1">' `endog` must contain only monthly'</span>
                                 <span class="s1">' variables, and so `k_endog_monthly` cannot'</span>
                                 <span class="s1">' be specified since it will be inferred from'</span>
                                 <span class="s1">' the shape of `endog`.'</span><span class="p">)</span>
            <span class="n">endog</span><span class="p">,</span> <span class="n">k_endog_monthly</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">construct_endog</span><span class="p">(</span>
                <span class="n">endog</span><span class="p">,</span> <span class="n">endog_quarterly</span><span class="p">)</span>
        <span class="n">endog_is_pandas</span> <span class="o">=</span> <span class="n">_is_using_pandas</span><span class="p">(</span><span class="n">endog</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">endog_is_pandas</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">endog</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">):</span>
                <span class="n">endog</span> <span class="o">=</span> <span class="n">endog</span><span class="o">.</span><span class="n">to_frame</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">endog</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">endog</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">endog</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

        <span class="k">if</span> <span class="n">k_endog_monthly</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">k_endog_monthly</span> <span class="o">=</span> <span class="n">endog</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">endog_is_pandas</span><span class="p">:</span>
            <span class="n">endog_names</span> <span class="o">=</span> <span class="n">endog</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">endog</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">endog_names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">'y'</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">endog_names</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s1">'y</span><span class="si">{</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="si">}</span><span class="s1">'</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">endog</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">k_endog_M</span> <span class="o">=</span> <span class="n">int_like</span><span class="p">(</span><span class="n">k_endog_monthly</span><span class="p">,</span> <span class="s1">'k_endog_monthly'</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k_endog_Q</span> <span class="o">=</span> <span class="n">endog</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog_M</span>

        <span class="c1"># Compute helper for handling factors / state indexing</span>
        <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s</span> <span class="o">=</span> <span class="n">DynamicFactorMQStates</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">k_endog_M</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog_Q</span><span class="p">,</span> <span class="n">endog_names</span><span class="p">,</span> <span class="n">factors</span><span class="p">,</span>
            <span class="n">factor_orders</span><span class="p">,</span> <span class="n">factor_multiplicities</span><span class="p">,</span> <span class="n">idiosyncratic_ar1</span><span class="p">)</span>

        <span class="c1"># Save parameterization</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">factors</span> <span class="o">=</span> <span class="n">factors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">factor_orders</span> <span class="o">=</span> <span class="n">factor_orders</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">factor_multiplicities</span> <span class="o">=</span> <span class="n">factor_multiplicities</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">endog_factor_map</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s</span><span class="o">.</span><span class="n">endog_factor_map</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">factor_block_orders</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s</span><span class="o">.</span><span class="n">factor_block_orders</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">factor_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s</span><span class="o">.</span><span class="n">factor_names</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k_factors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s</span><span class="o">.</span><span class="n">k_factors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k_factor_blocks</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">factor_block_orders</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_factor_order</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s</span><span class="o">.</span><span class="n">max_factor_order</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">idiosyncratic_ar1</span> <span class="o">=</span> <span class="n">idiosyncratic_ar1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">init_t0</span> <span class="o">=</span> <span class="n">init_t0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">obs_cov_diag</span> <span class="o">=</span> <span class="n">obs_cov_diag</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">init_t0</span><span class="p">:</span>
            <span class="c1"># TODO: test each of these options</span>
            <span class="k">if</span> <span class="n">endog_is_pandas</span><span class="p">:</span>
                <span class="n">ix</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">period_range</span><span class="p">(</span><span class="n">endog</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">endog</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                                     <span class="n">freq</span><span class="o">=</span><span class="s1">'M'</span><span class="p">)</span>
                <span class="n">endog</span> <span class="o">=</span> <span class="n">endog</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">ix</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">endog</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">]</span> <span class="o">*</span> <span class="n">endog</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">endog</span><span class="o">.</span><span class="n">T</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>

        <span class="c1"># Standardize endog, if requested</span>
        <span class="c1"># Note: endog_mean and endog_std will always each be 1-dimensional with</span>
        <span class="c1"># length equal to the number of endog variables</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">standardize</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">standardize</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">endog_mean</span><span class="p">,</span> <span class="n">endog_std</span> <span class="o">=</span> <span class="n">standardize</span>

            <span class="c1"># Validate the input</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">endog</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">endog_mean</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span>
                    <span class="n">endog_mean</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">(</span><span class="n">endog_names</span><span class="p">))):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'Invalid value passed for `standardize`:'</span>
                                 <span class="s1">' if a Pandas Series, must have index'</span>
                                 <span class="sa">f</span><span class="s1">' </span><span class="si">{</span><span class="n">endog_names</span><span class="si">}</span><span class="s1">. Got </span><span class="si">{</span><span class="n">endog_mean</span><span class="o">.</span><span class="n">index</span><span class="si">}</span><span class="s1">.'</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">endog_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">endog_mean</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">endog_std</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span>
                    <span class="n">endog_std</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">(</span><span class="n">endog_names</span><span class="p">))):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'Invalid value passed for `standardize`:'</span>
                                 <span class="s1">' if a Pandas Series, must have index'</span>
                                 <span class="sa">f</span><span class="s1">' </span><span class="si">{</span><span class="n">endog_names</span><span class="si">}</span><span class="s1">. Got </span><span class="si">{</span><span class="n">endog_std</span><span class="o">.</span><span class="n">index</span><span class="si">}</span><span class="s1">.'</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">endog_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">endog_std</span><span class="p">)</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">endog_mean</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="n">n</span><span class="p">,)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">endog_std</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="n">n</span><span class="p">,)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'Invalid value passed for `standardize`: each'</span>
                                 <span class="sa">f</span><span class="s1">' element must be shaped (</span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s1">,).'</span><span class="p">)</span>
            <span class="n">standardize</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="c1"># Make sure we have Pandas if endog is Pandas</span>
            <span class="k">if</span> <span class="n">endog_is_pandas</span><span class="p">:</span>
                <span class="n">endog_mean</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">endog_mean</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">endog_names</span><span class="p">)</span>
                <span class="n">endog_std</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">endog_std</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">endog_names</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">standardize</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="kc">True</span><span class="p">]:</span>
            <span class="n">endog_mean</span> <span class="o">=</span> <span class="n">endog</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">endog_std</span> <span class="o">=</span> <span class="n">endog</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">standardize</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="kc">False</span><span class="p">]:</span>
            <span class="n">endog_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">endog</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">endog_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">endog</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'Invalid value passed for `standardize`.'</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_endog_mean</span> <span class="o">=</span> <span class="n">endog_mean</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_endog_std</span> <span class="o">=</span> <span class="n">endog_std</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">standardize</span> <span class="o">=</span> <span class="n">standardize</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_endog_std</span> <span class="o">&lt;</span> <span class="mf">1e-10</span><span class="p">):</span>
            <span class="n">ix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_endog_std</span> <span class="o">&lt;</span> <span class="mf">1e-10</span><span class="p">)</span>
            <span class="n">names</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">endog_names</span><span class="p">)[</span><span class="n">ix</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'Constant variable(s) found in observed'</span>
                             <span class="s1">' variables, but constants cannot be included'</span>
                             <span class="sa">f</span><span class="s1">' in this model. These variables are: </span><span class="si">{</span><span class="n">names</span><span class="si">}</span><span class="s1">.'</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">standardize</span><span class="p">:</span>
            <span class="n">endog</span> <span class="o">=</span> <span class="p">(</span><span class="n">endog</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_endog_mean</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_endog_std</span>

        <span class="c1"># Observation / states slices</span>
        <span class="n">o</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_o</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">'M'</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">s_</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">k_endog_M</span><span class="p">],</span>
            <span class="s1">'Q'</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">s_</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">k_endog_M</span><span class="p">:]}</span>

        <span class="c1"># Construct the basic state space representation</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">endog</span><span class="p">,</span> <span class="n">k_states</span><span class="o">=</span><span class="n">s</span><span class="o">.</span><span class="n">k_states</span><span class="p">,</span> <span class="n">k_posdef</span><span class="o">=</span><span class="n">s</span><span class="o">.</span><span class="n">k_posdef</span><span class="p">,</span>
                         <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Revert the standardization for orig_endog</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">standardize</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">orig_endog</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">orig_endog</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_endog_std</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_endog_mean</span><span class="p">)</span>

        <span class="c1"># State initialization</span>
        <span class="c1"># Note: we could just initialize the entire thing as stationary, but</span>
        <span class="c1"># doing each block separately should be faster and avoid numerical</span>
        <span class="c1"># issues</span>
        <span class="k">if</span> <span class="s1">'initialization'</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">initialize</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_default_initialization</span><span class="p">())</span>

        <span class="c1"># Fixed components of the state space representation</span>

        <span class="c1"># &gt; design</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">idiosyncratic_ar1</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">[</span><span class="s1">'design'</span><span class="p">,</span> <span class="n">o</span><span class="p">[</span><span class="s1">'M'</span><span class="p">],</span> <span class="n">s</span><span class="p">[</span><span class="s1">'idio_ar_M'</span><span class="p">]]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_endog_M</span><span class="p">)</span>
        <span class="n">multipliers</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">multipliers</span><span class="p">)):</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">multipliers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="bp">self</span><span class="p">[</span><span class="s1">'design'</span><span class="p">,</span> <span class="n">o</span><span class="p">[</span><span class="s1">'Q'</span><span class="p">],</span> <span class="n">s</span><span class="p">[</span><span class="s1">'idio_ar_Q_ix'</span><span class="p">][:,</span> <span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">m</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_endog_Q</span><span class="p">))</span>

        <span class="c1"># &gt; obs cov</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">obs_cov_diag</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">[</span><span class="s1">'obs_cov'</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">)</span> <span class="o">*</span> <span class="mf">1e-4</span>

        <span class="c1"># &gt; transition</span>
        <span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="n">s</span><span class="o">.</span><span class="n">factor_blocks</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">block</span><span class="o">.</span><span class="n">k_factors</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">tmp</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">block</span><span class="o">.</span><span class="n">k_factors</span><span class="p">,</span> <span class="n">block</span><span class="o">.</span><span class="n">k_factors</span><span class="p">))</span>
            <span class="bp">self</span><span class="p">[</span><span class="s1">'transition'</span><span class="p">,</span> <span class="n">block</span><span class="p">[</span><span class="s1">'factors'</span><span class="p">],</span> <span class="n">block</span><span class="p">[</span><span class="s1">'factors'</span><span class="p">]]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">companion_matrix</span><span class="p">([</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">tmp</span><span class="p">]</span> <span class="o">*</span> <span class="n">block</span><span class="o">.</span><span class="n">_factor_order</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog_Q</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">k_endog_Q</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog_Q</span><span class="p">))</span>
        <span class="bp">self</span><span class="p">[</span><span class="s1">'transition'</span><span class="p">,</span> <span class="n">s</span><span class="p">[</span><span class="s1">'idio_ar_Q'</span><span class="p">],</span> <span class="n">s</span><span class="p">[</span><span class="s1">'idio_ar_Q'</span><span class="p">]]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">companion_matrix</span><span class="p">([</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">tmp</span><span class="p">]</span> <span class="o">*</span> <span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

        <span class="c1"># &gt; selection</span>
        <span class="n">ix1</span> <span class="o">=</span> <span class="n">ix2</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="n">s</span><span class="o">.</span><span class="n">factor_blocks</span><span class="p">:</span>
            <span class="n">ix2</span> <span class="o">+=</span> <span class="n">block</span><span class="o">.</span><span class="n">k_factors</span>
            <span class="bp">self</span><span class="p">[</span><span class="s1">'selection'</span><span class="p">,</span> <span class="n">block</span><span class="p">[</span><span class="s1">'factors_ix'</span><span class="p">][:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">ix1</span><span class="p">:</span><span class="n">ix2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">block</span><span class="o">.</span><span class="n">k_factors</span><span class="p">))</span>
            <span class="n">ix1</span> <span class="o">=</span> <span class="n">ix2</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">idiosyncratic_ar1</span><span class="p">:</span>
            <span class="n">ix2</span> <span class="o">=</span> <span class="n">ix1</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog_M</span>
            <span class="bp">self</span><span class="p">[</span><span class="s1">'selection'</span><span class="p">,</span> <span class="n">s</span><span class="p">[</span><span class="s1">'idio_ar_M'</span><span class="p">],</span> <span class="n">ix1</span><span class="p">:</span><span class="n">ix2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_endog_M</span><span class="p">)</span>
            <span class="n">ix1</span> <span class="o">=</span> <span class="n">ix2</span>

        <span class="n">ix2</span> <span class="o">=</span> <span class="n">ix1</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog_Q</span>
        <span class="bp">self</span><span class="p">[</span><span class="s1">'selection'</span><span class="p">,</span> <span class="n">s</span><span class="p">[</span><span class="s1">'idio_ar_Q_ix'</span><span class="p">][:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">ix1</span><span class="p">:</span><span class="n">ix2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_endog_Q</span><span class="p">))</span>

        <span class="c1"># Parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">params</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">([</span>
            <span class="p">(</span><span class="s1">'loadings'</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endog_factor_map</span><span class="o">.</span><span class="n">values</span><span class="p">)),</span>
            <span class="p">(</span><span class="s1">'factor_ar'</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">block</span><span class="o">.</span><span class="n">k_factors</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">block</span><span class="o">.</span><span class="n">factor_order</span>
                                  <span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="n">s</span><span class="o">.</span><span class="n">factor_blocks</span><span class="p">])),</span>
            <span class="p">(</span><span class="s1">'factor_cov'</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">block</span><span class="o">.</span><span class="n">k_factors</span> <span class="o">*</span> <span class="p">(</span><span class="n">block</span><span class="o">.</span><span class="n">k_factors</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
                                   <span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="n">s</span><span class="o">.</span><span class="n">factor_blocks</span><span class="p">])),</span>
            <span class="p">(</span><span class="s1">'idiosyncratic_ar1'</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">idiosyncratic_ar1</span> <span class="k">else</span> <span class="mi">0</span><span class="p">),</span>
            <span class="p">(</span><span class="s1">'idiosyncratic_var'</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">)])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k_params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>

        <span class="c1"># Parameter slices</span>
        <span class="n">ix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_params</span><span class="p">),</span>
                      <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">values</span><span class="p">()))[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_p</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span> <span class="n">ix</span><span class="p">))</span>

        <span class="c1"># Cache</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_loading_constraints</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># Initialization kwarg keys, e.g. for cloning</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_init_keys</span> <span class="o">+=</span> <span class="p">[</span>
            <span class="s1">'factors'</span><span class="p">,</span> <span class="s1">'factor_orders'</span><span class="p">,</span> <span class="s1">'factor_multiplicities'</span><span class="p">,</span>
            <span class="s1">'idiosyncratic_ar1'</span><span class="p">,</span> <span class="s1">'standardize'</span><span class="p">,</span> <span class="s1">'init_t0'</span><span class="p">,</span>
            <span class="s1">'obs_cov_diag'</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

<div class="viewcode-block" id="DynamicFactorMQ.construct_endog"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.dynamic_factor_mq.DynamicFactorMQ.construct_endog.html#statsmodels.tsa.statespace.dynamic_factor_mq.DynamicFactorMQ.construct_endog">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">construct_endog</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">endog_monthly</span><span class="p">,</span> <span class="n">endog_quarterly</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Construct a combined dataset from separate monthly and quarterly data.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        endog_monthly : array_like</span>
<span class="sd">            Monthly dataset. If a quarterly dataset is given, then this must</span>
<span class="sd">            be a Pandas object with a PeriodIndex or DatetimeIndex at a monthly</span>
<span class="sd">            frequency.</span>
<span class="sd">        endog_quarterly : array_like or None</span>
<span class="sd">            Quarterly dataset. If not None, then this must be a Pandas object</span>
<span class="sd">            with a PeriodIndex or DatetimeIndex at a quarterly frequency.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        endog : array_like</span>
<span class="sd">            If both endog_monthly and endog_quarterly were given, this is a</span>
<span class="sd">            Pandas DataFrame with a PeriodIndex at the monthly frequency, with</span>
<span class="sd">            all of the columns from `endog_monthly` ordered first and the</span>
<span class="sd">            columns from `endog_quarterly` ordered afterwards. Otherwise it is</span>
<span class="sd">            simply the input `endog_monthly` dataset.</span>
<span class="sd">        k_endog_monthly : int</span>
<span class="sd">            The number of monthly variables (which are ordered first) in the</span>
<span class="sd">            returned `endog` dataset.</span>
<span class="sd">        """</span>
        <span class="c1"># Create combined dataset</span>
        <span class="k">if</span> <span class="n">endog_quarterly</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Validate endog_monthly</span>
            <span class="n">base_msg</span> <span class="o">=</span> <span class="p">(</span><span class="s1">'If given both monthly and quarterly data'</span>
                        <span class="s1">' then the monthly dataset must be a Pandas'</span>
                        <span class="s1">' object with a date index at a monthly frequency.'</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">endog_monthly</span><span class="p">,</span> <span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'Given monthly dataset is not a'</span>
                                 <span class="s1">' Pandas object. '</span> <span class="o">+</span> <span class="n">base_msg</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">endog_monthly</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">inferred_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span>
                <span class="s2">"datetime64"</span><span class="p">,</span>
                <span class="s2">"period"</span><span class="p">,</span>
            <span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'Given monthly dataset has an'</span>
                                 <span class="s1">' index with non-date values. '</span> <span class="o">+</span> <span class="n">base_msg</span><span class="p">)</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">endog_monthly</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="s1">'freqstr'</span><span class="p">,</span> <span class="s1">'N'</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">'M'</span><span class="p">:</span>
                <span class="n">freqstr</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">endog_monthly</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="s1">'freqstr'</span><span class="p">,</span> <span class="s1">'None'</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'Index of given monthly dataset has a'</span>
                                 <span class="s1">' non-monthly frequency (to check this,'</span>
                                 <span class="s1">' examine the `freqstr` attribute of the'</span>
                                 <span class="s1">' index of the dataset - it should start with'</span>
                                 <span class="s1">' M if it is monthly).'</span>
                                 <span class="sa">f</span><span class="s1">' Got </span><span class="si">{</span><span class="n">freqstr</span><span class="si">}</span><span class="s1">. '</span> <span class="o">+</span> <span class="n">base_msg</span><span class="p">)</span>

            <span class="c1"># Validate endog_quarterly</span>
            <span class="n">base_msg</span> <span class="o">=</span> <span class="p">(</span><span class="s1">'If a quarterly dataset is given, then it must be a'</span>
                        <span class="s1">' Pandas object with a date index at a quarterly'</span>
                        <span class="s1">' frequency.'</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">endog_quarterly</span><span class="p">,</span> <span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'Given quarterly dataset is not a'</span>
                                 <span class="s1">' Pandas object. '</span> <span class="o">+</span> <span class="n">base_msg</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">endog_quarterly</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">inferred_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span>
                <span class="s2">"datetime64"</span><span class="p">,</span>
                <span class="s2">"period"</span><span class="p">,</span>
            <span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'Given quarterly dataset has an'</span>
                                 <span class="s1">' index with non-date values. '</span> <span class="o">+</span> <span class="n">base_msg</span><span class="p">)</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">endog_quarterly</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="s1">'freqstr'</span><span class="p">,</span> <span class="s1">'N'</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">'Q'</span><span class="p">:</span>
                <span class="n">freqstr</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">endog_quarterly</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="s1">'freqstr'</span><span class="p">,</span> <span class="s1">'None'</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'Index of given quarterly dataset'</span>
                                 <span class="s1">' has a non-quarterly frequency (to check'</span>
                                 <span class="s1">' this, examine the `freqstr` attribute of'</span>
                                 <span class="s1">' the index of the dataset - it should start'</span>
                                 <span class="s1">' with Q if it is quarterly).'</span>
                                 <span class="sa">f</span><span class="s1">' Got </span><span class="si">{</span><span class="n">freqstr</span><span class="si">}</span><span class="s1">. '</span> <span class="o">+</span> <span class="n">base_msg</span><span class="p">)</span>

            <span class="c1"># Convert to PeriodIndex, if applicable</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">endog_monthly</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="s1">'to_period'</span><span class="p">):</span>
                <span class="n">endog_monthly</span> <span class="o">=</span> <span class="n">endog_monthly</span><span class="o">.</span><span class="n">to_period</span><span class="p">(</span><span class="s1">'M'</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">endog_quarterly</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="s1">'to_period'</span><span class="p">):</span>
                <span class="n">endog_quarterly</span> <span class="o">=</span> <span class="n">endog_quarterly</span><span class="o">.</span><span class="n">to_period</span><span class="p">(</span><span class="s1">'Q'</span><span class="p">)</span>

            <span class="c1"># Combine the datasets</span>
            <span class="n">endog</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span>
                <span class="n">endog_monthly</span><span class="p">,</span>
                <span class="n">endog_quarterly</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span><span class="s1">'M'</span><span class="p">,</span> <span class="n">convention</span><span class="o">=</span><span class="s1">'end'</span><span class="p">)</span><span class="o">.</span><span class="n">first</span><span class="p">()],</span>
                <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

            <span class="c1"># Make sure we didn't accidentally get duplicate column names</span>
            <span class="n">column_counts</span> <span class="o">=</span> <span class="n">endog</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">value_counts</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">column_counts</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">columns</span> <span class="o">=</span> <span class="n">endog</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">object</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">column_counts</span><span class="o">.</span><span class="n">index</span><span class="p">:</span>
                    <span class="n">count</span> <span class="o">=</span> <span class="n">column_counts</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">count</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="n">mask</span> <span class="o">=</span> <span class="n">columns</span> <span class="o">==</span> <span class="n">name</span>
                    <span class="n">columns</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s1">'</span><span class="si">{</span><span class="n">name</span><span class="si">}{</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="si">}</span><span class="s1">'</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">count</span><span class="p">)]</span>
                <span class="n">endog</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="n">columns</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">endog</span> <span class="o">=</span> <span class="n">endog_monthly</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="n">endog_monthly</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">k_endog_monthly</span> <span class="o">=</span> <span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="k">else</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">endog</span><span class="p">,</span> <span class="n">k_endog_monthly</span></div>

<div class="viewcode-block" id="DynamicFactorMQ.clone"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.dynamic_factor_mq.DynamicFactorMQ.clone.html#statsmodels.tsa.statespace.dynamic_factor_mq.DynamicFactorMQ.clone">[docs]</a>    <span class="k">def</span> <span class="nf">clone</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">endog</span><span class="p">,</span> <span class="n">k_endog_monthly</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">endog_quarterly</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
              <span class="n">retain_standardization</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Clone state space model with new data and optionally new specification.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        endog : array_like</span>
<span class="sd">            The observed time-series process :math:`y`</span>
<span class="sd">        k_endog_monthly : int, optional</span>
<span class="sd">            If specifying a monthly/quarterly mixed frequency model in which</span>
<span class="sd">            the provided `endog` dataset contains both the monthly and</span>
<span class="sd">            quarterly data, this variable should be used to indicate how many</span>
<span class="sd">            of the variables are monthly.</span>
<span class="sd">        endog_quarterly : array_like, optional</span>
<span class="sd">            Observations of quarterly variables. If provided, must be a</span>
<span class="sd">            Pandas Series or DataFrame with a DatetimeIndex or PeriodIndex at</span>
<span class="sd">            the quarterly frequency.</span>
<span class="sd">        kwargs</span>
<span class="sd">            Keyword arguments to pass to the new model class to change the</span>
<span class="sd">            model specification.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        model : DynamicFactorMQ instance</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="n">retain_standardization</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">standardize</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">'standardize'</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_endog_mean</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_endog_std</span><span class="p">)</span>
        <span class="n">mod</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_clone_from_init_kwds</span><span class="p">(</span>
            <span class="n">endog</span><span class="p">,</span> <span class="n">k_endog_monthly</span><span class="o">=</span><span class="n">k_endog_monthly</span><span class="p">,</span>
            <span class="n">endog_quarterly</span><span class="o">=</span><span class="n">endog_quarterly</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">mod</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_res_classes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">'fit'</span><span class="p">:</span> <span class="p">(</span><span class="n">DynamicFactorMQResults</span><span class="p">,</span> <span class="n">mlemodel</span><span class="o">.</span><span class="n">MLEResultsWrapper</span><span class="p">)}</span>

    <span class="k">def</span> <span class="nf">_default_initialization</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s</span>
        <span class="n">init</span> <span class="o">=</span> <span class="n">initialization</span><span class="o">.</span><span class="n">Initialization</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_states</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="n">s</span><span class="o">.</span><span class="n">factor_blocks</span><span class="p">:</span>
            <span class="n">init</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">block</span><span class="p">[</span><span class="s1">'factors'</span><span class="p">],</span> <span class="s1">'stationary'</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">idiosyncratic_ar1</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="s1">'idio_ar_M'</span><span class="p">]</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">s</span><span class="p">[</span><span class="s1">'idio_ar_M'</span><span class="p">]</span><span class="o">.</span><span class="n">stop</span><span class="p">):</span>
                <span class="n">init</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="s1">'stationary'</span><span class="p">)</span>
        <span class="n">init</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="s1">'idio_ar_Q'</span><span class="p">],</span> <span class="s1">'stationary'</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">init</span>

    <span class="k">def</span> <span class="nf">_get_endog_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">truncate</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">as_string</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">truncate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">truncate</span> <span class="o">=</span> <span class="kc">False</span> <span class="k">if</span> <span class="n">as_string</span> <span class="ow">is</span> <span class="kc">False</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">24</span>
        <span class="k">if</span> <span class="n">as_string</span> <span class="ow">is</span> <span class="kc">False</span> <span class="ow">and</span> <span class="n">truncate</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'Can only truncate endog names if they'</span>
                             <span class="s1">' are returned as a string.'</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">as_string</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">as_string</span> <span class="o">=</span> <span class="n">truncate</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span>

        <span class="c1"># The base `endog_names` property is only a list if there are at least</span>
        <span class="c1"># two variables; often, we need it to be a list</span>
        <span class="n">endog_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">endog_names</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">endog_names</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">endog_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">endog_names</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">as_string</span><span class="p">:</span>
            <span class="n">endog_names</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">endog_names</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">truncate</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">truncate</span>
            <span class="n">endog_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">name</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">n</span> <span class="k">else</span> <span class="n">name</span><span class="p">[:</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="s1">'...'</span>
                           <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">endog_names</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">endog_names</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_model_name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">model_name</span> <span class="o">=</span> <span class="p">[</span>
            <span class="s1">'Dynamic Factor Model'</span><span class="p">,</span>
            <span class="sa">f</span><span class="s1">'</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">k_factors</span><span class="si">}</span><span class="s1"> factors in </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">k_factor_blocks</span><span class="si">}</span><span class="s1"> blocks'</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog_Q</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">model_name</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">'Mixed frequency (M/Q)'</span><span class="p">)</span>

        <span class="n">error_type</span> <span class="o">=</span> <span class="s1">'AR(1)'</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">idiosyncratic_ar1</span> <span class="k">else</span> <span class="s1">'iid'</span>
        <span class="n">model_name</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">'</span><span class="si">{</span><span class="n">error_type</span><span class="si">}</span><span class="s1"> idiosyncratic'</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">model_name</span>

    <span class="k">def</span> <span class="nf">summary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">truncate_endog_names</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Create a summary table describing the model.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        truncate_endog_names : int, optional</span>
<span class="sd">            The number of characters to show for names of observed variables.</span>
<span class="sd">            Default is 24 if there is more than one observed variable, or</span>
<span class="sd">            an unlimited number of there is only one.</span>
<span class="sd">        """</span>
        <span class="c1"># Get endog names</span>
        <span class="n">endog_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_endog_names</span><span class="p">(</span><span class="n">truncate</span><span class="o">=</span><span class="n">truncate_endog_names</span><span class="p">,</span>
                                            <span class="n">as_string</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">title</span> <span class="o">=</span> <span class="s1">'Model Specification: Dynamic Factor Model'</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index_dates</span><span class="p">:</span>
            <span class="n">ix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">ix</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">sample</span> <span class="o">=</span> <span class="p">[</span><span class="s1">'</span><span class="si">%s</span><span class="s1">'</span> <span class="o">%</span> <span class="n">d</span><span class="p">]</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">ix</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">sample</span> <span class="o">+=</span> <span class="p">[</span><span class="s1">'- '</span> <span class="o">+</span> <span class="s1">'</span><span class="si">%s</span><span class="s1">'</span> <span class="o">%</span> <span class="n">d</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sample</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="s1">' - '</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="p">)]</span>

        <span class="c1"># Standardize the model name as a list of str</span>
        <span class="n">model_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model_name</span>

        <span class="c1"># - Top summary table ------------------------------------------------</span>
        <span class="n">top_left</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">top_left</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s1">'Model:'</span><span class="p">,</span> <span class="p">[</span><span class="n">model_name</span><span class="p">[</span><span class="mi">0</span><span class="p">]]))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">model_name</span><span class="p">)):</span>
            <span class="n">top_left</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s1">''</span><span class="p">,</span> <span class="p">[</span><span class="s1">'+ '</span> <span class="o">+</span> <span class="n">model_name</span><span class="p">[</span><span class="n">i</span><span class="p">]]))</span>
        <span class="n">top_left</span> <span class="o">+=</span> <span class="p">[</span>
            <span class="p">(</span><span class="s1">'Sample:'</span><span class="p">,</span> <span class="p">[</span><span class="n">sample</span><span class="p">[</span><span class="mi">0</span><span class="p">]]),</span>
            <span class="p">(</span><span class="s1">''</span><span class="p">,</span> <span class="p">[</span><span class="n">sample</span><span class="p">[</span><span class="mi">1</span><span class="p">]])]</span>

        <span class="n">top_right</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog_Q</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">top_right</span> <span class="o">+=</span> <span class="p">[</span>
                <span class="p">(</span><span class="s1">'# of monthly variables:'</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">k_endog_M</span><span class="p">]),</span>
                <span class="p">(</span><span class="s1">'# of quarterly variables:'</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">k_endog_Q</span><span class="p">])]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">top_right</span> <span class="o">+=</span> <span class="p">[(</span><span class="s1">'# of observed variables:'</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">])]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_factor_blocks</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">top_right</span> <span class="o">+=</span> <span class="p">[(</span><span class="s1">'# of factors:'</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">k_factors</span><span class="p">])]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">top_right</span> <span class="o">+=</span> <span class="p">[(</span><span class="s1">'# of factor blocks:'</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">k_factor_blocks</span><span class="p">])]</span>
        <span class="n">top_right</span> <span class="o">+=</span> <span class="p">[(</span><span class="s1">'Idiosyncratic disturbances:'</span><span class="p">,</span>
                       <span class="p">[</span><span class="s1">'AR(1)'</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">idiosyncratic_ar1</span> <span class="k">else</span> <span class="s1">'iid'</span><span class="p">]),</span>
                      <span class="p">(</span><span class="s1">'Standardize variables:'</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">standardize</span><span class="p">])]</span>

        <span class="n">summary</span> <span class="o">=</span> <span class="n">Summary</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="n">summary</span><span class="o">.</span><span class="n">add_table_2cols</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gleft</span><span class="o">=</span><span class="n">top_left</span><span class="p">,</span> <span class="n">gright</span><span class="o">=</span><span class="n">top_right</span><span class="p">,</span>
                                <span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">)</span>
        <span class="n">table_ix</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span>

        <span class="c1"># - Endog / factor map -----------------------------------------------</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">endog_factor_map</span><span class="o">.</span><span class="n">replace</span><span class="p">({</span><span class="kc">True</span><span class="p">:</span> <span class="s1">'X'</span><span class="p">,</span> <span class="kc">False</span><span class="p">:</span> <span class="s1">''</span><span class="p">})</span>
        <span class="n">data</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">endog_names</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
            <span class="n">data</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="s1">' '</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">))</span>
        <span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">'Dep. variable'</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>

        <span class="n">params_data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">values</span>
        <span class="n">params_header</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="n">params_stubs</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">title</span> <span class="o">=</span> <span class="s1">'Observed variables / factor loadings'</span>
        <span class="n">table</span> <span class="o">=</span> <span class="n">SimpleTable</span><span class="p">(</span>
            <span class="n">params_data</span><span class="p">,</span> <span class="n">params_header</span><span class="p">,</span> <span class="n">params_stubs</span><span class="p">,</span>
            <span class="n">txt_fmt</span><span class="o">=</span><span class="n">fmt_params</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">)</span>

        <span class="n">summary</span><span class="o">.</span><span class="n">tables</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">table_ix</span><span class="p">,</span> <span class="n">table</span><span class="p">)</span>
        <span class="n">table_ix</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># - Factor blocks summary table --------------------------------------</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">factor_block_orders</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
        <span class="n">data</span><span class="p">[</span><span class="s1">'block'</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">'block'</span><span class="p">]</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">factor_names</span><span class="p">:</span> <span class="s1">', '</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">factor_names</span><span class="p">))</span>
        <span class="n">data</span><span class="p">[[</span><span class="s1">'order'</span><span class="p">]]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">data</span><span class="p">[[</span><span class="s1">'order'</span><span class="p">]]</span><span class="o">.</span><span class="n">applymap</span><span class="p">(</span><span class="nb">str</span><span class="p">))</span>

        <span class="n">params_data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">values</span>
        <span class="n">params_header</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="n">params_stubs</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">title</span> <span class="o">=</span> <span class="s1">'Factor blocks:'</span>
        <span class="n">table</span> <span class="o">=</span> <span class="n">SimpleTable</span><span class="p">(</span>
            <span class="n">params_data</span><span class="p">,</span> <span class="n">params_header</span><span class="p">,</span> <span class="n">params_stubs</span><span class="p">,</span>
            <span class="n">txt_fmt</span><span class="o">=</span><span class="n">fmt_params</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">)</span>

        <span class="n">summary</span><span class="o">.</span><span class="n">tables</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">table_ix</span><span class="p">,</span> <span class="n">table</span><span class="p">)</span>
        <span class="n">table_ix</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">summary</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""Summary tables showing model specification."""</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">summary</span><span class="p">())</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">state_names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""(list of str) List of human readable names for unobserved states."""</span>
        <span class="c1"># Factors</span>
        <span class="n">state_names</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s</span><span class="o">.</span><span class="n">factor_blocks</span><span class="p">:</span>
            <span class="n">state_names</span> <span class="o">+=</span> <span class="p">[</span><span class="sa">f</span><span class="s1">'</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1">'</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">block</span><span class="o">.</span><span class="n">factor_names</span><span class="p">[:]]</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">block</span><span class="o">.</span><span class="n">_factor_order</span><span class="p">):</span>
                <span class="n">state_names</span> <span class="o">+=</span> <span class="p">[</span><span class="sa">f</span><span class="s1">'L</span><span class="si">{</span><span class="n">s</span><span class="si">}</span><span class="s1">.</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1">'</span>
                                <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">block</span><span class="o">.</span><span class="n">factor_names</span><span class="p">]</span>

        <span class="c1"># Monthly error</span>
        <span class="n">endog_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_endog_names</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">idiosyncratic_ar1</span><span class="p">:</span>
            <span class="n">endog_names_M</span> <span class="o">=</span> <span class="n">endog_names</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_o</span><span class="p">[</span><span class="s1">'M'</span><span class="p">]]</span>
            <span class="n">state_names</span> <span class="o">+=</span> <span class="p">[</span><span class="sa">f</span><span class="s1">'eps_M.</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1">'</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">endog_names_M</span><span class="p">]</span>
        <span class="n">endog_names_Q</span> <span class="o">=</span> <span class="n">endog_names</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_o</span><span class="p">[</span><span class="s1">'Q'</span><span class="p">]]</span>

        <span class="c1"># Quarterly error</span>
        <span class="n">state_names</span> <span class="o">+=</span> <span class="p">[</span><span class="sa">f</span><span class="s1">'eps_Q.</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1">'</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">endog_names_Q</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">):</span>
            <span class="n">state_names</span> <span class="o">+=</span> <span class="p">[</span><span class="sa">f</span><span class="s1">'L</span><span class="si">{</span><span class="n">s</span><span class="si">}</span><span class="s1">.eps_Q.</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1">'</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">endog_names_Q</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">state_names</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">param_names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""(list of str) List of human readable parameter names."""</span>
        <span class="n">param_names</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># Loadings</span>
        <span class="c1"># So that Lambda = params[ix].reshape(self.k_endog, self.k_factors)</span>
        <span class="c1"># (where Lambda stacks Lambda_M and Lambda_Q)</span>
        <span class="n">endog_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_endog_names</span><span class="p">(</span><span class="n">as_string</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">endog_name</span> <span class="ow">in</span> <span class="n">endog_names</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s</span><span class="o">.</span><span class="n">factor_blocks</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">factor_name</span> <span class="ow">in</span> <span class="n">block</span><span class="o">.</span><span class="n">factor_names</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">endog_factor_map</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">endog_name</span><span class="p">,</span> <span class="n">factor_name</span><span class="p">]:</span>
                        <span class="n">param_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s1">'loading.</span><span class="si">{</span><span class="n">factor_name</span><span class="si">}</span><span class="s1">-&gt;</span><span class="si">{</span><span class="n">endog_name</span><span class="si">}</span><span class="s1">'</span><span class="p">)</span>

        <span class="c1"># Factor VAR</span>
        <span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s</span><span class="o">.</span><span class="n">factor_blocks</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">to_factor</span> <span class="ow">in</span> <span class="n">block</span><span class="o">.</span><span class="n">factor_names</span><span class="p">:</span>
                <span class="n">param_names</span> <span class="o">+=</span> <span class="p">[</span><span class="sa">f</span><span class="s1">'L</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">.</span><span class="si">{</span><span class="n">from_factor</span><span class="si">}</span><span class="s1">-&gt;</span><span class="si">{</span><span class="n">to_factor</span><span class="si">}</span><span class="s1">'</span>
                                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">block</span><span class="o">.</span><span class="n">factor_order</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                                <span class="k">for</span> <span class="n">from_factor</span> <span class="ow">in</span> <span class="n">block</span><span class="o">.</span><span class="n">factor_names</span><span class="p">]</span>

        <span class="c1"># Factor covariance</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_s</span><span class="o">.</span><span class="n">factor_blocks</span><span class="p">)):</span>
            <span class="n">block</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s</span><span class="o">.</span><span class="n">factor_blocks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">param_names</span> <span class="o">+=</span> <span class="p">[</span><span class="sa">f</span><span class="s1">'fb(</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">).cov.chol[</span><span class="si">{</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="si">}</span><span class="s1">,</span><span class="si">{</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="si">}</span><span class="s1">]'</span>
                            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">block</span><span class="o">.</span><span class="n">k_factors</span><span class="p">)</span>
                            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>

        <span class="c1"># Error AR(1)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">idiosyncratic_ar1</span><span class="p">:</span>
            <span class="n">endog_names_M</span> <span class="o">=</span> <span class="n">endog_names</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_o</span><span class="p">[</span><span class="s1">'M'</span><span class="p">]]</span>
            <span class="n">param_names</span> <span class="o">+=</span> <span class="p">[</span><span class="sa">f</span><span class="s1">'L1.eps_M.</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1">'</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">endog_names_M</span><span class="p">]</span>

            <span class="n">endog_names_Q</span> <span class="o">=</span> <span class="n">endog_names</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_o</span><span class="p">[</span><span class="s1">'Q'</span><span class="p">]]</span>
            <span class="n">param_names</span> <span class="o">+=</span> <span class="p">[</span><span class="sa">f</span><span class="s1">'L1.eps_Q.</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1">'</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">endog_names_Q</span><span class="p">]</span>

        <span class="c1"># Error innovation variances</span>
        <span class="n">param_names</span> <span class="o">+=</span> <span class="p">[</span><span class="sa">f</span><span class="s1">'sigma2.</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1">'</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">endog_names</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">param_names</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">start_params</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""(array) Starting parameters for maximum likelihood estimation."""</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_params</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

        <span class="c1"># (1) estimate factors one at a time, where the first step uses</span>
        <span class="c1"># PCA on all `endog` variables that load on the first factor, and</span>
        <span class="c1"># subsequent steps use residuals from the previous steps.</span>
        <span class="c1"># TODO: what about factors that only load on quarterly variables?</span>
        <span class="n">endog_factor_map_M</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">endog_factor_map</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">k_endog_M</span><span class="p">]</span>
        <span class="n">factors</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">endog</span> <span class="o">=</span> <span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endog</span><span class="p">)</span><span class="o">.</span><span class="n">interpolate</span><span class="p">()</span>
                                         <span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="s1">'backfill'</span><span class="p">)</span>
                                         <span class="o">.</span><span class="n">values</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">factor_names</span><span class="p">:</span>
            <span class="c1"># Try to retrieve this from monthly variables, which is most</span>
            <span class="c1"># consistent</span>
            <span class="n">endog_ix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">endog_factor_map_M</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">name</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
            <span class="c1"># But fall back to quarterly if necessary</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">endog_ix</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">endog_ix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endog_factor_map</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">name</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">factor_endog</span> <span class="o">=</span> <span class="n">endog</span><span class="p">[:,</span> <span class="n">endog_ix</span><span class="p">]</span>

            <span class="n">res_pca</span> <span class="o">=</span> <span class="n">PCA</span><span class="p">(</span><span class="n">factor_endog</span><span class="p">,</span> <span class="n">ncomp</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">'eig'</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">factors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">res_pca</span><span class="o">.</span><span class="n">factors</span><span class="p">)</span>
            <span class="n">endog</span><span class="p">[:,</span> <span class="n">endog_ix</span><span class="p">]</span> <span class="o">-=</span> <span class="n">res_pca</span><span class="o">.</span><span class="n">projection</span>
        <span class="n">factors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">factors</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># (2) Estimate coefficients for each endog, one at a time (OLS for</span>
        <span class="c1"># monthly variables, restricted OLS for quarterly). Also, compute</span>
        <span class="c1"># residuals.</span>
        <span class="n">loadings</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">resid</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_endog_M</span><span class="p">):</span>
            <span class="n">factor_ix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s</span><span class="o">.</span><span class="n">endog_factor_iloc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">factor_exog</span> <span class="o">=</span> <span class="n">factors</span><span class="p">[:,</span> <span class="n">factor_ix</span><span class="p">]</span>
            <span class="n">mod_ols</span> <span class="o">=</span> <span class="n">OLS</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endog</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span> <span class="n">exog</span><span class="o">=</span><span class="n">factor_exog</span><span class="p">,</span> <span class="n">missing</span><span class="o">=</span><span class="s1">'drop'</span><span class="p">)</span>
            <span class="n">res_ols</span> <span class="o">=</span> <span class="n">mod_ols</span><span class="o">.</span><span class="n">fit</span><span class="p">()</span>
            <span class="n">loadings</span> <span class="o">+=</span> <span class="n">res_ols</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="n">resid</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">res_ols</span><span class="o">.</span><span class="n">resid</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_endog_M</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">):</span>
            <span class="n">factor_ix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s</span><span class="o">.</span><span class="n">endog_factor_iloc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">factor_exog</span> <span class="o">=</span> <span class="n">lagmat</span><span class="p">(</span><span class="n">factors</span><span class="p">[:,</span> <span class="n">factor_ix</span><span class="p">],</span> <span class="mi">4</span><span class="p">,</span> <span class="n">original</span><span class="o">=</span><span class="s1">'in'</span><span class="p">)</span>
            <span class="n">mod_glm</span> <span class="o">=</span> <span class="n">GLM</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endog</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span> <span class="n">factor_exog</span><span class="p">,</span> <span class="n">missing</span><span class="o">=</span><span class="s1">'drop'</span><span class="p">)</span>
            <span class="n">res_glm</span> <span class="o">=</span> <span class="n">mod_glm</span><span class="o">.</span><span class="n">fit_constrained</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loading_constraints</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
            <span class="n">loadings</span> <span class="o">+=</span> <span class="n">res_glm</span><span class="o">.</span><span class="n">params</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">factor_ix</span><span class="p">)]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="n">resid</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">res_glm</span><span class="o">.</span><span class="n">resid_response</span><span class="p">)</span>
        <span class="n">params</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_p</span><span class="p">[</span><span class="s1">'loadings'</span><span class="p">]]</span> <span class="o">=</span> <span class="n">loadings</span>

        <span class="c1"># (3) For each factor block, use an AR or VAR model to get coefficients</span>
        <span class="c1"># and covariance estimate</span>
        <span class="c1"># Factor transitions</span>
        <span class="n">stationary</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="n">factor_ar</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">factor_cov</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s</span><span class="o">.</span><span class="n">factor_blocks</span><span class="p">:</span>
            <span class="n">factors_endog</span> <span class="o">=</span> <span class="n">factors</span><span class="p">[:,</span> <span class="n">i</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="n">block</span><span class="o">.</span><span class="n">k_factors</span><span class="p">]</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="n">block</span><span class="o">.</span><span class="n">k_factors</span>

            <span class="k">if</span> <span class="n">block</span><span class="o">.</span><span class="n">factor_order</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="n">block</span><span class="o">.</span><span class="n">k_factors</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">mod_factors</span> <span class="o">=</span> <span class="n">SARIMAX</span><span class="p">(</span><span class="n">factors_endog</span><span class="p">,</span>
                                      <span class="n">order</span><span class="o">=</span><span class="p">(</span><span class="n">block</span><span class="o">.</span><span class="n">factor_order</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
                <span class="n">sp</span> <span class="o">=</span> <span class="n">mod_factors</span><span class="o">.</span><span class="n">start_params</span>
                <span class="n">block_factor_ar</span> <span class="o">=</span> <span class="n">sp</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">block_factor_cov</span> <span class="o">=</span> <span class="n">sp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">:]</span>

                <span class="n">coefficient_matrices</span> <span class="o">=</span> <span class="n">mod_factors</span><span class="o">.</span><span class="n">start_params</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">block</span><span class="o">.</span><span class="n">k_factors</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">mod_factors</span> <span class="o">=</span> <span class="n">VAR</span><span class="p">(</span><span class="n">factors_endog</span><span class="p">)</span>
                <span class="n">res_factors</span> <span class="o">=</span> <span class="n">mod_factors</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span>
                    <span class="n">maxlags</span><span class="o">=</span><span class="n">block</span><span class="o">.</span><span class="n">factor_order</span><span class="p">,</span> <span class="n">ic</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">trend</span><span class="o">=</span><span class="s1">'nc'</span><span class="p">)</span>

                <span class="n">block_factor_ar</span> <span class="o">=</span> <span class="n">res_factors</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
                <span class="n">L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">cholesky</span><span class="p">(</span><span class="n">res_factors</span><span class="o">.</span><span class="n">sigma_u</span><span class="p">)</span>
                <span class="n">block_factor_cov</span> <span class="o">=</span> <span class="n">L</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">tril_indices_from</span><span class="p">(</span><span class="n">L</span><span class="p">)]</span>

                <span class="n">coefficient_matrices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">block_factor_ar</span><span class="p">,</span>
                               <span class="p">(</span><span class="n">block</span><span class="o">.</span><span class="n">k_factors</span><span class="p">,</span> <span class="n">block</span><span class="o">.</span><span class="n">k_factors</span><span class="p">,</span>
                                <span class="n">block</span><span class="o">.</span><span class="n">factor_order</span><span class="p">)),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

            <span class="c1"># Test for stationarity</span>
            <span class="n">stationary</span> <span class="o">=</span> <span class="n">is_invertible</span><span class="p">([</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="o">-</span><span class="n">coefficient_matrices</span><span class="p">))</span>

            <span class="c1"># Check for stationarity</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">stationary</span><span class="p">:</span>
                <span class="n">warn</span><span class="p">(</span><span class="s1">'Non-stationary starting factor autoregressive'</span>
                     <span class="s1">' parameters found for factor block'</span>
                     <span class="sa">f</span><span class="s1">' </span><span class="si">{</span><span class="n">block</span><span class="o">.</span><span class="n">factor_names</span><span class="si">}</span><span class="s1">. Using zeros as starting'</span>
                     <span class="s1">' parameters.'</span><span class="p">)</span>
                <span class="n">block_factor_ar</span><span class="p">[:]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">cov_factor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">factors_endog</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
                <span class="n">block_factor_cov</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">cov_factor</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">tril_indices</span><span class="p">(</span><span class="n">block</span><span class="o">.</span><span class="n">k_factors</span><span class="p">)])</span>
            <span class="n">factor_ar</span> <span class="o">+=</span> <span class="n">block_factor_ar</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="n">factor_cov</span> <span class="o">+=</span> <span class="n">block_factor_cov</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="n">params</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_p</span><span class="p">[</span><span class="s1">'factor_ar'</span><span class="p">]]</span> <span class="o">=</span> <span class="n">factor_ar</span>
        <span class="n">params</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_p</span><span class="p">[</span><span class="s1">'factor_cov'</span><span class="p">]]</span> <span class="o">=</span> <span class="n">factor_cov</span>

        <span class="c1"># (4) Use residuals from step (2) to estimate the idiosyncratic</span>
        <span class="c1"># component</span>
        <span class="c1"># Idiosyncratic component</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">idiosyncratic_ar1</span><span class="p">:</span>
            <span class="n">idio_ar1</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">idio_var</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_endog_M</span><span class="p">):</span>
                <span class="n">mod_idio</span> <span class="o">=</span> <span class="n">SARIMAX</span><span class="p">(</span><span class="n">resid</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">order</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">trend</span><span class="o">=</span><span class="s1">'c'</span><span class="p">)</span>
                <span class="n">sp</span> <span class="o">=</span> <span class="n">mod_idio</span><span class="o">.</span><span class="n">start_params</span>
                <span class="n">idio_ar1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">sp</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="mf">0.99</span><span class="p">,</span> <span class="mf">0.99</span><span class="p">))</span>
                <span class="n">idio_var</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">sp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="mf">1e-5</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_endog_M</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">):</span>
                <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">endog</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">y</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">y</span><span class="p">)]</span> <span class="o">=</span> <span class="n">resid</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">mod_idio</span> <span class="o">=</span> <span class="n">QuarterlyAR1</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
                <span class="n">res_idio</span> <span class="o">=</span> <span class="n">mod_idio</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">maxiter</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">return_params</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                        <span class="n">disp</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="n">res_idio</span> <span class="o">=</span> <span class="n">mod_idio</span><span class="o">.</span><span class="n">fit_em</span><span class="p">(</span><span class="n">res_idio</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
                                           <span class="n">return_params</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">idio_ar1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">res_idio</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="mf">0.99</span><span class="p">,</span> <span class="mf">0.99</span><span class="p">))</span>
                <span class="n">idio_var</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">res_idio</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mf">1e-5</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">))</span>
            <span class="n">params</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_p</span><span class="p">[</span><span class="s1">'idiosyncratic_ar1'</span><span class="p">]]</span> <span class="o">=</span> <span class="n">idio_ar1</span>
            <span class="n">params</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_p</span><span class="p">[</span><span class="s1">'idiosyncratic_var'</span><span class="p">]]</span> <span class="o">=</span> <span class="n">idio_var</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">idio_var</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">resid</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_endog_M</span><span class="p">)]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_endog_M</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">):</span>
                <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">endog</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">y</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">y</span><span class="p">)]</span> <span class="o">=</span> <span class="n">resid</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">mod_idio</span> <span class="o">=</span> <span class="n">QuarterlyAR1</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
                <span class="n">res_idio</span> <span class="o">=</span> <span class="n">mod_idio</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">return_params</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">disp</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="n">idio_var</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">res_idio</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mf">1e-5</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">))</span>
            <span class="n">params</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_p</span><span class="p">[</span><span class="s1">'idiosyncratic_var'</span><span class="p">]]</span> <span class="o">=</span> <span class="n">idio_var</span>

        <span class="k">return</span> <span class="n">params</span>

    <span class="k">def</span> <span class="nf">transform_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unconstrained</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Transform parameters from optimizer space to model space.</span>

<span class="sd">        Transform unconstrained parameters used by the optimizer to constrained</span>
<span class="sd">        parameters used in likelihood evaluation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        unconstrained : array_like</span>
<span class="sd">            Array of unconstrained parameters used by the optimizer, to be</span>
<span class="sd">            transformed.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        constrained : array_like</span>
<span class="sd">            Array of constrained parameters which may be used in likelihood</span>
<span class="sd">            evaluation.</span>
<span class="sd">        """</span>
        <span class="n">constrained</span> <span class="o">=</span> <span class="n">unconstrained</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># Stationary factor VAR</span>
        <span class="n">unconstrained_factor_ar</span> <span class="o">=</span> <span class="n">unconstrained</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_p</span><span class="p">[</span><span class="s1">'factor_ar'</span><span class="p">]]</span>
        <span class="n">constrained_factor_ar</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s</span><span class="o">.</span><span class="n">factor_blocks</span><span class="p">:</span>
            <span class="n">length</span> <span class="o">=</span> <span class="n">block</span><span class="o">.</span><span class="n">k_factors</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">block</span><span class="o">.</span><span class="n">factor_order</span>
            <span class="n">tmp_coeff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
                <span class="n">unconstrained_factor_ar</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="n">length</span><span class="p">],</span>
                <span class="p">(</span><span class="n">block</span><span class="o">.</span><span class="n">k_factors</span><span class="p">,</span> <span class="n">block</span><span class="o">.</span><span class="n">k_factors</span> <span class="o">*</span> <span class="n">block</span><span class="o">.</span><span class="n">factor_order</span><span class="p">))</span>
            <span class="n">tmp_cov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">block</span><span class="o">.</span><span class="n">k_factors</span><span class="p">)</span>
            <span class="n">tmp_coeff</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">constrain_stationary_multivariate</span><span class="p">(</span><span class="n">tmp_coeff</span><span class="p">,</span>
                                                             <span class="n">tmp_cov</span><span class="p">)</span>
            <span class="n">constrained_factor_ar</span> <span class="o">+=</span> <span class="n">tmp_coeff</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="n">length</span>
        <span class="n">constrained</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_p</span><span class="p">[</span><span class="s1">'factor_ar'</span><span class="p">]]</span> <span class="o">=</span> <span class="n">constrained_factor_ar</span>

        <span class="c1"># Stationary idiosyncratic AR(1)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">idiosyncratic_ar1</span><span class="p">:</span>
            <span class="n">idio_ar1</span> <span class="o">=</span> <span class="n">unconstrained</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_p</span><span class="p">[</span><span class="s1">'idiosyncratic_ar1'</span><span class="p">]]</span>
            <span class="n">constrained</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_p</span><span class="p">[</span><span class="s1">'idiosyncratic_ar1'</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">constrain_stationary_univariate</span><span class="p">(</span><span class="n">idio_ar1</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">)]</span>

        <span class="c1"># Positive idiosyncratic variances</span>
        <span class="n">constrained</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_p</span><span class="p">[</span><span class="s1">'idiosyncratic_var'</span><span class="p">]]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">constrained</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_p</span><span class="p">[</span><span class="s1">'idiosyncratic_var'</span><span class="p">]]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">constrained</span>

    <span class="k">def</span> <span class="nf">untransform_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">constrained</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Transform parameters from model space to optimizer space.</span>

<span class="sd">        Transform constrained parameters used in likelihood evaluation</span>
<span class="sd">        to unconstrained parameters used by the optimizer.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        constrained : array_like</span>
<span class="sd">            Array of constrained parameters used in likelihood evaluation, to</span>
<span class="sd">            be transformed.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        unconstrained : array_like</span>
<span class="sd">            Array of unconstrained parameters used by the optimizer.</span>
<span class="sd">        """</span>
        <span class="n">unconstrained</span> <span class="o">=</span> <span class="n">constrained</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># Stationary factor VAR</span>
        <span class="n">constrained_factor_ar</span> <span class="o">=</span> <span class="n">constrained</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_p</span><span class="p">[</span><span class="s1">'factor_ar'</span><span class="p">]]</span>
        <span class="n">unconstrained_factor_ar</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s</span><span class="o">.</span><span class="n">factor_blocks</span><span class="p">:</span>
            <span class="n">length</span> <span class="o">=</span> <span class="n">block</span><span class="o">.</span><span class="n">k_factors</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">block</span><span class="o">.</span><span class="n">factor_order</span>
            <span class="n">tmp_coeff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
                <span class="n">constrained_factor_ar</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="n">length</span><span class="p">],</span>
                <span class="p">(</span><span class="n">block</span><span class="o">.</span><span class="n">k_factors</span><span class="p">,</span> <span class="n">block</span><span class="o">.</span><span class="n">k_factors</span> <span class="o">*</span> <span class="n">block</span><span class="o">.</span><span class="n">factor_order</span><span class="p">))</span>
            <span class="n">tmp_cov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">block</span><span class="o">.</span><span class="n">k_factors</span><span class="p">)</span>
            <span class="n">tmp_coeff</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">unconstrain_stationary_multivariate</span><span class="p">(</span><span class="n">tmp_coeff</span><span class="p">,</span>
                                                               <span class="n">tmp_cov</span><span class="p">)</span>
            <span class="n">unconstrained_factor_ar</span> <span class="o">+=</span> <span class="n">tmp_coeff</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="n">length</span>
        <span class="n">unconstrained</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_p</span><span class="p">[</span><span class="s1">'factor_ar'</span><span class="p">]]</span> <span class="o">=</span> <span class="n">unconstrained_factor_ar</span>

        <span class="c1"># Stationary idiosyncratic AR(1)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">idiosyncratic_ar1</span><span class="p">:</span>
            <span class="n">idio_ar1</span> <span class="o">=</span> <span class="n">constrained</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_p</span><span class="p">[</span><span class="s1">'idiosyncratic_ar1'</span><span class="p">]]</span>
            <span class="n">unconstrained</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_p</span><span class="p">[</span><span class="s1">'idiosyncratic_ar1'</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">unconstrain_stationary_univariate</span><span class="p">(</span><span class="n">idio_ar1</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">)]</span>

        <span class="c1"># Positive idiosyncratic variances</span>
        <span class="n">unconstrained</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_p</span><span class="p">[</span><span class="s1">'idiosyncratic_var'</span><span class="p">]]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">unconstrained</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_p</span><span class="p">[</span><span class="s1">'idiosyncratic_var'</span><span class="p">]]</span><span class="o">**</span><span class="mf">0.5</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">unconstrained</span>

    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Update the parameters of the model.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array_like</span>
<span class="sd">            Array of new parameters.</span>
<span class="sd">        transformed : bool, optional</span>
<span class="sd">            Whether or not `params` is already transformed. If set to False,</span>
<span class="sd">            `transform_params` is called. Default is True.</span>

<span class="sd">        """</span>
        <span class="n">params</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Local copies</span>
        <span class="n">o</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_o</span>
        <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s</span>
        <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_p</span>

        <span class="c1"># Loadings</span>
        <span class="n">loadings</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="n">p</span><span class="p">[</span><span class="s1">'loadings'</span><span class="p">]]</span>
        <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_endog_M</span><span class="p">):</span>
            <span class="n">iloc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s</span><span class="o">.</span><span class="n">endog_factor_iloc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">k_factors</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">iloc</span><span class="p">)</span>
            <span class="n">factor_ix</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="s1">'factors_L1'</span><span class="p">][</span><span class="n">iloc</span><span class="p">]</span>
            <span class="bp">self</span><span class="p">[</span><span class="s1">'design'</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">factor_ix</span><span class="p">]</span> <span class="o">=</span> <span class="n">loadings</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">start</span> <span class="o">+</span> <span class="n">k_factors</span><span class="p">]</span>
            <span class="n">start</span> <span class="o">+=</span> <span class="n">k_factors</span>
        <span class="n">multipliers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">])[:,</span> <span class="kc">None</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_endog_M</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">):</span>
            <span class="n">iloc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s</span><span class="o">.</span><span class="n">endog_factor_iloc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">k_factors</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">iloc</span><span class="p">)</span>
            <span class="n">factor_ix</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="s1">'factors_L1_5_ix'</span><span class="p">][:,</span> <span class="n">iloc</span><span class="p">]</span>
            <span class="bp">self</span><span class="p">[</span><span class="s1">'design'</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">factor_ix</span><span class="o">.</span><span class="n">ravel</span><span class="p">()]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span>
                <span class="n">loadings</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">start</span> <span class="o">+</span> <span class="n">k_factors</span><span class="p">]</span> <span class="o">*</span> <span class="n">multipliers</span><span class="p">)</span>
            <span class="n">start</span> <span class="o">+=</span> <span class="n">k_factors</span>

        <span class="c1"># Factor VAR</span>
        <span class="n">factor_ar</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="n">p</span><span class="p">[</span><span class="s1">'factor_ar'</span><span class="p">]]</span>
        <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="n">s</span><span class="o">.</span><span class="n">factor_blocks</span><span class="p">:</span>
            <span class="n">k_params</span> <span class="o">=</span> <span class="n">block</span><span class="o">.</span><span class="n">k_factors</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">block</span><span class="o">.</span><span class="n">factor_order</span>
            <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
                <span class="n">factor_ar</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">start</span> <span class="o">+</span> <span class="n">k_params</span><span class="p">],</span>
                <span class="p">(</span><span class="n">block</span><span class="o">.</span><span class="n">k_factors</span><span class="p">,</span> <span class="n">block</span><span class="o">.</span><span class="n">k_factors</span> <span class="o">*</span> <span class="n">block</span><span class="o">.</span><span class="n">factor_order</span><span class="p">))</span>
            <span class="n">start</span> <span class="o">+=</span> <span class="n">k_params</span>
            <span class="bp">self</span><span class="p">[</span><span class="s1">'transition'</span><span class="p">,</span> <span class="n">block</span><span class="p">[</span><span class="s1">'factors_L1'</span><span class="p">],</span> <span class="n">block</span><span class="p">[</span><span class="s1">'factors_ar'</span><span class="p">]]</span> <span class="o">=</span> <span class="n">A</span>

        <span class="c1"># Factor covariance</span>
        <span class="n">factor_cov</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="n">p</span><span class="p">[</span><span class="s1">'factor_cov'</span><span class="p">]]</span>
        <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">ix1</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="n">s</span><span class="o">.</span><span class="n">factor_blocks</span><span class="p">:</span>
            <span class="n">k_params</span> <span class="o">=</span> <span class="n">block</span><span class="o">.</span><span class="n">k_factors</span> <span class="o">*</span> <span class="p">(</span><span class="n">block</span><span class="o">.</span><span class="n">k_factors</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
            <span class="n">L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">block</span><span class="o">.</span><span class="n">k_factors</span><span class="p">,</span> <span class="n">block</span><span class="o">.</span><span class="n">k_factors</span><span class="p">),</span>
                         <span class="n">dtype</span><span class="o">=</span><span class="n">params</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="n">L</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">tril_indices_from</span><span class="p">(</span><span class="n">L</span><span class="p">)]</span> <span class="o">=</span> <span class="n">factor_cov</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">start</span> <span class="o">+</span> <span class="n">k_params</span><span class="p">]</span>
            <span class="n">start</span> <span class="o">+=</span> <span class="n">k_params</span>
            <span class="n">Q</span> <span class="o">=</span> <span class="n">L</span> <span class="o">@</span> <span class="n">L</span><span class="o">.</span><span class="n">T</span>
            <span class="n">ix2</span> <span class="o">=</span> <span class="n">ix1</span> <span class="o">+</span> <span class="n">block</span><span class="o">.</span><span class="n">k_factors</span>
            <span class="bp">self</span><span class="p">[</span><span class="s1">'state_cov'</span><span class="p">,</span> <span class="n">ix1</span><span class="p">:</span><span class="n">ix2</span><span class="p">,</span> <span class="n">ix1</span><span class="p">:</span><span class="n">ix2</span><span class="p">]</span> <span class="o">=</span> <span class="n">Q</span>
            <span class="n">ix1</span> <span class="o">=</span> <span class="n">ix2</span>

        <span class="c1"># Error AR(1)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">idiosyncratic_ar1</span><span class="p">:</span>
            <span class="n">alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="n">p</span><span class="p">[</span><span class="s1">'idiosyncratic_ar1'</span><span class="p">]])</span>
            <span class="bp">self</span><span class="p">[</span><span class="s1">'transition'</span><span class="p">,</span> <span class="n">s</span><span class="p">[</span><span class="s1">'idio_ar_L1'</span><span class="p">],</span> <span class="n">s</span><span class="p">[</span><span class="s1">'idio_ar_L1'</span><span class="p">]]</span> <span class="o">=</span> <span class="n">alpha</span>

        <span class="c1"># Error variances</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">idiosyncratic_ar1</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">[</span><span class="s1">'state_cov'</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_factors</span><span class="p">:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_factors</span><span class="p">:]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="n">p</span><span class="p">[</span><span class="s1">'idiosyncratic_var'</span><span class="p">]]))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">idio_var</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="n">p</span><span class="p">[</span><span class="s1">'idiosyncratic_var'</span><span class="p">]]</span>
            <span class="bp">self</span><span class="p">[</span><span class="s1">'obs_cov'</span><span class="p">,</span> <span class="n">o</span><span class="p">[</span><span class="s1">'M'</span><span class="p">],</span> <span class="n">o</span><span class="p">[</span><span class="s1">'M'</span><span class="p">]]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">idio_var</span><span class="p">[</span><span class="n">o</span><span class="p">[</span><span class="s1">'M'</span><span class="p">]])</span>
            <span class="bp">self</span><span class="p">[</span><span class="s1">'state_cov'</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_factors</span><span class="p">:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_factors</span><span class="p">:]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">idio_var</span><span class="p">[</span><span class="n">o</span><span class="p">[</span><span class="s1">'Q'</span><span class="p">]]))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">loglike_constant</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Constant term in the joint log-likelihood function.</span>

<span class="sd">        Useful in facilitating comparisons to other packages that exclude the</span>
<span class="sd">        constant from the log-likelihood computation.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endog</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">loading_constraints</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">"""</span>
<span class="sd">        Matrix formulation of quarterly variables' factor loading constraints.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        i : int</span>
<span class="sd">            Index of the `endog` variable to compute constraints for.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        R : array (k_constraints, k_factors * 5)</span>
<span class="sd">        q : array (k_constraints,)</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        If the factors were known, then the factor loadings for the ith</span>
<span class="sd">        quarterly variable would be computed by a linear regression of the form</span>

<span class="sd">        y_i = A_i' f + B_i' L1.f + C_i' L2.f + D_i' L3.f + E_i' L4.f</span>

<span class="sd">        where:</span>

<span class="sd">        - f is (k_i x 1) and collects all of the factors that load on y_i</span>
<span class="sd">        - L{j}.f is (k_i x 1) and collects the jth lag of each factor</span>
<span class="sd">        - A_i, ..., E_i are (k_i x 1) and collect factor loadings</span>

<span class="sd">        As the observed variable is quarterly while the factors are monthly, we</span>
<span class="sd">        want to restrict the estimated regression coefficients to be:</span>

<span class="sd">        y_i = A_i f + 2 A_i L1.f + 3 A_i L2.f + 2 A_i L3.f + A_i L4.f</span>

<span class="sd">        Stack the unconstrained coefficients: \Lambda_i = [A_i' B_i' ... E_i']'</span>

<span class="sd">        Then the constraints can be written as follows, for l = 1, ..., k_i</span>

<span class="sd">        - 2 A_{i,l} - B_{i,l} = 0</span>
<span class="sd">        - 3 A_{i,l} - C_{i,l} = 0</span>
<span class="sd">        - 2 A_{i,l} - D_{i,l} = 0</span>
<span class="sd">        - A_{i,l} - E_{i,l} = 0</span>

<span class="sd">        So that k_constraints = 4 * k_i. In matrix form the constraints are:</span>

<span class="sd">        .. math::</span>

<span class="sd">            R \Lambda_i = q</span>

<span class="sd">        where :math:`\Lambda_i` is shaped `(k_i * 5,)`, :math:`R` is shaped</span>
<span class="sd">        `(k_constraints, k_i * 5)`, and :math:`q` is shaped `(k_constraints,)`.</span>


<span class="sd">        For example, for the case that k_i = 2, we can write:</span>

<span class="sd">        |  2 0   -1  0    0  0    0  0    0  0  |   | A_{i,1} |     | 0 |</span>
<span class="sd">        |  0 2    0 -1    0  0    0  0    0  0  |   | A_{i,2} |     | 0 |</span>
<span class="sd">        |  3 0    0  0   -1  0    0  0    0  0  |   | B_{i,1} |     | 0 |</span>
<span class="sd">        |  0 3    0  0    0 -1    0  0    0  0  |   | B_{i,2} |     | 0 |</span>
<span class="sd">        |  2 0    0  0    0  0   -1  0    0  0  |   | C_{i,1} |  =  | 0 |</span>
<span class="sd">        |  0 2    0  0    0  0    0 -1    0  0  |   | C_{i,2} |     | 0 |</span>
<span class="sd">        |  1 0    0  0    0  0    0  0   -1  0  |   | D_{i,1} |     | 0 |</span>
<span class="sd">        |  0 1    0  0    0  0    0  0    0 -1  |   | D_{i,2} |     | 0 |</span>
<span class="sd">                                                    | E_{i,1} |     | 0 |</span>
<span class="sd">                                                    | E_{i,2} |     | 0 |</span>

<span class="sd">        """</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog_M</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'No constraints for monthly variables.'</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_loading_constraints</span><span class="p">:</span>
            <span class="n">k_factors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">endog_factor_map</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

            <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">k_factors</span> <span class="o">*</span> <span class="mi">4</span><span class="p">,</span> <span class="n">k_factors</span> <span class="o">*</span> <span class="mi">5</span><span class="p">))</span>
            <span class="n">q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">R</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

            <span class="c1"># Let R = [R_1 R_2]</span>
            <span class="c1"># Then R_1 is multiples of the identity matrix</span>
            <span class="n">multipliers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
            <span class="n">R</span><span class="p">[:,</span> <span class="p">:</span><span class="n">k_factors</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
                <span class="p">(</span><span class="n">multipliers</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">k_factors</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span> <span class="kc">None</span><span class="p">])</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
                <span class="p">(</span><span class="n">k_factors</span> <span class="o">*</span> <span class="mi">4</span><span class="p">,</span> <span class="n">k_factors</span><span class="p">))</span>

            <span class="c1"># And R_2 is the identity</span>
            <span class="n">R</span><span class="p">[:,</span> <span class="n">k_factors</span><span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">k_factors</span> <span class="o">*</span> <span class="mi">4</span><span class="p">))</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_loading_constraints</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_loading_constraints</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

<div class="viewcode-block" id="DynamicFactorMQ.fit"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.dynamic_factor_mq.DynamicFactorMQ.fit.html#statsmodels.tsa.statespace.dynamic_factor_mq.DynamicFactorMQ.fit">[docs]</a>    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">includes_fixed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">cov_type</span><span class="o">=</span><span class="s1">'none'</span><span class="p">,</span> <span class="n">cov_kwds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">'em'</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span>
            <span class="n">tolerance</span><span class="o">=</span><span class="mf">1e-6</span><span class="p">,</span> <span class="n">em_initialization</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">mstep_method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">full_output</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">disp</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">return_params</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">optim_score</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">optim_complex_step</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">optim_hessian</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">flags</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">low_memory</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">llf_decrease_action</span><span class="o">=</span><span class="s1">'revert'</span><span class="p">,</span>
            <span class="n">llf_decrease_tolerance</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Fits the model by maximum likelihood via Kalman filter.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        start_params : array_like, optional</span>
<span class="sd">            Initial guess of the solution for the loglikelihood maximization.</span>
<span class="sd">            If None, the default is given by Model.start_params.</span>
<span class="sd">        transformed : bool, optional</span>
<span class="sd">            Whether or not `start_params` is already transformed. Default is</span>
<span class="sd">            True.</span>
<span class="sd">        includes_fixed : bool, optional</span>
<span class="sd">            If parameters were previously fixed with the `fix_params` method,</span>
<span class="sd">            this argument describes whether or not `start_params` also includes</span>
<span class="sd">            the fixed parameters, in addition to the free parameters. Default</span>
<span class="sd">            is False.</span>
<span class="sd">        cov_type : str, optional</span>
<span class="sd">            The `cov_type` keyword governs the method for calculating the</span>
<span class="sd">            covariance matrix of parameter estimates. Can be one of:</span>

<span class="sd">            - 'opg' for the outer product of gradient estimator</span>
<span class="sd">            - 'oim' for the observed information matrix estimator, calculated</span>
<span class="sd">              using the method of Harvey (1989)</span>
<span class="sd">            - 'approx' for the observed information matrix estimator,</span>
<span class="sd">              calculated using a numerical approximation of the Hessian matrix.</span>
<span class="sd">            - 'robust' for an approximate (quasi-maximum likelihood) covariance</span>
<span class="sd">              matrix that may be valid even in the presence of some</span>
<span class="sd">              misspecifications. Intermediate calculations use the 'oim'</span>
<span class="sd">              method.</span>
<span class="sd">            - 'robust_approx' is the same as 'robust' except that the</span>
<span class="sd">              intermediate calculations use the 'approx' method.</span>
<span class="sd">            - 'none' for no covariance matrix calculation.</span>

<span class="sd">            Default is 'none', since computing this matrix can be very slow</span>
<span class="sd">            when there are a large number of parameters.</span>
<span class="sd">        cov_kwds : dict or None, optional</span>
<span class="sd">            A dictionary of arguments affecting covariance matrix computation.</span>

<span class="sd">            **opg, oim, approx, robust, robust_approx**</span>

<span class="sd">            - 'approx_complex_step' : bool, optional - If True, numerical</span>
<span class="sd">              approximations are computed using complex-step methods. If False,</span>
<span class="sd">              numerical approximations are computed using finite difference</span>
<span class="sd">              methods. Default is True.</span>
<span class="sd">            - 'approx_centered' : bool, optional - If True, numerical</span>
<span class="sd">              approximations computed using finite difference methods use a</span>
<span class="sd">              centered approximation. Default is False.</span>
<span class="sd">        method : str, optional</span>
<span class="sd">            The `method` determines which solver from `scipy.optimize`</span>
<span class="sd">            is used, and it can be chosen from among the following strings:</span>

<span class="sd">            - 'em' for the EM algorithm</span>
<span class="sd">            - 'newton' for Newton-Raphson</span>
<span class="sd">            - 'nm' for Nelder-Mead</span>
<span class="sd">            - 'bfgs' for Broyden-Fletcher-Goldfarb-Shanno (BFGS)</span>
<span class="sd">            - 'lbfgs' for limited-memory BFGS with optional box constraints</span>
<span class="sd">            - 'powell' for modified Powell's method</span>
<span class="sd">            - 'cg' for conjugate gradient</span>
<span class="sd">            - 'ncg' for Newton-conjugate gradient</span>
<span class="sd">            - 'basinhopping' for global basin-hopping solver</span>

<span class="sd">            The explicit arguments in `fit` are passed to the solver,</span>
<span class="sd">            with the exception of the basin-hopping solver. Each</span>
<span class="sd">            solver has several optional arguments that are not the same across</span>
<span class="sd">            solvers. See the notes section below (or scipy.optimize) for the</span>
<span class="sd">            available arguments and for the list of explicit arguments that the</span>
<span class="sd">            basin-hopping solver supports.</span>
<span class="sd">        maxiter : int, optional</span>
<span class="sd">            The maximum number of iterations to perform.</span>
<span class="sd">        full_output : bool, optional</span>
<span class="sd">            Set to True to have all available output in the Results object's</span>
<span class="sd">            mle_retvals attribute. The output is dependent on the solver.</span>
<span class="sd">            See LikelihoodModelResults notes section for more information.</span>
<span class="sd">        disp : bool, optional</span>
<span class="sd">            Set to True to print convergence messages.</span>
<span class="sd">        callback : callable callback(xk), optional</span>
<span class="sd">            Called after each iteration, as callback(xk), where xk is the</span>
<span class="sd">            current parameter vector.</span>
<span class="sd">        return_params : bool, optional</span>
<span class="sd">            Whether or not to return only the array of maximizing parameters.</span>
<span class="sd">            Default is False.</span>
<span class="sd">        optim_score : {'harvey', 'approx'} or None, optional</span>
<span class="sd">            The method by which the score vector is calculated. 'harvey' uses</span>
<span class="sd">            the method from Harvey (1989), 'approx' uses either finite</span>
<span class="sd">            difference or complex step differentiation depending upon the</span>
<span class="sd">            value of `optim_complex_step`, and None uses the built-in gradient</span>
<span class="sd">            approximation of the optimizer. Default is None. This keyword is</span>
<span class="sd">            only relevant if the optimization method uses the score.</span>
<span class="sd">        optim_complex_step : bool, optional</span>
<span class="sd">            Whether or not to use complex step differentiation when</span>
<span class="sd">            approximating the score; if False, finite difference approximation</span>
<span class="sd">            is used. Default is True. This keyword is only relevant if</span>
<span class="sd">            `optim_score` is set to 'harvey' or 'approx'.</span>
<span class="sd">        optim_hessian : {'opg','oim','approx'}, optional</span>
<span class="sd">            The method by which the Hessian is numerically approximated. 'opg'</span>
<span class="sd">            uses outer product of gradients, 'oim' uses the information</span>
<span class="sd">            matrix formula from Harvey (1989), and 'approx' uses numerical</span>
<span class="sd">            approximation. This keyword is only relevant if the</span>
<span class="sd">            optimization method uses the Hessian matrix.</span>
<span class="sd">        low_memory : bool, optional</span>
<span class="sd">            If set to True, techniques are applied to substantially reduce</span>
<span class="sd">            memory usage. If used, some features of the results object will</span>
<span class="sd">            not be available (including smoothed results and in-sample</span>
<span class="sd">            prediction), although out-of-sample forecasting is possible.</span>
<span class="sd">            Note that this option is not available when using the EM algorithm</span>
<span class="sd">            (which is the default for this model). Default is False.</span>
<span class="sd">        llf_decrease_action : {'ignore', 'warn', 'revert'}, optional</span>
<span class="sd">            Action to take if the log-likelihood decreases in an EM iteration.</span>
<span class="sd">            'ignore' continues the iterations, 'warn' issues a warning but</span>
<span class="sd">            continues the iterations, while 'revert' ends the iterations and</span>
<span class="sd">            returns the result from the last good iteration. Default is 'warn'.</span>
<span class="sd">        llf_decrease_tolerance : float, optional</span>
<span class="sd">            Minimum size of the log-likelihood decrease required to trigger a</span>
<span class="sd">            warning or to end the EM iterations. Setting this value slightly</span>
<span class="sd">            larger than zero allows small decreases in the log-likelihood that</span>
<span class="sd">            may be caused by numerical issues. If set to zero, then any</span>
<span class="sd">            decrease will trigger the `llf_decrease_action`. Default is 1e-4.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Additional keyword arguments to pass to the optimizer.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        MLEResults</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        statsmodels.base.model.LikelihoodModel.fit</span>
<span class="sd">        statsmodels.tsa.statespace.mlemodel.MLEResults</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">'em'</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_em</span><span class="p">(</span>
                <span class="n">start_params</span><span class="o">=</span><span class="n">start_params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="n">transformed</span><span class="p">,</span>
                <span class="n">cov_type</span><span class="o">=</span><span class="n">cov_type</span><span class="p">,</span> <span class="n">cov_kwds</span><span class="o">=</span><span class="n">cov_kwds</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="n">maxiter</span><span class="p">,</span>
                <span class="n">tolerance</span><span class="o">=</span><span class="n">tolerance</span><span class="p">,</span> <span class="n">em_initialization</span><span class="o">=</span><span class="n">em_initialization</span><span class="p">,</span>
                <span class="n">mstep_method</span><span class="o">=</span><span class="n">mstep_method</span><span class="p">,</span> <span class="n">full_output</span><span class="o">=</span><span class="n">full_output</span><span class="p">,</span> <span class="n">disp</span><span class="o">=</span><span class="n">disp</span><span class="p">,</span>
                <span class="n">return_params</span><span class="o">=</span><span class="n">return_params</span><span class="p">,</span> <span class="n">low_memory</span><span class="o">=</span><span class="n">low_memory</span><span class="p">,</span>
                <span class="n">llf_decrease_action</span><span class="o">=</span><span class="n">llf_decrease_action</span><span class="p">,</span>
                <span class="n">llf_decrease_tolerance</span><span class="o">=</span><span class="n">llf_decrease_tolerance</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span>
                <span class="n">start_params</span><span class="o">=</span><span class="n">start_params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="n">transformed</span><span class="p">,</span>
                <span class="n">includes_fixed</span><span class="o">=</span><span class="n">includes_fixed</span><span class="p">,</span> <span class="n">cov_type</span><span class="o">=</span><span class="n">cov_type</span><span class="p">,</span>
                <span class="n">cov_kwds</span><span class="o">=</span><span class="n">cov_kwds</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="n">maxiter</span><span class="p">,</span>
                <span class="n">tolerance</span><span class="o">=</span><span class="n">tolerance</span><span class="p">,</span> <span class="n">full_output</span><span class="o">=</span><span class="n">full_output</span><span class="p">,</span> <span class="n">disp</span><span class="o">=</span><span class="n">disp</span><span class="p">,</span>
                <span class="n">callback</span><span class="o">=</span><span class="n">callback</span><span class="p">,</span> <span class="n">return_params</span><span class="o">=</span><span class="n">return_params</span><span class="p">,</span>
                <span class="n">optim_score</span><span class="o">=</span><span class="n">optim_score</span><span class="p">,</span>
                <span class="n">optim_complex_step</span><span class="o">=</span><span class="n">optim_complex_step</span><span class="p">,</span>
                <span class="n">optim_hessian</span><span class="o">=</span><span class="n">optim_hessian</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="n">flags</span><span class="p">,</span>
                <span class="n">low_memory</span><span class="o">=</span><span class="n">low_memory</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">fit_em</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cov_type</span><span class="o">=</span><span class="s1">'none'</span><span class="p">,</span>
               <span class="n">cov_kwds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mf">1e-6</span><span class="p">,</span> <span class="n">disp</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
               <span class="n">em_initialization</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">mstep_method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">full_output</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
               <span class="n">return_params</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">low_memory</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
               <span class="n">llf_decrease_action</span><span class="o">=</span><span class="s1">'revert'</span><span class="p">,</span> <span class="n">llf_decrease_tolerance</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Fits the model by maximum likelihood via the EM algorithm.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        start_params : array_like, optional</span>
<span class="sd">            Initial guess of the solution for the loglikelihood maximization.</span>
<span class="sd">            The default is to use `DynamicFactorMQ.start_params`.</span>
<span class="sd">        transformed : bool, optional</span>
<span class="sd">            Whether or not `start_params` is already transformed. Default is</span>
<span class="sd">            True.</span>
<span class="sd">        cov_type : str, optional</span>
<span class="sd">            The `cov_type` keyword governs the method for calculating the</span>
<span class="sd">            covariance matrix of parameter estimates. Can be one of:</span>

<span class="sd">            - 'opg' for the outer product of gradient estimator</span>
<span class="sd">            - 'oim' for the observed information matrix estimator, calculated</span>
<span class="sd">              using the method of Harvey (1989)</span>
<span class="sd">            - 'approx' for the observed information matrix estimator,</span>
<span class="sd">              calculated using a numerical approximation of the Hessian matrix.</span>
<span class="sd">            - 'robust' for an approximate (quasi-maximum likelihood) covariance</span>
<span class="sd">              matrix that may be valid even in the presence of some</span>
<span class="sd">              misspecifications. Intermediate calculations use the 'oim'</span>
<span class="sd">              method.</span>
<span class="sd">            - 'robust_approx' is the same as 'robust' except that the</span>
<span class="sd">              intermediate calculations use the 'approx' method.</span>
<span class="sd">            - 'none' for no covariance matrix calculation.</span>

<span class="sd">            Default is 'none', since computing this matrix can be very slow</span>
<span class="sd">            when there are a large number of parameters.</span>
<span class="sd">        cov_kwds : dict or None, optional</span>
<span class="sd">            A dictionary of arguments affecting covariance matrix computation.</span>

<span class="sd">            **opg, oim, approx, robust, robust_approx**</span>

<span class="sd">            - 'approx_complex_step' : bool, optional - If True, numerical</span>
<span class="sd">              approximations are computed using complex-step methods. If False,</span>
<span class="sd">              numerical approximations are computed using finite difference</span>
<span class="sd">              methods. Default is True.</span>
<span class="sd">            - 'approx_centered' : bool, optional - If True, numerical</span>
<span class="sd">              approximations computed using finite difference methods use a</span>
<span class="sd">              centered approximation. Default is False.</span>
<span class="sd">        maxiter : int, optional</span>
<span class="sd">            The maximum number of EM iterations to perform.</span>
<span class="sd">        tolerance : float, optional</span>
<span class="sd">            Parameter governing convergence of the EM algorithm. The</span>
<span class="sd">            `tolerance` is the minimum relative increase in the likelihood</span>
<span class="sd">            for which convergence will be declared. A smaller value for the</span>
<span class="sd">            `tolerance` will typically yield more precise parameter estimates,</span>
<span class="sd">            but will typically require more EM iterations. Default is 1e-6.</span>
<span class="sd">        disp : int or bool, optional</span>
<span class="sd">            Controls printing of EM iteration progress. If an integer, progress</span>
<span class="sd">            is printed at every `disp` iterations. A value of True is</span>
<span class="sd">            interpreted as the value of 1. Default is False (nothing will be</span>
<span class="sd">            printed).</span>
<span class="sd">        em_initialization : bool, optional</span>
<span class="sd">            Whether or not to also update the Kalman filter initialization</span>
<span class="sd">            using the EM algorithm. Default is True.</span>
<span class="sd">        mstep_method : {None, 'missing', 'nonmissing'}, optional</span>
<span class="sd">            The EM algorithm maximization step. If there are no NaN values</span>
<span class="sd">            in the dataset, this can be set to "nonmissing" (which is slightly</span>
<span class="sd">            faster) or "missing", otherwise it must be "missing". Default is</span>
<span class="sd">            "nonmissing" if there are no NaN values or "missing" if there are.</span>
<span class="sd">        full_output : bool, optional</span>
<span class="sd">            Set to True to have all available output from EM iterations in</span>
<span class="sd">            the Results object's mle_retvals attribute.</span>
<span class="sd">        return_params : bool, optional</span>
<span class="sd">            Whether or not to return only the array of maximizing parameters.</span>
<span class="sd">            Default is False.</span>
<span class="sd">        low_memory : bool, optional</span>
<span class="sd">            This option cannot be used with the EM algorithm and will raise an</span>
<span class="sd">            error if set to True. Default is False.</span>
<span class="sd">        llf_decrease_action : {'ignore', 'warn', 'revert'}, optional</span>
<span class="sd">            Action to take if the log-likelihood decreases in an EM iteration.</span>
<span class="sd">            'ignore' continues the iterations, 'warn' issues a warning but</span>
<span class="sd">            continues the iterations, while 'revert' ends the iterations and</span>
<span class="sd">            returns the result from the last good iteration. Default is 'warn'.</span>
<span class="sd">        llf_decrease_tolerance : float, optional</span>
<span class="sd">            Minimum size of the log-likelihood decrease required to trigger a</span>
<span class="sd">            warning or to end the EM iterations. Setting this value slightly</span>
<span class="sd">            larger than zero allows small decreases in the log-likelihood that</span>
<span class="sd">            may be caused by numerical issues. If set to zero, then any</span>
<span class="sd">            decrease will trigger the `llf_decrease_action`. Default is 1e-4.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        DynamicFactorMQResults</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        statsmodels.tsa.statespace.mlemodel.MLEModel.fit</span>
<span class="sd">        statsmodels.tsa.statespace.mlemodel.MLEResults</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_fixed_params</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">'Cannot fit using the EM algorithm while'</span>
                                      <span class="s1">' holding some parameters fixed.'</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">low_memory</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'Cannot fit using the EM algorithm when using'</span>
                             <span class="s1">' low_memory option.'</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">start_params</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">start_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">start_params</span>
            <span class="n">transformed</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">start_params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">start_params</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">transformed</span><span class="p">:</span>
            <span class="n">start_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_params</span><span class="p">(</span><span class="n">start_params</span><span class="p">)</span>

        <span class="n">llf_decrease_action</span> <span class="o">=</span> <span class="n">string_like</span><span class="p">(</span>
            <span class="n">llf_decrease_action</span><span class="p">,</span> <span class="s1">'llf_decrease_action'</span><span class="p">,</span>
            <span class="n">options</span><span class="o">=</span><span class="p">[</span><span class="s1">'ignore'</span><span class="p">,</span> <span class="s1">'warn'</span><span class="p">,</span> <span class="s1">'revert'</span><span class="p">])</span>

        <span class="n">disp</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">disp</span><span class="p">)</span>

        <span class="c1"># Perform expectation-maximization</span>
        <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s</span>
        <span class="n">llf</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">params</span> <span class="o">=</span> <span class="p">[</span><span class="n">start_params</span><span class="p">]</span>
        <span class="n">init</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">inits</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">initialization</span><span class="p">]</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">delta</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">terminate</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1"># init_stationary = None if em_initialization else True</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">maxiter</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">terminate</span> <span class="ow">and</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="p">(</span><span class="n">delta</span> <span class="o">&gt;</span> <span class="n">tolerance</span><span class="p">)):</span>
            <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_em_iteration</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">init</span><span class="o">=</span><span class="n">init</span><span class="p">,</span>
                                     <span class="n">mstep_method</span><span class="o">=</span><span class="n">mstep_method</span><span class="p">)</span>
            <span class="n">new_llf</span> <span class="o">=</span> <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">llf_obs</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

            <span class="c1"># If we are not using EM initialization, then we need to check for</span>
            <span class="c1"># non-stationary parameters</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">em_initialization</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">switch_init</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">T</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s1">'transition'</span><span class="p">]</span>
                <span class="n">init</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">initialization</span>
                <span class="n">iloc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_states</span><span class="p">)</span>

                <span class="c1"># We may only have global initialization if we have no</span>
                <span class="c1"># quarterly variables and idiosyncratic_ar1=False</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog_Q</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">idiosyncratic_ar1</span><span class="p">:</span>
                    <span class="n">block</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">factor_blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">init</span><span class="o">.</span><span class="n">initialization_type</span> <span class="o">==</span> <span class="s1">'stationary'</span><span class="p">:</span>
                        <span class="n">Tb</span> <span class="o">=</span> <span class="n">T</span><span class="p">[</span><span class="n">block</span><span class="p">[</span><span class="s1">'factors'</span><span class="p">],</span> <span class="n">block</span><span class="p">[</span><span class="s1">'factors'</span><span class="p">]]</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigvals</span><span class="p">(</span><span class="n">Tb</span><span class="p">)</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mf">1e-10</span><span class="p">)):</span>
                            <span class="n">init</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">block</span><span class="p">[</span><span class="s1">'factors'</span><span class="p">],</span> <span class="s1">'diffuse'</span><span class="p">)</span>
                            <span class="n">switch_init</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                                <span class="s1">'factor block:'</span>
                                <span class="sa">f</span><span class="s1">' </span><span class="si">{</span><span class="nb">tuple</span><span class="p">(</span><span class="n">block</span><span class="o">.</span><span class="n">factor_names</span><span class="p">)</span><span class="si">}</span><span class="s1">'</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Factor blocks</span>
                    <span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="n">s</span><span class="o">.</span><span class="n">factor_blocks</span><span class="p">:</span>
                        <span class="n">b</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">iloc</span><span class="p">[</span><span class="n">block</span><span class="p">[</span><span class="s1">'factors'</span><span class="p">]])</span>
                        <span class="n">init_type</span> <span class="o">=</span> <span class="n">init</span><span class="o">.</span><span class="n">blocks</span><span class="p">[</span><span class="n">b</span><span class="p">]</span><span class="o">.</span><span class="n">initialization_type</span>
                        <span class="k">if</span> <span class="n">init_type</span> <span class="o">==</span> <span class="s1">'stationary'</span><span class="p">:</span>
                            <span class="n">Tb</span> <span class="o">=</span> <span class="n">T</span><span class="p">[</span><span class="n">block</span><span class="p">[</span><span class="s1">'factors'</span><span class="p">],</span> <span class="n">block</span><span class="p">[</span><span class="s1">'factors'</span><span class="p">]]</span>
                            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigvals</span><span class="p">(</span><span class="n">Tb</span><span class="p">)</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mf">1e-10</span><span class="p">)):</span>
                                <span class="n">init</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">block</span><span class="p">[</span><span class="s1">'factors'</span><span class="p">],</span> <span class="s1">'diffuse'</span><span class="p">)</span>
                                <span class="n">switch_init</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                                    <span class="s1">'factor block:'</span>
                                    <span class="sa">f</span><span class="s1">' </span><span class="si">{</span><span class="nb">tuple</span><span class="p">(</span><span class="n">block</span><span class="o">.</span><span class="n">factor_names</span><span class="p">)</span><span class="si">}</span><span class="s1">'</span><span class="p">)</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">idiosyncratic_ar1</span><span class="p">:</span>
                    <span class="n">endog_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_endog_names</span><span class="p">(</span><span class="n">as_string</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="c1"># Monthly variables</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="s1">'idio_ar_M'</span><span class="p">]</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">s</span><span class="p">[</span><span class="s1">'idio_ar_M'</span><span class="p">]</span><span class="o">.</span><span class="n">stop</span><span class="p">):</span>
                        <span class="n">init_type</span> <span class="o">=</span> <span class="n">init</span><span class="o">.</span><span class="n">blocks</span><span class="p">[(</span><span class="n">j</span><span class="p">,)]</span><span class="o">.</span><span class="n">initialization_type</span>
                        <span class="k">if</span> <span class="n">init_type</span> <span class="o">==</span> <span class="s1">'stationary'</span><span class="p">:</span>
                            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">T</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">j</span><span class="p">])</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mf">1e-10</span><span class="p">):</span>
                                <span class="n">init</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="s1">'diffuse'</span><span class="p">)</span>
                                <span class="n">name</span> <span class="o">=</span> <span class="n">endog_names</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="n">s</span><span class="p">[</span><span class="s1">'idio_ar_M'</span><span class="p">]</span><span class="o">.</span><span class="n">start</span><span class="p">]</span>
                                <span class="n">switch_init</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                                    <span class="s1">'idiosyncratic AR(1) for monthly'</span>
                                    <span class="sa">f</span><span class="s1">' variable: </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1">'</span><span class="p">)</span>

                    <span class="c1"># Quarterly variables</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog_Q</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">b</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">iloc</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="s1">'idio_ar_Q'</span><span class="p">]])</span>
                        <span class="n">init_type</span> <span class="o">=</span> <span class="n">init</span><span class="o">.</span><span class="n">blocks</span><span class="p">[</span><span class="n">b</span><span class="p">]</span><span class="o">.</span><span class="n">initialization_type</span>
                        <span class="k">if</span> <span class="n">init_type</span> <span class="o">==</span> <span class="s1">'stationary'</span><span class="p">:</span>
                            <span class="n">Tb</span> <span class="o">=</span> <span class="n">T</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="s1">'idio_ar_Q'</span><span class="p">],</span> <span class="n">s</span><span class="p">[</span><span class="s1">'idio_ar_Q'</span><span class="p">]]</span>
                            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigvals</span><span class="p">(</span><span class="n">Tb</span><span class="p">)</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mf">1e-10</span><span class="p">)):</span>
                                <span class="n">init</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="s1">'idio_ar_Q'</span><span class="p">],</span> <span class="s1">'diffuse'</span><span class="p">)</span>
                                <span class="n">switch_init</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                                    <span class="s1">'idiosyncratic AR(1) for the'</span>
                                    <span class="s1">' block of quarterly variables'</span><span class="p">)</span>

                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">switch_init</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">warn</span><span class="p">(</span><span class="s1">'Non-stationary parameters found at EM iteration'</span>
                         <span class="sa">f</span><span class="s1">' </span><span class="si">{</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="si">}</span><span class="s1">, which is not compatible with'</span>
                         <span class="s1">' stationary initialization. Initialization was'</span>
                         <span class="s1">' switched to diffuse for the following: '</span>
                         <span class="sa">f</span><span class="s1">' </span><span class="si">{</span><span class="n">switch_init</span><span class="si">}</span><span class="s1">, and fitting was restarted.'</span><span class="p">)</span>
                    <span class="n">results</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_em</span><span class="p">(</span>
                        <span class="n">start_params</span><span class="o">=</span><span class="n">params</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">transformed</span><span class="o">=</span><span class="n">transformed</span><span class="p">,</span>
                        <span class="n">cov_type</span><span class="o">=</span><span class="n">cov_type</span><span class="p">,</span> <span class="n">cov_kwds</span><span class="o">=</span><span class="n">cov_kwds</span><span class="p">,</span>
                        <span class="n">maxiter</span><span class="o">=</span><span class="n">maxiter</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="n">tolerance</span><span class="p">,</span>
                        <span class="n">em_initialization</span><span class="o">=</span><span class="n">em_initialization</span><span class="p">,</span>
                        <span class="n">mstep_method</span><span class="o">=</span><span class="n">mstep_method</span><span class="p">,</span> <span class="n">full_output</span><span class="o">=</span><span class="n">full_output</span><span class="p">,</span>
                        <span class="n">disp</span><span class="o">=</span><span class="n">disp</span><span class="p">,</span> <span class="n">return_params</span><span class="o">=</span><span class="n">return_params</span><span class="p">,</span>
                        <span class="n">low_memory</span><span class="o">=</span><span class="n">low_memory</span><span class="p">,</span>
                        <span class="n">llf_decrease_action</span><span class="o">=</span><span class="n">llf_decrease_action</span><span class="p">,</span>
                        <span class="n">llf_decrease_tolerance</span><span class="o">=</span><span class="n">llf_decrease_tolerance</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">initialize</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_default_initialization</span><span class="p">())</span>
                    <span class="k">return</span> <span class="n">results</span>

            <span class="c1"># Check for decrease in the log-likelihood</span>
            <span class="c1"># Note: allow a little numerical error before declaring a decrease</span>
            <span class="n">llf_decrease</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="p">(</span><span class="n">new_llf</span> <span class="o">-</span> <span class="n">llf</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">llf_decrease_tolerance</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">llf_decrease_action</span> <span class="o">==</span> <span class="s1">'revert'</span> <span class="ow">and</span> <span class="n">llf_decrease</span><span class="p">:</span>
                <span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s1">'Log-likelihood decreased at EM iteration </span><span class="si">{</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="si">}</span><span class="s1">.'</span>
                     <span class="sa">f</span><span class="s1">' Reverting to the results from EM iteration </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">'</span>
                     <span class="s1">' (prior to the decrease) and returning the solution.'</span><span class="p">)</span>
                <span class="c1"># Terminated iteration</span>
                <span class="n">i</span> <span class="o">-=</span> <span class="mi">1</span>
                <span class="n">terminate</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">llf_decrease_action</span> <span class="o">==</span> <span class="s1">'warn'</span> <span class="ow">and</span> <span class="n">llf_decrease</span><span class="p">:</span>
                    <span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s1">'Log-likelihood decreased at EM iteration </span><span class="si">{</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="si">}</span><span class="s1">,'</span>
                         <span class="s1">' which can indicate numerical issues.'</span><span class="p">)</span>
                <span class="n">llf</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_llf</span><span class="p">)</span>
                <span class="n">params</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">em_initialization</span><span class="p">:</span>
                    <span class="n">init</span> <span class="o">=</span> <span class="n">initialization</span><span class="o">.</span><span class="n">Initialization</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">k_states</span><span class="p">,</span> <span class="s1">'known'</span><span class="p">,</span>
                        <span class="n">constant</span><span class="o">=</span><span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">smoothed_state</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                        <span class="n">stationary_cov</span><span class="o">=</span><span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">smoothed_state_cov</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
                    <span class="n">inits</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">init</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">delta</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">llf</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">llf</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span> <span class="o">/</span>
                             <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">llf</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">llf</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">])))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">delta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>

                <span class="c1"># If `disp` is not False, display the first iteration</span>
                <span class="k">if</span> <span class="n">disp</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">'EM start iterations, llf=</span><span class="si">{</span><span class="n">llf</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">:</span><span class="s1">.5g</span><span class="si">}</span><span class="s1">'</span><span class="p">)</span>
                <span class="c1"># Print output every `disp` observations</span>
                <span class="k">elif</span> <span class="n">disp</span> <span class="ow">and</span> <span class="p">((</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">disp</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">'EM iteration </span><span class="si">{</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="si">}</span><span class="s1">, llf=</span><span class="si">{</span><span class="n">llf</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">:</span><span class="s1">.5g</span><span class="si">}</span><span class="s1">,'</span>
                          <span class="sa">f</span><span class="s1">' convergence criterion=</span><span class="si">{</span><span class="n">delta</span><span class="si">:</span><span class="s1">.5g</span><span class="si">}</span><span class="s1">'</span><span class="p">)</span>

            <span class="c1"># Advance the iteration counter</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># Check for convergence</span>
        <span class="n">not_converged</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">maxiter</span> <span class="ow">and</span> <span class="n">delta</span> <span class="o">&gt;</span> <span class="n">tolerance</span><span class="p">)</span>

        <span class="c1"># If no convergence without explicit termination, warn users</span>
        <span class="k">if</span> <span class="n">not_converged</span><span class="p">:</span>
            <span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s1">'EM reached maximum number of iterations (</span><span class="si">{</span><span class="n">maxiter</span><span class="si">}</span><span class="s1">),'</span>
                 <span class="sa">f</span><span class="s1">' without achieving convergence: llf=</span><span class="si">{</span><span class="n">llf</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">:</span><span class="s1">.5g</span><span class="si">}</span><span class="s1">,'</span>
                 <span class="sa">f</span><span class="s1">' convergence criterion=</span><span class="si">{</span><span class="n">delta</span><span class="si">:</span><span class="s1">.5g</span><span class="si">}</span><span class="s1">'</span>
                 <span class="sa">f</span><span class="s1">' (while specified tolerance was </span><span class="si">{</span><span class="n">tolerance</span><span class="si">:</span><span class="s1">.5g</span><span class="si">}</span><span class="s1">)'</span><span class="p">)</span>

        <span class="c1"># If `disp` is not False, display the final iteration</span>
        <span class="k">if</span> <span class="n">disp</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">terminate</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">'EM terminated at iteration </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">, llf=</span><span class="si">{</span><span class="n">llf</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">:</span><span class="s1">.5g</span><span class="si">}</span><span class="s1">,'</span>
                      <span class="sa">f</span><span class="s1">' convergence criterion=</span><span class="si">{</span><span class="n">delta</span><span class="si">:</span><span class="s1">.5g</span><span class="si">}</span><span class="s1">'</span>
                      <span class="sa">f</span><span class="s1">' (while specified tolerance was </span><span class="si">{</span><span class="n">tolerance</span><span class="si">:</span><span class="s1">.5g</span><span class="si">}</span><span class="s1">)'</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">not_converged</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">'EM reached maximum number of iterations (</span><span class="si">{</span><span class="n">maxiter</span><span class="si">}</span><span class="s1">),'</span>
                      <span class="sa">f</span><span class="s1">' without achieving convergence: llf=</span><span class="si">{</span><span class="n">llf</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">:</span><span class="s1">.5g</span><span class="si">}</span><span class="s1">,'</span>
                      <span class="sa">f</span><span class="s1">' convergence criterion=</span><span class="si">{</span><span class="n">delta</span><span class="si">:</span><span class="s1">.5g</span><span class="si">}</span><span class="s1">'</span>
                      <span class="sa">f</span><span class="s1">' (while specified tolerance was </span><span class="si">{</span><span class="n">tolerance</span><span class="si">:</span><span class="s1">.5g</span><span class="si">}</span><span class="s1">)'</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">'EM converged at iteration </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">, llf=</span><span class="si">{</span><span class="n">llf</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">:</span><span class="s1">.5g</span><span class="si">}</span><span class="s1">,'</span>
                      <span class="sa">f</span><span class="s1">' convergence criterion=</span><span class="si">{</span><span class="n">delta</span><span class="si">:</span><span class="s1">.5g</span><span class="si">}</span><span class="s1">'</span>
                      <span class="sa">f</span><span class="s1">' &lt; tolerance=</span><span class="si">{</span><span class="n">tolerance</span><span class="si">:</span><span class="s1">.5g</span><span class="si">}</span><span class="s1">'</span><span class="p">)</span>

        <span class="c1"># Just return the fitted parameters if requested</span>
        <span class="k">if</span> <span class="n">return_params</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># Otherwise construct the results class if desired</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">em_initialization</span><span class="p">:</span>
                <span class="n">base_init</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">initialization</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">initialization</span> <span class="o">=</span> <span class="n">init</span>
            <span class="c1"># Note that because we are using params[-1], we are actually using</span>
            <span class="c1"># the results from one additional iteration compared to the</span>
            <span class="c1"># iteration at which we declared convergence.</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">smooth</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                 <span class="n">cov_type</span><span class="o">=</span><span class="n">cov_type</span><span class="p">,</span> <span class="n">cov_kwds</span><span class="o">=</span><span class="n">cov_kwds</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">em_initialization</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">initialization</span> <span class="o">=</span> <span class="n">base_init</span>

            <span class="c1"># Save the output</span>
            <span class="k">if</span> <span class="n">full_output</span><span class="p">:</span>
                <span class="n">llf</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">llf</span><span class="p">)</span>
                <span class="n">em_retvals</span> <span class="o">=</span> <span class="n">Bunch</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="s1">'params'</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">params</span><span class="p">),</span>
                                      <span class="s1">'llf'</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">llf</span><span class="p">),</span>
                                      <span class="s1">'iter'</span><span class="p">:</span> <span class="n">i</span><span class="p">,</span>
                                      <span class="s1">'inits'</span><span class="p">:</span> <span class="n">inits</span><span class="p">})</span>
                <span class="n">em_settings</span> <span class="o">=</span> <span class="n">Bunch</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="s1">'method'</span><span class="p">:</span> <span class="s1">'em'</span><span class="p">,</span>
                                       <span class="s1">'tolerance'</span><span class="p">:</span> <span class="n">tolerance</span><span class="p">,</span>
                                       <span class="s1">'maxiter'</span><span class="p">:</span> <span class="n">maxiter</span><span class="p">})</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">em_retvals</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">em_settings</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="n">result</span><span class="o">.</span><span class="n">_results</span><span class="o">.</span><span class="n">mle_retvals</span> <span class="o">=</span> <span class="n">em_retvals</span>
            <span class="n">result</span><span class="o">.</span><span class="n">_results</span><span class="o">.</span><span class="n">mle_settings</span> <span class="o">=</span> <span class="n">em_settings</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">_em_iteration</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params0</span><span class="p">,</span> <span class="n">init</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mstep_method</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">"""EM iteration."""</span>
        <span class="c1"># (E)xpectation step</span>
        <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_em_expectation_step</span><span class="p">(</span><span class="n">params0</span><span class="p">,</span> <span class="n">init</span><span class="o">=</span><span class="n">init</span><span class="p">)</span>

        <span class="c1"># (M)aximization step</span>
        <span class="n">params1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_em_maximization_step</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">params0</span><span class="p">,</span>
                                             <span class="n">mstep_method</span><span class="o">=</span><span class="n">mstep_method</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">res</span><span class="p">,</span> <span class="n">params1</span>

    <span class="k">def</span> <span class="nf">_em_expectation_step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params0</span><span class="p">,</span> <span class="n">init</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">"""EM expectation step."""</span>
        <span class="c1"># (E)xpectation step</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">params0</span><span class="p">)</span>
        <span class="c1"># Re-initialize state, if new initialization is given</span>
        <span class="k">if</span> <span class="n">init</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">base_init</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">initialization</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">initialization</span> <span class="o">=</span> <span class="n">init</span>
        <span class="c1"># Perform smoothing, only saving what is required</span>
        <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">smooth</span><span class="p">(</span>
            <span class="n">SMOOTHER_STATE</span> <span class="o">|</span> <span class="n">SMOOTHER_STATE_COV</span> <span class="o">|</span> <span class="n">SMOOTHER_STATE_AUTOCOV</span><span class="p">,</span>
            <span class="n">update_filter</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">res</span><span class="o">.</span><span class="n">llf_obs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">_kalman_filter</span><span class="o">.</span><span class="n">loglikelihood</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># Reset initialization</span>
        <span class="k">if</span> <span class="n">init</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">initialization</span> <span class="o">=</span> <span class="n">base_init</span>

        <span class="k">return</span> <span class="n">res</span>

    <span class="k">def</span> <span class="nf">_em_maximization_step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">params0</span><span class="p">,</span> <span class="n">mstep_method</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">"""EM maximization step."""</span>
        <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s</span>

        <span class="n">a</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">smoothed_state</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>
        <span class="n">cov_a</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">smoothed_state_cov</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">acov_a</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">smoothed_state_autocov</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># E[a_t a_t'], t = 0, ..., T</span>
        <span class="n">Eaa</span> <span class="o">=</span> <span class="n">cov_a</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="c1"># E[a_t a_{t-1}'], t = 1, ..., T</span>
        <span class="n">Eaa1</span> <span class="o">=</span> <span class="n">acov_a</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">a</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

        <span class="c1"># Observation equation</span>
        <span class="n">has_missing</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">nmissing</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mstep_method</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">mstep_method</span> <span class="o">=</span> <span class="s1">'missing'</span> <span class="k">if</span> <span class="n">has_missing</span> <span class="k">else</span> <span class="s1">'nonmissing'</span>
        <span class="n">mstep_method</span> <span class="o">=</span> <span class="n">mstep_method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">mstep_method</span> <span class="o">==</span> <span class="s1">'nonmissing'</span> <span class="ow">and</span> <span class="n">has_missing</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'Cannot use EM algorithm option'</span>
                             <span class="s1">' `mstep_method="nonmissing"` with missing data.'</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">mstep_method</span> <span class="o">==</span> <span class="s1">'nonmissing'</span><span class="p">:</span>
            <span class="n">func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_em_maximization_obs_nonmissing</span>
        <span class="k">elif</span> <span class="n">mstep_method</span> <span class="o">==</span> <span class="s1">'missing'</span><span class="p">:</span>
            <span class="n">func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_em_maximization_obs_missing</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'Invalid maximization step method: "</span><span class="si">%s</span><span class="s1">".'</span>
                             <span class="o">%</span> <span class="n">mstep_method</span><span class="p">)</span>
        <span class="c1"># TODO: compute H is pretty slow</span>
        <span class="n">Lambda</span><span class="p">,</span> <span class="n">H</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">Eaa</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">compute_H</span><span class="o">=</span><span class="p">(</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">idiosyncratic_ar1</span><span class="p">))</span>

        <span class="c1"># Factor VAR and covariance</span>
        <span class="n">factor_ar</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">factor_cov</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">s</span><span class="o">.</span><span class="n">factor_blocks</span><span class="p">:</span>
            <span class="n">A</span> <span class="o">=</span> <span class="n">Eaa</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="p">[</span><span class="s1">'factors_ar'</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="s1">'factors_ar'</span><span class="p">]]</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">B</span> <span class="o">=</span> <span class="n">Eaa1</span><span class="p">[:,</span> <span class="n">b</span><span class="p">[</span><span class="s1">'factors_L1'</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="s1">'factors_ar'</span><span class="p">]]</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">C</span> <span class="o">=</span> <span class="n">Eaa</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="n">b</span><span class="p">[</span><span class="s1">'factors_L1'</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="s1">'factors_L1'</span><span class="p">]]</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">nobs</span> <span class="o">=</span> <span class="n">Eaa</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>

            <span class="c1"># want: x = B A^{-1}, so solve: x A = B or solve: A' x' = B'</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">f_A</span> <span class="o">=</span> <span class="n">cho_solve</span><span class="p">(</span><span class="n">cho_factor</span><span class="p">(</span><span class="n">A</span><span class="p">),</span> <span class="n">B</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
            <span class="k">except</span> <span class="n">LinAlgError</span><span class="p">:</span>
                <span class="c1"># Fall back to general solver if there are problems with</span>
                <span class="c1"># postive-definiteness</span>
                <span class="n">f_A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

            <span class="n">f_Q</span> <span class="o">=</span> <span class="p">(</span><span class="n">C</span> <span class="o">-</span> <span class="n">f_A</span> <span class="o">@</span> <span class="n">B</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">/</span> <span class="n">nobs</span>
            <span class="n">factor_ar</span> <span class="o">+=</span> <span class="n">f_A</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="n">factor_cov</span> <span class="o">+=</span> <span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">cholesky</span><span class="p">(</span><span class="n">f_Q</span><span class="p">)[</span><span class="n">np</span><span class="o">.</span><span class="n">tril_indices_from</span><span class="p">(</span><span class="n">f_Q</span><span class="p">)]</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>

        <span class="c1"># Idiosyncratic AR(1) and variances</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">idiosyncratic_ar1</span><span class="p">:</span>
            <span class="n">ix</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="s1">'idio_ar_L1'</span><span class="p">]</span>

            <span class="n">Ad</span> <span class="o">=</span> <span class="n">Eaa</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">diagonal</span><span class="p">()</span>
            <span class="n">Bd</span> <span class="o">=</span> <span class="n">Eaa1</span><span class="p">[:,</span> <span class="n">ix</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">diagonal</span><span class="p">()</span>
            <span class="n">Cd</span> <span class="o">=</span> <span class="n">Eaa</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="n">ix</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">diagonal</span><span class="p">()</span>
            <span class="n">nobs</span> <span class="o">=</span> <span class="n">Eaa</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>

            <span class="n">alpha</span> <span class="o">=</span> <span class="n">Bd</span> <span class="o">/</span> <span class="n">Ad</span>
            <span class="n">sigma2</span> <span class="o">=</span> <span class="p">(</span><span class="n">Cd</span> <span class="o">-</span> <span class="n">alpha</span> <span class="o">*</span> <span class="n">Bd</span><span class="p">)</span> <span class="o">/</span> <span class="n">nobs</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ix</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="s1">'idio_ar_L1'</span><span class="p">]</span>
            <span class="n">C</span> <span class="o">=</span> <span class="n">Eaa</span><span class="p">[:,</span> <span class="n">ix</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">sigma2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">H</span><span class="o">.</span><span class="n">diagonal</span><span class="p">()[</span><span class="bp">self</span><span class="o">.</span><span class="n">_o</span><span class="p">[</span><span class="s1">'M'</span><span class="p">]],</span>
                           <span class="n">C</span><span class="o">.</span><span class="n">diagonal</span><span class="p">()</span> <span class="o">/</span> <span class="n">Eaa</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>

        <span class="c1"># Save parameters</span>
        <span class="n">params1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">params0</span><span class="p">)</span>
        <span class="n">loadings</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">):</span>
            <span class="n">iloc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s</span><span class="o">.</span><span class="n">endog_factor_iloc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">factor_ix</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="s1">'factors_L1'</span><span class="p">][</span><span class="n">iloc</span><span class="p">]</span>
            <span class="n">loadings</span> <span class="o">+=</span> <span class="n">Lambda</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">factor_ix</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="n">params1</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_p</span><span class="p">[</span><span class="s1">'loadings'</span><span class="p">]]</span> <span class="o">=</span> <span class="n">loadings</span>
        <span class="n">params1</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_p</span><span class="p">[</span><span class="s1">'factor_ar'</span><span class="p">]]</span> <span class="o">=</span> <span class="n">factor_ar</span>
        <span class="n">params1</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_p</span><span class="p">[</span><span class="s1">'factor_cov'</span><span class="p">]]</span> <span class="o">=</span> <span class="n">factor_cov</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">idiosyncratic_ar1</span><span class="p">:</span>
            <span class="n">params1</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_p</span><span class="p">[</span><span class="s1">'idiosyncratic_ar1'</span><span class="p">]]</span> <span class="o">=</span> <span class="n">alpha</span>
        <span class="n">params1</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_p</span><span class="p">[</span><span class="s1">'idiosyncratic_var'</span><span class="p">]]</span> <span class="o">=</span> <span class="n">sigma2</span>

        <span class="k">return</span> <span class="n">params1</span>

    <span class="k">def</span> <span class="nf">_em_maximization_obs_nonmissing</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">Eaa</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">compute_H</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">"""EM maximization step, observation equation without missing data."""</span>
        <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">Eaa</span><span class="o">.</span><span class="n">dtype</span>

        <span class="c1"># Observation equation (non-missing)</span>
        <span class="c1"># Note: we only compute loadings for monthly variables because</span>
        <span class="c1"># quarterly variables will always have missing entries, so we would</span>
        <span class="c1"># never choose this method in that case</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">k_states_factors</span>
        <span class="n">Lambda</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">,</span> <span class="n">k</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">):</span>
            <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">endog</span><span class="p">[:,</span> <span class="n">i</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">iloc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s</span><span class="o">.</span><span class="n">endog_factor_iloc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">factor_ix</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="s1">'factors_L1'</span><span class="p">][</span><span class="n">iloc</span><span class="p">]</span>

            <span class="n">ix</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">s_</span><span class="p">[:],)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span><span class="n">factor_ix</span><span class="p">,</span> <span class="n">factor_ix</span><span class="p">)</span>
            <span class="n">A</span> <span class="o">=</span> <span class="n">Eaa</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">B</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">a</span><span class="p">[:,</span> <span class="n">factor_ix</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">idiosyncratic_ar1</span><span class="p">:</span>
                <span class="n">ix1</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">k_states_factors</span> <span class="o">+</span> <span class="n">i</span>
                <span class="n">ix2</span> <span class="o">=</span> <span class="n">ix1</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="n">B</span> <span class="o">-=</span> <span class="n">Eaa</span><span class="p">[:,</span> <span class="n">ix1</span><span class="p">:</span><span class="n">ix2</span><span class="p">,</span> <span class="n">factor_ix</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

            <span class="c1"># want: x = B A^{-1}, so solve: x A = B or solve: A' x' = B'</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">Lambda</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">factor_ix</span><span class="p">]</span> <span class="o">=</span> <span class="n">cho_solve</span><span class="p">(</span><span class="n">cho_factor</span><span class="p">(</span><span class="n">A</span><span class="p">),</span> <span class="n">B</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
            <span class="k">except</span> <span class="n">LinAlgError</span><span class="p">:</span>
                <span class="c1"># Fall back to general solver if there are problems with</span>
                <span class="c1"># postive-definiteness</span>
                <span class="n">Lambda</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">factor_ix</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

        <span class="c1"># Compute new obs cov</span>
        <span class="c1"># Note: this is unnecessary if `idiosyncratic_ar1=True`.</span>
        <span class="c1"># This is written in a slightly more general way than</span>
        <span class="c1"># Banbura and Modugno (2014), equation (7); see instead equation (13)</span>
        <span class="c1"># of Wu et al. (1996)</span>
        <span class="c1"># "An algorithm for estimating parameters of state-space models"</span>
        <span class="k">if</span> <span class="n">compute_H</span><span class="p">:</span>
            <span class="n">Z</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s1">'design'</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">Z</span><span class="p">[:,</span> <span class="p">:</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">Lambda</span>
            <span class="n">BL</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">endog</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">a</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">@</span> <span class="n">Z</span><span class="o">.</span><span class="n">T</span>
            <span class="n">C</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">endog</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">endog</span>

            <span class="n">H</span> <span class="o">=</span> <span class="p">(</span><span class="n">C</span> <span class="o">+</span> <span class="o">-</span><span class="n">BL</span> <span class="o">-</span> <span class="n">BL</span><span class="o">.</span><span class="n">T</span> <span class="o">+</span> <span class="n">Z</span> <span class="o">@</span> <span class="n">Eaa</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">@</span> <span class="n">Z</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

        <span class="k">return</span> <span class="n">Lambda</span><span class="p">,</span> <span class="n">H</span>

    <span class="k">def</span> <span class="nf">_em_maximization_obs_missing</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">Eaa</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">compute_H</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">"""EM maximization step, observation equation with missing data."""</span>
        <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">Eaa</span><span class="o">.</span><span class="n">dtype</span>

        <span class="c1"># Observation equation (missing)</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">k_states_factors</span>
        <span class="n">Lambda</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">,</span> <span class="n">k</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

        <span class="n">W</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">res</span><span class="o">.</span><span class="n">missing</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">W</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>

        <span class="c1"># Compute design for monthly</span>
        <span class="c1"># Note: the relevant A changes for each i</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_endog_M</span><span class="p">):</span>
            <span class="n">iloc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s</span><span class="o">.</span><span class="n">endog_factor_iloc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">factor_ix</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="s1">'factors_L1'</span><span class="p">][</span><span class="n">iloc</span><span class="p">]</span>

            <span class="n">m</span> <span class="o">=</span> <span class="n">mask</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span>
            <span class="n">yt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">endog</span><span class="p">[</span><span class="n">m</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>

            <span class="n">ix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">factor_ix</span><span class="p">,</span> <span class="n">factor_ix</span><span class="p">)</span>
            <span class="n">Ai</span> <span class="o">=</span> <span class="n">Eaa</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">Bi</span> <span class="o">=</span> <span class="n">yt</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">a</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">factor_ix</span><span class="p">)][</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">idiosyncratic_ar1</span><span class="p">:</span>
                <span class="n">ix1</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">k_states_factors</span> <span class="o">+</span> <span class="n">i</span>
                <span class="n">ix2</span> <span class="o">=</span> <span class="n">ix1</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="n">Bi</span> <span class="o">-=</span> <span class="n">Eaa</span><span class="p">[</span><span class="n">m</span><span class="p">,</span> <span class="n">ix1</span><span class="p">:</span><span class="n">ix2</span><span class="p">][</span><span class="o">...</span><span class="p">,</span> <span class="n">factor_ix</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="c1"># want: x = B A^{-1}, so solve: x A = B or solve: A' x' = B'</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">Lambda</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">factor_ix</span><span class="p">]</span> <span class="o">=</span> <span class="n">cho_solve</span><span class="p">(</span><span class="n">cho_factor</span><span class="p">(</span><span class="n">Ai</span><span class="p">),</span> <span class="n">Bi</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
            <span class="k">except</span> <span class="n">LinAlgError</span><span class="p">:</span>
                <span class="c1"># Fall back to general solver if there are problems with</span>
                <span class="c1"># postive-definiteness</span>
                <span class="n">Lambda</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">factor_ix</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">Ai</span><span class="p">,</span> <span class="n">Bi</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

        <span class="c1"># Compute unrestricted design for quarterly</span>
        <span class="c1"># See Banbura at al. (2011), where this is described in Appendix C,</span>
        <span class="c1"># between equations (13) and (14).</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog_Q</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Note: the relevant A changes for each i</span>
            <span class="n">multipliers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">])[:,</span> <span class="kc">None</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_endog_M</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">):</span>
                <span class="n">iloc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s</span><span class="o">.</span><span class="n">endog_factor_iloc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">factor_ix</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="s1">'factors_L1_5_ix'</span><span class="p">][:,</span> <span class="n">iloc</span><span class="p">]</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

                <span class="n">R</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">loading_constraints</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

                <span class="n">iQ</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog_M</span>
                <span class="n">m</span> <span class="o">=</span> <span class="n">mask</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span>
                <span class="n">yt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">endog</span><span class="p">[</span><span class="n">m</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                <span class="n">ix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">factor_ix</span><span class="p">,</span> <span class="n">factor_ix</span><span class="p">)</span>
                <span class="n">Ai</span> <span class="o">=</span> <span class="n">Eaa</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">BiQ</span> <span class="o">=</span> <span class="n">yt</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">a</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">factor_ix</span><span class="p">)][</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">idiosyncratic_ar1</span><span class="p">:</span>
                    <span class="n">ix</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">s_</span><span class="p">[:],)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="s1">'idio_ar_Q_ix'</span><span class="p">][</span><span class="n">iQ</span><span class="p">],</span> <span class="n">factor_ix</span><span class="p">)</span>
                    <span class="n">Eepsf</span> <span class="o">=</span> <span class="n">Eaa</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span>
                    <span class="n">BiQ</span> <span class="o">-=</span> <span class="p">(</span><span class="n">multipliers</span> <span class="o">*</span> <span class="n">Eepsf</span><span class="p">[</span><span class="n">m</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

                <span class="c1"># Note that there was a typo in Banbura et al. (2011) for</span>
                <span class="c1"># the formula applying the restrictions. In their notation,</span>
                <span class="c1"># they show (C D C')^{-1} while it should be (C D^{-1} C')^{-1}</span>
                <span class="c1"># Note: in reality, this is:</span>
                <span class="c1"># unrestricted - Aii @ R.T @ RARi @ (R @ unrestricted - q)</span>
                <span class="c1"># where the restrictions are defined as: R @ unrestricted = q</span>
                <span class="c1"># However, here q = 0, so we can simplify.</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">L_and_lower</span> <span class="o">=</span> <span class="n">cho_factor</span><span class="p">(</span><span class="n">Ai</span><span class="p">)</span>
                    <span class="c1"># x = BQ A^{-1}, or x A = BQ, so solve A' x' = (BQ)'</span>
                    <span class="n">unrestricted</span> <span class="o">=</span> <span class="n">cho_solve</span><span class="p">(</span><span class="n">L_and_lower</span><span class="p">,</span> <span class="n">BiQ</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">AiiRT</span> <span class="o">=</span> <span class="n">cho_solve</span><span class="p">(</span><span class="n">L_and_lower</span><span class="p">,</span> <span class="n">R</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

                    <span class="n">L_and_lower</span> <span class="o">=</span> <span class="n">cho_factor</span><span class="p">(</span><span class="n">R</span> <span class="o">@</span> <span class="n">AiiRT</span><span class="p">)</span>
                    <span class="n">RAiiRTiR</span> <span class="o">=</span> <span class="n">cho_solve</span><span class="p">(</span><span class="n">L_and_lower</span><span class="p">,</span> <span class="n">R</span><span class="p">)</span>
                    <span class="n">restricted</span> <span class="o">=</span> <span class="n">unrestricted</span> <span class="o">-</span> <span class="n">AiiRT</span> <span class="o">@</span> <span class="n">RAiiRTiR</span> <span class="o">@</span> <span class="n">unrestricted</span>
                <span class="k">except</span> <span class="n">LinAlgError</span><span class="p">:</span>
                    <span class="c1"># Fall back to slower method if there are problems with</span>
                    <span class="c1"># postive-definiteness</span>
                    <span class="n">Aii</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">Ai</span><span class="p">)</span>
                    <span class="n">unrestricted</span> <span class="o">=</span> <span class="p">(</span><span class="n">BiQ</span> <span class="o">@</span> <span class="n">Aii</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">RARi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">R</span> <span class="o">@</span> <span class="n">Aii</span> <span class="o">@</span> <span class="n">R</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
                    <span class="n">restricted</span> <span class="o">=</span> <span class="p">(</span><span class="n">unrestricted</span> <span class="o">-</span>
                                  <span class="n">Aii</span> <span class="o">@</span> <span class="n">R</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">RARi</span> <span class="o">@</span> <span class="n">R</span> <span class="o">@</span> <span class="n">unrestricted</span><span class="p">)</span>
                <span class="n">Lambda</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">factor_ix</span><span class="p">]</span> <span class="o">=</span> <span class="n">restricted</span>

        <span class="c1"># Compute new obs cov</span>
        <span class="c1"># Note: this is unnecessary if `idiosyncratic_ar1=True`.</span>
        <span class="c1"># See Banbura and Modugno (2014), equation (12)</span>
        <span class="c1"># This does not literally follow their formula, e.g. multiplying by the</span>
        <span class="c1"># W_t selection matrices, because those formulas require loops that are</span>
        <span class="c1"># relatively slow. The formulation here is vectorized.</span>
        <span class="k">if</span> <span class="n">compute_H</span><span class="p">:</span>
            <span class="n">Z</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s1">'design'</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">Z</span><span class="p">[:,</span> <span class="p">:</span><span class="n">Lambda</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">Lambda</span>

            <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endog</span><span class="p">)</span>
            <span class="n">C</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">y</span>
            <span class="n">W</span> <span class="o">=</span> <span class="n">W</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>
            <span class="n">IW</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">W</span>

            <span class="n">WL</span> <span class="o">=</span> <span class="n">W</span> <span class="o">*</span> <span class="n">Z</span>
            <span class="n">WLT</span> <span class="o">=</span> <span class="n">WL</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">BL</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">@</span> <span class="n">a</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">@</span> <span class="n">WLT</span>
            <span class="n">A</span> <span class="o">=</span> <span class="n">Eaa</span>

            <span class="n">BLT</span> <span class="o">=</span> <span class="n">BL</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">IWT</span> <span class="o">=</span> <span class="n">IW</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

            <span class="n">H</span> <span class="o">=</span> <span class="p">(</span><span class="n">C</span> <span class="o">+</span> <span class="p">(</span><span class="o">-</span><span class="n">BL</span> <span class="o">-</span> <span class="n">BLT</span> <span class="o">+</span> <span class="n">WL</span> <span class="o">@</span> <span class="n">A</span> <span class="o">@</span> <span class="n">WLT</span> <span class="o">+</span>
                      <span class="n">IW</span> <span class="o">*</span> <span class="bp">self</span><span class="p">[</span><span class="s1">'obs_cov'</span><span class="p">]</span> <span class="o">*</span> <span class="n">IWT</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

        <span class="k">return</span> <span class="n">Lambda</span><span class="p">,</span> <span class="n">H</span>

    <span class="k">def</span> <span class="nf">smooth</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">includes_fixed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
               <span class="n">complex_step</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">cov_type</span><span class="o">=</span><span class="s1">'none'</span><span class="p">,</span> <span class="n">cov_kwds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="n">return_ssm</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">results_class</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="n">results_wrapper_class</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Kalman smoothing.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array_like</span>
<span class="sd">            Array of parameters at which to evaluate the loglikelihood</span>
<span class="sd">            function.</span>
<span class="sd">        transformed : bool, optional</span>
<span class="sd">            Whether or not `params` is already transformed. Default is True.</span>
<span class="sd">        return_ssm : bool,optional</span>
<span class="sd">            Whether or not to return only the state space output or a full</span>
<span class="sd">            results object. Default is to return a full results object.</span>
<span class="sd">        cov_type : str, optional</span>
<span class="sd">            See `MLEResults.fit` for a description of covariance matrix types</span>
<span class="sd">            for results object. Default is None.</span>
<span class="sd">        cov_kwds : dict or None, optional</span>
<span class="sd">            See `MLEResults.get_robustcov_results` for a description required</span>
<span class="sd">            keywords for alternative covariance estimators</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Additional keyword arguments to pass to the Kalman filter. See</span>
<span class="sd">            `KalmanFilter.filter` for more details.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">smooth</span><span class="p">(</span>
            <span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="n">transformed</span><span class="p">,</span> <span class="n">includes_fixed</span><span class="o">=</span><span class="n">includes_fixed</span><span class="p">,</span>
            <span class="n">complex_step</span><span class="o">=</span><span class="n">complex_step</span><span class="p">,</span> <span class="n">cov_type</span><span class="o">=</span><span class="n">cov_type</span><span class="p">,</span> <span class="n">cov_kwds</span><span class="o">=</span><span class="n">cov_kwds</span><span class="p">,</span>
            <span class="n">return_ssm</span><span class="o">=</span><span class="n">return_ssm</span><span class="p">,</span> <span class="n">results_class</span><span class="o">=</span><span class="n">results_class</span><span class="p">,</span>
            <span class="n">results_wrapper_class</span><span class="o">=</span><span class="n">results_wrapper_class</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

<div class="viewcode-block" id="DynamicFactorMQ.filter"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.dynamic_factor_mq.DynamicFactorMQ.filter.html#statsmodels.tsa.statespace.dynamic_factor_mq.DynamicFactorMQ.filter">[docs]</a>    <span class="k">def</span> <span class="nf">filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">includes_fixed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
               <span class="n">complex_step</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">cov_type</span><span class="o">=</span><span class="s1">'none'</span><span class="p">,</span> <span class="n">cov_kwds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="n">return_ssm</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">results_class</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="n">results_wrapper_class</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">low_memory</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Kalman filtering.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array_like</span>
<span class="sd">            Array of parameters at which to evaluate the loglikelihood</span>
<span class="sd">            function.</span>
<span class="sd">        transformed : bool, optional</span>
<span class="sd">            Whether or not `params` is already transformed. Default is True.</span>
<span class="sd">        return_ssm : bool,optional</span>
<span class="sd">            Whether or not to return only the state space output or a full</span>
<span class="sd">            results object. Default is to return a full results object.</span>
<span class="sd">        cov_type : str, optional</span>
<span class="sd">            See `MLEResults.fit` for a description of covariance matrix types</span>
<span class="sd">            for results object. Default is 'none'.</span>
<span class="sd">        cov_kwds : dict or None, optional</span>
<span class="sd">            See `MLEResults.get_robustcov_results` for a description required</span>
<span class="sd">            keywords for alternative covariance estimators</span>
<span class="sd">        low_memory : bool, optional</span>
<span class="sd">            If set to True, techniques are applied to substantially reduce</span>
<span class="sd">            memory usage. If used, some features of the results object will</span>
<span class="sd">            not be available (including in-sample prediction), although</span>
<span class="sd">            out-of-sample forecasting is possible. Default is False.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Additional keyword arguments to pass to the Kalman filter. See</span>
<span class="sd">            `KalmanFilter.filter` for more details.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
            <span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="n">transformed</span><span class="p">,</span> <span class="n">includes_fixed</span><span class="o">=</span><span class="n">includes_fixed</span><span class="p">,</span>
            <span class="n">complex_step</span><span class="o">=</span><span class="n">complex_step</span><span class="p">,</span> <span class="n">cov_type</span><span class="o">=</span><span class="n">cov_type</span><span class="p">,</span> <span class="n">cov_kwds</span><span class="o">=</span><span class="n">cov_kwds</span><span class="p">,</span>
            <span class="n">return_ssm</span><span class="o">=</span><span class="n">return_ssm</span><span class="p">,</span> <span class="n">results_class</span><span class="o">=</span><span class="n">results_class</span><span class="p">,</span>
            <span class="n">results_wrapper_class</span><span class="o">=</span><span class="n">results_wrapper_class</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">simulate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">nsimulations</span><span class="p">,</span> <span class="n">measurement_shocks</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">state_shocks</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">initial_state</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">anchor</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">repetitions</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">exog</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">extend_model</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">extend_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">includes_fixed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">original_scale</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">"""</span>
<span class="sd">        Simulate a new time series following the state space model.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array_like</span>
<span class="sd">            Array of parameters to use in constructing the state space</span>
<span class="sd">            representation to use when simulating.</span>
<span class="sd">        nsimulations : int</span>
<span class="sd">            The number of observations to simulate. If the model is</span>
<span class="sd">            time-invariant this can be any number. If the model is</span>
<span class="sd">            time-varying, then this number must be less than or equal to the</span>
<span class="sd">            number of observations.</span>
<span class="sd">        measurement_shocks : array_like, optional</span>
<span class="sd">            If specified, these are the shocks to the measurement equation,</span>
<span class="sd">            :math:`\varepsilon_t`. If unspecified, these are automatically</span>
<span class="sd">            generated using a pseudo-random number generator. If specified,</span>
<span class="sd">            must be shaped `nsimulations` x `k_endog`, where `k_endog` is the</span>
<span class="sd">            same as in the state space model.</span>
<span class="sd">        state_shocks : array_like, optional</span>
<span class="sd">            If specified, these are the shocks to the state equation,</span>
<span class="sd">            :math:`\eta_t`. If unspecified, these are automatically</span>
<span class="sd">            generated using a pseudo-random number generator. If specified,</span>
<span class="sd">            must be shaped `nsimulations` x `k_posdef` where `k_posdef` is the</span>
<span class="sd">            same as in the state space model.</span>
<span class="sd">        initial_state : array_like, optional</span>
<span class="sd">            If specified, this is the initial state vector to use in</span>
<span class="sd">            simulation, which should be shaped (`k_states` x 1), where</span>
<span class="sd">            `k_states` is the same as in the state space model. If unspecified,</span>
<span class="sd">            but the model has been initialized, then that initialization is</span>
<span class="sd">            used. This must be specified if `anchor` is anything other than</span>
<span class="sd">            "start" or 0 (or else you can use the `simulate` method on a</span>
<span class="sd">            results object rather than on the model object).</span>
<span class="sd">        anchor : int, str, or datetime, optional</span>
<span class="sd">            First period for simulation. The simulation will be conditional on</span>
<span class="sd">            all existing datapoints prior to the `anchor`.  Type depends on the</span>
<span class="sd">            index of the given `endog` in the model. Two special cases are the</span>
<span class="sd">            strings 'start' and 'end'. `start` refers to beginning the</span>
<span class="sd">            simulation at the first period of the sample, and `end` refers to</span>
<span class="sd">            beginning the simulation at the first period after the sample.</span>
<span class="sd">            Integer values can run from 0 to `nobs`, or can be negative to</span>
<span class="sd">            apply negative indexing. Finally, if a date/time index was provided</span>
<span class="sd">            to the model, then this argument can be a date string to parse or a</span>
<span class="sd">            datetime type. Default is 'start'.</span>
<span class="sd">        repetitions : int, optional</span>
<span class="sd">            Number of simulated paths to generate. Default is 1 simulated path.</span>
<span class="sd">        exog : array_like, optional</span>
<span class="sd">            New observations of exogenous regressors, if applicable.</span>
<span class="sd">        transformed : bool, optional</span>
<span class="sd">            Whether or not `params` is already transformed. Default is</span>
<span class="sd">            True.</span>
<span class="sd">        includes_fixed : bool, optional</span>
<span class="sd">            If parameters were previously fixed with the `fix_params` method,</span>
<span class="sd">            this argument describes whether or not `params` also includes</span>
<span class="sd">            the fixed parameters, in addition to the free parameters. Default</span>
<span class="sd">            is False.</span>
<span class="sd">        original_scale : bool, optional</span>
<span class="sd">            If the model specification standardized the data, whether or not</span>
<span class="sd">            to return simulations in the original scale of the data (i.e.</span>
<span class="sd">            before it was standardized by the model). Default is True.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        simulated_obs : ndarray</span>
<span class="sd">            An array of simulated observations. If `repetitions=None`, then it</span>
<span class="sd">            will be shaped (nsimulations x k_endog) or (nsimulations,) if</span>
<span class="sd">            `k_endog=1`. Otherwise it will be shaped</span>
<span class="sd">            (nsimulations x k_endog x repetitions). If the model was given</span>
<span class="sd">            Pandas input then the output will be a Pandas object. If</span>
<span class="sd">            `k_endog &gt; 1` and `repetitions` is not None, then the output will</span>
<span class="sd">            be a Pandas DataFrame that has a MultiIndex for the columns, with</span>
<span class="sd">            the first level containing the names of the `endog` variables and</span>
<span class="sd">            the second level containing the repetition number.</span>
<span class="sd">        """</span>
        <span class="c1"># Get usual simulations (in the possibly-standardized scale)</span>
        <span class="n">sim</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">simulate</span><span class="p">(</span>
            <span class="n">params</span><span class="p">,</span> <span class="n">nsimulations</span><span class="p">,</span> <span class="n">measurement_shocks</span><span class="o">=</span><span class="n">measurement_shocks</span><span class="p">,</span>
            <span class="n">state_shocks</span><span class="o">=</span><span class="n">state_shocks</span><span class="p">,</span> <span class="n">initial_state</span><span class="o">=</span><span class="n">initial_state</span><span class="p">,</span>
            <span class="n">anchor</span><span class="o">=</span><span class="n">anchor</span><span class="p">,</span> <span class="n">repetitions</span><span class="o">=</span><span class="n">repetitions</span><span class="p">,</span> <span class="n">exog</span><span class="o">=</span><span class="n">exog</span><span class="p">,</span>
            <span class="n">extend_model</span><span class="o">=</span><span class="n">extend_model</span><span class="p">,</span> <span class="n">extend_kwargs</span><span class="o">=</span><span class="n">extend_kwargs</span><span class="p">,</span>
            <span class="n">transformed</span><span class="o">=</span><span class="n">transformed</span><span class="p">,</span> <span class="n">includes_fixed</span><span class="o">=</span><span class="n">includes_fixed</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># If applicable, convert predictions back to original space</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">standardize</span> <span class="ow">and</span> <span class="n">original_scale</span><span class="p">:</span>
            <span class="n">use_pandas</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">PandasData</span><span class="p">)</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">shape</span>

            <span class="k">if</span> <span class="n">use_pandas</span><span class="p">:</span>
                <span class="c1"># pd.Series (k_endog=1, replications=None)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">sim</span> <span class="o">=</span> <span class="n">sim</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_endog_std</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_endog_mean</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="c1"># pd.DataFrame (k_endog &gt; 1, replications=None)</span>
                <span class="c1"># [or]</span>
                <span class="c1"># pd.DataFrame with MultiIndex (replications &gt; 0)</span>
                <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">sim</span> <span class="o">=</span> <span class="p">(</span><span class="n">sim</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_endog_std</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                              <span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_endog_mean</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># 1-dim array (k_endog=1, replications=None)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">sim</span> <span class="o">=</span> <span class="n">sim</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_endog_std</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_endog_mean</span>
                <span class="c1"># 2-dim array (k_endog &gt; 1, replications=None)</span>
                <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">sim</span> <span class="o">=</span> <span class="n">sim</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_endog_std</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_endog_mean</span>
                <span class="c1"># 3-dim array with MultiIndex (replications &gt; 0)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Get arrays into the form that can be used for</span>
                    <span class="c1"># broadcasting</span>
                    <span class="n">std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_endog_std</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>
                    <span class="n">mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_endog_mean</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>
                    <span class="n">sim</span> <span class="o">=</span> <span class="n">sim</span> <span class="o">*</span> <span class="n">std</span> <span class="o">+</span> <span class="n">mean</span>

        <span class="k">return</span> <span class="n">sim</span>

    <span class="k">def</span> <span class="nf">impulse_responses</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">steps</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">impulse</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                          <span class="n">orthogonalized</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">cumulative</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">anchor</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                          <span class="n">exog</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">extend_model</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">extend_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                          <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">includes_fixed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                          <span class="n">original_scale</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Impulse response function.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array_like</span>
<span class="sd">            Array of model parameters.</span>
<span class="sd">        steps : int, optional</span>
<span class="sd">            The number of steps for which impulse responses are calculated.</span>
<span class="sd">            Default is 1. Note that for time-invariant models, the initial</span>
<span class="sd">            impulse is not counted as a step, so if `steps=1`, the output will</span>
<span class="sd">            have 2 entries.</span>
<span class="sd">        impulse : int or array_like</span>
<span class="sd">            If an integer, the state innovation to pulse; must be between 0</span>
<span class="sd">            and `k_posdef-1`. Alternatively, a custom impulse vector may be</span>
<span class="sd">            provided; must be shaped `k_posdef x 1`.</span>
<span class="sd">        orthogonalized : bool, optional</span>
<span class="sd">            Whether or not to perform impulse using orthogonalized innovations.</span>
<span class="sd">            Note that this will also affect custum `impulse` vectors. Default</span>
<span class="sd">            is False.</span>
<span class="sd">        cumulative : bool, optional</span>
<span class="sd">            Whether or not to return cumulative impulse responses. Default is</span>
<span class="sd">            False.</span>
<span class="sd">        anchor : int, str, or datetime, optional</span>
<span class="sd">            Time point within the sample for the state innovation impulse. Type</span>
<span class="sd">            depends on the index of the given `endog` in the model. Two special</span>
<span class="sd">            cases are the strings 'start' and 'end', which refer to setting the</span>
<span class="sd">            impulse at the first and last points of the sample, respectively.</span>
<span class="sd">            Integer values can run from 0 to `nobs - 1`, or can be negative to</span>
<span class="sd">            apply negative indexing. Finally, if a date/time index was provided</span>
<span class="sd">            to the model, then this argument can be a date string to parse or a</span>
<span class="sd">            datetime type. Default is 'start'.</span>
<span class="sd">        exog : array_like, optional</span>
<span class="sd">            New observations of exogenous regressors for our-of-sample periods,</span>
<span class="sd">            if applicable.</span>
<span class="sd">        transformed : bool, optional</span>
<span class="sd">            Whether or not `params` is already transformed. Default is</span>
<span class="sd">            True.</span>
<span class="sd">        includes_fixed : bool, optional</span>
<span class="sd">            If parameters were previously fixed with the `fix_params` method,</span>
<span class="sd">            this argument describes whether or not `params` also includes</span>
<span class="sd">            the fixed parameters, in addition to the free parameters. Default</span>
<span class="sd">            is False.</span>
<span class="sd">        original_scale : bool, optional</span>
<span class="sd">            If the model specification standardized the data, whether or not</span>
<span class="sd">            to return impulse responses in the original scale of the data (i.e.</span>
<span class="sd">            before it was standardized by the model). Default is True.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            If the model has time-varying design or transition matrices and the</span>
<span class="sd">            combination of `anchor` and `steps` implies creating impulse</span>
<span class="sd">            responses for the out-of-sample period, then these matrices must</span>
<span class="sd">            have updated values provided for the out-of-sample steps. For</span>
<span class="sd">            example, if `design` is a time-varying component, `nobs` is 10,</span>
<span class="sd">            `anchor=1`, and `steps` is 15, a (`k_endog` x `k_states` x 7)</span>
<span class="sd">            matrix must be provided with the new design matrix values.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        impulse_responses : ndarray</span>
<span class="sd">            Responses for each endogenous variable due to the impulse</span>
<span class="sd">            given by the `impulse` argument. For a time-invariant model, the</span>
<span class="sd">            impulse responses are given for `steps + 1` elements (this gives</span>
<span class="sd">            the "initial impulse" followed by `steps` responses for the</span>
<span class="sd">            important cases of VAR and SARIMAX models), while for time-varying</span>
<span class="sd">            models the impulse responses are only given for `steps` elements</span>
<span class="sd">            (to avoid having to unexpectedly provide updated time-varying</span>
<span class="sd">            matrices).</span>

<span class="sd">        """</span>
        <span class="c1"># Get usual simulations (in the possibly-standardized scale)</span>
        <span class="n">irfs</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">impulse_responses</span><span class="p">(</span>
            <span class="n">params</span><span class="p">,</span> <span class="n">steps</span><span class="o">=</span><span class="n">steps</span><span class="p">,</span> <span class="n">impulse</span><span class="o">=</span><span class="n">impulse</span><span class="p">,</span>
            <span class="n">orthogonalized</span><span class="o">=</span><span class="n">orthogonalized</span><span class="p">,</span> <span class="n">cumulative</span><span class="o">=</span><span class="n">cumulative</span><span class="p">,</span>
            <span class="n">anchor</span><span class="o">=</span><span class="n">anchor</span><span class="p">,</span> <span class="n">exog</span><span class="o">=</span><span class="n">exog</span><span class="p">,</span> <span class="n">extend_model</span><span class="o">=</span><span class="n">extend_model</span><span class="p">,</span>
            <span class="n">extend_kwargs</span><span class="o">=</span><span class="n">extend_kwargs</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="n">transformed</span><span class="p">,</span>
            <span class="n">includes_fixed</span><span class="o">=</span><span class="n">includes_fixed</span><span class="p">,</span> <span class="n">original_scale</span><span class="o">=</span><span class="n">original_scale</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># If applicable, convert predictions back to original space</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">standardize</span> <span class="ow">and</span> <span class="n">original_scale</span><span class="p">:</span>
            <span class="n">use_pandas</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">PandasData</span><span class="p">)</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="n">irfs</span><span class="o">.</span><span class="n">shape</span>

            <span class="k">if</span> <span class="n">use_pandas</span><span class="p">:</span>
                <span class="c1"># pd.Series (k_endog=1, replications=None)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">irfs</span> <span class="o">=</span> <span class="n">irfs</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_endog_std</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="c1"># pd.DataFrame (k_endog &gt; 1)</span>
                <span class="c1"># [or]</span>
                <span class="c1"># pd.DataFrame with MultiIndex (replications &gt; 0)</span>
                <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">irfs</span> <span class="o">=</span> <span class="n">irfs</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_endog_std</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># 1-dim array (k_endog=1)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">irfs</span> <span class="o">=</span> <span class="n">irfs</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_endog_std</span>
                <span class="c1"># 2-dim array (k_endog &gt; 1)</span>
                <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">irfs</span> <span class="o">=</span> <span class="n">irfs</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_endog_std</span>

        <span class="k">return</span> <span class="n">irfs</span></div>


<span class="k">class</span> <span class="nc">DynamicFactorMQResults</span><span class="p">(</span><span class="n">mlemodel</span><span class="o">.</span><span class="n">MLEResults</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    Results from fitting a dynamic factor model</span>
<span class="sd">    """</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">filter_results</span><span class="p">,</span> <span class="n">cov_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">DynamicFactorMQResults</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">model</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">filter_results</span><span class="p">,</span> <span class="n">cov_type</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">factors</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Estimates of unobserved factors.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        out : Bunch</span>
<span class="sd">            Has the following attributes shown in Notes.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The output is a bunch of the following format:</span>

<span class="sd">        - `filtered`: a time series array with the filtered estimate of</span>
<span class="sd">          the component</span>
<span class="sd">        - `filtered_cov`: a time series array with the filtered estimate of</span>
<span class="sd">          the variance/covariance of the component</span>
<span class="sd">        - `smoothed`: a time series array with the smoothed estimate of</span>
<span class="sd">          the component</span>
<span class="sd">        - `smoothed_cov`: a time series array with the smoothed estimate of</span>
<span class="sd">          the variance/covariance of the component</span>
<span class="sd">        - `offset`: an integer giving the offset in the state vector where</span>
<span class="sd">          this component begins</span>
<span class="sd">        """</span>
        <span class="n">out</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">k_factors</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">iloc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">_s</span><span class="o">.</span><span class="n">factors_L1</span>
            <span class="n">ix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">state_names</span><span class="p">)[</span><span class="n">iloc</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">Bunch</span><span class="p">(</span>
                <span class="n">filtered</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="o">.</span><span class="n">filtered</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">ix</span><span class="p">],</span>
                <span class="n">filtered_cov</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="o">.</span><span class="n">filtered_cov</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">s_</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="p">:],</span> <span class="n">ix</span><span class="p">],</span>
                <span class="n">smoothed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">smoothed_cov</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">smoothed_state</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">out</span><span class="o">.</span><span class="n">smoothed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="o">.</span><span class="n">smoothed</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">ix</span><span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">smoothed_state_cov</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">out</span><span class="o">.</span><span class="n">smoothed_cov</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="o">.</span><span class="n">smoothed_cov</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">s_</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="p">:],</span> <span class="n">ix</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span> <span class="nf">get_coefficients_of_determination</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">'individual'</span><span class="p">,</span>
                                          <span class="n">which</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Get coefficients of determination (R-squared) for variables / factors.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        method : {'individual', 'joint', 'cumulative'}, optional</span>
<span class="sd">            The type of R-squared values to generate. "individual" plots</span>
<span class="sd">            the R-squared of each variable on each factor; "joint" plots the</span>
<span class="sd">            R-squared of each variable on each factor that it loads on;</span>
<span class="sd">            "cumulative" plots the successive R-squared values as each</span>
<span class="sd">            additional factor is added to the regression, for each variable.</span>
<span class="sd">            Default is 'individual'.</span>
<span class="sd">        which: {None, 'filtered', 'smoothed'}, optional</span>
<span class="sd">            Whether to compute R-squared values based on filtered or smoothed</span>
<span class="sd">            estimates of the factors. Default is 'smoothed' if smoothed results</span>
<span class="sd">            are available and 'filtered' otherwise.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        rsquared : pd.DataFrame or pd.Series</span>
<span class="sd">            The R-squared values from regressions of observed variables on</span>
<span class="sd">            one or more of the factors. If method='individual' or</span>
<span class="sd">            method='cumulative', this will be a Pandas DataFrame with observed</span>
<span class="sd">            variables as the index and factors as the columns . If</span>
<span class="sd">            method='joint', will be a Pandas Series with observed variables as</span>
<span class="sd">            the index.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        plot_coefficients_of_determination</span>
<span class="sd">        coefficients_of_determination</span>
<span class="sd">        """</span>
        <span class="kn">from</span> <span class="nn">statsmodels.tools</span> <span class="kn">import</span> <span class="n">add_constant</span>

        <span class="n">method</span> <span class="o">=</span> <span class="n">string_like</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="s1">'method'</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="p">[</span><span class="s1">'individual'</span><span class="p">,</span> <span class="s1">'joint'</span><span class="p">,</span>
                                                        <span class="s1">'cumulative'</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">which</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">which</span> <span class="o">=</span> <span class="s1">'filtered'</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">smoothed_state</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="s1">'smoothed'</span>

        <span class="n">k_endog</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">k_endog</span>
        <span class="n">k_factors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">k_factors</span>
        <span class="n">ef_map</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">_s</span><span class="o">.</span><span class="n">endog_factor_map</span>
        <span class="n">endog_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">endog_names</span>
        <span class="n">factor_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">factor_names</span>

        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">'individual'</span><span class="p">:</span>
            <span class="n">coefficients</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">k_endog</span><span class="p">,</span> <span class="n">k_factors</span><span class="p">))</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k_factors</span><span class="p">):</span>
                <span class="n">exog</span> <span class="o">=</span> <span class="n">add_constant</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">factors</span><span class="p">[</span><span class="n">which</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="n">i</span><span class="p">])</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k_endog</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">ef_map</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]:</span>
                        <span class="n">endog</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_results</span><span class="o">.</span><span class="n">endog</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                        <span class="n">coefficients</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="n">OLS</span><span class="p">(</span><span class="n">endog</span><span class="p">,</span> <span class="n">exog</span><span class="p">,</span> <span class="n">missing</span><span class="o">=</span><span class="s1">'drop'</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">()</span><span class="o">.</span><span class="n">rsquared</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">coefficients</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

            <span class="n">coefficients</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">coefficients</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">endog_names</span><span class="p">,</span>
                                        <span class="n">columns</span><span class="o">=</span><span class="n">factor_names</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">'joint'</span><span class="p">:</span>
            <span class="n">coefficients</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">k_endog</span><span class="p">,))</span>
            <span class="n">exog</span> <span class="o">=</span> <span class="n">add_constant</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">factors</span><span class="p">[</span><span class="n">which</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k_endog</span><span class="p">):</span>
                <span class="n">endog</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_results</span><span class="o">.</span><span class="n">endog</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="n">ix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="n">ef_map</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                <span class="n">X</span> <span class="o">=</span> <span class="n">exog</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">ix</span><span class="p">]</span>
                <span class="n">coefficients</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">OLS</span><span class="p">(</span><span class="n">endog</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">missing</span><span class="o">=</span><span class="s1">'drop'</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">()</span><span class="o">.</span><span class="n">rsquared</span><span class="p">)</span>
            <span class="n">coefficients</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">coefficients</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">endog_names</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">'cumulative'</span><span class="p">:</span>
            <span class="n">coefficients</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">k_endog</span><span class="p">,</span> <span class="n">k_factors</span><span class="p">))</span>
            <span class="n">exog</span> <span class="o">=</span> <span class="n">add_constant</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">factors</span><span class="p">[</span><span class="n">which</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k_endog</span><span class="p">):</span>
                <span class="n">endog</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_results</span><span class="o">.</span><span class="n">endog</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>

                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k_factors</span><span class="p">):</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">_s</span><span class="o">.</span><span class="n">endog_factor_map</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]:</span>
                        <span class="n">ix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="n">ef_map</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span>
                                   <span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">k_factors</span> <span class="o">-</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span>
                        <span class="n">X</span> <span class="o">=</span> <span class="n">exog</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">ix</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()]</span>
                        <span class="n">coefficients</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="n">OLS</span><span class="p">(</span><span class="n">endog</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">missing</span><span class="o">=</span><span class="s1">'drop'</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">()</span><span class="o">.</span><span class="n">rsquared</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">coefficients</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">coefficients</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">coefficients</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">endog_names</span><span class="p">,</span>
                                        <span class="n">columns</span><span class="o">=</span><span class="n">factor_names</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">coefficients</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">coefficients_of_determination</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Individual coefficients of determination (:math:`R^2`).</span>

<span class="sd">        Coefficients of determination (:math:`R^2`) from regressions of</span>
<span class="sd">        endogenous variables on individual estimated factors.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        coefficients_of_determination : ndarray</span>
<span class="sd">            A `k_endog` x `k_factors` array, where</span>
<span class="sd">            `coefficients_of_determination[i, j]` represents the :math:`R^2`</span>
<span class="sd">            value from a regression of factor `j` and a constant on endogenous</span>
<span class="sd">            variable `i`.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Although it can be difficult to interpret the estimated factor loadings</span>
<span class="sd">        and factors, it is often helpful to use the coefficients of</span>
<span class="sd">        determination from univariate regressions to assess the importance of</span>
<span class="sd">        each factor in explaining the variation in each endogenous variable.</span>

<span class="sd">        In models with many variables and factors, this can sometimes lend</span>
<span class="sd">        interpretation to the factors (for example sometimes one factor will</span>
<span class="sd">        load primarily on real variables and another on nominal variables).</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        get_coefficients_of_determination</span>
<span class="sd">        plot_coefficients_of_determination</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_coefficients_of_determination</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="s1">'individual'</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">plot_coefficients_of_determination</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">'individual'</span><span class="p">,</span>
                                           <span class="n">which</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">endog_labels</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                           <span class="n">fig</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Plot coefficients of determination (R-squared) for variables / factors.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        method : {'individual', 'joint', 'cumulative'}, optional</span>
<span class="sd">            The type of R-squared values to generate. "individual" plots</span>
<span class="sd">            the R-squared of each variable on each factor; "joint" plots the</span>
<span class="sd">            R-squared of each variable on each factor that it loads on;</span>
<span class="sd">            "cumulative" plots the successive R-squared values as each</span>
<span class="sd">            additional factor is added to the regression, for each variable.</span>
<span class="sd">            Default is 'individual'.</span>
<span class="sd">        which: {None, 'filtered', 'smoothed'}, optional</span>
<span class="sd">            Whether to compute R-squared values based on filtered or smoothed</span>
<span class="sd">            estimates of the factors. Default is 'smoothed' if smoothed results</span>
<span class="sd">            are available and 'filtered' otherwise.</span>
<span class="sd">        endog_labels : bool, optional</span>
<span class="sd">            Whether or not to label the endogenous variables along the x-axis</span>
<span class="sd">            of the plots. Default is to include labels if there are 5 or fewer</span>
<span class="sd">            endogenous variables.</span>
<span class="sd">        fig : Figure, optional</span>
<span class="sd">            If given, subplots are created in this figure instead of in a new</span>
<span class="sd">            figure. Note that the grid will be created in the provided</span>
<span class="sd">            figure using `fig.add_subplot()`.</span>
<span class="sd">        figsize : tuple, optional</span>
<span class="sd">            If a figure is created, this argument allows specifying a size.</span>
<span class="sd">            The tuple is (width, height).</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The endogenous variables are arranged along the x-axis according to</span>
<span class="sd">        their position in the model's `endog` array.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        get_coefficients_of_determination</span>
<span class="sd">        """</span>
        <span class="kn">from</span> <span class="nn">statsmodels.graphics.utils</span> <span class="kn">import</span> <span class="n">_import_mpl</span><span class="p">,</span> <span class="n">create_mpl_fig</span>
        <span class="n">_import_mpl</span><span class="p">()</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">create_mpl_fig</span><span class="p">(</span><span class="n">fig</span><span class="p">,</span> <span class="n">figsize</span><span class="p">)</span>

        <span class="n">method</span> <span class="o">=</span> <span class="n">string_like</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="s1">'method'</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="p">[</span><span class="s1">'individual'</span><span class="p">,</span> <span class="s1">'joint'</span><span class="p">,</span>
                                                        <span class="s1">'cumulative'</span><span class="p">])</span>

        <span class="c1"># Should we label endogenous variables?</span>
        <span class="k">if</span> <span class="n">endog_labels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">endog_labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">k_endog</span> <span class="o">&lt;=</span> <span class="mi">5</span>

        <span class="c1"># Plot the coefficients of determination</span>
        <span class="n">rsquared</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_coefficients_of_determination</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
                                                          <span class="n">which</span><span class="o">=</span><span class="n">which</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">method</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">'individual'</span><span class="p">,</span> <span class="s1">'cumulative'</span><span class="p">]:</span>
            <span class="n">plot_idx</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">for</span> <span class="n">factor_name</span><span class="p">,</span> <span class="n">coeffs</span> <span class="ow">in</span> <span class="n">rsquared</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
                <span class="c1"># Create the new axis</span>
                <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">k_factors</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">plot_idx</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">title</span><span class="o">=</span><span class="sa">f</span><span class="s1">'</span><span class="si">{</span><span class="n">factor_name</span><span class="si">}</span><span class="s1">'</span><span class="p">,</span> <span class="n">ylabel</span><span class="o">=</span><span class="sa">r</span><span class="s1">'$R^2$'</span><span class="p">)</span>

                <span class="n">coeffs</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">'bar'</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">plot_idx</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">rsquared</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">endog_labels</span><span class="p">:</span>
                    <span class="n">ax</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">set_ticklabels</span><span class="p">([])</span>

                <span class="n">plot_idx</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">'joint'</span><span class="p">:</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">title</span><span class="o">=</span><span class="sa">r</span><span class="s1">'$R^2$ - regression on all loaded factors'</span><span class="p">,</span>
                   <span class="n">ylabel</span><span class="o">=</span><span class="sa">r</span><span class="s1">'$R^2$'</span><span class="p">)</span>
            <span class="n">rsquared</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">'bar'</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">endog_labels</span><span class="p">:</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">set_ticklabels</span><span class="p">([])</span>

        <span class="k">return</span> <span class="n">fig</span>

    <span class="k">def</span> <span class="nf">get_prediction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dynamic</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                       <span class="n">index</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">exog</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">extend_model</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                       <span class="n">extend_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">original_scale</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        In-sample prediction and out-of-sample forecasting.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        start : int, str, or datetime, optional</span>
<span class="sd">            Zero-indexed observation number at which to start forecasting,</span>
<span class="sd">            i.e., the first forecast is start. Can also be a date string to</span>
<span class="sd">            parse or a datetime type. Default is the the zeroth observation.</span>
<span class="sd">        end : int, str, or datetime, optional</span>
<span class="sd">            Zero-indexed observation number at which to end forecasting, i.e.,</span>
<span class="sd">            the last forecast is end. Can also be a date string to</span>
<span class="sd">            parse or a datetime type. However, if the dates index does not</span>
<span class="sd">            have a fixed frequency, end must be an integer index if you</span>
<span class="sd">            want out of sample prediction. Default is the last observation in</span>
<span class="sd">            the sample.</span>
<span class="sd">        dynamic : bool, int, str, or datetime, optional</span>
<span class="sd">            Integer offset relative to `start` at which to begin dynamic</span>
<span class="sd">            prediction. Can also be an absolute date string to parse or a</span>
<span class="sd">            datetime type (these are not interpreted as offsets).</span>
<span class="sd">            Prior to this observation, true endogenous values will be used for</span>
<span class="sd">            prediction; starting with this observation and continuing through</span>
<span class="sd">            the end of prediction, forecasted endogenous values will be used</span>
<span class="sd">            instead.</span>
<span class="sd">        original_scale : bool, optional</span>
<span class="sd">            If the model specification standardized the data, whether or not</span>
<span class="sd">            to return predictions in the original scale of the data (i.e.</span>
<span class="sd">            before it was standardized by the model). Default is True.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Additional arguments may required for forecasting beyond the end</span>
<span class="sd">            of the sample. See `FilterResults.predict` for more details.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        forecast : ndarray</span>
<span class="sd">            Array of out of in-sample predictions and / or out-of-sample</span>
<span class="sd">            forecasts. An (npredict x k_endog) array.</span>
<span class="sd">        """</span>
        <span class="c1"># Get usual predictions (in the possibly-standardized scale)</span>
        <span class="n">res</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get_prediction</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="n">end</span><span class="p">,</span> <span class="n">dynamic</span><span class="o">=</span><span class="n">dynamic</span><span class="p">,</span>
                                     <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span> <span class="n">exog</span><span class="o">=</span><span class="n">exog</span><span class="p">,</span>
                                     <span class="n">extend_model</span><span class="o">=</span><span class="n">extend_model</span><span class="p">,</span>
                                     <span class="n">extend_kwargs</span><span class="o">=</span><span class="n">extend_kwargs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># If applicable, convert predictions back to original space</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">standardize</span> <span class="ow">and</span> <span class="n">original_scale</span><span class="p">:</span>
            <span class="n">prediction_results</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">prediction_results</span>
            <span class="n">k_endog</span><span class="p">,</span> <span class="n">nobs</span> <span class="o">=</span> <span class="n">prediction_results</span><span class="o">.</span><span class="n">endog</span><span class="o">.</span><span class="n">shape</span>

            <span class="n">mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">_endog_mean</span><span class="p">)</span>
            <span class="n">std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">_endog_std</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">k_endog</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">mean</span> <span class="o">=</span> <span class="n">mean</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>
                <span class="n">std</span> <span class="o">=</span> <span class="n">std</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">prediction_results</span><span class="o">.</span><span class="n">results</span><span class="o">.</span><span class="n">memory_no_forecast_mean</span><span class="p">:</span>
                <span class="n">res</span><span class="o">.</span><span class="n">_results</span><span class="o">.</span><span class="n">_predicted_mean</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">res</span><span class="o">.</span><span class="n">_results</span><span class="o">.</span><span class="n">_predicted_mean</span> <span class="o">*</span> <span class="n">std</span> <span class="o">+</span> <span class="n">mean</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">prediction_results</span><span class="o">.</span><span class="n">results</span><span class="o">.</span><span class="n">memory_no_forecast_cov</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">k_endog</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">res</span><span class="o">.</span><span class="n">_results</span><span class="o">.</span><span class="n">_var_pred_mean</span> <span class="o">*=</span> <span class="n">std</span><span class="o">**</span><span class="mi">2</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">res</span><span class="o">.</span><span class="n">_results</span><span class="o">.</span><span class="n">_var_pred_mean</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">std</span> <span class="o">*</span> <span class="n">res</span><span class="o">.</span><span class="n">_results</span><span class="o">.</span><span class="n">_var_pred_mean</span> <span class="o">*</span> <span class="n">std</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">res</span>

    <span class="k">def</span> <span class="nf">news</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">comparison</span><span class="p">,</span> <span class="n">impact_date</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">impacted_variable</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
             <span class="n">start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">periods</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">exog</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
             <span class="n">comparison_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">return_raw</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mf">1e-10</span><span class="p">,</span>
             <span class="n">endog_quarterly</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">original_scale</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Compute impacts from updated data (news and revisions).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        comparison : array_like or MLEResults</span>
<span class="sd">            An updated dataset with updated and/or revised data from which the</span>
<span class="sd">            news can be computed, or an updated or previous results object</span>
<span class="sd">            to use in computing the news.</span>
<span class="sd">        impact_date : int, str, or datetime, optional</span>
<span class="sd">            A single specific period of impacts from news and revisions to</span>
<span class="sd">            compute. Can also be a date string to parse or a datetime type.</span>
<span class="sd">            This argument cannot be used in combination with `start`, `end`, or</span>
<span class="sd">            `periods`. Default is the first out-of-sample observation.</span>
<span class="sd">        impacted_variable : str, list, array, or slice, optional</span>
<span class="sd">            Observation variable label or slice of labels specifying that only</span>
<span class="sd">            specific impacted variables should be shown in the News output. The</span>
<span class="sd">            impacted variable(s) describe the variables that were *affected* by</span>
<span class="sd">            the news. If you do not know the labels for the variables, check</span>
<span class="sd">            the `endog_names` attribute of the model instance.</span>
<span class="sd">        start : int, str, or datetime, optional</span>
<span class="sd">            The first period of impacts from news and revisions to compute.</span>
<span class="sd">            Can also be a date string to parse or a datetime type. Default is</span>
<span class="sd">            the first out-of-sample observation.</span>
<span class="sd">        end : int, str, or datetime, optional</span>
<span class="sd">            The last period of impacts from news and revisions to compute.</span>
<span class="sd">            Can also be a date string to parse or a datetime type. Default is</span>
<span class="sd">            the first out-of-sample observation.</span>
<span class="sd">        periods : int, optional</span>
<span class="sd">            The number of periods of impacts from news and revisions to</span>
<span class="sd">            compute.</span>
<span class="sd">        exog : array_like, optional</span>
<span class="sd">            Array of exogenous regressors for the out-of-sample period, if</span>
<span class="sd">            applicable.</span>
<span class="sd">        comparison_type : {None, 'previous', 'updated'}</span>
<span class="sd">            This denotes whether the `comparison` argument represents a</span>
<span class="sd">            *previous* results object or dataset or an *updated* results object</span>
<span class="sd">            or dataset. If not specified, then an attempt is made to determine</span>
<span class="sd">            the comparison type.</span>
<span class="sd">        return_raw : bool, optional</span>
<span class="sd">            Whether or not to return only the specific output or a full</span>
<span class="sd">            results object. Default is to return a full results object.</span>
<span class="sd">        tolerance : float, optional</span>
<span class="sd">            The numerical threshold for determining zero impact. Default is</span>
<span class="sd">            that any impact less than 1e-10 is assumed to be zero.</span>
<span class="sd">        endog_quarterly : array_like, optional</span>
<span class="sd">            New observations of quarterly variables, if `comparison` was</span>
<span class="sd">            provided as an updated monthly dataset. If this argument is</span>
<span class="sd">            provided, it must be a Pandas Series or DataFrame with a</span>
<span class="sd">            DatetimeIndex or PeriodIndex at the quarterly frequency.</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        .. [1] Bańbura, Marta, and Michele Modugno.</span>
<span class="sd">               "Maximum likelihood estimation of factor models on datasets with</span>
<span class="sd">               arbitrary pattern of missing data."</span>
<span class="sd">               Journal of Applied Econometrics 29, no. 1 (2014): 133-160.</span>
<span class="sd">        .. [2] Bańbura, Marta, Domenico Giannone, and Lucrezia Reichlin.</span>
<span class="sd">               "Nowcasting."</span>
<span class="sd">               The Oxford Handbook of Economic Forecasting. July 8, 2011.</span>
<span class="sd">        .. [3] Bańbura, Marta, Domenico Giannone, Michele Modugno, and Lucrezia</span>
<span class="sd">               Reichlin.</span>
<span class="sd">               "Now-casting and the real-time data flow."</span>
<span class="sd">               In Handbook of economic forecasting, vol. 2, pp. 195-237.</span>
<span class="sd">               Elsevier, 2013.</span>
<span class="sd">        """</span>
        <span class="n">news_results</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">news</span><span class="p">(</span>
            <span class="n">comparison</span><span class="p">,</span> <span class="n">impact_date</span><span class="o">=</span><span class="n">impact_date</span><span class="p">,</span>
            <span class="n">impacted_variable</span><span class="o">=</span><span class="n">impacted_variable</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="n">end</span><span class="p">,</span>
            <span class="n">periods</span><span class="o">=</span><span class="n">periods</span><span class="p">,</span> <span class="n">exog</span><span class="o">=</span><span class="n">exog</span><span class="p">,</span> <span class="n">comparison_type</span><span class="o">=</span><span class="n">comparison_type</span><span class="p">,</span>
            <span class="n">return_raw</span><span class="o">=</span><span class="n">return_raw</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="n">tolerance</span><span class="p">,</span>
            <span class="n">endog_quarterly</span><span class="o">=</span><span class="n">endog_quarterly</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># If we have standardized the data, we may want to report the news in</span>
        <span class="c1"># the original scale. If so, we need to modify the data to "undo" the</span>
        <span class="c1"># standardization.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">return_raw</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">standardize</span> <span class="ow">and</span> <span class="n">original_scale</span><span class="p">:</span>
            <span class="n">endog_mean</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">_endog_mean</span>
            <span class="n">endog_std</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">_endog_std</span>

            <span class="c1"># Don't need to add in the mean for the impacts, since they are</span>
            <span class="c1"># the difference of two forecasts</span>
            <span class="n">news_results</span><span class="o">.</span><span class="n">total_impacts</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">news_results</span><span class="o">.</span><span class="n">total_impacts</span> <span class="o">*</span> <span class="n">endog_std</span><span class="p">)</span>
            <span class="n">news_results</span><span class="o">.</span><span class="n">update_impacts</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">news_results</span><span class="o">.</span><span class="n">update_impacts</span> <span class="o">*</span> <span class="n">endog_std</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">news_results</span><span class="o">.</span><span class="n">revision_impacts</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">news_results</span><span class="o">.</span><span class="n">revision_impacts</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">news_results</span><span class="o">.</span><span class="n">revision_impacts</span> <span class="o">*</span> <span class="n">endog_std</span><span class="p">)</span>

            <span class="c1"># Update forecasts</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">'prev_impacted_forecasts'</span><span class="p">,</span> <span class="s1">'news'</span><span class="p">,</span> <span class="s1">'update_realized'</span><span class="p">,</span>
                         <span class="s1">'update_forecasts'</span><span class="p">,</span> <span class="s1">'post_impacted_forecasts'</span><span class="p">]:</span>
                <span class="n">dta</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">news_results</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

                <span class="c1"># for pd.Series, dta.multiply(...) removes the name attribute;</span>
                <span class="c1"># save it now so that we can add it back in</span>
                <span class="n">orig_name</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">dta</span><span class="p">,</span> <span class="s1">'name'</span><span class="p">):</span>
                    <span class="n">orig_name</span> <span class="o">=</span> <span class="n">dta</span><span class="o">.</span><span class="n">name</span>

                <span class="n">dta</span> <span class="o">=</span> <span class="n">dta</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">endog_std</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

                <span class="c1"># add back in the name attribute if it was removed</span>
                <span class="k">if</span> <span class="n">orig_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">dta</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">orig_name</span>

                <span class="k">if</span> <span class="n">name</span> <span class="o">!=</span> <span class="s1">'news'</span><span class="p">:</span>
                    <span class="n">dta</span> <span class="o">=</span> <span class="n">dta</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">endog_mean</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="n">news_results</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">dta</span><span class="p">)</span>

            <span class="c1"># For the weights: rows correspond to update (date, variable) and</span>
            <span class="c1"># columns correspond to the impacted variable.</span>
            <span class="c1"># 1. Because we have modified the updates (realized, forecasts, and</span>
            <span class="c1">#    forecast errors) to be in the scale of the original updated</span>
            <span class="c1">#    variable, we need to essentially reverse that change for each</span>
            <span class="c1">#    row of the weights by dividing by the standard deviation of</span>
            <span class="c1">#    that row's updated variable</span>
            <span class="c1"># 2. Because we want the impacts to be in the scale of the original</span>
            <span class="c1">#    impacted variable, we need to multiply each column by the</span>
            <span class="c1">#    standard deviation of that column's impacted variable</span>
            <span class="n">news_results</span><span class="o">.</span><span class="n">weights</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">news_results</span><span class="o">.</span><span class="n">weights</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">endog_std</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                                    <span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">endog_std</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">news_results</span>

    <span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">endog</span><span class="p">,</span> <span class="n">endog_quarterly</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">refit</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fit_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="n">copy_initialization</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">retain_standardization</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
               <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Recreate the results object with new data appended to original data.</span>

<span class="sd">        Creates a new result object applied to a dataset that is created by</span>
<span class="sd">        appending new data to the end of the model's original data. The new</span>
<span class="sd">        results can then be used for analysis or forecasting.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        endog : array_like</span>
<span class="sd">            New observations from the modeled time-series process.</span>
<span class="sd">        endog_quarterly : array_like, optional</span>
<span class="sd">            New observations of quarterly variables. If provided, must be a</span>
<span class="sd">            Pandas Series or DataFrame with a DatetimeIndex or PeriodIndex at</span>
<span class="sd">            the quarterly frequency.</span>
<span class="sd">        refit : bool, optional</span>
<span class="sd">            Whether to re-fit the parameters, based on the combined dataset.</span>
<span class="sd">            Default is False (so parameters from the current results object</span>
<span class="sd">            are used to create the new results object).</span>
<span class="sd">        fit_kwargs : dict, optional</span>
<span class="sd">            Keyword arguments to pass to `fit` (if `refit=True`) or `filter` /</span>
<span class="sd">            `smooth`.</span>
<span class="sd">        copy_initialization : bool, optional</span>
<span class="sd">            Whether or not to copy the initialization from the current results</span>
<span class="sd">            set to the new model. Default is True.</span>
<span class="sd">        retain_standardization : bool, optional</span>
<span class="sd">            Whether or not to use the mean and standard deviations that were</span>
<span class="sd">            used to standardize the data in the current model in the new model.</span>
<span class="sd">            Default is True.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Keyword arguments may be used to modify model specification</span>
<span class="sd">            arguments when created the new model object.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        results</span>
<span class="sd">            Updated Results object, that includes results from both the</span>
<span class="sd">            original dataset and the new dataset.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The `endog` and `exog` arguments to this method must be formatted in</span>
<span class="sd">        the same way (e.g. Pandas Series versus Numpy array) as were the</span>
<span class="sd">        `endog` and `exog` arrays passed to the original model.</span>

<span class="sd">        The `endog` (and, if applicable, `endog_quarterly`) arguments to this</span>
<span class="sd">        method should consist of new observations that occurred directly after</span>
<span class="sd">        the last element of `endog`. For any other kind of dataset, see the</span>
<span class="sd">        `apply` method.</span>

<span class="sd">        This method will apply filtering to all of the original data as well</span>
<span class="sd">        as to the new data. To apply filtering only to the new data (which</span>
<span class="sd">        can be much faster if the original dataset is large), see the `extend`</span>
<span class="sd">        method.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        extend</span>
<span class="sd">        apply</span>
<span class="sd">        """</span>
        <span class="c1"># Construct the combined dataset, if necessary</span>
        <span class="n">endog</span><span class="p">,</span> <span class="n">k_endog_monthly</span> <span class="o">=</span> <span class="n">DynamicFactorMQ</span><span class="o">.</span><span class="n">construct_endog</span><span class="p">(</span>
            <span class="n">endog</span><span class="p">,</span> <span class="n">endog_quarterly</span><span class="p">)</span>

        <span class="c1"># Check for compatible dimensions</span>
        <span class="n">k_endog</span> <span class="o">=</span> <span class="n">endog</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">endog</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="k">else</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">k_endog_monthly</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">k_endog_M</span> <span class="ow">or</span>
                <span class="n">k_endog</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">k_endog</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'Cannot append data of a different dimension to'</span>
                             <span class="s1">' a model.'</span><span class="p">)</span>

        <span class="n">kwargs</span><span class="p">[</span><span class="s1">'k_endog_monthly'</span><span class="p">]</span> <span class="o">=</span> <span class="n">k_endog_monthly</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="n">endog</span><span class="p">,</span> <span class="n">refit</span><span class="o">=</span><span class="n">refit</span><span class="p">,</span> <span class="n">fit_kwargs</span><span class="o">=</span><span class="n">fit_kwargs</span><span class="p">,</span>
            <span class="n">copy_initialization</span><span class="o">=</span><span class="n">copy_initialization</span><span class="p">,</span>
            <span class="n">retain_standardization</span><span class="o">=</span><span class="n">retain_standardization</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">extend</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">endog</span><span class="p">,</span> <span class="n">endog_quarterly</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fit_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="n">retain_standardization</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Recreate the results object for new data that extends original data.</span>

<span class="sd">        Creates a new result object applied to a new dataset that is assumed to</span>
<span class="sd">        follow directly from the end of the model's original data. The new</span>
<span class="sd">        results can then be used for analysis or forecasting.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        endog : array_like</span>
<span class="sd">            New observations from the modeled time-series process.</span>
<span class="sd">        endog_quarterly : array_like, optional</span>
<span class="sd">            New observations of quarterly variables. If provided, must be a</span>
<span class="sd">            Pandas Series or DataFrame with a DatetimeIndex or PeriodIndex at</span>
<span class="sd">            the quarterly frequency.</span>
<span class="sd">        fit_kwargs : dict, optional</span>
<span class="sd">            Keyword arguments to pass to `filter` or `smooth`.</span>
<span class="sd">        retain_standardization : bool, optional</span>
<span class="sd">            Whether or not to use the mean and standard deviations that were</span>
<span class="sd">            used to standardize the data in the current model in the new model.</span>
<span class="sd">            Default is True.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Keyword arguments may be used to modify model specification</span>
<span class="sd">            arguments when created the new model object.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        results</span>
<span class="sd">            Updated Results object, that includes results only for the new</span>
<span class="sd">            dataset.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        append</span>
<span class="sd">        apply</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The `endog` argument to this method should consist of new observations</span>
<span class="sd">        that occurred directly after the last element of the model's original</span>
<span class="sd">        `endog` array. For any other kind of dataset, see the `apply` method.</span>

<span class="sd">        This method will apply filtering only to the new data provided by the</span>
<span class="sd">        `endog` argument, which can be much faster than re-filtering the entire</span>
<span class="sd">        dataset. However, the returned results object will only have results</span>
<span class="sd">        for the new data. To retrieve results for both the new data and the</span>
<span class="sd">        original data, see the `append` method.</span>
<span class="sd">        """</span>
        <span class="c1"># Construct the combined dataset, if necessary</span>
        <span class="n">endog</span><span class="p">,</span> <span class="n">k_endog_monthly</span> <span class="o">=</span> <span class="n">DynamicFactorMQ</span><span class="o">.</span><span class="n">construct_endog</span><span class="p">(</span>
            <span class="n">endog</span><span class="p">,</span> <span class="n">endog_quarterly</span><span class="p">)</span>

        <span class="c1"># Check for compatible dimensions</span>
        <span class="n">k_endog</span> <span class="o">=</span> <span class="n">endog</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">endog</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="k">else</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">k_endog_monthly</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">k_endog_M</span> <span class="ow">or</span>
                <span class="n">k_endog</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">k_endog</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'Cannot append data of a different dimension to'</span>
                             <span class="s1">' a model.'</span><span class="p">)</span>

        <span class="n">kwargs</span><span class="p">[</span><span class="s1">'k_endog_monthly'</span><span class="p">]</span> <span class="o">=</span> <span class="n">k_endog_monthly</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
            <span class="n">endog</span><span class="p">,</span> <span class="n">fit_kwargs</span><span class="o">=</span><span class="n">fit_kwargs</span><span class="p">,</span>
            <span class="n">retain_standardization</span><span class="o">=</span><span class="n">retain_standardization</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">endog</span><span class="p">,</span> <span class="n">k_endog_monthly</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">endog_quarterly</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
              <span class="n">refit</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fit_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">copy_initialization</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
              <span class="n">retain_standardization</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Apply the fitted parameters to new data unrelated to the original data.</span>

<span class="sd">        Creates a new result object using the current fitted parameters,</span>
<span class="sd">        applied to a completely new dataset that is assumed to be unrelated to</span>
<span class="sd">        the model's original data. The new results can then be used for</span>
<span class="sd">        analysis or forecasting.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        endog : array_like</span>
<span class="sd">            New observations from the modeled time-series process.</span>
<span class="sd">        k_endog_monthly : int, optional</span>
<span class="sd">            If specifying a monthly/quarterly mixed frequency model in which</span>
<span class="sd">            the provided `endog` dataset contains both the monthly and</span>
<span class="sd">            quarterly data, this variable should be used to indicate how many</span>
<span class="sd">            of the variables are monthly.</span>
<span class="sd">        endog_quarterly : array_like, optional</span>
<span class="sd">            New observations of quarterly variables. If provided, must be a</span>
<span class="sd">            Pandas Series or DataFrame with a DatetimeIndex or PeriodIndex at</span>
<span class="sd">            the quarterly frequency.</span>
<span class="sd">        refit : bool, optional</span>
<span class="sd">            Whether to re-fit the parameters, using the new dataset.</span>
<span class="sd">            Default is False (so parameters from the current results object</span>
<span class="sd">            are used to create the new results object).</span>
<span class="sd">        fit_kwargs : dict, optional</span>
<span class="sd">            Keyword arguments to pass to `fit` (if `refit=True`) or `filter` /</span>
<span class="sd">            `smooth`.</span>
<span class="sd">        copy_initialization : bool, optional</span>
<span class="sd">            Whether or not to copy the initialization from the current results</span>
<span class="sd">            set to the new model. Default is False.</span>
<span class="sd">        retain_standardization : bool, optional</span>
<span class="sd">            Whether or not to use the mean and standard deviations that were</span>
<span class="sd">            used to standardize the data in the current model in the new model.</span>
<span class="sd">            Default is True.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Keyword arguments may be used to modify model specification</span>
<span class="sd">            arguments when created the new model object.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        results</span>
<span class="sd">            Updated Results object, that includes results only for the new</span>
<span class="sd">            dataset.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        statsmodels.tsa.statespace.mlemodel.MLEResults.append</span>
<span class="sd">        statsmodels.tsa.statespace.mlemodel.MLEResults.apply</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The `endog` argument to this method should consist of new observations</span>
<span class="sd">        that are not necessarily related to the original model's `endog`</span>
<span class="sd">        dataset. For observations that continue that original dataset by follow</span>
<span class="sd">        directly after its last element, see the `append` and `extend` methods.</span>
<span class="sd">        """</span>
        <span class="n">mod</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">endog</span><span class="p">,</span> <span class="n">k_endog_monthly</span><span class="o">=</span><span class="n">k_endog_monthly</span><span class="p">,</span>
                               <span class="n">endog_quarterly</span><span class="o">=</span><span class="n">endog_quarterly</span><span class="p">,</span>
                               <span class="n">retain_standardization</span><span class="o">=</span><span class="n">retain_standardization</span><span class="p">,</span>
                               <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">copy_initialization</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_results</span>
            <span class="n">init</span> <span class="o">=</span> <span class="n">initialization</span><span class="o">.</span><span class="n">Initialization</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">k_states</span><span class="p">,</span> <span class="s1">'known'</span><span class="p">,</span> <span class="n">constant</span><span class="o">=</span><span class="n">res</span><span class="o">.</span><span class="n">initial_state</span><span class="p">,</span>
                <span class="n">stationary_cov</span><span class="o">=</span><span class="n">res</span><span class="o">.</span><span class="n">initial_state_cov</span><span class="p">)</span>
            <span class="n">mod</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">initialization</span> <span class="o">=</span> <span class="n">init</span>

        <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">refit</span><span class="o">=</span><span class="n">refit</span><span class="p">,</span> <span class="n">fit_kwargs</span><span class="o">=</span><span class="n">fit_kwargs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">res</span>

    <span class="k">def</span> <span class="nf">summary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=.</span><span class="mi">05</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">model_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">display_params</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">display_diagnostics</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">display_params_as_list</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">truncate_endog_names</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">display_max_endog</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Summarize the Model.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        alpha : float, optional</span>
<span class="sd">            Significance level for the confidence intervals. Default is 0.05.</span>
<span class="sd">        start : int, optional</span>
<span class="sd">            Integer of the start observation. Default is 0.</span>
<span class="sd">        title : str, optional</span>
<span class="sd">            The title used for the summary table.</span>
<span class="sd">        model_name : str, optional</span>
<span class="sd">            The name of the model used. Default is to use model class name.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        summary : Summary instance</span>
<span class="sd">            This holds the summary table and text, which can be printed or</span>
<span class="sd">            converted to various output formats.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        statsmodels.iolib.summary.Summary</span>
<span class="sd">        """</span>
        <span class="n">mod</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span>

        <span class="c1"># Default title / model name</span>
        <span class="k">if</span> <span class="n">title</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">title</span> <span class="o">=</span> <span class="s1">'Dynamic Factor Results'</span>
        <span class="k">if</span> <span class="n">model_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">model_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">_model_name</span>

        <span class="c1"># Get endog names</span>
        <span class="n">endog_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">_get_endog_names</span><span class="p">(</span>
            <span class="n">truncate</span><span class="o">=</span><span class="n">truncate_endog_names</span><span class="p">)</span>

        <span class="c1"># Get extra elements for top summary table</span>
        <span class="n">extra_top_left</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">extra_top_right</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">mle_retvals</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">'mle_retvals'</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">mle_settings</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">'mle_settings'</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mle_settings</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">mle_settings</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s1">'em'</span><span class="p">:</span>
            <span class="n">extra_top_right</span> <span class="o">+=</span> <span class="p">[(</span><span class="s1">'EM Iterations'</span><span class="p">,</span> <span class="p">[</span><span class="sa">f</span><span class="s1">'</span><span class="si">{</span><span class="n">mle_retvals</span><span class="o">.</span><span class="n">iter</span><span class="si">}</span><span class="s1">'</span><span class="p">])]</span>

        <span class="c1"># Get the basic summary tables</span>
        <span class="n">summary</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">summary</span><span class="p">(</span>
            <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="n">start</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">,</span> <span class="n">model_name</span><span class="o">=</span><span class="n">model_name</span><span class="p">,</span>
            <span class="n">display_params</span><span class="o">=</span><span class="p">(</span><span class="n">display_params</span> <span class="ow">and</span> <span class="n">display_params_as_list</span><span class="p">),</span>
            <span class="n">display_diagnostics</span><span class="o">=</span><span class="n">display_diagnostics</span><span class="p">,</span>
            <span class="n">truncate_endog_names</span><span class="o">=</span><span class="n">truncate_endog_names</span><span class="p">,</span>
            <span class="n">display_max_endog</span><span class="o">=</span><span class="n">display_max_endog</span><span class="p">,</span>
            <span class="n">extra_top_left</span><span class="o">=</span><span class="n">extra_top_left</span><span class="p">,</span> <span class="n">extra_top_right</span><span class="o">=</span><span class="n">extra_top_right</span><span class="p">)</span>

        <span class="c1"># Get tables of parameters</span>
        <span class="n">table_ix</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">display_params_as_list</span><span class="p">:</span>

            <span class="c1"># Observation equation table</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">filter_results</span><span class="o">.</span><span class="n">design</span><span class="p">[:,</span> <span class="n">mod</span><span class="o">.</span><span class="n">_s</span><span class="p">[</span><span class="s1">'factors_L1'</span><span class="p">],</span> <span class="mi">0</span><span class="p">],</span>
                <span class="n">index</span><span class="o">=</span><span class="n">endog_names</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">mod</span><span class="o">.</span><span class="n">factor_names</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">applymap</span><span class="p">(</span><span class="k">lambda</span> <span class="n">s</span><span class="p">:</span> <span class="s1">'</span><span class="si">%.2f</span><span class="s1">'</span> <span class="o">%</span> <span class="n">s</span><span class="p">)</span>

            <span class="c1"># Idiosyncratic terms</span>
            <span class="c1"># data['   '] = '   '</span>
            <span class="n">k_idio</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">mod</span><span class="o">.</span><span class="n">idiosyncratic_ar1</span><span class="p">:</span>
                <span class="n">data</span><span class="p">[</span><span class="s1">'   idiosyncratic: AR(1)'</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="n">mod</span><span class="o">.</span><span class="n">_p</span><span class="p">[</span><span class="s1">'idiosyncratic_ar1'</span><span class="p">]])</span>
                <span class="n">k_idio</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">data</span><span class="p">[</span><span class="s1">'var.'</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="n">mod</span><span class="o">.</span><span class="n">_p</span><span class="p">[</span><span class="s1">'idiosyncratic_var'</span><span class="p">]]</span>
            <span class="n">data</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="o">-</span><span class="n">k_idio</span><span class="p">:]</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="o">-</span><span class="n">k_idio</span><span class="p">:]</span><span class="o">.</span><span class="n">applymap</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">s</span><span class="p">:</span> <span class="s1">'</span><span class="si">%.2f</span><span class="s1">'</span> <span class="o">%</span> <span class="n">s</span><span class="p">)</span>

            <span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">'Factor loadings:'</span>

            <span class="c1"># Clear entries for non-loading factors</span>
            <span class="n">base_iloc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">mod</span><span class="o">.</span><span class="n">k_factors</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">mod</span><span class="o">.</span><span class="n">k_endog</span><span class="p">):</span>
                <span class="n">iloc</span> <span class="o">=</span> <span class="p">[</span><span class="n">j</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">base_iloc</span>
                        <span class="k">if</span> <span class="n">j</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">mod</span><span class="o">.</span><span class="n">_s</span><span class="o">.</span><span class="n">endog_factor_iloc</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
                <span class="n">data</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">iloc</span><span class="p">]</span> <span class="o">=</span> <span class="s1">'.'</span>

            <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>

            <span class="c1"># Build the table</span>
            <span class="n">params_data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">values</span>
            <span class="n">params_header</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="n">params_stubs</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="n">title</span> <span class="o">=</span> <span class="s1">'Observation equation:'</span>
            <span class="n">table</span> <span class="o">=</span> <span class="n">SimpleTable</span><span class="p">(</span>
                <span class="n">params_data</span><span class="p">,</span> <span class="n">params_header</span><span class="p">,</span> <span class="n">params_stubs</span><span class="p">,</span>
                <span class="n">txt_fmt</span><span class="o">=</span><span class="n">fmt_params</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">)</span>
            <span class="n">summary</span><span class="o">.</span><span class="n">tables</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">table_ix</span><span class="p">,</span> <span class="n">table</span><span class="p">)</span>
            <span class="n">table_ix</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="c1"># Factor transitions</span>
            <span class="n">ix1</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">ix2</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mod</span><span class="o">.</span><span class="n">_s</span><span class="o">.</span><span class="n">factor_blocks</span><span class="p">)):</span>
                <span class="n">block</span> <span class="o">=</span> <span class="n">mod</span><span class="o">.</span><span class="n">_s</span><span class="o">.</span><span class="n">factor_blocks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">ix2</span> <span class="o">+=</span> <span class="n">block</span><span class="o">.</span><span class="n">k_factors</span>

                <span class="n">T</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_results</span><span class="o">.</span><span class="n">transition</span>
                <span class="n">lag_names</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">block</span><span class="o">.</span><span class="n">factor_order</span><span class="p">):</span>
                    <span class="n">lag_names</span> <span class="o">+=</span> <span class="p">[</span><span class="sa">f</span><span class="s1">'L</span><span class="si">{</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="si">}</span><span class="s1">.</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1">'</span>
                                  <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">block</span><span class="o">.</span><span class="n">factor_names</span><span class="p">]</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">T</span><span class="p">[</span><span class="n">block</span><span class="o">.</span><span class="n">factors_L1</span><span class="p">,</span> <span class="n">block</span><span class="o">.</span><span class="n">factors_ar</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                                    <span class="n">index</span><span class="o">=</span><span class="n">block</span><span class="o">.</span><span class="n">factor_names</span><span class="p">,</span>
                                    <span class="n">columns</span><span class="o">=</span><span class="n">lag_names</span><span class="p">)</span>
                <span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">''</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">applymap</span><span class="p">(</span><span class="k">lambda</span> <span class="n">s</span><span class="p">:</span> <span class="s1">'</span><span class="si">%.2f</span><span class="s1">'</span> <span class="o">%</span> <span class="n">s</span><span class="p">)</span>

                <span class="n">Q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_results</span><span class="o">.</span><span class="n">state_cov</span>
                <span class="c1"># data[' '] = ''</span>
                <span class="k">if</span> <span class="n">block</span><span class="o">.</span><span class="n">k_factors</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">data</span><span class="p">[</span><span class="s1">'   error variance'</span><span class="p">]</span> <span class="o">=</span> <span class="n">Q</span><span class="p">[</span><span class="n">ix1</span><span class="p">,</span> <span class="n">ix1</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">data</span><span class="p">[</span><span class="s1">'   error covariance'</span><span class="p">]</span> <span class="o">=</span> <span class="n">block</span><span class="o">.</span><span class="n">factor_names</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">block</span><span class="o">.</span><span class="n">k_factors</span><span class="p">):</span>
                        <span class="n">data</span><span class="p">[</span><span class="n">block</span><span class="o">.</span><span class="n">factor_names</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="o">=</span> <span class="n">Q</span><span class="p">[</span><span class="n">ix1</span><span class="p">:</span><span class="n">ix2</span><span class="p">,</span> <span class="n">ix1</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span>
                <span class="n">data</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="o">-</span><span class="n">block</span><span class="o">.</span><span class="n">k_factors</span><span class="p">:]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">data</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="o">-</span><span class="n">block</span><span class="o">.</span><span class="n">k_factors</span><span class="p">:]</span><span class="o">.</span><span class="n">applymap</span><span class="p">(</span>
                        <span class="k">lambda</span> <span class="n">s</span><span class="p">:</span> <span class="s1">'</span><span class="si">%.2f</span><span class="s1">'</span> <span class="o">%</span> <span class="n">s</span><span class="p">))</span>

                <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>

                <span class="n">params_data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">values</span>
                <span class="n">params_header</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                <span class="n">params_stubs</span> <span class="o">=</span> <span class="kc">None</span>

                <span class="n">title</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">'Transition: Factor block </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">'</span>
                <span class="n">table</span> <span class="o">=</span> <span class="n">SimpleTable</span><span class="p">(</span>
                    <span class="n">params_data</span><span class="p">,</span> <span class="n">params_header</span><span class="p">,</span> <span class="n">params_stubs</span><span class="p">,</span>
                    <span class="n">txt_fmt</span><span class="o">=</span><span class="n">fmt_params</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">)</span>
                <span class="n">summary</span><span class="o">.</span><span class="n">tables</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">table_ix</span><span class="p">,</span> <span class="n">table</span><span class="p">)</span>
                <span class="n">table_ix</span> <span class="o">+=</span> <span class="mi">1</span>

                <span class="n">ix1</span> <span class="o">=</span> <span class="n">ix2</span>

        <span class="k">return</span> <span class="n">summary</span>
</pre></div>

          </article>
        </div>
      </div>
    </main>
  </div>
  <footer class="md-footer">
    <div class="md-footer-nav">
      <nav class="md-footer-nav__inner md-grid">
          
          
        </a>
        
      </nav>
    </div>
    <div class="md-footer-meta md-typeset">
      <div class="md-footer-meta__inner md-grid">
        <div class="md-footer-copyright">
          <div class="md-footer-copyright__highlight">
              &#169; Copyright 2009-2019, Josef Perktold, Skipper Seabold, Jonathan Taylor, statsmodels-developers.
              
          </div>
            Last updated on
              Feb 02, 2021.
            <br/>
            Created using
            <a href="http://www.sphinx-doc.org/">Sphinx</a> 3.4.3.
             and
            <a href="https://github.com/bashtage/sphinx-material/">Material for
              Sphinx</a>
        </div>
      </div>
    </div>
  </footer>
  <script src="../../../../_static/javascripts/application.js"></script>
  <script>app.initialize({version: "1.0.4", url: {base: ".."}})</script>
  </body>
</html>