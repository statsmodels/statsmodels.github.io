

<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <meta name="lang:clipboard.copy" content="Copy to clipboard">
  <meta name="lang:clipboard.copied" content="Copied to clipboard">
  <meta name="lang:search.language" content="en">
  <meta name="lang:search.pipeline.stopwords" content="True">
  <meta name="lang:search.pipeline.trimmer" content="True">
  <meta name="lang:search.result.none" content="No matching documents">
  <meta name="lang:search.result.one" content="1 matching document">
  <meta name="lang:search.result.other" content="# matching documents">
  <meta name="lang:search.tokenizer" content="[\s\-]+">

  
    <link href="https://fonts.gstatic.com/" rel="preconnect" crossorigin>
    <link href="https://fonts.googleapis.com/css?family=Roboto+Mono:400,500,700|Roboto:300,400,400i,700&display=fallback" rel="stylesheet">

    <style>
      body,
      input {
        font-family: "Roboto", "Helvetica Neue", Helvetica, Arial, sans-serif
      }

      code,
      kbd,
      pre {
        font-family: "Roboto Mono", "Courier New", Courier, monospace
      }
    </style>
  

  <link rel="stylesheet" href="../../../_static/stylesheets/application.css"/>
  <link rel="stylesheet" href="../../../_static/stylesheets/application-palette.css"/>
  <link rel="stylesheet" href="../../../_static/stylesheets/application-fixes.css"/>
  
  <link rel="stylesheet" href="../../../_static/fonts/material-icons.css"/>
  
  <meta name="theme-color" content="#3f51b5">
  <script src="../../../_static/javascripts/modernizr.js"></script>
  
  
  
    <title>statsmodels.discrete.discrete_model &#8212; statsmodels</title>
  <link rel="icon" type="image/png" sizes="32x32" href="../../../_static/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="../../../_static/icons/favicon-16x16.png">
  <link rel="manifest" href="../../../_static/icons/site.webmanifest">
  <link rel="mask-icon" href="../../../_static/icons/safari-pinned-tab.svg" color="#919191">
  <meta name="msapplication-TileColor" content="#2b5797">
  <meta name="msapplication-config" content="../../../_static/icons/browserconfig.xml">
  <link rel="stylesheet" href="../../../_static/stylesheets/examples.css">
  <link rel="stylesheet" href="../../../_static/stylesheets/deprecation.css">
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/material.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css" />
    <script id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
    <link rel="shortcut icon" href="../../../_static/favicon.ico"/>
    <link rel="author" title="About these documents" href="../../../about.html" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
  
   

  </head>
  <body dir=ltr
        data-md-color-primary=indigo data-md-color-accent=blue>
  
  <svg class="md-svg">
    <defs data-children-count="0">
      
      <svg xmlns="http://www.w3.org/2000/svg" width="416" height="448" viewBox="0 0 416 448" id="__github"><path fill="currentColor" d="M160 304q0 10-3.125 20.5t-10.75 19T128 352t-18.125-8.5-10.75-19T96 304t3.125-20.5 10.75-19T128 256t18.125 8.5 10.75 19T160 304zm160 0q0 10-3.125 20.5t-10.75 19T288 352t-18.125-8.5-10.75-19T256 304t3.125-20.5 10.75-19T288 256t18.125 8.5 10.75 19T320 304zm40 0q0-30-17.25-51T296 232q-10.25 0-48.75 5.25Q229.5 240 208 240t-39.25-2.75Q130.75 232 120 232q-29.5 0-46.75 21T56 304q0 22 8 38.375t20.25 25.75 30.5 15 35 7.375 37.25 1.75h42q20.5 0 37.25-1.75t35-7.375 30.5-15 20.25-25.75T360 304zm56-44q0 51.75-15.25 82.75-9.5 19.25-26.375 33.25t-35.25 21.5-42.5 11.875-42.875 5.5T212 416q-19.5 0-35.5-.75t-36.875-3.125-38.125-7.5-34.25-12.875T37 371.5t-21.5-28.75Q0 312 0 260q0-59.25 34-99-6.75-20.5-6.75-42.5 0-29 12.75-54.5 27 0 47.5 9.875t47.25 30.875Q171.5 96 212 96q37 0 70 8 26.25-20.5 46.75-30.25T376 64q12.75 25.5 12.75 54.5 0 21.75-6.75 42 34 40 34 99.5z"/></svg>
      
    </defs>
  </svg>
  
  <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer">
  <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search">
  <label class="md-overlay" data-md-component="overlay" for="__drawer"></label>
  <a href="#_modules/statsmodels/discrete/discrete_model" tabindex="1" class="md-skip"> Skip to content </a>
  <header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid">
    <div class="md-flex navheader">
      <div class="md-flex__cell md-flex__cell--shrink">
        <a href="../../../index.html" title="statsmodels"
           class="md-header-nav__button md-logo">
          
              <img src="../../../_static/statsmodels-logo-v2-bw.svg" height="26"
                   alt="statsmodels logo">
          
        </a>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        <label class="md-icon md-icon--menu md-header-nav__button" for="__drawer"></label>
      </div>
      <div class="md-flex__cell md-flex__cell--stretch">
        <div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
          <span class="md-header-nav__topic">statsmodels v0.12.2</span>
          <span class="md-header-nav__topic"> statsmodels.discrete.discrete_model </span>
        </div>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        <label class="md-icon md-icon--search md-header-nav__button" for="__search"></label>
        
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" action="../../../search.html" method="GET" name="search">
      <input type="text" class="md-search__input" name="q" placeholder="Search"
             autocapitalize="off" autocomplete="off" spellcheck="false"
             data-md-component="query" data-md-state="active">
      <label class="md-icon md-search__icon" for="__search"></label>
      <button type="reset" class="md-icon md-search__icon" data-md-component="reset" tabindex="-1">
        &#xE5CD;
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="result">
          <div class="md-search-result__meta">
            Type to start searching
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>

      </div>
      
        <div class="md-flex__cell md-flex__cell--shrink">
          <div class="md-header-nav__source">
            <a href="https://github.com/statsmodels/statsmodels" title="Go to repository" class="md-source" data-md-source="github">

    <div class="md-source__icon">
      <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24" width="28" height="28">
        <use xlink:href="#__github" width="24" height="24"></use>
      </svg>
    </div>
  
  <div class="md-source__repository">
    statsmodels
  </div>
</a>
          </div>
        </div>
      
      
  
  <script src="../../../_static/javascripts/version_dropdown.js"></script>
  <script>
    var json_loc = "../../../_static/versions.json",
        target_loc = "../../../../",
        text = "Versions";
    $( document ).ready( add_version_dropdown(json_loc, target_loc, text));
  </script>
  

    </div>
  </nav>
</header>

  
  <div class="md-container">
    
    
    
  <nav class="md-tabs" data-md-component="tabs">
    <div class="md-tabs__inner md-grid">
      <ul class="md-tabs__list">
          <li class="md-tabs__item"><a href="../../index.html" class="md-tabs__link">Module code</a></li>
      </ul>
    </div>
  </nav>
    <main class="md-main">
      <div class="md-main__inner md-grid" data-md-component="container">
        
          <div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
            <div class="md-sidebar__scrollwrap">
              <div class="md-sidebar__inner">
                <nav class="md-nav md-nav--primary" data-md-level="0">
  <label class="md-nav__title md-nav__title--site" for="__drawer">
    <a href="../../../index.html" title="statsmodels" class="md-nav__button md-logo">
      
        <img src="../../../_static/statsmodels-logo-v2-bw.svg" alt=" logo" width="48" height="48">
      
    </a>
    <a href="../../../index.html"
       title="statsmodels">statsmodels v0.12.2</a>
  </label>
    <div class="md-nav__source">
      <a href="https://github.com/statsmodels/statsmodels" title="Go to repository" class="md-source" data-md-source="github">

    <div class="md-source__icon">
      <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24" width="28" height="28">
        <use xlink:href="#__github" width="24" height="24"></use>
      </svg>
    </div>
  
  <div class="md-source__repository">
    statsmodels
  </div>
</a>
    </div>
  
  

  
  <ul class="md-nav__list">
    <li class="md-nav__item">
    
    
      <a href="../../../install.html" class="md-nav__link">Installing statsmodels</a>
      
    
    </li>
    <li class="md-nav__item">
    
    
      <a href="../../../gettingstarted.html" class="md-nav__link">Getting started</a>
      
    
    </li>
    <li class="md-nav__item">
    
    
      <a href="../../../user-guide.html" class="md-nav__link">User Guide</a>
      
    
    </li>
    <li class="md-nav__item">
    
    
      <a href="../../../examples/index.html" class="md-nav__link">Examples</a>
      
    
    </li>
    <li class="md-nav__item">
    
    
      <a href="../../../api.html" class="md-nav__link">API Reference</a>
      
    
    </li>
    <li class="md-nav__item">
    
    
      <a href="../../../about.html" class="md-nav__link">About statsmodels</a>
      
    
    </li>
    <li class="md-nav__item">
    
    
      <a href="../../../dev/index.html" class="md-nav__link">Developer Page</a>
      
    
    </li>
    <li class="md-nav__item">
    
    
      <a href="../../../release/index.html" class="md-nav__link">Release Notes</a>
      
    
    </li>
  </ul>
  

</nav>
              </div>
            </div>
          </div>
          <div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
            <div class="md-sidebar__scrollwrap">
              <div class="md-sidebar__inner">
                
<nav class="md-nav md-nav--secondary">
  <ul class="md-nav__list" data-md-scrollfix="">
    

<li id="searchbox" class="md-nav__item"></li>

  </ul>
</nav>
              </div>
            </div>
          </div>
        
        <div class="md-content">
          <article class="md-content__inner md-typeset" role="main">
            
  <h1 id="modules-statsmodels-discrete-discrete-model--page-root">Source code for statsmodels.discrete.discrete_model</h1><div class="highlight"><pre>
<span></span><span class="sd">"""</span>
<span class="sd">Limited dependent variable and qualitative variables.</span>

<span class="sd">Includes binary outcomes, count data, (ordered) ordinal data and limited</span>
<span class="sd">dependent variables.</span>

<span class="sd">General References</span>
<span class="sd">--------------------</span>

<span class="sd">A.C. Cameron and P.K. Trivedi.  `Regression Analysis of Count Data`.</span>
<span class="sd">    Cambridge, 1998</span>

<span class="sd">G.S. Madalla. `Limited-Dependent and Qualitative Variables in Econometrics`.</span>
<span class="sd">    Cambridge, 1983.</span>

<span class="sd">W. Greene. `Econometric Analysis`. Prentice Hall, 5th. edition. 2003.</span>
<span class="sd">"""</span>
<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">"Poisson"</span><span class="p">,</span> <span class="s2">"Logit"</span><span class="p">,</span> <span class="s2">"Probit"</span><span class="p">,</span> <span class="s2">"MNLogit"</span><span class="p">,</span> <span class="s2">"NegativeBinomial"</span><span class="p">,</span>
           <span class="s2">"GeneralizedPoisson"</span><span class="p">,</span> <span class="s2">"NegativeBinomialP"</span><span class="p">,</span> <span class="s2">"CountModel"</span><span class="p">]</span>

<span class="kn">from</span> <span class="nn">statsmodels.compat.pandas</span> <span class="kn">import</span> <span class="n">Appender</span>

<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">pandas</span> <span class="kn">import</span> <span class="n">MultiIndex</span><span class="p">,</span> <span class="n">get_dummies</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">special</span><span class="p">,</span> <span class="n">stats</span>
<span class="kn">from</span> <span class="nn">scipy.special</span> <span class="kn">import</span> <span class="n">digamma</span><span class="p">,</span> <span class="n">gammaln</span><span class="p">,</span> <span class="n">loggamma</span><span class="p">,</span> <span class="n">polygamma</span>
<span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">nbinom</span>

<span class="kn">from</span> <span class="nn">statsmodels.base.data</span> <span class="kn">import</span> <span class="n">handle_data</span>  <span class="c1"># for mnlogit</span>
<span class="kn">from</span> <span class="nn">statsmodels.base.l1_slsqp</span> <span class="kn">import</span> <span class="n">fit_l1_slsqp</span>
<span class="kn">import</span> <span class="nn">statsmodels.base.model</span> <span class="k">as</span> <span class="nn">base</span>
<span class="kn">import</span> <span class="nn">statsmodels.base.wrapper</span> <span class="k">as</span> <span class="nn">wrap</span>
<span class="kn">from</span> <span class="nn">statsmodels.distributions</span> <span class="kn">import</span> <span class="n">genpoisson_p</span>
<span class="kn">import</span> <span class="nn">statsmodels.regression.linear_model</span> <span class="k">as</span> <span class="nn">lm</span>
<span class="kn">from</span> <span class="nn">statsmodels.tools</span> <span class="kn">import</span> <span class="n">data</span> <span class="k">as</span> <span class="n">data_tools</span><span class="p">,</span> <span class="n">tools</span>
<span class="kn">from</span> <span class="nn">statsmodels.tools.decorators</span> <span class="kn">import</span> <span class="n">cache_readonly</span>
<span class="kn">from</span> <span class="nn">statsmodels.tools.numdiff</span> <span class="kn">import</span> <span class="n">approx_fprime_cs</span>
<span class="kn">from</span> <span class="nn">statsmodels.tools.sm_exceptions</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">PerfectSeparationError</span><span class="p">,</span>
    <span class="n">SpecificationWarning</span><span class="p">,</span>
<span class="p">)</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">cvxopt</span>  <span class="c1"># noqa:F401</span>
    <span class="n">have_cvxopt</span> <span class="o">=</span> <span class="kc">True</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="n">have_cvxopt</span> <span class="o">=</span> <span class="kc">False</span>


<span class="c1"># TODO: When we eventually get user-settable precision, we need to change</span>
<span class="c1">#       this</span>
<span class="n">FLOAT_EPS</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span>

<span class="c1"># TODO: add options for the parameter covariance/variance</span>
<span class="c1">#       ie., OIM, EIM, and BHHH see Green 21.4</span>

<span class="n">_discrete_models_docs</span> <span class="o">=</span> <span class="s2">"""</span>
<span class="s2">"""</span>

<span class="n">_discrete_results_docs</span> <span class="o">=</span> <span class="s2">"""</span>
<span class="s2">    </span><span class="si">%(one_line_description)s</span><span class="s2"></span>

<span class="s2">    Parameters</span>
<span class="s2">    ----------</span>
<span class="s2">    model : A DiscreteModel instance</span>
<span class="s2">    params : array_like</span>
<span class="s2">        The parameters of a fitted model.</span>
<span class="s2">    hessian : array_like</span>
<span class="s2">        The hessian of the fitted model.</span>
<span class="s2">    scale : float</span>
<span class="s2">        A scale parameter for the covariance matrix.</span>

<span class="s2">    Attributes</span>
<span class="s2">    ----------</span>
<span class="s2">    df_resid : float</span>
<span class="s2">        See model definition.</span>
<span class="s2">    df_model : float</span>
<span class="s2">        See model definition.</span>
<span class="s2">    llf : float</span>
<span class="s2">        Value of the loglikelihood</span>
<span class="s2">    </span><span class="si">%(extra_attr)s</span><span class="s2">"""</span>

<span class="n">_l1_results_attr</span> <span class="o">=</span> <span class="s2">"""    nnz_params : int</span>
<span class="s2">        The number of nonzero parameters in the model.  Train with</span>
<span class="s2">        trim_params == True or else numerical error will distort this.</span>
<span class="s2">    trimmed : bool array</span>
<span class="s2">        trimmed[i] == True if the ith parameter was trimmed from the model."""</span>

<span class="n">_get_start_params_null_docs</span> <span class="o">=</span> <span class="s2">"""</span>
<span class="s2">Compute one-step moment estimator for null (constant-only) model</span>

<span class="s2">This is a preliminary estimator used as start_params.</span>

<span class="s2">Returns</span>
<span class="s2">-------</span>
<span class="s2">params : ndarray</span>
<span class="s2">    parameter estimate based one one-step moment matching</span>

<span class="s2">"""</span>

<span class="n">_check_rank_doc</span> <span class="o">=</span> <span class="s2">"""</span>
<span class="s2">    check_rank : bool</span>
<span class="s2">        Check exog rank to determine model degrees of freedom. Default is</span>
<span class="s2">        True. Setting to False reduces model initialization time when</span>
<span class="s2">        exog.shape[1] is large.</span>
<span class="s2">    """</span>


<span class="c1"># helper for MNLogit (will be generally useful later)</span>
<span class="k">def</span> <span class="nf">_numpy_to_dummies</span><span class="p">(</span><span class="n">endog</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">endog</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">endog</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">"S"</span><span class="p">,</span> <span class="s2">"O"</span><span class="p">]:</span>
        <span class="n">endog_dummies</span> <span class="o">=</span> <span class="n">endog</span>
        <span class="n">ynames</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">endog</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">dummies</span> <span class="o">=</span> <span class="n">get_dummies</span><span class="p">(</span><span class="n">endog</span><span class="p">,</span> <span class="n">drop_first</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">ynames</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="n">dummies</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dummies</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])}</span>
        <span class="n">endog_dummies</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">dummies</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">endog_dummies</span><span class="p">,</span> <span class="n">ynames</span>

    <span class="k">return</span> <span class="n">endog_dummies</span><span class="p">,</span> <span class="n">ynames</span>


<span class="k">def</span> <span class="nf">_pandas_to_dummies</span><span class="p">(</span><span class="n">endog</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">endog</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">endog</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">yname</span> <span class="o">=</span> <span class="n">endog</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">endog_dummies</span> <span class="o">=</span> <span class="n">get_dummies</span><span class="p">(</span><span class="n">endog</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># series</span>
            <span class="n">yname</span> <span class="o">=</span> <span class="s1">'y'</span>
            <span class="n">endog_dummies</span> <span class="o">=</span> <span class="n">endog</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">yname</span> <span class="o">=</span> <span class="n">endog</span><span class="o">.</span><span class="n">name</span>
        <span class="n">endog_dummies</span> <span class="o">=</span> <span class="n">get_dummies</span><span class="p">(</span><span class="n">endog</span><span class="p">)</span>
    <span class="n">ynames</span> <span class="o">=</span> <span class="n">endog_dummies</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">endog_dummies</span><span class="p">,</span> <span class="n">ynames</span><span class="p">,</span> <span class="n">yname</span>


<span class="k">def</span> <span class="nf">_validate_l1_method</span><span class="p">(</span><span class="n">method</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    As of 0.10.0, the supported values for `method` in `fit_regularized`</span>
<span class="sd">    are "l1" and "l1_cvxopt_cp".  If an invalid value is passed, raise</span>
<span class="sd">    with a helpful error message</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    method : str</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">    """</span>
    <span class="k">if</span> <span class="n">method</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">'l1'</span><span class="p">,</span> <span class="s1">'l1_cvxopt_cp'</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'`method` = </span><span class="si">{method}</span><span class="s1"> is not supported, use either '</span>
                         <span class="s1">'"l1" or "l1_cvxopt_cp"'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">))</span>


<span class="c1">#### Private Model Classes ####</span>


<span class="k">class</span> <span class="nc">DiscreteModel</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="n">LikelihoodModel</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    Abstract class for discrete choice models.</span>

<span class="sd">    This class does not do anything itself but lays out the methods and</span>
<span class="sd">    call signature expected of child classes in addition to those of</span>
<span class="sd">    statsmodels.model.LikelihoodModel.</span>
<span class="sd">    """</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">endog</span><span class="p">,</span> <span class="n">exog</span><span class="p">,</span> <span class="n">check_rank</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_rank</span> <span class="o">=</span> <span class="n">check_rank</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">endog</span><span class="p">,</span> <span class="n">exog</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">raise_on_perfect_prediction</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Initialize is called by</span>
<span class="sd">        statsmodels.model.LikelihoodModel.__init__</span>
<span class="sd">        and should contain any preprocessing that needs to be done for a model.</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_rank</span><span class="p">:</span>
            <span class="c1"># assumes constant</span>
            <span class="n">rank</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">matrix_rank</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exog</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">"qr"</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># If rank check is skipped, assume full</span>
            <span class="n">rank</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exog</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">df_model</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">rank</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">df_resid</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exog</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">rank</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">cdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        The cumulative distribution function of the model.</span>
<span class="sd">        """</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="k">def</span> <span class="nf">pdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        The probability density (mass) function of the model.</span>
<span class="sd">        """</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="k">def</span> <span class="nf">_check_perfect_pred</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="n">endog</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">endog</span>
        <span class="n">fittedvalues</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exog</span><span class="p">,</span> <span class="n">params</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">exog</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]]))</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">raise_on_perfect_prediction</span> <span class="ow">and</span>
                <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">fittedvalues</span> <span class="o">-</span> <span class="n">endog</span><span class="p">,</span> <span class="mi">0</span><span class="p">)):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">"Perfect separation detected, results not available"</span>
            <span class="k">raise</span> <span class="n">PerfectSeparationError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

    <span class="nd">@Appender</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="n">LikelihoodModel</span><span class="o">.</span><span class="n">fit</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">'newton'</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="mi">35</span><span class="p">,</span>
            <span class="n">full_output</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">disp</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Fit the model using maximum likelihood.</span>

<span class="sd">        The rest of the docstring is from</span>
<span class="sd">        statsmodels.base.model.LikelihoodModel.fit</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="n">callback</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">callback</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_perfect_pred</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">pass</span>  <span class="c1"># TODO: make a function factory to have multiple call-backs</span>

        <span class="n">mlefit</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">start_params</span><span class="o">=</span><span class="n">start_params</span><span class="p">,</span>
                             <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
                             <span class="n">maxiter</span><span class="o">=</span><span class="n">maxiter</span><span class="p">,</span>
                             <span class="n">full_output</span><span class="o">=</span><span class="n">full_output</span><span class="p">,</span>
                             <span class="n">disp</span><span class="o">=</span><span class="n">disp</span><span class="p">,</span>
                             <span class="n">callback</span><span class="o">=</span><span class="n">callback</span><span class="p">,</span>
                             <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">mlefit</span>  <span class="c1"># It is up to subclasses to wrap results</span>

    <span class="k">def</span> <span class="nf">fit_regularized</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">'l1'</span><span class="p">,</span>
                        <span class="n">maxiter</span><span class="o">=</span><span class="s1">'defined_by_method'</span><span class="p">,</span> <span class="n">full_output</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">disp</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                        <span class="n">callback</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">trim_mode</span><span class="o">=</span><span class="s1">'auto'</span><span class="p">,</span>
                        <span class="n">auto_trim_tol</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">size_trim_tol</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">,</span> <span class="n">qc_tol</span><span class="o">=</span><span class="mf">0.03</span><span class="p">,</span>
                        <span class="n">qc_verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Fit the model using a regularized maximum likelihood.</span>

<span class="sd">        The regularization method AND the solver used is determined by the</span>
<span class="sd">        argument method.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        start_params : array_like, optional</span>
<span class="sd">            Initial guess of the solution for the loglikelihood maximization.</span>
<span class="sd">            The default is an array of zeros.</span>
<span class="sd">        method : 'l1' or 'l1_cvxopt_cp'</span>
<span class="sd">            See notes for details.</span>
<span class="sd">        maxiter : {int, 'defined_by_method'}</span>
<span class="sd">            Maximum number of iterations to perform.</span>
<span class="sd">            If 'defined_by_method', then use method defaults (see notes).</span>
<span class="sd">        full_output : bool</span>
<span class="sd">            Set to True to have all available output in the Results object's</span>
<span class="sd">            mle_retvals attribute. The output is dependent on the solver.</span>
<span class="sd">            See LikelihoodModelResults notes section for more information.</span>
<span class="sd">        disp : bool</span>
<span class="sd">            Set to True to print convergence messages.</span>
<span class="sd">        fargs : tuple</span>
<span class="sd">            Extra arguments passed to the likelihood function, i.e.,</span>
<span class="sd">            loglike(x,*args).</span>
<span class="sd">        callback : callable callback(xk)</span>
<span class="sd">            Called after each iteration, as callback(xk), where xk is the</span>
<span class="sd">            current parameter vector.</span>
<span class="sd">        retall : bool</span>
<span class="sd">            Set to True to return list of solutions at each iteration.</span>
<span class="sd">            Available in Results object's mle_retvals attribute.</span>
<span class="sd">        alpha : non-negative scalar or numpy array (same size as parameters)</span>
<span class="sd">            The weight multiplying the l1 penalty term.</span>
<span class="sd">        trim_mode : 'auto, 'size', or 'off'</span>
<span class="sd">            If not 'off', trim (set to zero) parameters that would have been</span>
<span class="sd">            zero if the solver reached the theoretical minimum.</span>
<span class="sd">            If 'auto', trim params using the Theory above.</span>
<span class="sd">            If 'size', trim params if they have very small absolute value.</span>
<span class="sd">        size_trim_tol : float or 'auto' (default = 'auto')</span>
<span class="sd">            Tolerance used when trim_mode == 'size'.</span>
<span class="sd">        auto_trim_tol : float</span>
<span class="sd">            Tolerance used when trim_mode == 'auto'.</span>
<span class="sd">        qc_tol : float</span>
<span class="sd">            Print warning and do not allow auto trim when (ii) (above) is</span>
<span class="sd">            violated by this much.</span>
<span class="sd">        qc_verbose : bool</span>
<span class="sd">            If true, print out a full QC report upon failure.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Additional keyword arguments used when fitting the model.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Results</span>
<span class="sd">            A results instance.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Using 'l1_cvxopt_cp' requires the cvxopt module.</span>

<span class="sd">        Extra parameters are not penalized if alpha is given as a scalar.</span>
<span class="sd">        An example is the shape parameter in NegativeBinomial `nb1` and `nb2`.</span>

<span class="sd">        Optional arguments for the solvers (available in Results.mle_settings)::</span>

<span class="sd">            'l1'</span>
<span class="sd">                acc : float (default 1e-6)</span>
<span class="sd">                    Requested accuracy as used by slsqp</span>
<span class="sd">            'l1_cvxopt_cp'</span>
<span class="sd">                abstol : float</span>
<span class="sd">                    absolute accuracy (default: 1e-7).</span>
<span class="sd">                reltol : float</span>
<span class="sd">                    relative accuracy (default: 1e-6).</span>
<span class="sd">                feastol : float</span>
<span class="sd">                    tolerance for feasibility conditions (default: 1e-7).</span>
<span class="sd">                refinement : int</span>
<span class="sd">                    number of iterative refinement steps when solving KKT</span>
<span class="sd">                    equations (default: 1).</span>

<span class="sd">        Optimization methodology</span>

<span class="sd">        With :math:`L` the negative log likelihood, we solve the convex but</span>
<span class="sd">        non-smooth problem</span>

<span class="sd">        .. math:: \\min_\\beta L(\\beta) + \\sum_k\\alpha_k |\\beta_k|</span>

<span class="sd">        via the transformation to the smooth, convex, constrained problem</span>
<span class="sd">        in twice as many variables (adding the "added variables" :math:`u_k`)</span>

<span class="sd">        .. math:: \\min_{\\beta,u} L(\\beta) + \\sum_k\\alpha_k u_k,</span>

<span class="sd">        subject to</span>

<span class="sd">        .. math:: -u_k \\leq \\beta_k \\leq u_k.</span>

<span class="sd">        With :math:`\\partial_k L` the derivative of :math:`L` in the</span>
<span class="sd">        :math:`k^{th}` parameter direction, theory dictates that, at the</span>
<span class="sd">        minimum, exactly one of two conditions holds:</span>

<span class="sd">        (i) :math:`|\\partial_k L| = \\alpha_k`  and  :math:`\\beta_k \\neq 0`</span>
<span class="sd">        (ii) :math:`|\\partial_k L| \\leq \\alpha_k`  and  :math:`\\beta_k = 0`</span>
<span class="sd">        """</span>
        <span class="n">_validate_l1_method</span><span class="p">(</span><span class="n">method</span><span class="p">)</span>
        <span class="c1"># Set attributes based on method</span>
        <span class="n">cov_params_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cov_params_func_l1</span>

        <span class="c1">### Bundle up extra kwargs for the dictionary kwargs.  These are</span>
        <span class="c1">### passed through super(...).fit() as kwargs and unpacked at</span>
        <span class="c1">### appropriate times</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">alpha</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="mi">0</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">'alpha'</span><span class="p">]</span> <span class="o">=</span> <span class="n">alpha</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="n">kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">'alpha_rescaled'</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">'alpha'</span><span class="p">]</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endog</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">'trim_mode'</span><span class="p">]</span> <span class="o">=</span> <span class="n">trim_mode</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">'size_trim_tol'</span><span class="p">]</span> <span class="o">=</span> <span class="n">size_trim_tol</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">'auto_trim_tol'</span><span class="p">]</span> <span class="o">=</span> <span class="n">auto_trim_tol</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">'qc_tol'</span><span class="p">]</span> <span class="o">=</span> <span class="n">qc_tol</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">'qc_verbose'</span><span class="p">]</span> <span class="o">=</span> <span class="n">qc_verbose</span>

        <span class="c1">### Define default keyword arguments to be passed to super(...).fit()</span>
        <span class="k">if</span> <span class="n">maxiter</span> <span class="o">==</span> <span class="s1">'defined_by_method'</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">'l1'</span><span class="p">:</span>
                <span class="n">maxiter</span> <span class="o">=</span> <span class="mi">1000</span>
            <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">'l1_cvxopt_cp'</span><span class="p">:</span>
                <span class="n">maxiter</span> <span class="o">=</span> <span class="mi">70</span>

        <span class="c1">## Parameters to pass to super(...).fit()</span>
        <span class="c1"># For the 'extra' parameters, pass all that are available,</span>
        <span class="c1"># even if we know (at this point) we will only use one.</span>
        <span class="n">extra_fit_funcs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">'l1'</span><span class="p">:</span> <span class="n">fit_l1_slsqp</span><span class="p">}</span>
        <span class="k">if</span> <span class="n">have_cvxopt</span> <span class="ow">and</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">'l1_cvxopt_cp'</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">statsmodels.base.l1_cvxopt</span> <span class="kn">import</span> <span class="n">fit_l1_cvxopt_cp</span>
            <span class="n">extra_fit_funcs</span><span class="p">[</span><span class="s1">'l1_cvxopt_cp'</span><span class="p">]</span> <span class="o">=</span> <span class="n">fit_l1_cvxopt_cp</span>
        <span class="k">elif</span> <span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">'l1_cvxopt_cp'</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"Cannot use l1_cvxopt_cp as cvxopt "</span>
                             <span class="s2">"was not found (install it, or use method='l1' instead)"</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">callback</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">callback</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_perfect_pred</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">pass</span>  <span class="c1"># make a function factory to have multiple call-backs</span>

        <span class="n">mlefit</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">start_params</span><span class="o">=</span><span class="n">start_params</span><span class="p">,</span>
                             <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
                             <span class="n">maxiter</span><span class="o">=</span><span class="n">maxiter</span><span class="p">,</span>
                             <span class="n">full_output</span><span class="o">=</span><span class="n">full_output</span><span class="p">,</span>
                             <span class="n">disp</span><span class="o">=</span><span class="n">disp</span><span class="p">,</span>
                             <span class="n">callback</span><span class="o">=</span><span class="n">callback</span><span class="p">,</span>
                             <span class="n">extra_fit_funcs</span><span class="o">=</span><span class="n">extra_fit_funcs</span><span class="p">,</span>
                             <span class="n">cov_params_func</span><span class="o">=</span><span class="n">cov_params_func</span><span class="p">,</span>
                             <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">mlefit</span>  <span class="c1"># up to subclasses to wrap results</span>

    <span class="k">def</span> <span class="nf">cov_params_func_l1</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">likelihood_model</span><span class="p">,</span> <span class="n">xopt</span><span class="p">,</span> <span class="n">retvals</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Computes cov_params on a reduced parameter space</span>
<span class="sd">        corresponding to the nonzero parameters resulting from the</span>
<span class="sd">        l1 regularized fit.</span>

<span class="sd">        Returns a full cov_params matrix, with entries corresponding</span>
<span class="sd">        to zero'd values set to np.nan.</span>
<span class="sd">        """</span>
        <span class="n">H</span> <span class="o">=</span> <span class="n">likelihood_model</span><span class="o">.</span><span class="n">hessian</span><span class="p">(</span><span class="n">xopt</span><span class="p">)</span>
        <span class="n">trimmed</span> <span class="o">=</span> <span class="n">retvals</span><span class="p">[</span><span class="s1">'trimmed'</span><span class="p">]</span>
        <span class="n">nz_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="o">~</span><span class="n">trimmed</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">nnz_params</span> <span class="o">=</span> <span class="p">(</span><span class="o">~</span><span class="n">trimmed</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">nnz_params</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">H_restricted</span> <span class="o">=</span> <span class="n">H</span><span class="p">[</span><span class="n">nz_idx</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">],</span> <span class="n">nz_idx</span><span class="p">]</span>
            <span class="c1"># Covariance estimate for the nonzero params</span>
            <span class="n">H_restricted_inv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="o">-</span><span class="n">H_restricted</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">H_restricted_inv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="n">cov_params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">cov_params</span><span class="p">[</span><span class="n">nz_idx</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">],</span> <span class="n">nz_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">H_restricted_inv</span>

        <span class="k">return</span> <span class="n">cov_params</span>

    <span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">exog</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">linear</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Predict response variable of a model given exogenous variables.</span>
<span class="sd">        """</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="k">def</span> <span class="nf">_derivative_exog</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">exog</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dummy_idx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                         <span class="n">count_idx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        This should implement the derivative of the non-linear function</span>
<span class="sd">        """</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="k">def</span> <span class="nf">_derivative_exog_helper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">margeff</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">exog</span><span class="p">,</span> <span class="n">dummy_idx</span><span class="p">,</span>
                                <span class="n">count_idx</span><span class="p">,</span> <span class="n">transform</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Helper for _derivative_exog to wrap results appropriately</span>
<span class="sd">        """</span>
        <span class="kn">from</span> <span class="nn">.discrete_margins</span> <span class="kn">import</span> <span class="n">_get_count_effects</span><span class="p">,</span> <span class="n">_get_dummy_effects</span>

        <span class="k">if</span> <span class="n">count_idx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">margeff</span> <span class="o">=</span> <span class="n">_get_count_effects</span><span class="p">(</span><span class="n">margeff</span><span class="p">,</span> <span class="n">exog</span><span class="p">,</span> <span class="n">count_idx</span><span class="p">,</span> <span class="n">transform</span><span class="p">,</span>
                                         <span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dummy_idx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">margeff</span> <span class="o">=</span> <span class="n">_get_dummy_effects</span><span class="p">(</span><span class="n">margeff</span><span class="p">,</span> <span class="n">exog</span><span class="p">,</span> <span class="n">dummy_idx</span><span class="p">,</span> <span class="n">transform</span><span class="p">,</span>
                                         <span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">margeff</span>


<div class="viewcode-block" id="BinaryModel"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.BinaryModel.html#statsmodels.discrete.count_model.BinaryModel">[docs]</a><span class="k">class</span> <span class="nc">BinaryModel</span><span class="p">(</span><span class="n">DiscreteModel</span><span class="p">):</span>
    <span class="n">_continuous_ok</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">endog</span><span class="p">,</span> <span class="n">exog</span><span class="p">,</span> <span class="n">check_rank</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">endog</span><span class="p">,</span> <span class="n">exog</span><span class="p">,</span> <span class="n">check_rank</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">issubclass</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="n">MultinomialModel</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">endog</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endog</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"endog must be in the unit interval."</span><span class="p">)</span>

            <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_continuous_ok</span> <span class="ow">and</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endog</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endog</span><span class="p">))):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"endog must be binary, either 0 or 1"</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">exog</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">linear</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Predict response variable of a model given exogenous variables.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array_like</span>
<span class="sd">            Fitted parameters of the model.</span>
<span class="sd">        exog : array_like</span>
<span class="sd">            1d or 2d array of exogenous values.  If not supplied, the</span>
<span class="sd">            whole exog attribute of the model is used.</span>
<span class="sd">        linear : bool, optional</span>
<span class="sd">            If True, returns the linear predictor dot(exog,params).  Else,</span>
<span class="sd">            returns the value of the cdf at the linear predictor.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        array</span>
<span class="sd">            Fitted values at exog.</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="n">exog</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">exog</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exog</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">linear</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">exog</span><span class="p">,</span> <span class="n">params</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">exog</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>

<div class="viewcode-block" id="BinaryModel.fit_regularized"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.BinaryModel.fit_regularized.html#statsmodels.discrete.count_model.BinaryModel.fit_regularized">[docs]</a>    <span class="nd">@Appender</span><span class="p">(</span><span class="n">DiscreteModel</span><span class="o">.</span><span class="n">fit_regularized</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">fit_regularized</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">'l1'</span><span class="p">,</span>
            <span class="n">maxiter</span><span class="o">=</span><span class="s1">'defined_by_method'</span><span class="p">,</span> <span class="n">full_output</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">disp</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">alpha</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">trim_mode</span><span class="o">=</span><span class="s1">'auto'</span><span class="p">,</span> <span class="n">auto_trim_tol</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">size_trim_tol</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">,</span>
            <span class="n">qc_tol</span><span class="o">=</span><span class="mf">0.03</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

        <span class="n">_validate_l1_method</span><span class="p">(</span><span class="n">method</span><span class="p">)</span>

        <span class="n">bnryfit</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">fit_regularized</span><span class="p">(</span><span class="n">start_params</span><span class="o">=</span><span class="n">start_params</span><span class="p">,</span>
                                          <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
                                          <span class="n">maxiter</span><span class="o">=</span><span class="n">maxiter</span><span class="p">,</span>
                                          <span class="n">full_output</span><span class="o">=</span><span class="n">full_output</span><span class="p">,</span>
                                          <span class="n">disp</span><span class="o">=</span><span class="n">disp</span><span class="p">,</span>
                                          <span class="n">callback</span><span class="o">=</span><span class="n">callback</span><span class="p">,</span>
                                          <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span>
                                          <span class="n">trim_mode</span><span class="o">=</span><span class="n">trim_mode</span><span class="p">,</span>
                                          <span class="n">auto_trim_tol</span><span class="o">=</span><span class="n">auto_trim_tol</span><span class="p">,</span>
                                          <span class="n">size_trim_tol</span><span class="o">=</span><span class="n">size_trim_tol</span><span class="p">,</span>
                                          <span class="n">qc_tol</span><span class="o">=</span><span class="n">qc_tol</span><span class="p">,</span>
                                          <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="n">discretefit</span> <span class="o">=</span> <span class="n">L1BinaryResults</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bnryfit</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">L1BinaryResultsWrapper</span><span class="p">(</span><span class="n">discretefit</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_derivative_predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">exog</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">transform</span><span class="o">=</span><span class="s1">'dydx'</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        For computing marginal effects standard errors.</span>

<span class="sd">        This is used only in the case of discrete and count regressors to</span>
<span class="sd">        get the variance-covariance of the marginal effects. It returns</span>
<span class="sd">        [d F / d params] where F is the predict.</span>

<span class="sd">        Transform can be 'dydx' or 'eydx'. Checking is done in margeff</span>
<span class="sd">        computations for appropriate transform.</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="n">exog</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">exog</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exog</span>
        <span class="n">dF</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">exog</span><span class="p">,</span> <span class="n">params</span><span class="p">))[:,</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">exog</span>
        <span class="k">if</span> <span class="s1">'ey'</span> <span class="ow">in</span> <span class="n">transform</span><span class="p">:</span>
            <span class="n">dF</span> <span class="o">/=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">exog</span><span class="p">)[:,</span><span class="kc">None</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">dF</span>

    <span class="k">def</span> <span class="nf">_derivative_exog</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">exog</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">transform</span><span class="o">=</span><span class="s1">'dydx'</span><span class="p">,</span>
                         <span class="n">dummy_idx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">count_idx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        For computing marginal effects returns dF(XB) / dX where F(.) is</span>
<span class="sd">        the predicted probabilities</span>

<span class="sd">        transform can be 'dydx', 'dyex', 'eydx', or 'eyex'.</span>

<span class="sd">        Not all of these make sense in the presence of discrete regressors,</span>
<span class="sd">        but checks are done in the results in get_margeff.</span>
<span class="sd">        """</span>
        <span class="c1"># Note: this form should be appropriate for</span>
        <span class="c1">#   group 1 probit, logit, logistic, cloglog, heckprob, xtprobit</span>
        <span class="k">if</span> <span class="n">exog</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">exog</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exog</span>

        <span class="n">margeff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">exog</span><span class="p">,</span> <span class="n">params</span><span class="p">))[:,</span> <span class="kc">None</span><span class="p">],</span>
                         <span class="n">params</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:])</span>

        <span class="k">if</span> <span class="s1">'ex'</span> <span class="ow">in</span> <span class="n">transform</span><span class="p">:</span>
            <span class="n">margeff</span> <span class="o">*=</span> <span class="n">exog</span>
        <span class="k">if</span> <span class="s1">'ey'</span> <span class="ow">in</span> <span class="n">transform</span><span class="p">:</span>
            <span class="n">margeff</span> <span class="o">/=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">exog</span><span class="p">)[:,</span> <span class="kc">None</span><span class="p">]</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_derivative_exog_helper</span><span class="p">(</span><span class="n">margeff</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">exog</span><span class="p">,</span>
                                            <span class="n">dummy_idx</span><span class="p">,</span> <span class="n">count_idx</span><span class="p">,</span> <span class="n">transform</span><span class="p">)</span></div>


<div class="viewcode-block" id="MultinomialModel"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.MultinomialModel.html#statsmodels.discrete.count_model.MultinomialModel">[docs]</a><span class="k">class</span> <span class="nc">MultinomialModel</span><span class="p">(</span><span class="n">BinaryModel</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">_handle_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">endog</span><span class="p">,</span> <span class="n">exog</span><span class="p">,</span> <span class="n">missing</span><span class="p">,</span> <span class="n">hasconst</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">data_tools</span><span class="o">.</span><span class="n">_is_using_ndarray_type</span><span class="p">(</span><span class="n">endog</span><span class="p">,</span> <span class="kc">None</span><span class="p">):</span>
            <span class="n">endog_dummies</span><span class="p">,</span> <span class="n">ynames</span> <span class="o">=</span> <span class="n">_numpy_to_dummies</span><span class="p">(</span><span class="n">endog</span><span class="p">)</span>
            <span class="n">yname</span> <span class="o">=</span> <span class="s1">'y'</span>
        <span class="k">elif</span> <span class="n">data_tools</span><span class="o">.</span><span class="n">_is_using_pandas</span><span class="p">(</span><span class="n">endog</span><span class="p">,</span> <span class="kc">None</span><span class="p">):</span>
            <span class="n">endog_dummies</span><span class="p">,</span> <span class="n">ynames</span><span class="p">,</span> <span class="n">yname</span> <span class="o">=</span> <span class="n">_pandas_to_dummies</span><span class="p">(</span><span class="n">endog</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">endog</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">endog</span><span class="p">)</span>
            <span class="n">endog_dummies</span><span class="p">,</span> <span class="n">ynames</span> <span class="o">=</span> <span class="n">_numpy_to_dummies</span><span class="p">(</span><span class="n">endog</span><span class="p">)</span>
            <span class="n">yname</span> <span class="o">=</span> <span class="s1">'y'</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ynames</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">ynames</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">endog_dummies</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">ynames</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_ynames_map</span> <span class="o">=</span> <span class="n">ynames</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">handle_data</span><span class="p">(</span><span class="n">endog_dummies</span><span class="p">,</span> <span class="n">exog</span><span class="p">,</span> <span class="n">missing</span><span class="p">,</span> <span class="n">hasconst</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">data</span><span class="o">.</span><span class="n">ynames</span> <span class="o">=</span> <span class="n">yname</span>  <span class="c1"># overwrite this to single endog name</span>
        <span class="n">data</span><span class="o">.</span><span class="n">orig_endog</span> <span class="o">=</span> <span class="n">endog</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wendog</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">endog</span>

        <span class="c1"># repeating from upstream...</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">'design_info'</span><span class="p">,</span> <span class="s1">'formula'</span><span class="p">]:</span>  <span class="c1"># leave attached to data</span>
                <span class="k">continue</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">key</span><span class="p">))</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="k">pass</span>
        <span class="k">return</span> <span class="n">data</span>

<div class="viewcode-block" id="MultinomialModel.initialize"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.MultinomialModel.initialize.html#statsmodels.discrete.count_model.MultinomialModel.initialize">[docs]</a>    <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Preprocesses the data for MNLogit.</span>
<span class="sd">        """</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">initialize</span><span class="p">()</span>
        <span class="c1"># This is also a "whiten" method in other models (eg regression)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">endog</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">endog</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># turn it into an array of col idx</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">J</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wendog</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">K</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exog</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">df_model</span> <span class="o">*=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">J</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># for each J - 1 equation.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">df_resid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exog</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">df_model</span> <span class="o">-</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">J</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span></div>

<div class="viewcode-block" id="MultinomialModel.predict"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.MultinomialModel.predict.html#statsmodels.discrete.count_model.MultinomialModel.predict">[docs]</a>    <span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">exog</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">linear</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Predict response variable of a model given exogenous variables.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array_like</span>
<span class="sd">            2d array of fitted parameters of the model. Should be in the</span>
<span class="sd">            order returned from the model.</span>
<span class="sd">        exog : array_like</span>
<span class="sd">            1d or 2d array of exogenous values.  If not supplied, the</span>
<span class="sd">            whole exog attribute of the model is used. If a 1d array is given</span>
<span class="sd">            it assumed to be 1 row of exogenous variables. If you only have</span>
<span class="sd">            one regressor and would like to do prediction, you must provide</span>
<span class="sd">            a 2d array with shape[1] == 1.</span>
<span class="sd">        linear : bool, optional</span>
<span class="sd">            If True, returns the linear predictor dot(exog,params).  Else,</span>
<span class="sd">            returns the value of the cdf at the linear predictor.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Column 0 is the base case, the rest conform to the rows of params</span>
<span class="sd">        shifted up one for the base case.</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="n">exog</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="c1"># do here to accommodate user-given exog</span>
            <span class="n">exog</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exog</span>
        <span class="k">if</span> <span class="n">exog</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">exog</span> <span class="o">=</span> <span class="n">exog</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span>
        <span class="n">pred</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">exog</span><span class="p">,</span> <span class="n">linear</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">linear</span><span class="p">:</span>
            <span class="n">pred</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">exog</span><span class="p">)),</span> <span class="n">pred</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">pred</span></div>

<div class="viewcode-block" id="MultinomialModel.fit"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.MultinomialModel.fit.html#statsmodels.discrete.count_model.MultinomialModel.fit">[docs]</a>    <span class="nd">@Appender</span><span class="p">(</span><span class="n">DiscreteModel</span><span class="o">.</span><span class="n">fit</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">'newton'</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="mi">35</span><span class="p">,</span>
            <span class="n">full_output</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">disp</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">start_params</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">start_params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">K</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">J</span><span class="o">-</span><span class="mi">1</span><span class="p">)))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">start_params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">start_params</span><span class="p">)</span>
        <span class="n">callback</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span> <span class="p">:</span> <span class="kc">None</span> <span class="c1"># placeholder until check_perfect_pred</span>
        <span class="c1"># skip calling super to handle results from LikelihoodModel</span>
        <span class="n">mnfit</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">LikelihoodModel</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start_params</span> <span class="o">=</span> <span class="n">start_params</span><span class="p">,</span>
                <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="n">maxiter</span><span class="p">,</span> <span class="n">full_output</span><span class="o">=</span><span class="n">full_output</span><span class="p">,</span>
                <span class="n">disp</span><span class="o">=</span><span class="n">disp</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="n">callback</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">mnfit</span><span class="o">.</span><span class="n">params</span> <span class="o">=</span> <span class="n">mnfit</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">'F'</span><span class="p">)</span>
        <span class="n">mnfit</span> <span class="o">=</span> <span class="n">MultinomialResults</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mnfit</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">MultinomialResultsWrapper</span><span class="p">(</span><span class="n">mnfit</span><span class="p">)</span></div>

<div class="viewcode-block" id="MultinomialModel.fit_regularized"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.MultinomialModel.fit_regularized.html#statsmodels.discrete.count_model.MultinomialModel.fit_regularized">[docs]</a>    <span class="nd">@Appender</span><span class="p">(</span><span class="n">DiscreteModel</span><span class="o">.</span><span class="n">fit_regularized</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">fit_regularized</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">'l1'</span><span class="p">,</span>
            <span class="n">maxiter</span><span class="o">=</span><span class="s1">'defined_by_method'</span><span class="p">,</span> <span class="n">full_output</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">disp</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">alpha</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">trim_mode</span><span class="o">=</span><span class="s1">'auto'</span><span class="p">,</span> <span class="n">auto_trim_tol</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">size_trim_tol</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">,</span>
            <span class="n">qc_tol</span><span class="o">=</span><span class="mf">0.03</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">start_params</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">start_params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">K</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">J</span><span class="o">-</span><span class="mi">1</span><span class="p">)))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">start_params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">start_params</span><span class="p">)</span>
        <span class="n">mnfit</span> <span class="o">=</span> <span class="n">DiscreteModel</span><span class="o">.</span><span class="n">fit_regularized</span><span class="p">(</span>
                <span class="bp">self</span><span class="p">,</span> <span class="n">start_params</span><span class="o">=</span><span class="n">start_params</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="n">maxiter</span><span class="p">,</span>
                <span class="n">full_output</span><span class="o">=</span><span class="n">full_output</span><span class="p">,</span> <span class="n">disp</span><span class="o">=</span><span class="n">disp</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="n">callback</span><span class="p">,</span>
                <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">trim_mode</span><span class="o">=</span><span class="n">trim_mode</span><span class="p">,</span> <span class="n">auto_trim_tol</span><span class="o">=</span><span class="n">auto_trim_tol</span><span class="p">,</span>
                <span class="n">size_trim_tol</span><span class="o">=</span><span class="n">size_trim_tol</span><span class="p">,</span> <span class="n">qc_tol</span><span class="o">=</span><span class="n">qc_tol</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">mnfit</span><span class="o">.</span><span class="n">params</span> <span class="o">=</span> <span class="n">mnfit</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">'F'</span><span class="p">)</span>
        <span class="n">mnfit</span> <span class="o">=</span> <span class="n">L1MultinomialResults</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mnfit</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">L1MultinomialResultsWrapper</span><span class="p">(</span><span class="n">mnfit</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_derivative_predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">exog</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">transform</span><span class="o">=</span><span class="s1">'dydx'</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        For computing marginal effects standard errors.</span>

<span class="sd">        This is used only in the case of discrete and count regressors to</span>
<span class="sd">        get the variance-covariance of the marginal effects. It returns</span>
<span class="sd">        [d F / d params] where F is the predicted probabilities for each</span>
<span class="sd">        choice. dFdparams is of shape nobs x (J*K) x (J-1)*K.</span>
<span class="sd">        The zero derivatives for the base category are not included.</span>

<span class="sd">        Transform can be 'dydx' or 'eydx'. Checking is done in margeff</span>
<span class="sd">        computations for appropriate transform.</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="n">exog</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">exog</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exog</span>
        <span class="k">if</span> <span class="n">params</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="c1"># will get flatted from approx_fprime</span>
            <span class="n">params</span> <span class="o">=</span> <span class="n">params</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">J</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">'F'</span><span class="p">)</span>

        <span class="n">eXB</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">exog</span><span class="p">,</span> <span class="n">params</span><span class="p">))</span>
        <span class="n">sum_eXB</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">eXB</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">))[:,</span><span class="kc">None</span><span class="p">]</span>
        <span class="n">J</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">J</span><span class="p">)</span>
        <span class="n">K</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">)</span>
        <span class="n">repeat_eXB</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">eXB</span><span class="p">,</span> <span class="n">J</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">exog</span><span class="p">,</span> <span class="n">J</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1"># this is the derivative wrt the base level</span>
        <span class="n">F0</span> <span class="o">=</span> <span class="o">-</span><span class="n">repeat_eXB</span> <span class="o">*</span> <span class="n">X</span> <span class="o">/</span> <span class="n">sum_eXB</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="c1"># this is the derivative wrt the other levels when</span>
        <span class="c1"># dF_j / dParams_j (ie., own equation)</span>
        <span class="c1">#NOTE: this computes too much, any easy way to cut down?</span>
        <span class="n">F1</span> <span class="o">=</span> <span class="n">eXB</span><span class="o">.</span><span class="n">T</span><span class="p">[:,:,</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="n">X</span> <span class="o">*</span> <span class="p">(</span><span class="n">sum_eXB</span> <span class="o">-</span> <span class="n">repeat_eXB</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">sum_eXB</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">F1</span> <span class="o">=</span> <span class="n">F1</span><span class="o">.</span><span class="n">transpose</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span> <span class="c1"># put the nobs index first</span>

        <span class="c1"># other equation index</span>
        <span class="n">other_idx</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">J</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">K</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>
        <span class="n">F1</span><span class="p">[:,</span> <span class="n">other_idx</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">eXB</span><span class="o">.</span><span class="n">T</span><span class="p">[:,:,</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="n">X</span><span class="o">*</span><span class="n">repeat_eXB</span> <span class="o">/</span> \
                           <span class="p">(</span><span class="n">sum_eXB</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">))[:,</span> <span class="n">other_idx</span><span class="p">]</span>
        <span class="n">dFdX</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">F0</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">,:],</span> <span class="n">F1</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="s1">'ey'</span> <span class="ow">in</span> <span class="n">transform</span><span class="p">:</span>
            <span class="n">dFdX</span> <span class="o">/=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">exog</span><span class="p">)[:,</span> <span class="p">:,</span> <span class="kc">None</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">dFdX</span>

    <span class="k">def</span> <span class="nf">_derivative_exog</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">exog</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">transform</span><span class="o">=</span><span class="s1">'dydx'</span><span class="p">,</span>
                         <span class="n">dummy_idx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">count_idx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        For computing marginal effects returns dF(XB) / dX where F(.) is</span>
<span class="sd">        the predicted probabilities</span>

<span class="sd">        transform can be 'dydx', 'dyex', 'eydx', or 'eyex'.</span>

<span class="sd">        Not all of these make sense in the presence of discrete regressors,</span>
<span class="sd">        but checks are done in the results in get_margeff.</span>

<span class="sd">        For Multinomial models the marginal effects are</span>

<span class="sd">        P[j] * (params[j] - sum_k P[k]*params[k])</span>

<span class="sd">        It is returned unshaped, so that each row contains each of the J</span>
<span class="sd">        equations. This makes it easier to take derivatives of this for</span>
<span class="sd">        standard errors. If you want average marginal effects you can do</span>
<span class="sd">        margeff.reshape(nobs, K, J, order='F).mean(0) and the marginal effects</span>
<span class="sd">        for choice J are in column J</span>
<span class="sd">        """</span>
        <span class="n">J</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">J</span><span class="p">)</span>  <span class="c1"># number of alternative choices</span>
        <span class="n">K</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">)</span>  <span class="c1"># number of variables</span>
        <span class="c1"># Note: this form should be appropriate for</span>
        <span class="c1">#   group 1 probit, logit, logistic, cloglog, heckprob, xtprobit</span>
        <span class="k">if</span> <span class="n">exog</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">exog</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exog</span>
        <span class="k">if</span> <span class="n">params</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># will get flatted from approx_fprime</span>
            <span class="n">params</span> <span class="o">=</span> <span class="n">params</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="n">J</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">'F'</span><span class="p">)</span>

        <span class="n">zeroparams</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">K</span><span class="p">),</span> <span class="n">params</span><span class="p">]</span>  <span class="c1"># add base in</span>

        <span class="n">cdf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">exog</span><span class="p">,</span> <span class="n">params</span><span class="p">))</span>

        <span class="c1"># TODO: meaningful interpretation for `iterm`?</span>
        <span class="n">iterm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">cdf</span><span class="p">[:,</span> <span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">*</span> <span class="n">zeroparams</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span>
                          <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">J</span><span class="p">))])</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="n">margeff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">cdf</span><span class="p">[:,</span> <span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="o">*</span> <span class="p">(</span><span class="n">zeroparams</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">iterm</span><span class="p">)</span>
                            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">J</span><span class="p">)])</span>

        <span class="c1"># swap the axes to make sure margeff are in order nobs, K, J</span>
        <span class="n">margeff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">margeff</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>

        <span class="k">if</span> <span class="s1">'ex'</span> <span class="ow">in</span> <span class="n">transform</span><span class="p">:</span>
            <span class="n">margeff</span> <span class="o">*=</span> <span class="n">exog</span>
        <span class="k">if</span> <span class="s1">'ey'</span> <span class="ow">in</span> <span class="n">transform</span><span class="p">:</span>
            <span class="n">margeff</span> <span class="o">/=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">exog</span><span class="p">)[:,</span><span class="kc">None</span><span class="p">,:]</span>

        <span class="n">margeff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_derivative_exog_helper</span><span class="p">(</span><span class="n">margeff</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">exog</span><span class="p">,</span>
                                               <span class="n">dummy_idx</span><span class="p">,</span> <span class="n">count_idx</span><span class="p">,</span> <span class="n">transform</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">margeff</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">exog</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">'F'</span><span class="p">)</span></div>


<span class="k">class</span> <span class="nc">CountModel</span><span class="p">(</span><span class="n">DiscreteModel</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">endog</span><span class="p">,</span> <span class="n">exog</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">exposure</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">missing</span><span class="o">=</span><span class="s1">'none'</span><span class="p">,</span>
                 <span class="n">check_rank</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">endog</span><span class="p">,</span> <span class="n">exog</span><span class="p">,</span> <span class="n">check_rank</span><span class="p">,</span> <span class="n">missing</span><span class="o">=</span><span class="n">missing</span><span class="p">,</span>
                         <span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">,</span> <span class="n">exposure</span><span class="o">=</span><span class="n">exposure</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">exposure</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">exposure</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exposure</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">exposure</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exposure</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">offset</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">offset</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">offset</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_inputs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">offset</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">exposure</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">endog</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">offset</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">delattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">'offset'</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">exposure</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">delattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">'exposure'</span><span class="p">)</span>

        <span class="c1"># promote dtype to float64 if needed</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">promote_types</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endog</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">endog</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endog</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">promote_types</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exog</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">exog</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exog</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">_check_inputs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">exposure</span><span class="p">,</span> <span class="n">endog</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">offset</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">offset</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">endog</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"offset is not the same length as endog"</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">exposure</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">exposure</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">endog</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"exposure is not the same length as endog"</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_init_kwds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># this is a temporary fixup because exposure has been transformed</span>
        <span class="c1"># see #1609</span>
        <span class="n">kwds</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_get_init_kwds</span><span class="p">()</span>
        <span class="k">if</span> <span class="s1">'exposure'</span> <span class="ow">in</span> <span class="n">kwds</span> <span class="ow">and</span> <span class="n">kwds</span><span class="p">[</span><span class="s1">'exposure'</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">kwds</span><span class="p">[</span><span class="s1">'exposure'</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">kwds</span><span class="p">[</span><span class="s1">'exposure'</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">kwds</span>

    <span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">exog</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">exposure</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">linear</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Predict response variable of a count model given exogenous variables</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array_like</span>
<span class="sd">            Model parameters</span>
<span class="sd">        exog : array_like, optional</span>
<span class="sd">            Design / exogenous data. Is exog is None, model exog is used.</span>
<span class="sd">        exposure : array_like, optional</span>
<span class="sd">            Log(exposure) is added to the linear prediction with</span>
<span class="sd">            coefficient equal to 1. If exposure is not provided and exog</span>
<span class="sd">            is None, uses the model's exposure if present.  If not, uses</span>
<span class="sd">            0 as the default value.</span>
<span class="sd">        offset : array_like, optional</span>
<span class="sd">            Offset is added to the linear prediction with coefficient</span>
<span class="sd">            equal to 1. If offset is not provided and exog</span>
<span class="sd">            is None, uses the model's offset if present.  If not, uses</span>
<span class="sd">            0 as the default value.</span>
<span class="sd">        linear : bool</span>
<span class="sd">            If True, returns the linear predicted values.  If False,</span>
<span class="sd">            returns the exponential of the linear predicted value.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        If exposure is specified, then it will be logged by the method.</span>
<span class="sd">        The user does not need to log it first.</span>
<span class="sd">        """</span>
        <span class="c1"># the following is copied from GLM predict (without family/link check)</span>
        <span class="c1"># Use fit offset if appropriate</span>
        <span class="k">if</span> <span class="n">offset</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">exog</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">'offset'</span><span class="p">):</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">offset</span>
        <span class="k">elif</span> <span class="n">offset</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="mf">0.</span>

        <span class="c1"># Use fit exposure if appropriate</span>
        <span class="k">if</span> <span class="n">exposure</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">exog</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">'exposure'</span><span class="p">):</span>
            <span class="c1"># Already logged</span>
            <span class="n">exposure</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exposure</span>
        <span class="k">elif</span> <span class="n">exposure</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">exposure</span> <span class="o">=</span> <span class="mf">0.</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">exposure</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">exposure</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">exog</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">exog</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exog</span>

        <span class="n">fitted</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">exog</span><span class="p">,</span> <span class="n">params</span><span class="p">[:</span><span class="n">exog</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
        <span class="n">linpred</span> <span class="o">=</span> <span class="n">fitted</span> <span class="o">+</span> <span class="n">exposure</span> <span class="o">+</span> <span class="n">offset</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">linear</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">linpred</span><span class="p">)</span> <span class="c1"># not cdf</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">linpred</span>

    <span class="k">def</span> <span class="nf">_derivative_predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">exog</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">transform</span><span class="o">=</span><span class="s1">'dydx'</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        For computing marginal effects standard errors.</span>

<span class="sd">        This is used only in the case of discrete and count regressors to</span>
<span class="sd">        get the variance-covariance of the marginal effects. It returns</span>
<span class="sd">        [d F / d params] where F is the predict.</span>

<span class="sd">        Transform can be 'dydx' or 'eydx'. Checking is done in margeff</span>
<span class="sd">        computations for appropriate transform.</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="n">exog</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">exog</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exog</span>
        <span class="c1">#NOTE: this handles offset and exposure</span>
        <span class="n">dF</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">exog</span><span class="p">)[:,</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">exog</span>
        <span class="k">if</span> <span class="s1">'ey'</span> <span class="ow">in</span> <span class="n">transform</span><span class="p">:</span>
            <span class="n">dF</span> <span class="o">/=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">exog</span><span class="p">)[:,</span><span class="kc">None</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">dF</span>

    <span class="k">def</span> <span class="nf">_derivative_exog</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">exog</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">transform</span><span class="o">=</span><span class="s2">"dydx"</span><span class="p">,</span>
                         <span class="n">dummy_idx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">count_idx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        For computing marginal effects. These are the marginal effects</span>
<span class="sd">        d F(XB) / dX</span>
<span class="sd">        For the Poisson model F(XB) is the predicted counts rather than</span>
<span class="sd">        the probabilities.</span>

<span class="sd">        transform can be 'dydx', 'dyex', 'eydx', or 'eyex'.</span>

<span class="sd">        Not all of these make sense in the presence of discrete regressors,</span>
<span class="sd">        but checks are done in the results in get_margeff.</span>
<span class="sd">        """</span>
        <span class="c1"># group 3 poisson, nbreg, zip, zinb</span>
        <span class="k">if</span> <span class="n">exog</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">exog</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exog</span>
        <span class="n">k_extra</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">'k_extra'</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">params_exog</span> <span class="o">=</span> <span class="n">params</span> <span class="k">if</span> <span class="n">k_extra</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">params</span><span class="p">[:</span><span class="o">-</span><span class="n">k_extra</span><span class="p">]</span>
        <span class="n">margeff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">exog</span><span class="p">)[:,</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">params_exog</span><span class="p">[</span><span class="kc">None</span><span class="p">,:]</span>
        <span class="k">if</span> <span class="s1">'ex'</span> <span class="ow">in</span> <span class="n">transform</span><span class="p">:</span>
            <span class="n">margeff</span> <span class="o">*=</span> <span class="n">exog</span>
        <span class="k">if</span> <span class="s1">'ey'</span> <span class="ow">in</span> <span class="n">transform</span><span class="p">:</span>
            <span class="n">margeff</span> <span class="o">/=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">exog</span><span class="p">)[:,</span><span class="kc">None</span><span class="p">]</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_derivative_exog_helper</span><span class="p">(</span><span class="n">margeff</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">exog</span><span class="p">,</span>
                                            <span class="n">dummy_idx</span><span class="p">,</span> <span class="n">count_idx</span><span class="p">,</span> <span class="n">transform</span><span class="p">)</span>

    <span class="nd">@Appender</span><span class="p">(</span><span class="n">DiscreteModel</span><span class="o">.</span><span class="n">fit</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">'newton'</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="mi">35</span><span class="p">,</span>
            <span class="n">full_output</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">disp</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">cntfit</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">start_params</span><span class="o">=</span><span class="n">start_params</span><span class="p">,</span>
                             <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
                             <span class="n">maxiter</span><span class="o">=</span><span class="n">maxiter</span><span class="p">,</span>
                             <span class="n">full_output</span><span class="o">=</span><span class="n">full_output</span><span class="p">,</span>
                             <span class="n">disp</span><span class="o">=</span><span class="n">disp</span><span class="p">,</span>
                             <span class="n">callback</span><span class="o">=</span><span class="n">callback</span><span class="p">,</span>
                             <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">discretefit</span> <span class="o">=</span> <span class="n">CountResults</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cntfit</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">CountResultsWrapper</span><span class="p">(</span><span class="n">discretefit</span><span class="p">)</span>

    <span class="nd">@Appender</span><span class="p">(</span><span class="n">DiscreteModel</span><span class="o">.</span><span class="n">fit_regularized</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">fit_regularized</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">'l1'</span><span class="p">,</span>
            <span class="n">maxiter</span><span class="o">=</span><span class="s1">'defined_by_method'</span><span class="p">,</span> <span class="n">full_output</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">disp</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">alpha</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">trim_mode</span><span class="o">=</span><span class="s1">'auto'</span><span class="p">,</span> <span class="n">auto_trim_tol</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">size_trim_tol</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">,</span>
            <span class="n">qc_tol</span><span class="o">=</span><span class="mf">0.03</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

        <span class="n">_validate_l1_method</span><span class="p">(</span><span class="n">method</span><span class="p">)</span>

        <span class="n">cntfit</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">fit_regularized</span><span class="p">(</span><span class="n">start_params</span><span class="o">=</span><span class="n">start_params</span><span class="p">,</span>
                                         <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
                                         <span class="n">maxiter</span><span class="o">=</span><span class="n">maxiter</span><span class="p">,</span>
                                         <span class="n">full_output</span><span class="o">=</span><span class="n">full_output</span><span class="p">,</span>
                                         <span class="n">disp</span><span class="o">=</span><span class="n">disp</span><span class="p">,</span>
                                         <span class="n">callback</span><span class="o">=</span><span class="n">callback</span><span class="p">,</span>
                                         <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span>
                                         <span class="n">trim_mode</span><span class="o">=</span><span class="n">trim_mode</span><span class="p">,</span> <span class="n">auto_trim_tol</span><span class="o">=</span><span class="n">auto_trim_tol</span><span class="p">,</span>
                                         <span class="n">size_trim_tol</span><span class="o">=</span><span class="n">size_trim_tol</span><span class="p">,</span>
                                         <span class="n">qc_tol</span><span class="o">=</span><span class="n">qc_tol</span><span class="p">,</span>
                                         <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="n">discretefit</span> <span class="o">=</span> <span class="n">L1CountResults</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cntfit</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">L1CountResultsWrapper</span><span class="p">(</span><span class="n">discretefit</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">OrderedModel</span><span class="p">(</span><span class="n">DiscreteModel</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="c1"># Public Model Classes</span>


<span class="k">class</span> <span class="nc">Poisson</span><span class="p">(</span><span class="n">CountModel</span><span class="p">):</span>
    <span class="vm">__doc__</span> <span class="o">=</span> <span class="s2">"""</span>
<span class="s2">    Poisson Model</span>

<span class="s2">    </span><span class="si">%(params)s</span><span class="s2"></span>
<span class="s2">    </span><span class="si">%(extra_params)s</span><span class="s2"></span>

<span class="s2">    Attributes</span>
<span class="s2">    ----------</span>
<span class="s2">    endog : ndarray</span>
<span class="s2">        A reference to the endogenous response variable</span>
<span class="s2">    exog : ndarray</span>
<span class="s2">        A reference to the exogenous design.</span>
<span class="s2">    """</span> <span class="o">%</span> <span class="p">{</span><span class="s1">'params'</span><span class="p">:</span> <span class="n">base</span><span class="o">.</span><span class="n">_model_params_doc</span><span class="p">,</span>
           <span class="s1">'extra_params'</span><span class="p">:</span>
           <span class="sd">"""offset : array_like</span>
<span class="sd">        Offset is added to the linear prediction with coefficient equal to 1.</span>
<span class="sd">    exposure : array_like</span>
<span class="sd">        Log(exposure) is added to the linear prediction with coefficient</span>
<span class="sd">        equal to 1.</span>
<span class="sd">        """</span> <span class="o">+</span> <span class="n">base</span><span class="o">.</span><span class="n">_missing_param_doc</span> <span class="o">+</span> <span class="n">_check_rank_doc</span><span class="p">}</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">family</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">statsmodels.genmod</span> <span class="kn">import</span> <span class="n">families</span>
        <span class="k">return</span> <span class="n">families</span><span class="o">.</span><span class="n">Poisson</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">cdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Poisson model cumulative distribution function</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X : array_like</span>
<span class="sd">            `X` is the linear predictor of the model.  See notes.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        The value of the Poisson CDF at each point.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The CDF is defined as</span>

<span class="sd">        .. math:: \\exp\\left(-\\lambda\\right)\\sum_{i=0}^{y}\\frac{\\lambda^{i}}{i!}</span>

<span class="sd">        where :math:`\\lambda` assumes the loglinear model. I.e.,</span>

<span class="sd">        .. math:: \\ln\\lambda_{i}=X\\beta</span>

<span class="sd">        The parameter `X` is :math:`X\\beta` in the above formula.</span>
<span class="sd">        """</span>
        <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">endog</span>
        <span class="k">return</span> <span class="n">stats</span><span class="o">.</span><span class="n">poisson</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">X</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">pdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Poisson model probability mass function</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X : array_like</span>
<span class="sd">            `X` is the linear predictor of the model.  See notes.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pdf : ndarray</span>
<span class="sd">            The value of the Poisson probability mass function, PMF, for each</span>
<span class="sd">            point of X.</span>

<span class="sd">        Notes</span>
<span class="sd">        --------</span>
<span class="sd">        The PMF is defined as</span>

<span class="sd">        .. math:: \\frac{e^{-\\lambda_{i}}\\lambda_{i}^{y_{i}}}{y_{i}!}</span>

<span class="sd">        where :math:`\\lambda` assumes the loglinear model. I.e.,</span>

<span class="sd">        .. math:: \\ln\\lambda_{i}=x_{i}\\beta</span>

<span class="sd">        The parameter `X` is :math:`x_{i}\\beta` in the above formula.</span>
<span class="sd">        """</span>
        <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">endog</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">stats</span><span class="o">.</span><span class="n">poisson</span><span class="o">.</span><span class="n">logpmf</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">X</span><span class="p">)))</span>

    <span class="k">def</span> <span class="nf">loglike</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Loglikelihood of Poisson model</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array_like</span>
<span class="sd">            The parameters of the model.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        loglike : float</span>
<span class="sd">            The log-likelihood function of the model evaluated at `params`.</span>
<span class="sd">            See notes.</span>

<span class="sd">        Notes</span>
<span class="sd">        --------</span>
<span class="sd">        .. math:: \\ln L=\\sum_{i=1}^{n}\\left[-\\lambda_{i}+y_{i}x_{i}^{\\prime}\\beta-\\ln y_{i}!\\right]</span>
<span class="sd">        """</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">"offset"</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">exposure</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">"exposure"</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">XB</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exog</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span> <span class="o">+</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">exposure</span>
        <span class="n">endog</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">endog</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">XB</span><span class="p">)</span> <span class="o">+</span>  <span class="n">endog</span><span class="o">*</span><span class="n">XB</span> <span class="o">-</span> <span class="n">gammaln</span><span class="p">(</span><span class="n">endog</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">loglikeobs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Loglikelihood for observations of Poisson model</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array_like</span>
<span class="sd">            The parameters of the model.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        loglike : array_like</span>
<span class="sd">            The log likelihood for each observation of the model evaluated</span>
<span class="sd">            at `params`. See Notes</span>

<span class="sd">        Notes</span>
<span class="sd">        --------</span>
<span class="sd">        .. math:: \\ln L_{i}=\\left[-\\lambda_{i}+y_{i}x_{i}^{\\prime}\\beta-\\ln y_{i}!\\right]</span>

<span class="sd">        for observations :math:`i=1,...,n`</span>
<span class="sd">        """</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">"offset"</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">exposure</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">"exposure"</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">XB</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exog</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span> <span class="o">+</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">exposure</span>
        <span class="n">endog</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">endog</span>
        <span class="c1">#np.sum(stats.poisson.logpmf(endog, np.exp(XB)))</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">XB</span><span class="p">)</span> <span class="o">+</span>  <span class="n">endog</span><span class="o">*</span><span class="n">XB</span> <span class="o">-</span> <span class="n">gammaln</span><span class="p">(</span><span class="n">endog</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

    <span class="nd">@Appender</span><span class="p">(</span><span class="n">_get_start_params_null_docs</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_get_start_params_null</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">"offset"</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">exposure</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">"exposure"</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">const</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endog</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">offset</span> <span class="o">+</span> <span class="n">exposure</span><span class="p">))</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        <span class="n">params</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">const</span><span class="p">)]</span>
        <span class="k">return</span> <span class="n">params</span>

    <span class="nd">@Appender</span><span class="p">(</span><span class="n">DiscreteModel</span><span class="o">.</span><span class="n">fit</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">'newton'</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="mi">35</span><span class="p">,</span>
            <span class="n">full_output</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">disp</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">start_params</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">const_idx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># k_params or k_exog not available?</span>
            <span class="n">start_params</span> <span class="o">=</span> <span class="mf">0.001</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exog</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">start_params</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">const_idx</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_start_params_null</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">cntfit</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">CountModel</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">start_params</span><span class="o">=</span><span class="n">start_params</span><span class="p">,</span>
                                             <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
                                             <span class="n">maxiter</span><span class="o">=</span><span class="n">maxiter</span><span class="p">,</span>
                                             <span class="n">full_output</span><span class="o">=</span><span class="n">full_output</span><span class="p">,</span>
                                             <span class="n">disp</span><span class="o">=</span><span class="n">disp</span><span class="p">,</span>
                                             <span class="n">callback</span><span class="o">=</span><span class="n">callback</span><span class="p">,</span>
                                             <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="s1">'cov_type'</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">cov_kwds</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">'cov_kwds'</span><span class="p">,</span> <span class="p">{})</span>
            <span class="n">kwds</span> <span class="o">=</span> <span class="p">{</span><span class="s1">'cov_type'</span><span class="p">:</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">'cov_type'</span><span class="p">],</span> <span class="s1">'cov_kwds'</span><span class="p">:</span><span class="n">cov_kwds</span><span class="p">}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">kwds</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">discretefit</span> <span class="o">=</span> <span class="n">PoissonResults</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cntfit</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">PoissonResultsWrapper</span><span class="p">(</span><span class="n">discretefit</span><span class="p">)</span>

    <span class="nd">@Appender</span><span class="p">(</span><span class="n">DiscreteModel</span><span class="o">.</span><span class="n">fit_regularized</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">fit_regularized</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">'l1'</span><span class="p">,</span>
            <span class="n">maxiter</span><span class="o">=</span><span class="s1">'defined_by_method'</span><span class="p">,</span> <span class="n">full_output</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">disp</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">alpha</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">trim_mode</span><span class="o">=</span><span class="s1">'auto'</span><span class="p">,</span> <span class="n">auto_trim_tol</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">size_trim_tol</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">,</span>
            <span class="n">qc_tol</span><span class="o">=</span><span class="mf">0.03</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

        <span class="n">_validate_l1_method</span><span class="p">(</span><span class="n">method</span><span class="p">)</span>

        <span class="n">cntfit</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">CountModel</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">fit_regularized</span><span class="p">(</span>
                <span class="n">start_params</span><span class="o">=</span><span class="n">start_params</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="n">maxiter</span><span class="p">,</span>
                <span class="n">full_output</span><span class="o">=</span><span class="n">full_output</span><span class="p">,</span> <span class="n">disp</span><span class="o">=</span><span class="n">disp</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="n">callback</span><span class="p">,</span>
                <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">trim_mode</span><span class="o">=</span><span class="n">trim_mode</span><span class="p">,</span> <span class="n">auto_trim_tol</span><span class="o">=</span><span class="n">auto_trim_tol</span><span class="p">,</span>
                <span class="n">size_trim_tol</span><span class="o">=</span><span class="n">size_trim_tol</span><span class="p">,</span> <span class="n">qc_tol</span><span class="o">=</span><span class="n">qc_tol</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="n">discretefit</span> <span class="o">=</span> <span class="n">L1PoissonResults</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cntfit</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">L1PoissonResultsWrapper</span><span class="p">(</span><span class="n">discretefit</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">fit_constrained</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">constraints</span><span class="p">,</span> <span class="n">start_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">fit_kwds</span><span class="p">):</span>
        <span class="sd">"""fit the model subject to linear equality constraints</span>

<span class="sd">        The constraints are of the form   `R params = q`</span>
<span class="sd">        where R is the constraint_matrix and q is the vector of</span>
<span class="sd">        constraint_values.</span>

<span class="sd">        The estimation creates a new model with transformed design matrix,</span>
<span class="sd">        exog, and converts the results back to the original parameterization.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        constraints : formula expression or tuple</span>
<span class="sd">            If it is a tuple, then the constraint needs to be given by two</span>
<span class="sd">            arrays (constraint_matrix, constraint_value), i.e. (R, q).</span>
<span class="sd">            Otherwise, the constraints can be given as strings or list of</span>
<span class="sd">            strings.</span>
<span class="sd">            see t_test for details</span>
<span class="sd">        start_params : None or array_like</span>
<span class="sd">            starting values for the optimization. `start_params` needs to be</span>
<span class="sd">            given in the original parameter space and are internally</span>
<span class="sd">            transformed.</span>
<span class="sd">        **fit_kwds : keyword arguments</span>
<span class="sd">            fit_kwds are used in the optimization of the transformed model.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        results : Results instance</span>
<span class="sd">        """</span>

        <span class="c1">#constraints = (R, q)</span>
        <span class="c1"># TODO: temporary trailing underscore to not overwrite the monkey</span>
        <span class="c1">#       patched version</span>
        <span class="c1"># TODO: decide whether to move the imports</span>
        <span class="kn">from</span> <span class="nn">patsy</span> <span class="kn">import</span> <span class="n">DesignInfo</span>
        <span class="kn">from</span> <span class="nn">statsmodels.base._constraints</span> <span class="kn">import</span> <span class="p">(</span><span class="n">fit_constrained</span><span class="p">,</span>
                                                   <span class="n">LinearConstraints</span><span class="p">)</span>

        <span class="c1"># same pattern as in base.LikelihoodModel.t_test</span>
        <span class="n">lc</span> <span class="o">=</span> <span class="n">DesignInfo</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exog_names</span><span class="p">)</span><span class="o">.</span><span class="n">linear_constraint</span><span class="p">(</span><span class="n">constraints</span><span class="p">)</span>
        <span class="n">R</span><span class="p">,</span> <span class="n">q</span> <span class="o">=</span> <span class="n">lc</span><span class="o">.</span><span class="n">coefs</span><span class="p">,</span> <span class="n">lc</span><span class="o">.</span><span class="n">constants</span>

        <span class="c1"># TODO: add start_params option, need access to tranformation</span>
        <span class="c1">#       fit_constrained needs to do the transformation</span>
        <span class="n">params</span><span class="p">,</span> <span class="n">cov</span><span class="p">,</span> <span class="n">res_constr</span> <span class="o">=</span> <span class="n">fit_constrained</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span>
                                                  <span class="n">start_params</span><span class="o">=</span><span class="n">start_params</span><span class="p">,</span>
                                                  <span class="n">fit_kwds</span><span class="o">=</span><span class="n">fit_kwds</span><span class="p">)</span>
        <span class="c1">#create dummy results Instance, TODO: wire up properly</span>
        <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">maxiter</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">'nm'</span><span class="p">,</span> <span class="n">disp</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                       <span class="n">warn_convergence</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="c1"># we get a wrapper back</span>
        <span class="n">res</span><span class="o">.</span><span class="n">mle_retvals</span><span class="p">[</span><span class="s1">'fcall'</span><span class="p">]</span> <span class="o">=</span> <span class="n">res_constr</span><span class="o">.</span><span class="n">mle_retvals</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">'fcall'</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="n">res</span><span class="o">.</span><span class="n">mle_retvals</span><span class="p">[</span><span class="s1">'iterations'</span><span class="p">]</span> <span class="o">=</span> <span class="n">res_constr</span><span class="o">.</span><span class="n">mle_retvals</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                                                        <span class="s1">'iterations'</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="n">res</span><span class="o">.</span><span class="n">mle_retvals</span><span class="p">[</span><span class="s1">'converged'</span><span class="p">]</span> <span class="o">=</span> <span class="n">res_constr</span><span class="o">.</span><span class="n">mle_retvals</span><span class="p">[</span><span class="s1">'converged'</span><span class="p">]</span>
        <span class="n">res</span><span class="o">.</span><span class="n">_results</span><span class="o">.</span><span class="n">params</span> <span class="o">=</span> <span class="n">params</span>
        <span class="n">res</span><span class="o">.</span><span class="n">_results</span><span class="o">.</span><span class="n">cov_params_default</span> <span class="o">=</span> <span class="n">cov</span>
        <span class="n">cov_type</span> <span class="o">=</span> <span class="n">fit_kwds</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">'cov_type'</span><span class="p">,</span> <span class="s1">'nonrobust'</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">cov_type</span> <span class="o">!=</span> <span class="s1">'nonrobust'</span><span class="p">:</span>
            <span class="n">res</span><span class="o">.</span><span class="n">_results</span><span class="o">.</span><span class="n">normalized_cov_params</span> <span class="o">=</span> <span class="n">cov</span> <span class="c1"># assume scale=1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">res</span><span class="o">.</span><span class="n">_results</span><span class="o">.</span><span class="n">normalized_cov_params</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">k_constr</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
        <span class="n">res</span><span class="o">.</span><span class="n">_results</span><span class="o">.</span><span class="n">df_resid</span> <span class="o">+=</span> <span class="n">k_constr</span>
        <span class="n">res</span><span class="o">.</span><span class="n">_results</span><span class="o">.</span><span class="n">df_model</span> <span class="o">-=</span> <span class="n">k_constr</span>
        <span class="n">res</span><span class="o">.</span><span class="n">_results</span><span class="o">.</span><span class="n">constraints</span> <span class="o">=</span> <span class="n">LinearConstraints</span><span class="o">.</span><span class="n">from_patsy</span><span class="p">(</span><span class="n">lc</span><span class="p">)</span>
        <span class="n">res</span><span class="o">.</span><span class="n">_results</span><span class="o">.</span><span class="n">k_constr</span> <span class="o">=</span> <span class="n">k_constr</span>
        <span class="n">res</span><span class="o">.</span><span class="n">_results</span><span class="o">.</span><span class="n">results_constrained</span> <span class="o">=</span> <span class="n">res_constr</span>
        <span class="k">return</span> <span class="n">res</span>

    <span class="k">def</span> <span class="nf">score</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Poisson model score (gradient) vector of the log-likelihood</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array_like</span>
<span class="sd">            The parameters of the model</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        score : ndarray, 1-D</span>
<span class="sd">            The score vector of the model, i.e. the first derivative of the</span>
<span class="sd">            loglikelihood function, evaluated at `params`</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        .. math:: \\frac{\\partial\\ln L}{\\partial\\beta}=\\sum_{i=1}^{n}\\left(y_{i}-\\lambda_{i}\\right)x_{i}</span>

<span class="sd">        where the loglinear model is assumed</span>

<span class="sd">        .. math:: \\ln\\lambda_{i}=x_{i}\\beta</span>
<span class="sd">        """</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">"offset"</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">exposure</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">"exposure"</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">X</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exog</span>
        <span class="n">L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">params</span><span class="p">)</span> <span class="o">+</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">exposure</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endog</span> <span class="o">-</span> <span class="n">L</span><span class="p">,</span> <span class="n">X</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">score_obs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Poisson model Jacobian of the log-likelihood for each observation</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array_like</span>
<span class="sd">            The parameters of the model</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        score : array_like</span>
<span class="sd">            The score vector (nobs, k_vars) of the model evaluated at `params`</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        .. math:: \\frac{\\partial\\ln L_{i}}{\\partial\\beta}=\\left(y_{i}-\\lambda_{i}\\right)x_{i}</span>

<span class="sd">        for observations :math:`i=1,...,n`</span>

<span class="sd">        where the loglinear model is assumed</span>

<span class="sd">        .. math:: \\ln\\lambda_{i}=x_{i}\\beta</span>
<span class="sd">        """</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">"offset"</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">exposure</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">"exposure"</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">X</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exog</span>
        <span class="n">L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">params</span><span class="p">)</span> <span class="o">+</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">exposure</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endog</span> <span class="o">-</span> <span class="n">L</span><span class="p">)[:,</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">X</span>

    <span class="k">def</span> <span class="nf">score_factor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Poisson model score_factor for each observation</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array_like</span>
<span class="sd">            The parameters of the model</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        score : array_like</span>
<span class="sd">            The score factor (nobs, ) of the model evaluated at `params`</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        .. math:: \\frac{\\partial\\ln L_{i}}{\\partial\\beta}=\\left(y_{i}-\\lambda_{i}\\right)</span>

<span class="sd">        for observations :math:`i=1,...,n`</span>

<span class="sd">        where the loglinear model is assumed</span>

<span class="sd">        .. math:: \\ln\\lambda_{i}=x_{i}\\beta</span>
<span class="sd">        """</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">"offset"</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">exposure</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">"exposure"</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">X</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exog</span>
        <span class="n">L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">params</span><span class="p">)</span> <span class="o">+</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">exposure</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endog</span> <span class="o">-</span> <span class="n">L</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">hessian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Poisson model Hessian matrix of the loglikelihood</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array_like</span>
<span class="sd">            The parameters of the model</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        hess : ndarray, (k_vars, k_vars)</span>
<span class="sd">            The Hessian, second derivative of loglikelihood function,</span>
<span class="sd">            evaluated at `params`</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        .. math:: \\frac{\\partial^{2}\\ln L}{\\partial\\beta\\partial\\beta^{\\prime}}=-\\sum_{i=1}^{n}\\lambda_{i}x_{i}x_{i}^{\\prime}</span>

<span class="sd">        where the loglinear model is assumed</span>

<span class="sd">        .. math:: \\ln\\lambda_{i}=x_{i}\\beta</span>
<span class="sd">        """</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">"offset"</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">exposure</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">"exposure"</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">X</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exog</span>
        <span class="n">L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">params</span><span class="p">)</span> <span class="o">+</span> <span class="n">exposure</span> <span class="o">+</span> <span class="n">offset</span><span class="p">)</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">L</span><span class="o">*</span><span class="n">X</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">X</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">hessian_factor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Poisson model Hessian factor</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array_like</span>
<span class="sd">            The parameters of the model</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        hess : ndarray, (nobs,)</span>
<span class="sd">            The Hessian factor, second derivative of loglikelihood function</span>
<span class="sd">            with respect to the linear predictor evaluated at `params`</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        .. math:: \\frac{\\partial^{2}\\ln L}{\\partial\\beta\\partial\\beta^{\\prime}}=-\\sum_{i=1}^{n}\\lambda_{i}</span>

<span class="sd">        where the loglinear model is assumed</span>

<span class="sd">        .. math:: \\ln\\lambda_{i}=x_{i}\\beta</span>
<span class="sd">        """</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">"offset"</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">exposure</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">"exposure"</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">X</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exog</span>
        <span class="n">L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">params</span><span class="p">)</span> <span class="o">+</span> <span class="n">exposure</span> <span class="o">+</span> <span class="n">offset</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">L</span>


<span class="k">class</span> <span class="nc">GeneralizedPoisson</span><span class="p">(</span><span class="n">CountModel</span><span class="p">):</span>
    <span class="vm">__doc__</span> <span class="o">=</span> <span class="s2">"""</span>
<span class="s2">    Generalized Poisson Model</span>

<span class="s2">    </span><span class="si">%(params)s</span><span class="s2"></span>
<span class="s2">    </span><span class="si">%(extra_params)s</span><span class="s2"></span>

<span class="s2">    Attributes</span>
<span class="s2">    ----------</span>
<span class="s2">    endog : ndarray</span>
<span class="s2">        A reference to the endogenous response variable</span>
<span class="s2">    exog : ndarray</span>
<span class="s2">        A reference to the exogenous design.</span>
<span class="s2">    """</span> <span class="o">%</span> <span class="p">{</span><span class="s1">'params'</span><span class="p">:</span> <span class="n">base</span><span class="o">.</span><span class="n">_model_params_doc</span><span class="p">,</span>
           <span class="s1">'extra_params'</span><span class="p">:</span>
               <span class="sd">"""</span>
<span class="sd">    p : scalar</span>
<span class="sd">        P denotes parameterizations for GP regression. p=1 for GP-1 and</span>
<span class="sd">        p=2 for GP-2. Default is p=1.</span>
<span class="sd">    offset : array_like</span>
<span class="sd">        Offset is added to the linear prediction with coefficient equal to 1.</span>
<span class="sd">    exposure : array_like</span>
<span class="sd">        Log(exposure) is added to the linear prediction with coefficient</span>
<span class="sd">        equal to 1."""</span> <span class="o">+</span> <span class="n">base</span><span class="o">.</span><span class="n">_missing_param_doc</span> <span class="o">+</span> <span class="n">_check_rank_doc</span><span class="p">}</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">endog</span><span class="p">,</span> <span class="n">exog</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">exposure</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">missing</span><span class="o">=</span><span class="s1">'none'</span><span class="p">,</span> <span class="n">check_rank</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">endog</span><span class="p">,</span>
                         <span class="n">exog</span><span class="p">,</span>
                         <span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">,</span>
                         <span class="n">exposure</span><span class="o">=</span><span class="n">exposure</span><span class="p">,</span>
                         <span class="n">missing</span><span class="o">=</span><span class="n">missing</span><span class="p">,</span>
                         <span class="n">check_rank</span><span class="o">=</span><span class="n">check_rank</span><span class="p">,</span>
                         <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parameterization</span> <span class="o">=</span> <span class="n">p</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">exog_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">'alpha'</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k_extra</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_transparams</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">_get_init_kwds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">kwds</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_get_init_kwds</span><span class="p">()</span>
        <span class="n">kwds</span><span class="p">[</span><span class="s1">'p'</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameterization</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">kwds</span>

    <span class="k">def</span> <span class="nf">loglike</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Loglikelihood of Generalized Poisson model</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array_like</span>
<span class="sd">            The parameters of the model.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        loglike : float</span>
<span class="sd">            The log-likelihood function of the model evaluated at `params`.</span>
<span class="sd">            See notes.</span>

<span class="sd">        Notes</span>
<span class="sd">        --------</span>
<span class="sd">        .. math:: \\ln L=\\sum_{i=1}^{n}\\left[\\mu_{i}+(y_{i}-1)*ln(\\mu_{i}+</span>
<span class="sd">            \\alpha*\\mu_{i}^{p-1}*y_{i})-y_{i}*ln(1+\\alpha*\\mu_{i}^{p-1})-</span>
<span class="sd">            ln(y_{i}!)-\\frac{\\mu_{i}+\\alpha*\\mu_{i}^{p-1}*y_{i}}{1+\\alpha*</span>
<span class="sd">            \\mu_{i}^{p-1}}\\right]</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loglikeobs</span><span class="p">(</span><span class="n">params</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">loglikeobs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Loglikelihood for observations of Generalized Poisson model</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array_like</span>
<span class="sd">            The parameters of the model.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        loglike : ndarray</span>
<span class="sd">            The log likelihood for each observation of the model evaluated</span>
<span class="sd">            at `params`. See Notes</span>

<span class="sd">        Notes</span>
<span class="sd">        --------</span>
<span class="sd">        .. math:: \\ln L=\\sum_{i=1}^{n}\\left[\\mu_{i}+(y_{i}-1)*ln(\\mu_{i}+</span>
<span class="sd">            \\alpha*\\mu_{i}^{p-1}*y_{i})-y_{i}*ln(1+\\alpha*\\mu_{i}^{p-1})-</span>
<span class="sd">            ln(y_{i}!)-\\frac{\\mu_{i}+\\alpha*\\mu_{i}^{p-1}*y_{i}}{1+\\alpha*</span>
<span class="sd">            \\mu_{i}^{p-1}}\\right]</span>

<span class="sd">        for observations :math:`i=1,...,n`</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transparams</span><span class="p">:</span>
            <span class="n">alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">alpha</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">params</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameterization</span>
        <span class="n">endog</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">endog</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
        <span class="n">mu_p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">mu</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
        <span class="n">a1</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">alpha</span> <span class="o">*</span> <span class="n">mu_p</span>
        <span class="n">a2</span> <span class="o">=</span> <span class="n">mu</span> <span class="o">+</span> <span class="p">(</span><span class="n">a1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">endog</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">mu</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">endog</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">a2</span><span class="p">)</span> <span class="o">-</span> <span class="n">endog</span> <span class="o">*</span>
                <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">a1</span><span class="p">)</span> <span class="o">-</span> <span class="n">gammaln</span><span class="p">(</span><span class="n">endog</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">a2</span> <span class="o">/</span> <span class="n">a1</span><span class="p">)</span>

    <span class="nd">@Appender</span><span class="p">(</span><span class="n">_get_start_params_null_docs</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_get_start_params_null</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">"offset"</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">exposure</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">"exposure"</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

        <span class="n">const</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endog</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">offset</span> <span class="o">+</span> <span class="n">exposure</span><span class="p">))</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        <span class="n">params</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">const</span><span class="p">)]</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="n">const</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">offset</span> <span class="o">+</span> <span class="n">exposure</span><span class="p">)</span>
        <span class="n">resid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">endog</span> <span class="o">-</span> <span class="n">mu</span>
        <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_estimate_dispersion</span><span class="p">(</span><span class="n">mu</span><span class="p">,</span> <span class="n">resid</span><span class="p">,</span> <span class="n">df_resid</span><span class="o">=</span><span class="n">resid</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">params</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_estimate_dispersion</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">resid</span><span class="p">,</span> <span class="n">df_resid</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameterization</span>
        <span class="k">if</span> <span class="n">df_resid</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">df_resid</span> <span class="o">=</span> <span class="n">resid</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">a</span> <span class="o">=</span> <span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">resid</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">mu</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">mu</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="n">q</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="n">df_resid</span>
        <span class="k">return</span> <span class="n">a</span>


    <span class="nd">@Appender</span><span class="p">(</span>
        <span class="sd">"""</span>
<span class="sd">        use_transparams : bool</span>
<span class="sd">            This parameter enable internal transformation to impose</span>
<span class="sd">            non-negativity. True to enable. Default is False.</span>
<span class="sd">            use_transparams=True imposes the no underdispersion (alpha &gt; 0)</span>
<span class="sd">            constraint. In case use_transparams=True and method="newton" or</span>
<span class="sd">            "ncg" transformation is ignored.</span>
<span class="sd">        """</span><span class="p">)</span>
    <span class="nd">@Appender</span><span class="p">(</span><span class="n">DiscreteModel</span><span class="o">.</span><span class="n">fit</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">'bfgs'</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="mi">35</span><span class="p">,</span>
            <span class="n">full_output</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">disp</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">use_transparams</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">cov_type</span><span class="o">=</span><span class="s1">'nonrobust'</span><span class="p">,</span> <span class="n">cov_kwds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">use_t</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">use_transparams</span> <span class="ow">and</span> <span class="n">method</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">'newton'</span><span class="p">,</span> <span class="s1">'ncg'</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_transparams</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">use_transparams</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">'Parameter "use_transparams" is ignored'</span><span class="p">,</span>
                              <span class="ne">RuntimeWarning</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_transparams</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="n">start_params</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">"offset"</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">"exposure"</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">offset</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">offset</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">offset</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">optim_kwds_prelim</span> <span class="o">=</span> <span class="p">{</span><span class="s1">'disp'</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">'skip_hessian'</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
                                 <span class="s1">'warn_convergence'</span><span class="p">:</span> <span class="kc">False</span><span class="p">}</span>
            <span class="n">optim_kwds_prelim</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">'optim_kwds_prelim'</span><span class="p">,</span> <span class="p">{}))</span>
            <span class="n">mod_poi</span> <span class="o">=</span> <span class="n">Poisson</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endog</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">exog</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">)</span>
            <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">():</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s2">"always"</span><span class="p">)</span>
                <span class="n">res_poi</span> <span class="o">=</span> <span class="n">mod_poi</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="o">**</span><span class="n">optim_kwds_prelim</span><span class="p">)</span>
            <span class="n">start_params</span> <span class="o">=</span> <span class="n">res_poi</span><span class="o">.</span><span class="n">params</span>
            <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_estimate_dispersion</span><span class="p">(</span><span class="n">res_poi</span><span class="o">.</span><span class="n">predict</span><span class="p">(),</span> <span class="n">res_poi</span><span class="o">.</span><span class="n">resid</span><span class="p">,</span>
                                          <span class="n">df_resid</span><span class="o">=</span><span class="n">res_poi</span><span class="o">.</span><span class="n">df_resid</span><span class="p">)</span>
            <span class="n">start_params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">start_params</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="o">-</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">a</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">callback</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># work around perfect separation callback #3895</span>
            <span class="n">callback</span> <span class="o">=</span> <span class="k">lambda</span> <span class="o">*</span><span class="n">x</span><span class="p">:</span> <span class="n">x</span>

        <span class="n">mlefit</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">start_params</span><span class="o">=</span><span class="n">start_params</span><span class="p">,</span>
                             <span class="n">maxiter</span><span class="o">=</span><span class="n">maxiter</span><span class="p">,</span>
                             <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
                             <span class="n">disp</span><span class="o">=</span><span class="n">disp</span><span class="p">,</span>
                             <span class="n">full_output</span><span class="o">=</span><span class="n">full_output</span><span class="p">,</span>
                             <span class="n">callback</span><span class="o">=</span><span class="n">callback</span><span class="p">,</span>
                             <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">use_transparams</span> <span class="ow">and</span> <span class="n">method</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">"newton"</span><span class="p">,</span> <span class="s2">"ncg"</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_transparams</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">mlefit</span><span class="o">.</span><span class="n">_results</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mlefit</span><span class="o">.</span><span class="n">_results</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="n">gpfit</span> <span class="o">=</span> <span class="n">GeneralizedPoissonResults</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mlefit</span><span class="o">.</span><span class="n">_results</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">GeneralizedPoissonResultsWrapper</span><span class="p">(</span><span class="n">gpfit</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">cov_kwds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cov_kwds</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="n">result</span><span class="o">.</span><span class="n">_get_robustcov_results</span><span class="p">(</span><span class="n">cov_type</span><span class="o">=</span><span class="n">cov_type</span><span class="p">,</span>
                                      <span class="n">use_self</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">use_t</span><span class="o">=</span><span class="n">use_t</span><span class="p">,</span> <span class="o">**</span><span class="n">cov_kwds</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="nd">@Appender</span><span class="p">(</span><span class="n">DiscreteModel</span><span class="o">.</span><span class="n">fit_regularized</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">fit_regularized</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">'l1'</span><span class="p">,</span>
            <span class="n">maxiter</span><span class="o">=</span><span class="s1">'defined_by_method'</span><span class="p">,</span> <span class="n">full_output</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">disp</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">alpha</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">trim_mode</span><span class="o">=</span><span class="s1">'auto'</span><span class="p">,</span> <span class="n">auto_trim_tol</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">size_trim_tol</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">,</span>
            <span class="n">qc_tol</span><span class="o">=</span><span class="mf">0.03</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

        <span class="n">_validate_l1_method</span><span class="p">(</span><span class="n">method</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">alpha</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">k_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exog</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_extra</span>
            <span class="n">alpha</span> <span class="o">=</span> <span class="n">alpha</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">k_params</span><span class="p">)</span>
            <span class="n">alpha</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">alpha_p</span> <span class="o">=</span> <span class="n">alpha</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_extra</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="k">else</span> <span class="n">alpha</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_transparams</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">start_params</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">"offset"</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">"exposure"</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">offset</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">offset</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">offset</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">mod_poi</span> <span class="o">=</span> <span class="n">Poisson</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endog</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">exog</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">)</span>
            <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">():</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s2">"always"</span><span class="p">)</span>
                <span class="n">start_params</span> <span class="o">=</span> <span class="n">mod_poi</span><span class="o">.</span><span class="n">fit_regularized</span><span class="p">(</span>
                    <span class="n">start_params</span><span class="o">=</span><span class="n">start_params</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="n">maxiter</span><span class="p">,</span>
                    <span class="n">full_output</span><span class="o">=</span><span class="n">full_output</span><span class="p">,</span> <span class="n">disp</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="n">callback</span><span class="p">,</span>
                    <span class="n">alpha</span><span class="o">=</span><span class="n">alpha_p</span><span class="p">,</span> <span class="n">trim_mode</span><span class="o">=</span><span class="n">trim_mode</span><span class="p">,</span>
                    <span class="n">auto_trim_tol</span><span class="o">=</span><span class="n">auto_trim_tol</span><span class="p">,</span> <span class="n">size_trim_tol</span><span class="o">=</span><span class="n">size_trim_tol</span><span class="p">,</span>
                    <span class="n">qc_tol</span><span class="o">=</span><span class="n">qc_tol</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">.</span><span class="n">params</span>
            <span class="n">start_params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">start_params</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)</span>

        <span class="n">cntfit</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">CountModel</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">fit_regularized</span><span class="p">(</span>
                <span class="n">start_params</span><span class="o">=</span><span class="n">start_params</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="n">maxiter</span><span class="p">,</span>
                <span class="n">full_output</span><span class="o">=</span><span class="n">full_output</span><span class="p">,</span> <span class="n">disp</span><span class="o">=</span><span class="n">disp</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="n">callback</span><span class="p">,</span>
                <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">trim_mode</span><span class="o">=</span><span class="n">trim_mode</span><span class="p">,</span> <span class="n">auto_trim_tol</span><span class="o">=</span><span class="n">auto_trim_tol</span><span class="p">,</span>
                <span class="n">size_trim_tol</span><span class="o">=</span><span class="n">size_trim_tol</span><span class="p">,</span> <span class="n">qc_tol</span><span class="o">=</span><span class="n">qc_tol</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="n">discretefit</span> <span class="o">=</span> <span class="n">L1GeneralizedPoissonResults</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cntfit</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">L1GeneralizedPoissonResultsWrapper</span><span class="p">(</span><span class="n">discretefit</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">score_obs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transparams</span><span class="p">:</span>
            <span class="n">alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">alpha</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">params</span> <span class="o">=</span> <span class="n">params</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameterization</span>
        <span class="n">exog</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exog</span>
        <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">endog</span><span class="p">[:,</span><span class="kc">None</span><span class="p">]</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">params</span><span class="p">)[:,</span><span class="kc">None</span><span class="p">]</span>
        <span class="n">mu_p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">mu</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
        <span class="n">a1</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">alpha</span> <span class="o">*</span> <span class="n">mu_p</span>
        <span class="n">a2</span> <span class="o">=</span> <span class="n">mu</span> <span class="o">+</span> <span class="n">alpha</span> <span class="o">*</span> <span class="n">mu_p</span> <span class="o">*</span> <span class="n">y</span>
        <span class="n">a3</span> <span class="o">=</span> <span class="n">alpha</span> <span class="o">*</span> <span class="n">p</span> <span class="o">*</span> <span class="n">mu</span> <span class="o">**</span> <span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">a4</span> <span class="o">=</span> <span class="n">a3</span> <span class="o">*</span> <span class="n">y</span>
        <span class="n">dmudb</span> <span class="o">=</span> <span class="n">mu</span> <span class="o">*</span> <span class="n">exog</span>

        <span class="n">dalpha</span> <span class="o">=</span> <span class="p">(</span><span class="n">mu_p</span> <span class="o">*</span> <span class="p">(</span><span class="n">y</span> <span class="o">*</span> <span class="p">((</span><span class="n">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">a2</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">/</span> <span class="n">a1</span><span class="p">)</span> <span class="o">+</span> <span class="n">a2</span> <span class="o">/</span> <span class="n">a1</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
        <span class="n">dparams</span> <span class="o">=</span> <span class="n">dmudb</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="n">a4</span> <span class="o">/</span> <span class="n">a1</span> <span class="o">+</span>
                           <span class="n">a3</span> <span class="o">*</span> <span class="n">a2</span> <span class="o">/</span> <span class="p">(</span><span class="n">a1</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span>
                           <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">a4</span><span class="p">)</span> <span class="o">*</span> <span class="p">((</span><span class="n">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">a2</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">a1</span><span class="p">)</span> <span class="o">+</span>
                           <span class="mi">1</span> <span class="o">/</span> <span class="n">mu</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">dparams</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">dalpha</span><span class="p">)),</span>
                              <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">score</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="n">score</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">score_obs</span><span class="p">(</span><span class="n">params</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transparams</span><span class="p">:</span>
            <span class="n">score</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">score</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span>
            <span class="k">return</span> <span class="n">score</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">score</span>

    <span class="k">def</span> <span class="nf">_score_p</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Generalized Poisson model derivative of the log-likelihood by p-parameter</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array_like</span>
<span class="sd">            The parameters of the model</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dldp : float</span>
<span class="sd">            dldp is first derivative of the loglikelihood function,</span>
<span class="sd">        evaluated at `p-parameter`.</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transparams</span><span class="p">:</span>
            <span class="n">alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">alpha</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">params</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameterization</span>
        <span class="n">exog</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exog</span>
        <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">endog</span><span class="p">[:,</span><span class="kc">None</span><span class="p">]</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">params</span><span class="p">)[:,</span><span class="kc">None</span><span class="p">]</span>
        <span class="n">mu_p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">mu</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
        <span class="n">a1</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">alpha</span> <span class="o">*</span> <span class="n">mu_p</span>
        <span class="n">a2</span> <span class="o">=</span> <span class="n">mu</span> <span class="o">+</span> <span class="n">alpha</span> <span class="o">*</span> <span class="n">mu_p</span> <span class="o">*</span> <span class="n">y</span>

        <span class="n">dp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">mu</span><span class="p">)</span> <span class="o">*</span> <span class="p">((</span><span class="n">a2</span> <span class="o">-</span> <span class="n">mu</span><span class="p">)</span> <span class="o">*</span> <span class="p">((</span><span class="n">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">a2</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">/</span> <span class="n">a1</span><span class="p">)</span> <span class="o">+</span>
                                   <span class="p">(</span><span class="n">a1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">a2</span> <span class="o">/</span> <span class="n">a1</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">dp</span>

    <span class="k">def</span> <span class="nf">hessian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Generalized Poisson model Hessian matrix of the loglikelihood</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array_like</span>
<span class="sd">            The parameters of the model</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        hess : ndarray, (k_vars, k_vars)</span>
<span class="sd">            The Hessian, second derivative of loglikelihood function,</span>
<span class="sd">            evaluated at `params`</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transparams</span><span class="p">:</span>
            <span class="n">alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">alpha</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">params</span> <span class="o">=</span> <span class="n">params</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameterization</span>
        <span class="n">exog</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exog</span>
        <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">endog</span><span class="p">[:,</span><span class="kc">None</span><span class="p">]</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">params</span><span class="p">)[:,</span><span class="kc">None</span><span class="p">]</span>
        <span class="n">mu_p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">mu</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
        <span class="n">a1</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">alpha</span> <span class="o">*</span> <span class="n">mu_p</span>
        <span class="n">a2</span> <span class="o">=</span> <span class="n">mu</span> <span class="o">+</span> <span class="n">alpha</span> <span class="o">*</span> <span class="n">mu_p</span> <span class="o">*</span> <span class="n">y</span>
        <span class="n">a3</span> <span class="o">=</span> <span class="n">alpha</span> <span class="o">*</span> <span class="n">p</span> <span class="o">*</span> <span class="n">mu</span> <span class="o">**</span> <span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">a4</span> <span class="o">=</span> <span class="n">a3</span> <span class="o">*</span> <span class="n">y</span>
        <span class="n">a5</span> <span class="o">=</span> <span class="n">p</span> <span class="o">*</span> <span class="n">mu</span> <span class="o">**</span> <span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">dmudb</span> <span class="o">=</span> <span class="n">mu</span> <span class="o">*</span> <span class="n">exog</span>

        <span class="c1"># for dl/dparams dparams</span>
        <span class="n">dim</span> <span class="o">=</span> <span class="n">exog</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">hess_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">dim</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">dim</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">hess_arr</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">mu</span> <span class="o">*</span> <span class="n">exog</span><span class="p">[:,</span><span class="n">i</span><span class="p">,</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">exog</span><span class="p">[:,</span><span class="n">j</span><span class="p">,</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span>
                    <span class="p">(</span><span class="n">mu</span> <span class="o">*</span> <span class="p">(</span><span class="n">a3</span> <span class="o">*</span> <span class="n">a4</span> <span class="o">/</span> <span class="n">a1</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span>
                           <span class="mi">2</span> <span class="o">*</span> <span class="n">a3</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">a2</span> <span class="o">/</span> <span class="n">a1</span><span class="o">**</span><span class="mi">3</span> <span class="o">+</span>
                           <span class="mi">2</span> <span class="o">*</span> <span class="n">a3</span> <span class="o">*</span> <span class="p">(</span><span class="n">a4</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">a1</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span>
                           <span class="n">a4</span> <span class="o">*</span> <span class="n">p</span> <span class="o">/</span> <span class="p">(</span><span class="n">mu</span> <span class="o">*</span> <span class="n">a1</span><span class="p">)</span> <span class="o">+</span>
                           <span class="n">a3</span> <span class="o">*</span> <span class="n">p</span> <span class="o">*</span> <span class="n">a2</span> <span class="o">/</span> <span class="p">(</span><span class="n">mu</span> <span class="o">*</span> <span class="n">a1</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span>
                           <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">a4</span> <span class="o">*</span> <span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">a2</span> <span class="o">*</span> <span class="n">mu</span><span class="p">)</span> <span class="o">-</span>
                           <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">a4</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="n">a2</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span>
                           <span class="n">a4</span> <span class="o">*</span> <span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">a1</span> <span class="o">*</span> <span class="n">mu</span><span class="p">))</span> <span class="o">+</span>
                     <span class="p">((</span><span class="n">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">a4</span><span class="p">)</span> <span class="o">/</span> <span class="n">a2</span> <span class="o">-</span>
                      <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">a4</span><span class="p">)</span> <span class="o">/</span> <span class="n">a1</span><span class="p">)),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">tri_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">triu_indices</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">hess_arr</span><span class="p">[</span><span class="n">tri_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">hess_arr</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="n">tri_idx</span><span class="p">]</span>

        <span class="c1"># for dl/dparams dalpha</span>
        <span class="n">dldpda</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="mi">2</span> <span class="o">*</span> <span class="n">a4</span> <span class="o">*</span> <span class="n">mu_p</span> <span class="o">/</span> <span class="n">a1</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span>
                         <span class="mi">2</span> <span class="o">*</span> <span class="n">a3</span> <span class="o">*</span> <span class="n">mu_p</span> <span class="o">*</span> <span class="n">a2</span> <span class="o">/</span> <span class="n">a1</span><span class="o">**</span><span class="mi">3</span> <span class="o">-</span>
                         <span class="n">mu_p</span> <span class="o">*</span> <span class="n">y</span> <span class="o">*</span> <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">a4</span><span class="p">)</span> <span class="o">/</span> <span class="n">a2</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span>
                         <span class="n">mu_p</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">a4</span><span class="p">)</span> <span class="o">/</span> <span class="n">a1</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span>
                         <span class="n">a5</span> <span class="o">*</span> <span class="n">y</span> <span class="o">*</span> <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">a2</span> <span class="o">-</span>
                         <span class="mi">2</span> <span class="o">*</span> <span class="n">a5</span> <span class="o">*</span> <span class="n">y</span> <span class="o">/</span> <span class="n">a1</span> <span class="o">+</span>
                         <span class="n">a5</span> <span class="o">*</span> <span class="n">a2</span> <span class="o">/</span> <span class="n">a1</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">dmudb</span><span class="p">,</span>
                        <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="n">hess_arr</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">dldpda</span>
        <span class="n">hess_arr</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">dldpda</span>

        <span class="c1"># for dl/dalpha dalpha</span>
        <span class="n">dldada</span> <span class="o">=</span> <span class="n">mu_p</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="n">y</span> <span class="o">/</span> <span class="n">a1</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span>
                            <span class="p">(</span><span class="n">y</span> <span class="o">/</span> <span class="n">a2</span><span class="p">)</span><span class="o">**</span><span class="mf">2.</span> <span class="o">*</span> <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span>
                            <span class="mi">2</span> <span class="o">*</span> <span class="n">a2</span> <span class="o">/</span> <span class="n">a1</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span>

        <span class="n">hess_arr</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">dldada</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">hess_arr</span>

    <span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">exog</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">exposure</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">which</span><span class="o">=</span><span class="s1">'mean'</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Predict response variable of a count model given exogenous variables.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        If exposure is specified, then it will be logged by the method.</span>
<span class="sd">        The user does not need to log it first.</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="n">exog</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">exog</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exog</span>

        <span class="k">if</span> <span class="n">exposure</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">exposure</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">'exposure'</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">exposure</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">exposure</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">exposure</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">offset</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">'offset'</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

        <span class="n">fitted</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">exog</span><span class="p">,</span> <span class="n">params</span><span class="p">[:</span><span class="n">exog</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
        <span class="n">linpred</span> <span class="o">=</span> <span class="n">fitted</span> <span class="o">+</span> <span class="n">exposure</span> <span class="o">+</span> <span class="n">offset</span>

        <span class="k">if</span> <span class="n">which</span> <span class="o">==</span> <span class="s1">'mean'</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">linpred</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">which</span> <span class="o">==</span> <span class="s1">'linear'</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">linpred</span>
        <span class="k">elif</span> <span class="n">which</span> <span class="o">==</span><span class="s1">'prob'</span><span class="p">:</span>
            <span class="n">counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endog</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
            <span class="n">mu</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">exog</span><span class="o">=</span><span class="n">exog</span><span class="p">,</span> <span class="n">exposure</span><span class="o">=</span><span class="n">exposure</span><span class="p">,</span>
                              <span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">)[:,</span><span class="kc">None</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">genpoisson_p</span><span class="o">.</span><span class="n">pmf</span><span class="p">(</span><span class="n">counts</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">params</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">parameterization</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'keyword </span><span class="se">\'</span><span class="s1">which</span><span class="se">\'</span><span class="s1"> not recognized'</span><span class="p">)</span>


<div class="viewcode-block" id="Logit"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.Logit.html#statsmodels.discrete.count_model.Logit">[docs]</a><span class="k">class</span> <span class="nc">Logit</span><span class="p">(</span><span class="n">BinaryModel</span><span class="p">):</span>
    <span class="vm">__doc__</span> <span class="o">=</span> <span class="s2">"""</span>
<span class="s2">    Logit Model</span>

<span class="s2">    </span><span class="si">%(params)s</span><span class="s2"></span>
<span class="s2">    </span><span class="si">%(extra_params)s</span><span class="s2"></span>

<span class="s2">    Attributes</span>
<span class="s2">    ----------</span>
<span class="s2">    endog : ndarray</span>
<span class="s2">        A reference to the endogenous response variable</span>
<span class="s2">    exog : ndarray</span>
<span class="s2">        A reference to the exogenous design.</span>
<span class="s2">    """</span> <span class="o">%</span> <span class="p">{</span><span class="s1">'params'</span><span class="p">:</span> <span class="n">base</span><span class="o">.</span><span class="n">_model_params_doc</span><span class="p">,</span>
           <span class="s1">'extra_params'</span><span class="p">:</span> <span class="n">base</span><span class="o">.</span><span class="n">_missing_param_doc</span> <span class="o">+</span> <span class="n">_check_rank_doc</span><span class="p">}</span>

    <span class="n">_continuous_ok</span> <span class="o">=</span> <span class="kc">True</span>

<div class="viewcode-block" id="Logit.cdf"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.Logit.cdf.html#statsmodels.discrete.count_model.Logit.cdf">[docs]</a>    <span class="k">def</span> <span class="nf">cdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        The logistic cumulative distribution function</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X : array_like</span>
<span class="sd">            `X` is the linear predictor of the logit model.  See notes.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        1/(1 + exp(-X))</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        In the logit model,</span>

<span class="sd">        .. math:: \\Lambda\\left(x^{\\prime}\\beta\\right)=</span>
<span class="sd">                  \\text{Prob}\\left(Y=1|x\\right)=</span>
<span class="sd">                  \\frac{e^{x^{\\prime}\\beta}}{1+e^{x^{\\prime}\\beta}}</span>
<span class="sd">        """</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">X</span><span class="p">))</span></div>

<div class="viewcode-block" id="Logit.pdf"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.Logit.pdf.html#statsmodels.discrete.count_model.Logit.pdf">[docs]</a>    <span class="k">def</span> <span class="nf">pdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        The logistic probability density function</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X : array_like</span>
<span class="sd">            `X` is the linear predictor of the logit model.  See notes.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pdf : ndarray</span>
<span class="sd">            The value of the Logit probability mass function, PMF, for each</span>
<span class="sd">            point of X. ``np.exp(-x)/(1+np.exp(-X))**2``</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        In the logit model,</span>

<span class="sd">        .. math:: \\lambda\\left(x^{\\prime}\\beta\\right)=\\frac{e^{-x^{\\prime}\\beta}}{\\left(1+e^{-x^{\\prime}\\beta}\\right)^{2}}</span>
<span class="sd">        """</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">X</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">X</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span></div>

<div class="viewcode-block" id="Logit.loglike"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.Logit.loglike.html#statsmodels.discrete.count_model.Logit.loglike">[docs]</a>    <span class="k">def</span> <span class="nf">loglike</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Log-likelihood of logit model.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array_like</span>
<span class="sd">            The parameters of the logit model.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        loglike : float</span>
<span class="sd">            The log-likelihood function of the model evaluated at `params`.</span>
<span class="sd">            See notes.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        .. math::</span>

<span class="sd">           \\ln L=\\sum_{i}\\ln\\Lambda</span>
<span class="sd">           \\left(q_{i}x_{i}^{\\prime}\\beta\\right)</span>

<span class="sd">        Where :math:`q=2y-1`. This simplification comes from the fact that the</span>
<span class="sd">        logistic distribution is symmetric.</span>
<span class="sd">        """</span>
        <span class="n">q</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">endog</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">X</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exog</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">q</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">params</span><span class="p">))))</span></div>

<div class="viewcode-block" id="Logit.loglikeobs"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.Logit.loglikeobs.html#statsmodels.discrete.count_model.Logit.loglikeobs">[docs]</a>    <span class="k">def</span> <span class="nf">loglikeobs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Log-likelihood of logit model for each observation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array_like</span>
<span class="sd">            The parameters of the logit model.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        loglike : ndarray</span>
<span class="sd">            The log likelihood for each observation of the model evaluated</span>
<span class="sd">            at `params`. See Notes</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        .. math::</span>

<span class="sd">           \\ln L=\\sum_{i}\\ln\\Lambda</span>
<span class="sd">           \\left(q_{i}x_{i}^{\\prime}\\beta\\right)</span>

<span class="sd">        for observations :math:`i=1,...,n`</span>

<span class="sd">        where :math:`q=2y-1`. This simplification comes from the fact that the</span>
<span class="sd">        logistic distribution is symmetric.</span>
<span class="sd">        """</span>
        <span class="n">q</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">endog</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">X</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exog</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">q</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">params</span><span class="p">)))</span></div>

<div class="viewcode-block" id="Logit.score"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.Logit.score.html#statsmodels.discrete.count_model.Logit.score">[docs]</a>    <span class="k">def</span> <span class="nf">score</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Logit model score (gradient) vector of the log-likelihood</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array_like</span>
<span class="sd">            The parameters of the model</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        score : ndarray, 1-D</span>
<span class="sd">            The score vector of the model, i.e. the first derivative of the</span>
<span class="sd">            loglikelihood function, evaluated at `params`</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        .. math:: \\frac{\\partial\\ln L}{\\partial\\beta}=\\sum_{i=1}^{n}\\left(y_{i}-\\Lambda_{i}\\right)x_{i}</span>
<span class="sd">        """</span>

        <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">endog</span>
        <span class="n">X</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exog</span>
        <span class="n">L</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">params</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">L</span><span class="p">,</span><span class="n">X</span><span class="p">)</span></div>

<div class="viewcode-block" id="Logit.score_obs"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.Logit.score_obs.html#statsmodels.discrete.count_model.Logit.score_obs">[docs]</a>    <span class="k">def</span> <span class="nf">score_obs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Logit model Jacobian of the log-likelihood for each observation</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array_like</span>
<span class="sd">            The parameters of the model</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        jac : array_like</span>
<span class="sd">            The derivative of the loglikelihood for each observation evaluated</span>
<span class="sd">            at `params`.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        .. math:: \\frac{\\partial\\ln L_{i}}{\\partial\\beta}=\\left(y_{i}-\\Lambda_{i}\\right)x_{i}</span>

<span class="sd">        for observations :math:`i=1,...,n`</span>
<span class="sd">        """</span>

        <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">endog</span>
        <span class="n">X</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exog</span>
        <span class="n">L</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">params</span><span class="p">))</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">L</span><span class="p">)[:,</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">X</span></div>

<div class="viewcode-block" id="Logit.hessian"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.Logit.hessian.html#statsmodels.discrete.count_model.Logit.hessian">[docs]</a>    <span class="k">def</span> <span class="nf">hessian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Logit model Hessian matrix of the log-likelihood</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array_like</span>
<span class="sd">            The parameters of the model</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        hess : ndarray, (k_vars, k_vars)</span>
<span class="sd">            The Hessian, second derivative of loglikelihood function,</span>
<span class="sd">            evaluated at `params`</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        .. math:: \\frac{\\partial^{2}\\ln L}{\\partial\\beta\\partial\\beta^{\\prime}}=-\\sum_{i}\\Lambda_{i}\\left(1-\\Lambda_{i}\\right)x_{i}x_{i}^{\\prime}</span>
<span class="sd">        """</span>
        <span class="n">X</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exog</span>
        <span class="n">L</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">params</span><span class="p">))</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">L</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">L</span><span class="p">)</span><span class="o">*</span><span class="n">X</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">X</span><span class="p">)</span></div>

<div class="viewcode-block" id="Logit.fit"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.Logit.fit.html#statsmodels.discrete.count_model.Logit.fit">[docs]</a>    <span class="nd">@Appender</span><span class="p">(</span><span class="n">DiscreteModel</span><span class="o">.</span><span class="n">fit</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">'newton'</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="mi">35</span><span class="p">,</span>
            <span class="n">full_output</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">disp</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">bnryfit</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">start_params</span><span class="o">=</span><span class="n">start_params</span><span class="p">,</span>
                              <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
                              <span class="n">maxiter</span><span class="o">=</span><span class="n">maxiter</span><span class="p">,</span>
                              <span class="n">full_output</span><span class="o">=</span><span class="n">full_output</span><span class="p">,</span>
                              <span class="n">disp</span><span class="o">=</span><span class="n">disp</span><span class="p">,</span>
                              <span class="n">callback</span><span class="o">=</span><span class="n">callback</span><span class="p">,</span>
                              <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="n">discretefit</span> <span class="o">=</span> <span class="n">LogitResults</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bnryfit</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">BinaryResultsWrapper</span><span class="p">(</span><span class="n">discretefit</span><span class="p">)</span></div></div>


<span class="k">class</span> <span class="nc">Probit</span><span class="p">(</span><span class="n">BinaryModel</span><span class="p">):</span>
    <span class="vm">__doc__</span> <span class="o">=</span> <span class="s2">"""</span>
<span class="s2">    Probit Model</span>

<span class="s2">    </span><span class="si">%(params)s</span><span class="s2"></span>
<span class="s2">    </span><span class="si">%(extra_params)s</span><span class="s2"></span>

<span class="s2">    Attributes</span>
<span class="s2">    ----------</span>
<span class="s2">    endog : ndarray</span>
<span class="s2">        A reference to the endogenous response variable</span>
<span class="s2">    exog : ndarray</span>
<span class="s2">        A reference to the exogenous design.</span>
<span class="s2">    """</span> <span class="o">%</span> <span class="p">{</span><span class="s1">'params'</span><span class="p">:</span> <span class="n">base</span><span class="o">.</span><span class="n">_model_params_doc</span><span class="p">,</span>
           <span class="s1">'extra_params'</span><span class="p">:</span> <span class="n">base</span><span class="o">.</span><span class="n">_missing_param_doc</span> <span class="o">+</span> <span class="n">_check_rank_doc</span><span class="p">}</span>

    <span class="k">def</span> <span class="nf">cdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Probit (Normal) cumulative distribution function</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X : array_like</span>
<span class="sd">            The linear predictor of the model (XB).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        cdf : ndarray</span>
<span class="sd">            The cdf evaluated at `X`.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This function is just an alias for scipy.stats.norm.cdf</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">_cdf</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">pdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Probit (Normal) probability density function</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X : array_like</span>
<span class="sd">            The linear predictor of the model (XB).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pdf : ndarray</span>
<span class="sd">            The value of the normal density function for each point of X.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This function is just an alias for scipy.stats.norm.pdf</span>
<span class="sd">        """</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">_pdf</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">loglike</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Log-likelihood of probit model (i.e., the normal distribution).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array_like</span>
<span class="sd">            The parameters of the model.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        loglike : float</span>
<span class="sd">            The log-likelihood function of the model evaluated at `params`.</span>
<span class="sd">            See notes.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        .. math:: \\ln L=\\sum_{i}\\ln\\Phi\\left(q_{i}x_{i}^{\\prime}\\beta\\right)</span>

<span class="sd">        Where :math:`q=2y-1`. This simplification comes from the fact that the</span>
<span class="sd">        normal distribution is symmetric.</span>
<span class="sd">        """</span>

        <span class="n">q</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">endog</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">X</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exog</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">q</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">params</span><span class="p">)),</span>
            <span class="n">FLOAT_EPS</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span>

    <span class="k">def</span> <span class="nf">loglikeobs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Log-likelihood of probit model for each observation</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array_like</span>
<span class="sd">            The parameters of the model.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        loglike : array_like</span>
<span class="sd">            The log likelihood for each observation of the model evaluated</span>
<span class="sd">            at `params`. See Notes</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        .. math:: \\ln L_{i}=\\ln\\Phi\\left(q_{i}x_{i}^{\\prime}\\beta\\right)</span>

<span class="sd">        for observations :math:`i=1,...,n`</span>

<span class="sd">        where :math:`q=2y-1`. This simplification comes from the fact that the</span>
<span class="sd">        normal distribution is symmetric.</span>
<span class="sd">        """</span>

        <span class="n">q</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">endog</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">X</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exog</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">q</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">params</span><span class="p">)),</span> <span class="n">FLOAT_EPS</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>


    <span class="k">def</span> <span class="nf">score</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Probit model score (gradient) vector</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array_like</span>
<span class="sd">            The parameters of the model</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        score : ndarray, 1-D</span>
<span class="sd">            The score vector of the model, i.e. the first derivative of the</span>
<span class="sd">            loglikelihood function, evaluated at `params`</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        .. math:: \\frac{\\partial\\ln L}{\\partial\\beta}=\\sum_{i=1}^{n}\\left[\\frac{q_{i}\\phi\\left(q_{i}x_{i}^{\\prime}\\beta\\right)}{\\Phi\\left(q_{i}x_{i}^{\\prime}\\beta\\right)}\\right]x_{i}</span>

<span class="sd">        Where :math:`q=2y-1`. This simplification comes from the fact that the</span>
<span class="sd">        normal distribution is symmetric.</span>
<span class="sd">        """</span>
        <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">endog</span>
        <span class="n">X</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exog</span>
        <span class="n">XB</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">params</span><span class="p">)</span>
        <span class="n">q</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">y</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="c1"># clip to get rid of invalid divide complaint</span>
        <span class="n">L</span> <span class="o">=</span> <span class="n">q</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="n">q</span><span class="o">*</span><span class="n">XB</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">q</span><span class="o">*</span><span class="n">XB</span><span class="p">),</span> <span class="n">FLOAT_EPS</span><span class="p">,</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">FLOAT_EPS</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">X</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">score_obs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Probit model Jacobian for each observation</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array_like</span>
<span class="sd">            The parameters of the model</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        jac : array_like</span>
<span class="sd">            The derivative of the loglikelihood for each observation evaluated</span>
<span class="sd">            at `params`.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        .. math:: \\frac{\\partial\\ln L_{i}}{\\partial\\beta}=\\left[\\frac{q_{i}\\phi\\left(q_{i}x_{i}^{\\prime}\\beta\\right)}{\\Phi\\left(q_{i}x_{i}^{\\prime}\\beta\\right)}\\right]x_{i}</span>

<span class="sd">        for observations :math:`i=1,...,n`</span>

<span class="sd">        Where :math:`q=2y-1`. This simplification comes from the fact that the</span>
<span class="sd">        normal distribution is symmetric.</span>
<span class="sd">        """</span>
        <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">endog</span>
        <span class="n">X</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exog</span>
        <span class="n">XB</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">params</span><span class="p">)</span>
        <span class="n">q</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">y</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="c1"># clip to get rid of invalid divide complaint</span>
        <span class="n">L</span> <span class="o">=</span> <span class="n">q</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="n">q</span><span class="o">*</span><span class="n">XB</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">q</span><span class="o">*</span><span class="n">XB</span><span class="p">),</span> <span class="n">FLOAT_EPS</span><span class="p">,</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">FLOAT_EPS</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">L</span><span class="p">[:,</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">X</span>

    <span class="k">def</span> <span class="nf">hessian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Probit model Hessian matrix of the log-likelihood</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array_like</span>
<span class="sd">            The parameters of the model</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        hess : ndarray, (k_vars, k_vars)</span>
<span class="sd">            The Hessian, second derivative of loglikelihood function,</span>
<span class="sd">            evaluated at `params`</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        .. math:: \\frac{\\partial^{2}\\ln L}{\\partial\\beta\\partial\\beta^{\\prime}}=-\\lambda_{i}\\left(\\lambda_{i}+x_{i}^{\\prime}\\beta\\right)x_{i}x_{i}^{\\prime}</span>

<span class="sd">        where</span>

<span class="sd">        .. math:: \\lambda_{i}=\\frac{q_{i}\\phi\\left(q_{i}x_{i}^{\\prime}\\beta\\right)}{\\Phi\\left(q_{i}x_{i}^{\\prime}\\beta\\right)}</span>

<span class="sd">        and :math:`q=2y-1`</span>
<span class="sd">        """</span>
        <span class="n">X</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exog</span>
        <span class="n">XB</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">params</span><span class="p">)</span>
        <span class="n">q</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">endog</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">L</span> <span class="o">=</span> <span class="n">q</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="n">q</span><span class="o">*</span><span class="n">XB</span><span class="p">)</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">q</span><span class="o">*</span><span class="n">XB</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="o">-</span><span class="n">L</span><span class="o">*</span><span class="p">(</span><span class="n">L</span><span class="o">+</span><span class="n">XB</span><span class="p">)</span><span class="o">*</span><span class="n">X</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">X</span><span class="p">)</span>

    <span class="nd">@Appender</span><span class="p">(</span><span class="n">DiscreteModel</span><span class="o">.</span><span class="n">fit</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">'newton'</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="mi">35</span><span class="p">,</span>
            <span class="n">full_output</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">disp</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">bnryfit</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">start_params</span><span class="o">=</span><span class="n">start_params</span><span class="p">,</span>
                              <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
                              <span class="n">maxiter</span><span class="o">=</span><span class="n">maxiter</span><span class="p">,</span>
                              <span class="n">full_output</span><span class="o">=</span><span class="n">full_output</span><span class="p">,</span>
                              <span class="n">disp</span><span class="o">=</span><span class="n">disp</span><span class="p">,</span>
                              <span class="n">callback</span><span class="o">=</span><span class="n">callback</span><span class="p">,</span>
                              <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">discretefit</span> <span class="o">=</span> <span class="n">ProbitResults</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bnryfit</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">BinaryResultsWrapper</span><span class="p">(</span><span class="n">discretefit</span><span class="p">)</span>


<div class="viewcode-block" id="MNLogit"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.MNLogit.html#statsmodels.discrete.count_model.MNLogit">[docs]</a><span class="k">class</span> <span class="nc">MNLogit</span><span class="p">(</span><span class="n">MultinomialModel</span><span class="p">):</span>
    <span class="vm">__doc__</span> <span class="o">=</span> <span class="s2">"""</span>
<span class="s2">    Multinomial Logit Model</span>

<span class="s2">    Parameters</span>
<span class="s2">    ----------</span>
<span class="s2">    endog : array_like</span>
<span class="s2">        `endog` is an 1-d vector of the endogenous response.  `endog` can</span>
<span class="s2">        contain strings, ints, or floats or may be a pandas Categorical Series.</span>
<span class="s2">        Note that if it contains strings, every distinct string will be a</span>
<span class="s2">        category.  No stripping of whitespace is done.</span>
<span class="s2">    exog : array_like</span>
<span class="s2">        A nobs x k array where `nobs` is the number of observations and `k`</span>
<span class="s2">        is the number of regressors. An intercept is not included by default</span>
<span class="s2">        and should be added by the user. See `statsmodels.tools.add_constant`.</span>
<span class="s2">    </span><span class="si">%(extra_params)s</span><span class="s2"></span>

<span class="s2">    Attributes</span>
<span class="s2">    ----------</span>
<span class="s2">    endog : ndarray</span>
<span class="s2">        A reference to the endogenous response variable</span>
<span class="s2">    exog : ndarray</span>
<span class="s2">        A reference to the exogenous design.</span>
<span class="s2">    J : float</span>
<span class="s2">        The number of choices for the endogenous variable. Note that this</span>
<span class="s2">        is zero-indexed.</span>
<span class="s2">    K : float</span>
<span class="s2">        The actual number of parameters for the exogenous design.  Includes</span>
<span class="s2">        the constant if the design has one.</span>
<span class="s2">    names : dict</span>
<span class="s2">        A dictionary mapping the column number in `wendog` to the variables</span>
<span class="s2">        in `endog`.</span>
<span class="s2">    wendog : ndarray</span>
<span class="s2">        An n x j array where j is the number of unique categories in `endog`.</span>
<span class="s2">        Each column of j is a dummy variable indicating the category of</span>
<span class="s2">        each observation. See `names` for a dictionary mapping each column to</span>
<span class="s2">        its category.</span>

<span class="s2">    Notes</span>
<span class="s2">    -----</span>
<span class="s2">    See developer notes for further information on `MNLogit` internals.</span>
<span class="s2">    """</span> <span class="o">%</span> <span class="p">{</span><span class="s1">'extra_params'</span><span class="p">:</span> <span class="n">base</span><span class="o">.</span><span class="n">_missing_param_doc</span> <span class="o">+</span> <span class="n">_check_rank_doc</span><span class="p">}</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">endog</span><span class="p">,</span> <span class="n">exog</span><span class="p">,</span> <span class="n">check_rank</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">endog</span><span class="p">,</span> <span class="n">exog</span><span class="p">,</span> <span class="n">check_rank</span><span class="o">=</span><span class="n">check_rank</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Override cov_names since multivariate model</span>
        <span class="n">yname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">endog_names</span>
        <span class="n">ynames</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ynames_map</span>
        <span class="n">ynames</span> <span class="o">=</span> <span class="n">MultinomialResults</span><span class="o">.</span><span class="n">_maybe_convert_ynames_int</span><span class="p">(</span><span class="n">ynames</span><span class="p">)</span>
        <span class="c1"># use range below to ensure sortedness</span>
        <span class="n">ynames</span> <span class="o">=</span> <span class="p">[</span><span class="n">ynames</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">J</span><span class="p">))]</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">MultiIndex</span><span class="o">.</span><span class="n">from_product</span><span class="p">((</span><span class="n">ynames</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">xnames</span><span class="p">),</span>
                                      <span class="n">names</span><span class="o">=</span><span class="p">(</span><span class="n">yname</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">cov_names</span> <span class="o">=</span> <span class="n">idx</span>

<div class="viewcode-block" id="MNLogit.pdf"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.MNLogit.pdf.html#statsmodels.discrete.count_model.MNLogit.pdf">[docs]</a>    <span class="k">def</span> <span class="nf">pdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">eXB</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        NotImplemented</span>
<span class="sd">        """</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>

<div class="viewcode-block" id="MNLogit.cdf"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.MNLogit.cdf.html#statsmodels.discrete.count_model.MNLogit.cdf">[docs]</a>    <span class="k">def</span> <span class="nf">cdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Multinomial logit cumulative distribution function.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X : ndarray</span>
<span class="sd">            The linear predictor of the model XB.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        cdf : ndarray</span>
<span class="sd">            The cdf evaluated at `X`.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        In the multinomial logit model.</span>
<span class="sd">        .. math:: \\frac{\\exp\\left(\\beta_{j}^{\\prime}x_{i}\\right)}{\\sum_{k=0}^{J}\\exp\\left(\\beta_{k}^{\\prime}x_{i}\\right)}</span>
<span class="sd">        """</span>
        <span class="n">eXB</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">X</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">eXB</span><span class="o">/</span><span class="n">eXB</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">)[:,</span><span class="kc">None</span><span class="p">]</span></div>

<div class="viewcode-block" id="MNLogit.loglike"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.MNLogit.loglike.html#statsmodels.discrete.count_model.MNLogit.loglike">[docs]</a>    <span class="k">def</span> <span class="nf">loglike</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Log-likelihood of the multinomial logit model.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array_like</span>
<span class="sd">            The parameters of the multinomial logit model.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        loglike : float</span>
<span class="sd">            The log-likelihood function of the model evaluated at `params`.</span>
<span class="sd">            See notes.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        .. math::</span>

<span class="sd">           \\ln L=\\sum_{i=1}^{n}\\sum_{j=0}^{J}d_{ij}\\ln</span>
<span class="sd">           \\left(\\frac{\\exp\\left(\\beta_{j}^{\\prime}x_{i}\\right)}</span>
<span class="sd">           {\\sum_{k=0}^{J}</span>
<span class="sd">           \\exp\\left(\\beta_{k}^{\\prime}x_{i}\\right)}\\right)</span>

<span class="sd">        where :math:`d_{ij}=1` if individual `i` chose alternative `j` and 0</span>
<span class="sd">        if not.</span>
<span class="sd">        """</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">params</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">'F'</span><span class="p">)</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wendog</span>
        <span class="n">logprob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exog</span><span class="p">,</span><span class="n">params</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">d</span> <span class="o">*</span> <span class="n">logprob</span><span class="p">)</span></div>

<div class="viewcode-block" id="MNLogit.loglikeobs"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.MNLogit.loglikeobs.html#statsmodels.discrete.count_model.MNLogit.loglikeobs">[docs]</a>    <span class="k">def</span> <span class="nf">loglikeobs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Log-likelihood of the multinomial logit model for each observation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array_like</span>
<span class="sd">            The parameters of the multinomial logit model.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        loglike : array_like</span>
<span class="sd">            The log likelihood for each observation of the model evaluated</span>
<span class="sd">            at `params`. See Notes</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        .. math::</span>

<span class="sd">           \\ln L_{i}=\\sum_{j=0}^{J}d_{ij}\\ln</span>
<span class="sd">           \\left(\\frac{\\exp\\left(\\beta_{j}^{\\prime}x_{i}\\right)}</span>
<span class="sd">           {\\sum_{k=0}^{J}</span>
<span class="sd">           \\exp\\left(\\beta_{k}^{\\prime}x_{i}\\right)}\\right)</span>

<span class="sd">        for observations :math:`i=1,...,n`</span>

<span class="sd">        where :math:`d_{ij}=1` if individual `i` chose alternative `j` and 0</span>
<span class="sd">        if not.</span>
<span class="sd">        """</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">params</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">'F'</span><span class="p">)</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wendog</span>
        <span class="n">logprob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exog</span><span class="p">,</span><span class="n">params</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">d</span> <span class="o">*</span> <span class="n">logprob</span></div>

<div class="viewcode-block" id="MNLogit.score"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.MNLogit.score.html#statsmodels.discrete.count_model.MNLogit.score">[docs]</a>    <span class="k">def</span> <span class="nf">score</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Score matrix for multinomial logit model log-likelihood</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : ndarray</span>
<span class="sd">            The parameters of the multinomial logit model.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        score : ndarray, (K * (J-1),)</span>
<span class="sd">            The 2-d score vector, i.e. the first derivative of the</span>
<span class="sd">            loglikelihood function, of the multinomial logit model evaluated at</span>
<span class="sd">            `params`.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        .. math:: \\frac{\\partial\\ln L}{\\partial\\beta_{j}}=\\sum_{i}\\left(d_{ij}-\\frac{\\exp\\left(\\beta_{j}^{\\prime}x_{i}\\right)}{\\sum_{k=0}^{J}\\exp\\left(\\beta_{k}^{\\prime}x_{i}\\right)}\\right)x_{i}</span>

<span class="sd">        for :math:`j=1,...,J`</span>

<span class="sd">        In the multinomial model the score matrix is K x J-1 but is returned</span>
<span class="sd">        as a flattened array to work with the solvers.</span>
<span class="sd">        """</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">params</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">'F'</span><span class="p">)</span>
        <span class="n">firstterm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wendog</span><span class="p">[:,</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exog</span><span class="p">,</span>
                                                  <span class="n">params</span><span class="p">))[:,</span><span class="mi">1</span><span class="p">:]</span>
        <span class="c1">#NOTE: might need to switch terms if params is reshaped</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">firstterm</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">exog</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span></div>

<div class="viewcode-block" id="MNLogit.loglike_and_score"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.MNLogit.loglike_and_score.html#statsmodels.discrete.count_model.MNLogit.loglike_and_score">[docs]</a>    <span class="k">def</span> <span class="nf">loglike_and_score</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Returns log likelihood and score, efficiently reusing calculations.</span>

<span class="sd">        Note that both of these returned quantities will need to be negated</span>
<span class="sd">        before being minimized by the maximum likelihood fitting machinery.</span>
<span class="sd">        """</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">params</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">'F'</span><span class="p">)</span>
        <span class="n">cdf_dot_exog_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exog</span><span class="p">,</span> <span class="n">params</span><span class="p">))</span>
        <span class="n">loglike_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wendog</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">cdf_dot_exog_params</span><span class="p">))</span>
        <span class="n">firstterm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wendog</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">cdf_dot_exog_params</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:]</span>
        <span class="n">score_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">firstterm</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">exog</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">loglike_value</span><span class="p">,</span> <span class="n">score_array</span></div>

<div class="viewcode-block" id="MNLogit.score_obs"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.MNLogit.score_obs.html#statsmodels.discrete.count_model.MNLogit.score_obs">[docs]</a>    <span class="k">def</span> <span class="nf">score_obs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Jacobian matrix for multinomial logit model log-likelihood</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : ndarray</span>
<span class="sd">            The parameters of the multinomial logit model.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        jac : array_like</span>
<span class="sd">            The derivative of the loglikelihood for each observation evaluated</span>
<span class="sd">            at `params` .</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        .. math:: \\frac{\\partial\\ln L_{i}}{\\partial\\beta_{j}}=\\left(d_{ij}-\\frac{\\exp\\left(\\beta_{j}^{\\prime}x_{i}\\right)}{\\sum_{k=0}^{J}\\exp\\left(\\beta_{k}^{\\prime}x_{i}\\right)}\\right)x_{i}</span>

<span class="sd">        for :math:`j=1,...,J`, for observations :math:`i=1,...,n`</span>

<span class="sd">        In the multinomial model the score vector is K x (J-1) but is returned</span>
<span class="sd">        as a flattened array. The Jacobian has the observations in rows and</span>
<span class="sd">        the flattened array of derivatives in columns.</span>
<span class="sd">        """</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">params</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">'F'</span><span class="p">)</span>
        <span class="n">firstterm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wendog</span><span class="p">[:,</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exog</span><span class="p">,</span>
                                                  <span class="n">params</span><span class="p">))[:,</span><span class="mi">1</span><span class="p">:]</span>
        <span class="c1">#NOTE: might need to switch terms if params is reshaped</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">firstterm</span><span class="p">[:,:,</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">exog</span><span class="p">[:,</span><span class="kc">None</span><span class="p">,:])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exog</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span></div>

<div class="viewcode-block" id="MNLogit.hessian"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.MNLogit.hessian.html#statsmodels.discrete.count_model.MNLogit.hessian">[docs]</a>    <span class="k">def</span> <span class="nf">hessian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Multinomial logit Hessian matrix of the log-likelihood</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array_like</span>
<span class="sd">            The parameters of the model</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        hess : ndarray, (J*K, J*K)</span>
<span class="sd">            The Hessian, second derivative of loglikelihood function with</span>
<span class="sd">            respect to the flattened parameters, evaluated at `params`</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        .. math:: \\frac{\\partial^{2}\\ln L}{\\partial\\beta_{j}\\partial\\beta_{l}}=-\\sum_{i=1}^{n}\\frac{\\exp\\left(\\beta_{j}^{\\prime}x_{i}\\right)}{\\sum_{k=0}^{J}\\exp\\left(\\beta_{k}^{\\prime}x_{i}\\right)}\\left[\\boldsymbol{1}\\left(j=l\\right)-\\frac{\\exp\\left(\\beta_{l}^{\\prime}x_{i}\\right)}{\\sum_{k=0}^{J}\\exp\\left(\\beta_{k}^{\\prime}x_{i}\\right)}\\right]x_{i}x_{l}^{\\prime}</span>

<span class="sd">        where</span>
<span class="sd">        :math:`\\boldsymbol{1}\\left(j=l\\right)` equals 1 if `j` = `l` and 0</span>
<span class="sd">        otherwise.</span>

<span class="sd">        The actual Hessian matrix has J**2 * K x K elements. Our Hessian</span>
<span class="sd">        is reshaped to be square (J*K, J*K) so that the solvers can use it.</span>

<span class="sd">        This implementation does not take advantage of the symmetry of</span>
<span class="sd">        the Hessian and could probably be refactored for speed.</span>
<span class="sd">        """</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">params</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">'F'</span><span class="p">)</span>
        <span class="n">X</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exog</span>
        <span class="n">pr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">params</span><span class="p">))</span>
        <span class="n">partials</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">J</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">J</span>
        <span class="n">K</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">J</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">J</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span> <span class="c1"># this loop assumes we drop the first col.</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">:</span>
                    <span class="n">partials</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>\
                        <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(((</span><span class="n">pr</span><span class="p">[:,</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">pr</span><span class="p">[:,</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]))[:,</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="n">X</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">X</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">partials</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(((</span><span class="n">pr</span><span class="p">[:,</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">*-</span><span class="n">pr</span><span class="p">[:,</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">])[:,</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="n">X</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">X</span><span class="p">))</span>
        <span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">partials</span><span class="p">)</span>
        <span class="c1"># the developer's notes on multinomial should clear this math up</span>
        <span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">J</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">J</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">K</span><span class="p">,</span> <span class="n">K</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">J</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">K</span><span class="p">,</span> <span class="p">(</span><span class="n">J</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">K</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">H</span></div></div>


<span class="c1">#TODO: Weibull can replaced by a survival analsysis function</span>
<span class="c1"># like stat's streg (The cox model as well)</span>
<span class="c1">#class Weibull(DiscreteModel):</span>
<span class="c1">#    """</span>
<span class="c1">#    Binary choice Weibull model</span>
<span class="c1">#</span>
<span class="c1">#    Notes</span>
<span class="c1">#    ------</span>
<span class="c1">#    This is unfinished and untested.</span>
<span class="c1">#    """</span>
<span class="c1">##TODO: add analytic hessian for Weibull</span>
<span class="c1">#    def initialize(self):</span>
<span class="c1">#        pass</span>
<span class="c1">#</span>
<span class="c1">#    def cdf(self, X):</span>
<span class="c1">#        """</span>
<span class="c1">#        Gumbell (Log Weibull) cumulative distribution function</span>
<span class="c1">#        """</span>
<span class="c1">##        return np.exp(-np.exp(-X))</span>
<span class="c1">#        return stats.gumbel_r.cdf(X)</span>
<span class="c1">#        # these two are equivalent.</span>
<span class="c1">#        # Greene table and discussion is incorrect.</span>
<span class="c1">#</span>
<span class="c1">#    def pdf(self, X):</span>
<span class="c1">#        """</span>
<span class="c1">#        Gumbell (LogWeibull) probability distribution function</span>
<span class="c1">#        """</span>
<span class="c1">#        return stats.gumbel_r.pdf(X)</span>
<span class="c1">#</span>
<span class="c1">#    def loglike(self, params):</span>
<span class="c1">#        """</span>
<span class="c1">#        Loglikelihood of Weibull distribution</span>
<span class="c1">#        """</span>
<span class="c1">#        X = self.exog</span>
<span class="c1">#        cdf = self.cdf(np.dot(X,params))</span>
<span class="c1">#        y = self.endog</span>
<span class="c1">#        return np.sum(y*np.log(cdf) + (1-y)*np.log(1-cdf))</span>
<span class="c1">#</span>
<span class="c1">#    def score(self, params):</span>
<span class="c1">#        y = self.endog</span>
<span class="c1">#        X = self.exog</span>
<span class="c1">#        F = self.cdf(np.dot(X,params))</span>
<span class="c1">#        f = self.pdf(np.dot(X,params))</span>
<span class="c1">#        term = (y*f/F + (1 - y)*-f/(1-F))</span>
<span class="c1">#        return np.dot(term,X)</span>
<span class="c1">#</span>
<span class="c1">#    def hessian(self, params):</span>
<span class="c1">#        hess = nd.Jacobian(self.score)</span>
<span class="c1">#        return hess(params)</span>
<span class="c1">#</span>
<span class="c1">#    def fit(self, start_params=None, method='newton', maxiter=35, tol=1e-08):</span>
<span class="c1">## The example had problems with all zero start values, Hessian = 0</span>
<span class="c1">#        if start_params is None:</span>
<span class="c1">#            start_params = OLS(self.endog, self.exog).fit().params</span>
<span class="c1">#        mlefit = super(Weibull, self).fit(start_params=start_params,</span>
<span class="c1">#                method=method, maxiter=maxiter, tol=tol)</span>
<span class="c1">#        return mlefit</span>
<span class="c1">#</span>


<div class="viewcode-block" id="NegativeBinomial"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.NegativeBinomial.html#statsmodels.discrete.count_model.NegativeBinomial">[docs]</a><span class="k">class</span> <span class="nc">NegativeBinomial</span><span class="p">(</span><span class="n">CountModel</span><span class="p">):</span>
    <span class="vm">__doc__</span> <span class="o">=</span> <span class="s2">"""</span>
<span class="s2">    Negative Binomial Model</span>

<span class="s2">    </span><span class="si">%(params)s</span><span class="s2"></span>
<span class="s2">    </span><span class="si">%(extra_params)s</span><span class="s2"></span>

<span class="s2">    Attributes</span>
<span class="s2">    ----------</span>
<span class="s2">    endog : ndarray</span>
<span class="s2">        A reference to the endogenous response variable</span>
<span class="s2">    exog : ndarray</span>
<span class="s2">        A reference to the exogenous design.</span>

<span class="s2">    References</span>
<span class="s2">    ----------</span>
<span class="s2">    Greene, W. 2008. "Functional forms for the negative binomial model</span>
<span class="s2">        for count data". Economics Letters. Volume 99, Number 3, pp.585-590.</span>
<span class="s2">    Hilbe, J.M. 2011. "Negative binomial regression". Cambridge University</span>
<span class="s2">        Press.</span>
<span class="s2">    """</span> <span class="o">%</span> <span class="p">{</span><span class="s1">'params'</span><span class="p">:</span> <span class="n">base</span><span class="o">.</span><span class="n">_model_params_doc</span><span class="p">,</span>
           <span class="s1">'extra_params'</span><span class="p">:</span>
           <span class="sd">"""loglike_method : str</span>
<span class="sd">        Log-likelihood type. 'nb2','nb1', or 'geometric'.</span>
<span class="sd">        Fitted value :math:`\\mu`</span>
<span class="sd">        Heterogeneity parameter :math:`\\alpha`</span>

<span class="sd">        - nb2: Variance equal to :math:`\\mu + \\alpha\\mu^2` (most common)</span>
<span class="sd">        - nb1: Variance equal to :math:`\\mu + \\alpha\\mu`</span>
<span class="sd">        - geometric: Variance equal to :math:`\\mu + \\mu^2`</span>
<span class="sd">    offset : array_like</span>
<span class="sd">        Offset is added to the linear prediction with coefficient equal to 1.</span>
<span class="sd">    exposure : array_like</span>
<span class="sd">        Log(exposure) is added to the linear prediction with coefficient</span>
<span class="sd">        equal to 1.</span>
<span class="sd">    """</span> <span class="o">+</span> <span class="n">base</span><span class="o">.</span><span class="n">_missing_param_doc</span> <span class="o">+</span> <span class="n">_check_rank_doc</span><span class="p">}</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">endog</span><span class="p">,</span> <span class="n">exog</span><span class="p">,</span> <span class="n">loglike_method</span><span class="o">=</span><span class="s1">'nb2'</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">exposure</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">missing</span><span class="o">=</span><span class="s1">'none'</span><span class="p">,</span> <span class="n">check_rank</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">endog</span><span class="p">,</span>
                         <span class="n">exog</span><span class="p">,</span>
                         <span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">,</span>
                         <span class="n">exposure</span><span class="o">=</span><span class="n">exposure</span><span class="p">,</span>
                         <span class="n">missing</span><span class="o">=</span><span class="n">missing</span><span class="p">,</span>
                         <span class="n">check_rank</span><span class="o">=</span><span class="n">check_rank</span><span class="p">,</span>
                         <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loglike_method</span> <span class="o">=</span> <span class="n">loglike_method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initialize</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">loglike_method</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">'nb2'</span><span class="p">,</span> <span class="s1">'nb1'</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">exog_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">'alpha'</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">k_extra</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">k_extra</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># store keys for extras if we need to recreate model instance</span>
        <span class="c1"># we need to append keys that do not go to super</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_init_keys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">'loglike_method'</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_initialize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">loglike_method</span> <span class="o">==</span> <span class="s1">'nb2'</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">hessian</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hessian_nb2</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">score</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_score_nbin</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">loglikeobs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_nb2</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_transparams</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># transform lnalpha -&gt; alpha in fit</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">loglike_method</span> <span class="o">==</span> <span class="s1">'nb1'</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">hessian</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hessian_nb1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">score</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_score_nb1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">loglikeobs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_nb1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_transparams</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># transform lnalpha -&gt; alpha in fit</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">loglike_method</span> <span class="o">==</span> <span class="s1">'geometric'</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">hessian</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hessian_geom</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">score</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_score_geom</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">loglikeobs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_geometric</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'Likelihood type must "nb1", "nb2" '</span>
                             <span class="s1">'or "geometric"'</span><span class="p">)</span>

    <span class="c1"># Workaround to pickle instance methods</span>
    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">odict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>  <span class="c1"># copy the dict since we change it</span>
        <span class="k">del</span> <span class="n">odict</span><span class="p">[</span><span class="s1">'hessian'</span><span class="p">]</span>
        <span class="k">del</span> <span class="n">odict</span><span class="p">[</span><span class="s1">'score'</span><span class="p">]</span>
        <span class="k">del</span> <span class="n">odict</span><span class="p">[</span><span class="s1">'loglikeobs'</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">odict</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indict</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">indict</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initialize</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_ll_nbin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">Q</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">iscomplex</span><span class="p">(</span><span class="n">params</span><span class="p">))</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">iscomplex</span><span class="p">(</span><span class="n">alpha</span><span class="p">):</span>
            <span class="n">gamma_ln</span> <span class="o">=</span> <span class="n">loggamma</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">gamma_ln</span> <span class="o">=</span> <span class="n">gammaln</span>
        <span class="n">endog</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">endog</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
        <span class="n">size</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">alpha</span> <span class="o">*</span> <span class="n">mu</span><span class="o">**</span><span class="n">Q</span>
        <span class="n">prob</span> <span class="o">=</span> <span class="n">size</span><span class="o">/</span><span class="p">(</span><span class="n">size</span><span class="o">+</span><span class="n">mu</span><span class="p">)</span>
        <span class="n">coeff</span> <span class="o">=</span> <span class="p">(</span><span class="n">gamma_ln</span><span class="p">(</span><span class="n">size</span><span class="o">+</span><span class="n">endog</span><span class="p">)</span> <span class="o">-</span> <span class="n">gamma_ln</span><span class="p">(</span><span class="n">endog</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span>
                 <span class="n">gamma_ln</span><span class="p">(</span><span class="n">size</span><span class="p">))</span>
        <span class="n">llf</span> <span class="o">=</span> <span class="n">coeff</span> <span class="o">+</span> <span class="n">size</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">prob</span><span class="p">)</span> <span class="o">+</span> <span class="n">endog</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">prob</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">llf</span>

    <span class="k">def</span> <span class="nf">_ll_nb2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transparams</span><span class="p">:</span>  <span class="c1"># got lnalpha during fit</span>
            <span class="n">alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">alpha</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_nbin</span><span class="p">(</span><span class="n">params</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">Q</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_ll_nb1</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transparams</span><span class="p">:</span>  <span class="c1"># got lnalpha during fit</span>
            <span class="n">alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">alpha</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_nbin</span><span class="p">(</span><span class="n">params</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">Q</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_ll_geometric</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="c1"># we give alpha of 1 because it's actually log(alpha) where alpha=0</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_nbin</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

<div class="viewcode-block" id="NegativeBinomial.loglike"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.NegativeBinomial.loglike.html#statsmodels.discrete.count_model.NegativeBinomial.loglike">[docs]</a>    <span class="k">def</span> <span class="nf">loglike</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">"""</span>
<span class="sd">        Loglikelihood for negative binomial model</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array_like</span>
<span class="sd">            The parameters of the model. If `loglike_method` is nb1 or</span>
<span class="sd">            nb2, then the ancillary parameter is expected to be the</span>
<span class="sd">            last element.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        llf : float</span>
<span class="sd">            The loglikelihood value at `params`</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Following notation in Greene (2008), with negative binomial</span>
<span class="sd">        heterogeneity parameter :math:`\alpha`:</span>

<span class="sd">        .. math::</span>

<span class="sd">           \lambda_i &amp;= exp(X\beta) \\</span>
<span class="sd">           \theta &amp;= 1 / \alpha \\</span>
<span class="sd">           g_i &amp;= \theta \lambda_i^Q \\</span>
<span class="sd">           w_i &amp;= g_i/(g_i + \lambda_i) \\</span>
<span class="sd">           r_i &amp;= \theta / (\theta+\lambda_i) \\</span>
<span class="sd">           ln \mathcal{L}_i &amp;= ln \Gamma(y_i+g_i) - ln \Gamma(1+y_i) + g_iln (r_i) + y_i ln(1-r_i)</span>

<span class="sd">        where :math`Q=0` for NB2 and geometric and :math:`Q=1` for NB1.</span>
<span class="sd">        For the geometric, :math:`\alpha=0` as well.</span>
<span class="sd">        """</span>
        <span class="n">llf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loglikeobs</span><span class="p">(</span><span class="n">params</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">llf</span></div>

    <span class="k">def</span> <span class="nf">_score_geom</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="n">exog</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exog</span>
        <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">endog</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">params</span><span class="p">)[:,</span> <span class="kc">None</span><span class="p">]</span>
        <span class="n">dparams</span> <span class="o">=</span> <span class="n">exog</span> <span class="o">*</span> <span class="p">(</span><span class="n">y</span><span class="o">-</span><span class="n">mu</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">mu</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dparams</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_score_nbin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">Q</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Score vector for NB2 model</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transparams</span><span class="p">:</span> <span class="c1"># lnalpha came in during fit</span>
            <span class="n">alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">alpha</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">params</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">exog</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exog</span>
        <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">endog</span><span class="p">[:,</span><span class="kc">None</span><span class="p">]</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">params</span><span class="p">)[:,</span><span class="kc">None</span><span class="p">]</span>
        <span class="n">a1</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">alpha</span> <span class="o">*</span> <span class="n">mu</span><span class="o">**</span><span class="n">Q</span>
        <span class="n">prob</span> <span class="o">=</span> <span class="n">a1</span> <span class="o">/</span> <span class="p">(</span><span class="n">a1</span> <span class="o">+</span> <span class="n">mu</span><span class="p">)</span>  <span class="c1"># a1 aka "size" in _ll_nbin</span>
        <span class="k">if</span> <span class="n">Q</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># nb1</span>
            <span class="c1"># Q == 1 --&gt; a1 = mu / alpha --&gt; prob = 1 / (alpha + 1)</span>
            <span class="n">dgpart</span> <span class="o">=</span> <span class="n">digamma</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">a1</span><span class="p">)</span> <span class="o">-</span> <span class="n">digamma</span><span class="p">(</span><span class="n">a1</span><span class="p">)</span>
            <span class="n">dparams</span> <span class="o">=</span> <span class="n">exog</span> <span class="o">*</span> <span class="n">a1</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">prob</span><span class="p">)</span> <span class="o">+</span>
                       <span class="n">dgpart</span><span class="p">)</span>
            <span class="n">dalpha</span> <span class="o">=</span> <span class="p">((</span><span class="n">alpha</span> <span class="o">*</span> <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">mu</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">prob</span><span class="p">)</span> <span class="o">-</span>
                              <span class="n">mu</span><span class="o">*</span><span class="p">(</span><span class="n">dgpart</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="o">-</span>
                       <span class="n">mu</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">prob</span><span class="p">)</span> <span class="o">+</span>
                           <span class="n">dgpart</span><span class="p">))</span><span class="o">/</span>
                       <span class="p">(</span><span class="n">alpha</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">alpha</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

        <span class="k">elif</span> <span class="n">Q</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># nb2</span>
            <span class="n">dgpart</span> <span class="o">=</span> <span class="n">digamma</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">a1</span><span class="p">)</span> <span class="o">-</span> <span class="n">digamma</span><span class="p">(</span><span class="n">a1</span><span class="p">)</span>
            <span class="n">dparams</span> <span class="o">=</span> <span class="n">exog</span><span class="o">*</span><span class="n">a1</span> <span class="o">*</span> <span class="p">(</span><span class="n">y</span><span class="o">-</span><span class="n">mu</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">mu</span><span class="o">+</span><span class="n">a1</span><span class="p">)</span>
            <span class="n">da1</span> <span class="o">=</span> <span class="o">-</span><span class="n">alpha</span><span class="o">**-</span><span class="mi">2</span>
            <span class="n">dalpha</span> <span class="o">=</span> <span class="p">(</span><span class="n">dgpart</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">a1</span><span class="p">)</span>
                        <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">a1</span><span class="o">+</span><span class="n">mu</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">y</span><span class="o">-</span><span class="n">mu</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">a1</span><span class="o">+</span><span class="n">mu</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">*</span> <span class="n">da1</span>

        <span class="c1">#multiply above by constant outside sum to reduce rounding error</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transparams</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">dparams</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">dalpha</span><span class="o">*</span><span class="n">alpha</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">dparams</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">dalpha</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_score_nb1</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_score_nbin</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">Q</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_hessian_geom</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="n">exog</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exog</span>
        <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">endog</span><span class="p">[:,</span><span class="kc">None</span><span class="p">]</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">params</span><span class="p">)[:,</span><span class="kc">None</span><span class="p">]</span>

        <span class="c1"># for dl/dparams dparams</span>
        <span class="n">dim</span> <span class="o">=</span> <span class="n">exog</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">hess_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">dim</span><span class="p">,</span> <span class="n">dim</span><span class="p">))</span>
        <span class="n">const_arr</span> <span class="o">=</span> <span class="n">mu</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">y</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">mu</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="n">i</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">hess_arr</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">-</span><span class="n">exog</span><span class="p">[:,</span><span class="n">i</span><span class="p">,</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">exog</span><span class="p">[:,</span><span class="n">j</span><span class="p">,</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span>
                                       <span class="n">const_arr</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">tri_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">triu_indices</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">hess_arr</span><span class="p">[</span><span class="n">tri_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">hess_arr</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="n">tri_idx</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">hess_arr</span>


    <span class="k">def</span> <span class="nf">_hessian_nb1</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Hessian of NB1 model.</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transparams</span><span class="p">:</span> <span class="c1"># lnalpha came in during fit</span>
            <span class="n">alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">alpha</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">params</span> <span class="o">=</span> <span class="n">params</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">exog</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exog</span>
        <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">endog</span><span class="p">[:,</span><span class="kc">None</span><span class="p">]</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">params</span><span class="p">)[:,</span><span class="kc">None</span><span class="p">]</span>

        <span class="n">a1</span> <span class="o">=</span> <span class="n">mu</span><span class="o">/</span><span class="n">alpha</span>
        <span class="n">dgpart</span> <span class="o">=</span> <span class="n">digamma</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">a1</span><span class="p">)</span> <span class="o">-</span> <span class="n">digamma</span><span class="p">(</span><span class="n">a1</span><span class="p">)</span>
        <span class="n">prob</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">alpha</span><span class="p">)</span>  <span class="c1"># equiv: a1 / (a1 + mu)</span>

        <span class="c1"># for dl/dparams dparams</span>
        <span class="n">dim</span> <span class="o">=</span> <span class="n">exog</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">hess_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">dim</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">dim</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
        <span class="c1">#const_arr = a1*mu*(a1+y)/(mu+a1)**2</span>
        <span class="c1"># not all of dparams</span>
        <span class="n">dparams</span> <span class="o">=</span> <span class="n">exog</span> <span class="o">/</span> <span class="n">alpha</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">prob</span><span class="p">)</span> <span class="o">+</span>
                                  <span class="n">dgpart</span><span class="p">)</span>

        <span class="n">dmudb</span> <span class="o">=</span> <span class="n">exog</span><span class="o">*</span><span class="n">mu</span>
        <span class="n">xmu_alpha</span> <span class="o">=</span> <span class="n">exog</span> <span class="o">*</span> <span class="n">a1</span>
        <span class="n">trigamma</span> <span class="o">=</span> <span class="p">(</span><span class="n">special</span><span class="o">.</span><span class="n">polygamma</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">a1</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span> <span class="o">-</span>
                    <span class="n">special</span><span class="o">.</span><span class="n">polygamma</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">a1</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="n">i</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">hess_arr</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dparams</span><span class="p">[:,</span><span class="n">i</span><span class="p">,</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">dmudb</span><span class="p">[:,</span><span class="n">j</span><span class="p">,</span><span class="kc">None</span><span class="p">]</span> <span class="o">+</span>
                                 <span class="n">xmu_alpha</span><span class="p">[:,</span><span class="n">i</span><span class="p">,</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">xmu_alpha</span><span class="p">[:,</span><span class="n">j</span><span class="p">,</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span>
                                 <span class="n">trigamma</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">tri_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">triu_indices</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">hess_arr</span><span class="p">[</span><span class="n">tri_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">hess_arr</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="n">tri_idx</span><span class="p">]</span>

        <span class="c1"># for dl/dparams dalpha</span>
        <span class="n">da1</span> <span class="o">=</span> <span class="o">-</span><span class="n">alpha</span><span class="o">**-</span><span class="mi">2</span>
        <span class="n">dldpda</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">-</span><span class="n">a1</span> <span class="o">*</span> <span class="n">dparams</span> <span class="o">+</span> <span class="n">exog</span> <span class="o">*</span> <span class="n">a1</span> <span class="o">*</span>
                        <span class="p">(</span><span class="o">-</span><span class="n">trigamma</span><span class="o">*</span><span class="n">mu</span><span class="o">/</span><span class="n">alpha</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">prob</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="n">hess_arr</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">dldpda</span>
        <span class="n">hess_arr</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">dldpda</span>

        <span class="n">log_alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">prob</span><span class="p">)</span>
        <span class="n">alpha3</span> <span class="o">=</span> <span class="n">alpha</span><span class="o">**</span><span class="mi">3</span>
        <span class="n">alpha2</span> <span class="o">=</span> <span class="n">alpha</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">mu2</span> <span class="o">=</span> <span class="n">mu</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">dada</span> <span class="o">=</span> <span class="p">((</span><span class="n">alpha3</span><span class="o">*</span><span class="n">mu</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">log_alpha</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">dgpart</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span> <span class="o">-</span>
                 <span class="mi">2</span><span class="o">*</span><span class="n">alpha3</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span>
                 <span class="mi">4</span><span class="o">*</span><span class="n">alpha2</span><span class="o">*</span><span class="n">mu</span><span class="o">*</span><span class="p">(</span><span class="n">log_alpha</span> <span class="o">+</span> <span class="n">dgpart</span><span class="p">)</span> <span class="o">+</span>
                 <span class="n">alpha2</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">mu</span> <span class="o">-</span> <span class="n">y</span><span class="p">)</span> <span class="o">+</span>
                 <span class="mi">2</span><span class="o">*</span><span class="n">alpha</span><span class="o">*</span><span class="n">mu2</span><span class="o">*</span><span class="n">trigamma</span> <span class="o">+</span> <span class="n">mu2</span> <span class="o">*</span> <span class="n">trigamma</span> <span class="o">+</span> <span class="n">alpha2</span> <span class="o">*</span> <span class="n">mu2</span> <span class="o">*</span> <span class="n">trigamma</span> <span class="o">+</span>
                 <span class="mi">2</span><span class="o">*</span><span class="n">alpha</span><span class="o">*</span><span class="n">mu</span><span class="o">*</span><span class="p">(</span><span class="n">log_alpha</span> <span class="o">+</span> <span class="n">dgpart</span><span class="p">)</span>
                 <span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">alpha</span><span class="o">**</span><span class="mi">4</span><span class="o">*</span><span class="p">(</span><span class="n">alpha2</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">alpha</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span>
        <span class="n">hess_arr</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">dada</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">hess_arr</span>

    <span class="k">def</span> <span class="nf">_hessian_nb2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Hessian of NB2 model.</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transparams</span><span class="p">:</span> <span class="c1"># lnalpha came in during fit</span>
            <span class="n">alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">alpha</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">a1</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">alpha</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">params</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">exog</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exog</span>
        <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">endog</span><span class="p">[:,</span><span class="kc">None</span><span class="p">]</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">params</span><span class="p">)[:,</span><span class="kc">None</span><span class="p">]</span>
        <span class="n">prob</span> <span class="o">=</span> <span class="n">a1</span> <span class="o">/</span> <span class="p">(</span><span class="n">a1</span> <span class="o">+</span> <span class="n">mu</span><span class="p">)</span>
        <span class="n">dgpart</span> <span class="o">=</span> <span class="n">digamma</span><span class="p">(</span><span class="n">a1</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span> <span class="o">-</span> <span class="n">digamma</span><span class="p">(</span><span class="n">a1</span><span class="p">)</span>

        <span class="c1"># for dl/dparams dparams</span>
        <span class="n">dim</span> <span class="o">=</span> <span class="n">exog</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">hess_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">dim</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">dim</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">const_arr</span> <span class="o">=</span> <span class="n">a1</span><span class="o">*</span><span class="n">mu</span><span class="o">*</span><span class="p">(</span><span class="n">a1</span><span class="o">+</span><span class="n">y</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">mu</span><span class="o">+</span><span class="n">a1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="n">i</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">hess_arr</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">-</span><span class="n">exog</span><span class="p">[:,</span><span class="n">i</span><span class="p">,</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">exog</span><span class="p">[:,</span><span class="n">j</span><span class="p">,</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span>
                                       <span class="n">const_arr</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">tri_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">triu_indices</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">hess_arr</span><span class="p">[</span><span class="n">tri_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">hess_arr</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="n">tri_idx</span><span class="p">]</span>

        <span class="c1"># for dl/dparams dalpha</span>
        <span class="n">da1</span> <span class="o">=</span> <span class="o">-</span><span class="n">alpha</span><span class="o">**-</span><span class="mi">2</span>
        <span class="n">dldpda</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">mu</span><span class="o">*</span><span class="n">exog</span><span class="o">*</span><span class="p">(</span><span class="n">y</span><span class="o">-</span><span class="n">mu</span><span class="p">)</span><span class="o">*</span><span class="n">a1</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="p">(</span><span class="n">mu</span><span class="o">+</span><span class="n">a1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">hess_arr</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">dldpda</span>
        <span class="n">hess_arr</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">dldpda</span>

        <span class="c1"># for dl/dalpha dalpha</span>
        <span class="c1">#NOTE: polygamma(1,x) is the trigamma function</span>
        <span class="n">da2</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">alpha</span><span class="o">**-</span><span class="mi">3</span>
        <span class="n">dalpha</span> <span class="o">=</span> <span class="n">da1</span> <span class="o">*</span> <span class="p">(</span><span class="n">dgpart</span> <span class="o">+</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">prob</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">mu</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">a1</span><span class="o">+</span><span class="n">mu</span><span class="p">))</span>
        <span class="n">dada</span> <span class="o">=</span> <span class="p">(</span><span class="n">da2</span> <span class="o">*</span> <span class="n">dalpha</span><span class="o">/</span><span class="n">da1</span> <span class="o">+</span> <span class="n">da1</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">special</span><span class="o">.</span><span class="n">polygamma</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">a1</span><span class="o">+</span><span class="n">y</span><span class="p">)</span> <span class="o">-</span>
                    <span class="n">special</span><span class="o">.</span><span class="n">polygamma</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">a1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">/</span><span class="n">a1</span> <span class="o">-</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">a1</span> <span class="o">+</span> <span class="n">mu</span><span class="p">)</span> <span class="o">+</span>
                    <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">mu</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">mu</span> <span class="o">+</span> <span class="n">a1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">hess_arr</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">dada</span>

        <span class="k">return</span> <span class="n">hess_arr</span>

    <span class="c1">#TODO: replace this with analytic where is it used?</span>
<div class="viewcode-block" id="NegativeBinomial.score_obs"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.NegativeBinomial.score_obs.html#statsmodels.discrete.count_model.NegativeBinomial.score_obs">[docs]</a>    <span class="k">def</span> <span class="nf">score_obs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="n">sc</span> <span class="o">=</span> <span class="n">approx_fprime_cs</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">loglikeobs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">sc</span></div>

    <span class="nd">@Appender</span><span class="p">(</span><span class="n">_get_start_params_null_docs</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_get_start_params_null</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">"offset"</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">exposure</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">"exposure"</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">const</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endog</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">offset</span> <span class="o">+</span> <span class="n">exposure</span><span class="p">))</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        <span class="n">params</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">const</span><span class="p">)]</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="n">const</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">offset</span> <span class="o">+</span> <span class="n">exposure</span><span class="p">)</span>
        <span class="n">resid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">endog</span> <span class="o">-</span> <span class="n">mu</span>
        <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_estimate_dispersion</span><span class="p">(</span><span class="n">mu</span><span class="p">,</span> <span class="n">resid</span><span class="p">,</span> <span class="n">df_resid</span><span class="o">=</span><span class="n">resid</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">params</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_estimate_dispersion</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">resid</span><span class="p">,</span> <span class="n">df_resid</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">df_resid</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">df_resid</span> <span class="o">=</span> <span class="n">resid</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">loglike_method</span> <span class="o">==</span> <span class="s1">'nb2'</span><span class="p">:</span>
            <span class="c1">#params.append(np.linalg.pinv(mu[:,None]).dot(resid**2 / mu - 1))</span>
            <span class="n">a</span> <span class="o">=</span> <span class="p">((</span><span class="n">resid</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="n">mu</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">mu</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="n">df_resid</span>
        <span class="k">else</span><span class="p">:</span> <span class="c1">#self.loglike_method == 'nb1':</span>
            <span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="n">resid</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="n">mu</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="n">df_resid</span>
        <span class="k">return</span> <span class="n">a</span>

<div class="viewcode-block" id="NegativeBinomial.fit"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.NegativeBinomial.fit.html#statsmodels.discrete.count_model.NegativeBinomial.fit">[docs]</a>    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">'bfgs'</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="mi">35</span><span class="p">,</span>
            <span class="n">full_output</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">disp</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">cov_type</span><span class="o">=</span><span class="s1">'nonrobust'</span><span class="p">,</span> <span class="n">cov_kwds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">use_t</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

        <span class="c1"># Note: do not let super handle robust covariance because it has</span>
        <span class="c1"># transformed params</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_transparams</span> <span class="o">=</span> <span class="kc">False</span> <span class="c1"># always define attribute</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">loglike_method</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">'nb'</span><span class="p">)</span> <span class="ow">and</span> <span class="n">method</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">'newton'</span><span class="p">,</span>
                                                                   <span class="s1">'ncg'</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_transparams</span> <span class="o">=</span> <span class="kc">True</span> <span class="c1"># in case same Model instance is refit</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">loglike_method</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">'nb'</span><span class="p">):</span> <span class="c1"># method is newton/ncg</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_transparams</span> <span class="o">=</span> <span class="kc">False</span> <span class="c1"># because we need to step in alpha space</span>

        <span class="k">if</span> <span class="n">start_params</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Use poisson fit as first guess.</span>
            <span class="c1">#TODO, Warning: this assumes exposure is logged</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">"offset"</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">"exposure"</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">offset</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">offset</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">offset</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">optim_kwds_prelim</span> <span class="o">=</span> <span class="p">{</span><span class="s1">'disp'</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">'skip_hessian'</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
                                 <span class="s1">'warn_convergence'</span><span class="p">:</span> <span class="kc">False</span><span class="p">}</span>
            <span class="n">optim_kwds_prelim</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">'optim_kwds_prelim'</span><span class="p">,</span> <span class="p">{}))</span>
            <span class="n">mod_poi</span> <span class="o">=</span> <span class="n">Poisson</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endog</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">exog</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">)</span>
            <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">():</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s2">"always"</span><span class="p">)</span>
                <span class="n">res_poi</span> <span class="o">=</span> <span class="n">mod_poi</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="o">**</span><span class="n">optim_kwds_prelim</span><span class="p">)</span>
            <span class="n">start_params</span> <span class="o">=</span> <span class="n">res_poi</span><span class="o">.</span><span class="n">params</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">loglike_method</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">'nb'</span><span class="p">):</span>
                <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_estimate_dispersion</span><span class="p">(</span><span class="n">res_poi</span><span class="o">.</span><span class="n">predict</span><span class="p">(),</span> <span class="n">res_poi</span><span class="o">.</span><span class="n">resid</span><span class="p">,</span>
                                              <span class="n">df_resid</span><span class="o">=</span><span class="n">res_poi</span><span class="o">.</span><span class="n">df_resid</span><span class="p">)</span>
                <span class="n">start_params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">start_params</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">a</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transparams</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="c1"># transform user provided start_params dispersion, see #3918</span>
                <span class="n">start_params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">start_params</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">start_params</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">start_params</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">callback</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># work around perfect separation callback #3895</span>
            <span class="n">callback</span> <span class="o">=</span> <span class="k">lambda</span> <span class="o">*</span><span class="n">x</span><span class="p">:</span> <span class="n">x</span>

        <span class="n">mlefit</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">start_params</span><span class="o">=</span><span class="n">start_params</span><span class="p">,</span>
                             <span class="n">maxiter</span><span class="o">=</span><span class="n">maxiter</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">disp</span><span class="o">=</span><span class="n">disp</span><span class="p">,</span>
                             <span class="n">full_output</span><span class="o">=</span><span class="n">full_output</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="n">callback</span><span class="p">,</span>
                             <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                        <span class="c1"># TODO: Fix NBin _check_perfect_pred</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">loglike_method</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">'nb'</span><span class="p">):</span>
            <span class="c1"># mlefit is a wrapped counts results</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_transparams</span> <span class="o">=</span> <span class="kc">False</span> <span class="c1"># do not need to transform anymore now</span>
            <span class="c1"># change from lnalpha to alpha</span>
            <span class="k">if</span> <span class="n">method</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">"newton"</span><span class="p">,</span> <span class="s2">"ncg"</span><span class="p">]:</span>
                <span class="n">mlefit</span><span class="o">.</span><span class="n">_results</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mlefit</span><span class="o">.</span><span class="n">_results</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

            <span class="n">nbinfit</span> <span class="o">=</span> <span class="n">NegativeBinomialResults</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mlefit</span><span class="o">.</span><span class="n">_results</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">NegativeBinomialResultsWrapper</span><span class="p">(</span><span class="n">nbinfit</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">mlefit</span>

        <span class="k">if</span> <span class="n">cov_kwds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cov_kwds</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1">#TODO: make this unnecessary ?</span>
        <span class="n">result</span><span class="o">.</span><span class="n">_get_robustcov_results</span><span class="p">(</span><span class="n">cov_type</span><span class="o">=</span><span class="n">cov_type</span><span class="p">,</span>
                                    <span class="n">use_self</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">use_t</span><span class="o">=</span><span class="n">use_t</span><span class="p">,</span> <span class="o">**</span><span class="n">cov_kwds</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="NegativeBinomial.fit_regularized"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.NegativeBinomial.fit_regularized.html#statsmodels.discrete.count_model.NegativeBinomial.fit_regularized">[docs]</a>    <span class="k">def</span> <span class="nf">fit_regularized</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">'l1'</span><span class="p">,</span>
            <span class="n">maxiter</span><span class="o">=</span><span class="s1">'defined_by_method'</span><span class="p">,</span> <span class="n">full_output</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">disp</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">alpha</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">trim_mode</span><span class="o">=</span><span class="s1">'auto'</span><span class="p">,</span> <span class="n">auto_trim_tol</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">size_trim_tol</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">,</span>
            <span class="n">qc_tol</span><span class="o">=</span><span class="mf">0.03</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

        <span class="n">_validate_l1_method</span><span class="p">(</span><span class="n">method</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">loglike_method</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">'nb'</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span>
                                                     <span class="n">alpha</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">):</span>
            <span class="c1"># do not penalize alpha if alpha is scalar</span>
            <span class="n">k_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exog</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_extra</span>
            <span class="n">alpha</span> <span class="o">=</span> <span class="n">alpha</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">k_params</span><span class="p">)</span>
            <span class="n">alpha</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># alpha for regularized poisson to get starting values</span>
        <span class="n">alpha_p</span> <span class="o">=</span> <span class="n">alpha</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_extra</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="k">else</span> <span class="n">alpha</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_transparams</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">start_params</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Use poisson fit as first guess.</span>
            <span class="c1">#TODO, Warning: this assumes exposure is logged</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">"offset"</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">"exposure"</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">offset</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">offset</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">offset</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">mod_poi</span> <span class="o">=</span> <span class="n">Poisson</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endog</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">exog</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">)</span>
            <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">():</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s2">"always"</span><span class="p">)</span>
                <span class="n">start_params</span> <span class="o">=</span> <span class="n">mod_poi</span><span class="o">.</span><span class="n">fit_regularized</span><span class="p">(</span>
                    <span class="n">start_params</span><span class="o">=</span><span class="n">start_params</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="n">maxiter</span><span class="p">,</span>
                    <span class="n">full_output</span><span class="o">=</span><span class="n">full_output</span><span class="p">,</span> <span class="n">disp</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="n">callback</span><span class="p">,</span>
                    <span class="n">alpha</span><span class="o">=</span><span class="n">alpha_p</span><span class="p">,</span> <span class="n">trim_mode</span><span class="o">=</span><span class="n">trim_mode</span><span class="p">,</span>
                    <span class="n">auto_trim_tol</span><span class="o">=</span><span class="n">auto_trim_tol</span><span class="p">,</span> <span class="n">size_trim_tol</span><span class="o">=</span><span class="n">size_trim_tol</span><span class="p">,</span>
                    <span class="n">qc_tol</span><span class="o">=</span><span class="n">qc_tol</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">.</span><span class="n">params</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">loglike_method</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">'nb'</span><span class="p">):</span>
                <span class="n">start_params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">start_params</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)</span>

        <span class="n">cntfit</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">CountModel</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">fit_regularized</span><span class="p">(</span>
                <span class="n">start_params</span><span class="o">=</span><span class="n">start_params</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="n">maxiter</span><span class="p">,</span>
                <span class="n">full_output</span><span class="o">=</span><span class="n">full_output</span><span class="p">,</span> <span class="n">disp</span><span class="o">=</span><span class="n">disp</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="n">callback</span><span class="p">,</span>
                <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">trim_mode</span><span class="o">=</span><span class="n">trim_mode</span><span class="p">,</span> <span class="n">auto_trim_tol</span><span class="o">=</span><span class="n">auto_trim_tol</span><span class="p">,</span>
                <span class="n">size_trim_tol</span><span class="o">=</span><span class="n">size_trim_tol</span><span class="p">,</span> <span class="n">qc_tol</span><span class="o">=</span><span class="n">qc_tol</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="n">discretefit</span> <span class="o">=</span> <span class="n">L1NegativeBinomialResults</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cntfit</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">L1NegativeBinomialResultsWrapper</span><span class="p">(</span><span class="n">discretefit</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="NegativeBinomialP"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.NegativeBinomialP.html#statsmodels.discrete.count_model.NegativeBinomialP">[docs]</a><span class="k">class</span> <span class="nc">NegativeBinomialP</span><span class="p">(</span><span class="n">CountModel</span><span class="p">):</span>
    <span class="vm">__doc__</span> <span class="o">=</span> <span class="s2">"""</span>
<span class="s2">    Generalized Negative Binomial (NB-P) Model</span>

<span class="s2">    </span><span class="si">%(params)s</span><span class="s2"></span>
<span class="s2">    </span><span class="si">%(extra_params)s</span><span class="s2"></span>

<span class="s2">    Attributes</span>
<span class="s2">    ----------</span>
<span class="s2">    endog : ndarray</span>
<span class="s2">        A reference to the endogenous response variable</span>
<span class="s2">    exog : ndarray</span>
<span class="s2">        A reference to the exogenous design.</span>
<span class="s2">    p : scalar</span>
<span class="s2">        P denotes parameterizations for NB-P regression. p=1 for NB-1 and</span>
<span class="s2">        p=2 for NB-2. Default is p=1.</span>
<span class="s2">    """</span> <span class="o">%</span> <span class="p">{</span><span class="s1">'params'</span><span class="p">:</span> <span class="n">base</span><span class="o">.</span><span class="n">_model_params_doc</span><span class="p">,</span>
           <span class="s1">'extra_params'</span><span class="p">:</span>
               <span class="sd">"""p : scalar</span>
<span class="sd">        P denotes parameterizations for NB regression. p=1 for NB-1 and</span>
<span class="sd">        p=2 for NB-2. Default is p=2.</span>
<span class="sd">    offset : array_like</span>
<span class="sd">        Offset is added to the linear prediction with coefficient equal to 1.</span>
<span class="sd">    exposure : array_like</span>
<span class="sd">        Log(exposure) is added to the linear prediction with coefficient</span>
<span class="sd">        equal to 1.</span>
<span class="sd">        """</span> <span class="o">+</span> <span class="n">base</span><span class="o">.</span><span class="n">_missing_param_doc</span> <span class="o">+</span> <span class="n">_check_rank_doc</span><span class="p">}</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">endog</span><span class="p">,</span> <span class="n">exog</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">exposure</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">missing</span><span class="o">=</span><span class="s1">'none'</span><span class="p">,</span> <span class="n">check_rank</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">endog</span><span class="p">,</span>
                         <span class="n">exog</span><span class="p">,</span>
                         <span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">,</span>
                         <span class="n">exposure</span><span class="o">=</span><span class="n">exposure</span><span class="p">,</span>
                         <span class="n">missing</span><span class="o">=</span><span class="n">missing</span><span class="p">,</span>
                         <span class="n">check_rank</span><span class="o">=</span><span class="n">check_rank</span><span class="p">,</span>
                         <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parameterization</span> <span class="o">=</span> <span class="n">p</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">exog_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">'alpha'</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k_extra</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_transparams</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">_get_init_kwds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">kwds</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_get_init_kwds</span><span class="p">()</span>
        <span class="n">kwds</span><span class="p">[</span><span class="s1">'p'</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameterization</span>
        <span class="k">return</span> <span class="n">kwds</span>

<div class="viewcode-block" id="NegativeBinomialP.loglike"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.NegativeBinomialP.loglike.html#statsmodels.discrete.count_model.NegativeBinomialP.loglike">[docs]</a>    <span class="k">def</span> <span class="nf">loglike</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Loglikelihood of Generalized Negative Binomial (NB-P) model</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array_like</span>
<span class="sd">            The parameters of the model.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        loglike : float</span>
<span class="sd">            The log-likelihood function of the model evaluated at `params`.</span>
<span class="sd">            See notes.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loglikeobs</span><span class="p">(</span><span class="n">params</span><span class="p">))</span></div>

<div class="viewcode-block" id="NegativeBinomialP.loglikeobs"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.NegativeBinomialP.loglikeobs.html#statsmodels.discrete.count_model.NegativeBinomialP.loglikeobs">[docs]</a>    <span class="k">def</span> <span class="nf">loglikeobs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Loglikelihood for observations of Generalized Negative Binomial (NB-P) model</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array_like</span>
<span class="sd">            The parameters of the model.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        loglike : ndarray</span>
<span class="sd">            The log likelihood for each observation of the model evaluated</span>
<span class="sd">            at `params`. See Notes</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transparams</span><span class="p">:</span>
            <span class="n">alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">alpha</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">params</span> <span class="o">=</span> <span class="n">params</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameterization</span>
        <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">endog</span>

        <span class="n">mu</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
        <span class="n">mu_p</span> <span class="o">=</span> <span class="n">mu</span><span class="o">**</span><span class="p">(</span><span class="mi">2</span> <span class="o">-</span> <span class="n">p</span><span class="p">)</span>
        <span class="n">a1</span> <span class="o">=</span> <span class="n">mu_p</span> <span class="o">/</span> <span class="n">alpha</span>
        <span class="n">a2</span> <span class="o">=</span> <span class="n">mu</span> <span class="o">+</span> <span class="n">a1</span>

        <span class="n">llf</span> <span class="o">=</span> <span class="p">(</span><span class="n">gammaln</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">a1</span><span class="p">)</span> <span class="o">-</span> <span class="n">gammaln</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">gammaln</span><span class="p">(</span><span class="n">a1</span><span class="p">)</span> <span class="o">+</span>
               <span class="n">a1</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">a1</span><span class="p">)</span> <span class="o">+</span> <span class="n">y</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">mu</span><span class="p">)</span> <span class="o">-</span>
               <span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">a1</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">a2</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">llf</span></div>

<div class="viewcode-block" id="NegativeBinomialP.score_obs"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.NegativeBinomialP.score_obs.html#statsmodels.discrete.count_model.NegativeBinomialP.score_obs">[docs]</a>    <span class="k">def</span> <span class="nf">score_obs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Generalized Negative Binomial (NB-P) model score (gradient) vector of the log-likelihood for each observations.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array_like</span>
<span class="sd">            The parameters of the model</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        score : ndarray, 1-D</span>
<span class="sd">            The score vector of the model, i.e. the first derivative of the</span>
<span class="sd">            loglikelihood function, evaluated at `params`</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transparams</span><span class="p">:</span>
            <span class="n">alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">alpha</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">params</span> <span class="o">=</span> <span class="n">params</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">p</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameterization</span>
        <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">endog</span>

        <span class="n">mu</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
        <span class="n">mu_p</span> <span class="o">=</span> <span class="n">mu</span><span class="o">**</span><span class="n">p</span>
        <span class="n">a1</span> <span class="o">=</span> <span class="n">mu_p</span> <span class="o">/</span> <span class="n">alpha</span>
        <span class="n">a2</span> <span class="o">=</span> <span class="n">mu</span> <span class="o">+</span> <span class="n">a1</span>
        <span class="n">a3</span> <span class="o">=</span> <span class="n">y</span> <span class="o">+</span> <span class="n">a1</span>
        <span class="n">a4</span> <span class="o">=</span> <span class="n">p</span> <span class="o">*</span> <span class="n">a1</span> <span class="o">/</span> <span class="n">mu</span>

        <span class="n">dgpart</span> <span class="o">=</span> <span class="n">digamma</span><span class="p">(</span><span class="n">a3</span><span class="p">)</span> <span class="o">-</span> <span class="n">digamma</span><span class="p">(</span><span class="n">a1</span><span class="p">)</span>
        <span class="n">dgterm</span> <span class="o">=</span> <span class="n">dgpart</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">a1</span> <span class="o">/</span> <span class="n">a2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">a3</span> <span class="o">/</span> <span class="n">a2</span>
        <span class="c1"># TODO: better name/interpretation for dgterm?</span>

        <span class="n">dparams</span> <span class="o">=</span> <span class="p">(</span><span class="n">a4</span> <span class="o">*</span> <span class="n">dgterm</span> <span class="o">-</span>
                   <span class="n">a3</span> <span class="o">/</span> <span class="n">a2</span> <span class="o">+</span>
                   <span class="n">y</span> <span class="o">/</span> <span class="n">mu</span><span class="p">)</span>
        <span class="n">dparams</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exog</span><span class="o">.</span><span class="n">T</span> <span class="o">*</span> <span class="n">mu</span> <span class="o">*</span> <span class="n">dparams</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="n">dalpha</span> <span class="o">=</span> <span class="o">-</span><span class="n">a1</span> <span class="o">/</span> <span class="n">alpha</span> <span class="o">*</span> <span class="n">dgterm</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">dparams</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">dalpha</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">),</span>
                              <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span></div>

<div class="viewcode-block" id="NegativeBinomialP.score"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.NegativeBinomialP.score.html#statsmodels.discrete.count_model.NegativeBinomialP.score">[docs]</a>    <span class="k">def</span> <span class="nf">score</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Generalized Negative Binomial (NB-P) model score (gradient) vector of the log-likelihood</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array_like</span>
<span class="sd">            The parameters of the model</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        score : ndarray, 1-D</span>
<span class="sd">            The score vector of the model, i.e. the first derivative of the</span>
<span class="sd">            loglikelihood function, evaluated at `params`</span>
<span class="sd">        """</span>
        <span class="n">score</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">score_obs</span><span class="p">(</span><span class="n">params</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transparams</span><span class="p">:</span>
            <span class="n">score</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">score</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span>
            <span class="k">return</span> <span class="n">score</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">score</span></div>

<div class="viewcode-block" id="NegativeBinomialP.hessian"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.NegativeBinomialP.hessian.html#statsmodels.discrete.count_model.NegativeBinomialP.hessian">[docs]</a>    <span class="k">def</span> <span class="nf">hessian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Generalized Negative Binomial (NB-P) model hessian maxtrix of the log-likelihood</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array_like</span>
<span class="sd">            The parameters of the model</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        hessian : ndarray, 2-D</span>
<span class="sd">            The hessian matrix of the model.</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transparams</span><span class="p">:</span>
            <span class="n">alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">alpha</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">params</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">p</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameterization</span>
        <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">endog</span>
        <span class="n">exog</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exog</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>

        <span class="n">mu_p</span> <span class="o">=</span> <span class="n">mu</span><span class="o">**</span><span class="n">p</span>
        <span class="n">a1</span> <span class="o">=</span> <span class="n">mu_p</span> <span class="o">/</span> <span class="n">alpha</span>
        <span class="n">a2</span> <span class="o">=</span> <span class="n">mu</span> <span class="o">+</span> <span class="n">a1</span>
        <span class="n">a3</span> <span class="o">=</span> <span class="n">y</span> <span class="o">+</span> <span class="n">a1</span>
        <span class="n">a4</span> <span class="o">=</span> <span class="n">p</span> <span class="o">*</span> <span class="n">a1</span> <span class="o">/</span> <span class="n">mu</span>

        <span class="n">prob</span> <span class="o">=</span> <span class="n">a1</span> <span class="o">/</span> <span class="n">a2</span>
        <span class="n">lprob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">prob</span><span class="p">)</span>
        <span class="n">dgpart</span> <span class="o">=</span> <span class="n">digamma</span><span class="p">(</span><span class="n">a3</span><span class="p">)</span> <span class="o">-</span> <span class="n">digamma</span><span class="p">(</span><span class="n">a1</span><span class="p">)</span>
        <span class="n">pgpart</span> <span class="o">=</span> <span class="n">polygamma</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">a3</span><span class="p">)</span> <span class="o">-</span> <span class="n">polygamma</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">a1</span><span class="p">)</span>

        <span class="n">dim</span> <span class="o">=</span> <span class="n">exog</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">hess_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">dim</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dim</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>

        <span class="n">coeff</span> <span class="o">=</span> <span class="n">mu</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(((</span><span class="mi">1</span> <span class="o">+</span> <span class="n">a4</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">a3</span> <span class="o">/</span> <span class="n">a2</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span>
                          <span class="n">a3</span> <span class="o">/</span> <span class="n">a2</span> <span class="o">*</span> <span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">a4</span> <span class="o">/</span> <span class="n">mu</span> <span class="o">-</span>
                          <span class="n">y</span> <span class="o">/</span> <span class="n">mu</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span>
                          <span class="mi">2</span> <span class="o">*</span> <span class="n">a4</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">a4</span><span class="p">)</span> <span class="o">/</span> <span class="n">a2</span> <span class="o">+</span>
                          <span class="n">p</span> <span class="o">*</span> <span class="n">a4</span> <span class="o">/</span> <span class="n">mu</span> <span class="o">*</span> <span class="p">(</span><span class="n">lprob</span> <span class="o">+</span> <span class="n">dgpart</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span>
                          <span class="n">a4</span> <span class="o">/</span> <span class="n">mu</span> <span class="o">*</span> <span class="p">(</span><span class="n">lprob</span> <span class="o">+</span> <span class="n">dgpart</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span>
                          <span class="n">a4</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">pgpart</span><span class="p">)</span> <span class="o">+</span>
                         <span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">a4</span><span class="p">)</span> <span class="o">*</span> <span class="n">a3</span> <span class="o">/</span> <span class="n">a2</span> <span class="o">+</span>
                          <span class="n">y</span> <span class="o">/</span> <span class="n">mu</span> <span class="o">+</span>
                          <span class="n">a4</span> <span class="o">*</span> <span class="p">(</span><span class="n">lprob</span> <span class="o">+</span> <span class="n">dgpart</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="o">/</span> <span class="n">mu</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim</span><span class="p">):</span>
            <span class="n">hess_arr</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exog</span><span class="p">[:,</span> <span class="p">:]</span><span class="o">.</span><span class="n">T</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">exog</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">coeff</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>


        <span class="n">hess_arr</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exog</span><span class="p">[:,</span> <span class="p">:]</span><span class="o">.</span><span class="n">T</span> <span class="o">*</span> <span class="n">mu</span> <span class="o">*</span> <span class="n">a1</span> <span class="o">*</span>
                <span class="p">((</span><span class="mi">1</span> <span class="o">+</span> <span class="n">a4</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">a3</span> <span class="o">/</span> <span class="n">a2</span><span class="p">)</span> <span class="o">/</span> <span class="n">a2</span> <span class="o">-</span>
                 <span class="n">p</span> <span class="o">*</span> <span class="p">(</span><span class="n">lprob</span> <span class="o">+</span> <span class="n">dgpart</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">mu</span> <span class="o">+</span>
                 <span class="n">p</span> <span class="o">/</span> <span class="n">mu</span> <span class="o">*</span> <span class="p">(</span><span class="n">a3</span> <span class="o">+</span> <span class="n">p</span> <span class="o">*</span> <span class="n">a1</span><span class="p">)</span> <span class="o">/</span> <span class="n">a2</span> <span class="o">-</span>
                 <span class="n">a4</span> <span class="o">*</span> <span class="n">pgpart</span><span class="p">)</span> <span class="o">/</span> <span class="n">alpha</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>


        <span class="n">da2</span> <span class="o">=</span> <span class="p">(</span><span class="n">a1</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">lprob</span> <span class="o">+</span>
                     <span class="mi">2</span> <span class="o">*</span> <span class="n">dgpart</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">-</span>
                     <span class="mi">2</span> <span class="o">*</span> <span class="n">a3</span> <span class="o">/</span> <span class="n">a2</span>
                     <span class="o">+</span> <span class="n">a1</span> <span class="o">*</span> <span class="n">pgpart</span>
                     <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">prob</span> <span class="o">+</span>
                     <span class="n">prob</span> <span class="o">*</span> <span class="n">a3</span> <span class="o">/</span> <span class="n">a2</span><span class="p">)</span> <span class="o">/</span> <span class="n">alpha</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

        <span class="n">hess_arr</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">da2</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

        <span class="n">tri_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">triu_indices</span><span class="p">(</span><span class="n">dim</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">hess_arr</span><span class="p">[</span><span class="n">tri_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">hess_arr</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="n">tri_idx</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">hess_arr</span></div>

    <span class="nd">@Appender</span><span class="p">(</span><span class="n">_get_start_params_null_docs</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_get_start_params_null</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">"offset"</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">exposure</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">"exposure"</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameterization</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="n">const</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endog</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">offset</span> <span class="o">+</span> <span class="n">exposure</span><span class="p">))</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        <span class="n">params</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">const</span><span class="p">)]</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="n">const</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">offset</span> <span class="o">+</span> <span class="n">exposure</span><span class="p">)</span>
        <span class="n">resid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">endog</span> <span class="o">-</span> <span class="n">mu</span>
        <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_estimate_dispersion</span><span class="p">(</span><span class="n">mu</span><span class="p">,</span> <span class="n">resid</span><span class="p">,</span> <span class="n">df_resid</span><span class="o">=</span><span class="n">resid</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">params</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_estimate_dispersion</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">resid</span><span class="p">,</span> <span class="n">df_resid</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameterization</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">df_resid</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">df_resid</span> <span class="o">=</span> <span class="n">resid</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">a</span> <span class="o">=</span> <span class="p">((</span><span class="n">resid</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="n">mu</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">mu</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="n">q</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="n">df_resid</span>
        <span class="k">return</span> <span class="n">a</span>

<div class="viewcode-block" id="NegativeBinomialP.fit"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.NegativeBinomialP.fit.html#statsmodels.discrete.count_model.NegativeBinomialP.fit">[docs]</a>    <span class="nd">@Appender</span><span class="p">(</span><span class="n">DiscreteModel</span><span class="o">.</span><span class="n">fit</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">'bfgs'</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="mi">35</span><span class="p">,</span>
            <span class="n">full_output</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">disp</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">use_transparams</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">cov_type</span><span class="o">=</span><span class="s1">'nonrobust'</span><span class="p">,</span> <span class="n">cov_kwds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">use_t</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># TODO: Fix doc string</span>
        <span class="sd">"""</span>
<span class="sd">        use_transparams : bool</span>
<span class="sd">            This parameter enable internal transformation to impose</span>
<span class="sd">            non-negativity. True to enable. Default is False.</span>
<span class="sd">            use_transparams=True imposes the no underdispersion (alpha &gt; 0)</span>
<span class="sd">            constraint. In case use_transparams=True and method="newton" or</span>
<span class="sd">            "ncg" transformation is ignored.</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="n">use_transparams</span> <span class="ow">and</span> <span class="n">method</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">'newton'</span><span class="p">,</span> <span class="s1">'ncg'</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_transparams</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">use_transparams</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">'Parameter "use_transparams" is ignored'</span><span class="p">,</span>
                              <span class="ne">RuntimeWarning</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_transparams</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="n">start_params</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">"offset"</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">"exposure"</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">offset</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">offset</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">offset</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="n">optim_kwds_prelim</span> <span class="o">=</span> <span class="p">{</span><span class="s1">'disp'</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">'skip_hessian'</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
                                 <span class="s1">'warn_convergence'</span><span class="p">:</span> <span class="kc">False</span><span class="p">}</span>
            <span class="n">optim_kwds_prelim</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">'optim_kwds_prelim'</span><span class="p">,</span> <span class="p">{}))</span>
            <span class="n">mod_poi</span> <span class="o">=</span> <span class="n">Poisson</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endog</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">exog</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">)</span>
            <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">():</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s2">"always"</span><span class="p">)</span>
                <span class="n">res_poi</span> <span class="o">=</span> <span class="n">mod_poi</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="o">**</span><span class="n">optim_kwds_prelim</span><span class="p">)</span>
            <span class="n">start_params</span> <span class="o">=</span> <span class="n">res_poi</span><span class="o">.</span><span class="n">params</span>
            <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_estimate_dispersion</span><span class="p">(</span><span class="n">res_poi</span><span class="o">.</span><span class="n">predict</span><span class="p">(),</span> <span class="n">res_poi</span><span class="o">.</span><span class="n">resid</span><span class="p">,</span>
                                          <span class="n">df_resid</span><span class="o">=</span><span class="n">res_poi</span><span class="o">.</span><span class="n">df_resid</span><span class="p">)</span>
            <span class="n">start_params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">start_params</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">a</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">callback</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># work around perfect separation callback #3895</span>
            <span class="n">callback</span> <span class="o">=</span> <span class="k">lambda</span> <span class="o">*</span><span class="n">x</span><span class="p">:</span> <span class="n">x</span>

        <span class="n">mlefit</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">NegativeBinomialP</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">start_params</span><span class="o">=</span><span class="n">start_params</span><span class="p">,</span>
                        <span class="n">maxiter</span><span class="o">=</span><span class="n">maxiter</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">disp</span><span class="o">=</span><span class="n">disp</span><span class="p">,</span>
                        <span class="n">full_output</span><span class="o">=</span><span class="n">full_output</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="n">callback</span><span class="p">,</span>
                        <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">use_transparams</span> <span class="ow">and</span> <span class="n">method</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">"newton"</span><span class="p">,</span> <span class="s2">"ncg"</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_transparams</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">mlefit</span><span class="o">.</span><span class="n">_results</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mlefit</span><span class="o">.</span><span class="n">_results</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="n">nbinfit</span> <span class="o">=</span> <span class="n">NegativeBinomialResults</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mlefit</span><span class="o">.</span><span class="n">_results</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">NegativeBinomialResultsWrapper</span><span class="p">(</span><span class="n">nbinfit</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">cov_kwds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cov_kwds</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">result</span><span class="o">.</span><span class="n">_get_robustcov_results</span><span class="p">(</span><span class="n">cov_type</span><span class="o">=</span><span class="n">cov_type</span><span class="p">,</span>
                                    <span class="n">use_self</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">use_t</span><span class="o">=</span><span class="n">use_t</span><span class="p">,</span> <span class="o">**</span><span class="n">cov_kwds</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span></div>

<div class="viewcode-block" id="NegativeBinomialP.fit_regularized"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.NegativeBinomialP.fit_regularized.html#statsmodels.discrete.count_model.NegativeBinomialP.fit_regularized">[docs]</a>    <span class="nd">@Appender</span><span class="p">(</span><span class="n">DiscreteModel</span><span class="o">.</span><span class="n">fit_regularized</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">fit_regularized</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">'l1'</span><span class="p">,</span>
            <span class="n">maxiter</span><span class="o">=</span><span class="s1">'defined_by_method'</span><span class="p">,</span> <span class="n">full_output</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">disp</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">alpha</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">trim_mode</span><span class="o">=</span><span class="s1">'auto'</span><span class="p">,</span> <span class="n">auto_trim_tol</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">size_trim_tol</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">,</span>
            <span class="n">qc_tol</span><span class="o">=</span><span class="mf">0.03</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

        <span class="n">_validate_l1_method</span><span class="p">(</span><span class="n">method</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">alpha</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">k_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exog</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_extra</span>
            <span class="n">alpha</span> <span class="o">=</span> <span class="n">alpha</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">k_params</span><span class="p">)</span>
            <span class="n">alpha</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">alpha_p</span> <span class="o">=</span> <span class="n">alpha</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_extra</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="k">else</span> <span class="n">alpha</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_transparams</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">start_params</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">"offset"</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">"exposure"</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">offset</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">offset</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">offset</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">mod_poi</span> <span class="o">=</span> <span class="n">Poisson</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endog</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">exog</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">)</span>
            <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">():</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s2">"always"</span><span class="p">)</span>
                <span class="n">start_params</span> <span class="o">=</span> <span class="n">mod_poi</span><span class="o">.</span><span class="n">fit_regularized</span><span class="p">(</span>
                    <span class="n">start_params</span><span class="o">=</span><span class="n">start_params</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="n">maxiter</span><span class="p">,</span>
                    <span class="n">full_output</span><span class="o">=</span><span class="n">full_output</span><span class="p">,</span> <span class="n">disp</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="n">callback</span><span class="p">,</span>
                    <span class="n">alpha</span><span class="o">=</span><span class="n">alpha_p</span><span class="p">,</span> <span class="n">trim_mode</span><span class="o">=</span><span class="n">trim_mode</span><span class="p">,</span>
                    <span class="n">auto_trim_tol</span><span class="o">=</span><span class="n">auto_trim_tol</span><span class="p">,</span> <span class="n">size_trim_tol</span><span class="o">=</span><span class="n">size_trim_tol</span><span class="p">,</span>
                    <span class="n">qc_tol</span><span class="o">=</span><span class="n">qc_tol</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">.</span><span class="n">params</span>
            <span class="n">start_params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">start_params</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)</span>

        <span class="n">cntfit</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">CountModel</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">fit_regularized</span><span class="p">(</span>
                <span class="n">start_params</span><span class="o">=</span><span class="n">start_params</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="n">maxiter</span><span class="p">,</span>
                <span class="n">full_output</span><span class="o">=</span><span class="n">full_output</span><span class="p">,</span> <span class="n">disp</span><span class="o">=</span><span class="n">disp</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="n">callback</span><span class="p">,</span>
                <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">trim_mode</span><span class="o">=</span><span class="n">trim_mode</span><span class="p">,</span> <span class="n">auto_trim_tol</span><span class="o">=</span><span class="n">auto_trim_tol</span><span class="p">,</span>
                <span class="n">size_trim_tol</span><span class="o">=</span><span class="n">size_trim_tol</span><span class="p">,</span> <span class="n">qc_tol</span><span class="o">=</span><span class="n">qc_tol</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="n">discretefit</span> <span class="o">=</span> <span class="n">L1NegativeBinomialResults</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cntfit</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">L1NegativeBinomialResultsWrapper</span><span class="p">(</span><span class="n">discretefit</span><span class="p">)</span></div>

<div class="viewcode-block" id="NegativeBinomialP.predict"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.NegativeBinomialP.predict.html#statsmodels.discrete.count_model.NegativeBinomialP.predict">[docs]</a>    <span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">exog</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">exposure</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">which</span><span class="o">=</span><span class="s1">'mean'</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Predict response variable of a model given exogenous variables.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array_like</span>
<span class="sd">            2d array of fitted parameters of the model. Should be in the</span>
<span class="sd">            order returned from the model.</span>
<span class="sd">        exog : array_like, optional</span>
<span class="sd">            1d or 2d array of exogenous values.  If not supplied, the</span>
<span class="sd">            whole exog attribute of the model is used. If a 1d array is given</span>
<span class="sd">            it assumed to be 1 row of exogenous variables. If you only have</span>
<span class="sd">            one regressor and would like to do prediction, you must provide</span>
<span class="sd">            a 2d array with shape[1] == 1.</span>
<span class="sd">        linear : bool, optional</span>
<span class="sd">            If True, returns the linear predictor dot(exog,params).  Else,</span>
<span class="sd">            returns the value of the cdf at the linear predictor.</span>
<span class="sd">        offset : array_like, optional</span>
<span class="sd">            Offset is added to the linear prediction with coefficient equal to 1.</span>
<span class="sd">        exposure : array_like, optional</span>
<span class="sd">            Log(exposure) is added to the linear prediction with coefficient</span>
<span class="sd">        equal to 1.</span>
<span class="sd">        which : 'mean', 'linear', 'prob', optional.</span>
<span class="sd">            'mean' returns the exp of linear predictor exp(dot(exog,params)).</span>
<span class="sd">            'linear' returns the linear predictor dot(exog,params).</span>
<span class="sd">            'prob' return probabilities for counts from 0 to max(endog).</span>
<span class="sd">            Default is 'mean'.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="n">exog</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">exog</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exog</span>

        <span class="k">if</span> <span class="n">exposure</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">exposure</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">'exposure'</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">exposure</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">exposure</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">exposure</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">offset</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">'offset'</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

        <span class="n">fitted</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">exog</span><span class="p">,</span> <span class="n">params</span><span class="p">[:</span><span class="n">exog</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
        <span class="n">linpred</span> <span class="o">=</span> <span class="n">fitted</span> <span class="o">+</span> <span class="n">exposure</span> <span class="o">+</span> <span class="n">offset</span>

        <span class="k">if</span> <span class="n">which</span> <span class="o">==</span> <span class="s1">'mean'</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">linpred</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">which</span> <span class="o">==</span> <span class="s1">'linear'</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">linpred</span>
        <span class="k">elif</span> <span class="n">which</span> <span class="o">==</span><span class="s1">'prob'</span><span class="p">:</span>
            <span class="n">counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endog</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
            <span class="n">mu</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">exog</span><span class="p">,</span> <span class="n">exposure</span><span class="p">,</span> <span class="n">offset</span><span class="p">)</span>
            <span class="n">size</span><span class="p">,</span> <span class="n">prob</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_params</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">mu</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">nbinom</span><span class="o">.</span><span class="n">pmf</span><span class="p">(</span><span class="n">counts</span><span class="p">,</span> <span class="n">size</span><span class="p">[:,</span><span class="kc">None</span><span class="p">],</span> <span class="n">prob</span><span class="p">[:,</span><span class="kc">None</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'keyword "which" = </span><span class="si">%s</span><span class="s1"> not recognized'</span> <span class="o">%</span> <span class="n">which</span><span class="p">)</span></div>

<div class="viewcode-block" id="NegativeBinomialP.convert_params"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.NegativeBinomialP.convert_params.html#statsmodels.discrete.count_model.NegativeBinomialP.convert_params">[docs]</a>    <span class="k">def</span> <span class="nf">convert_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">mu</span><span class="p">):</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">p</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameterization</span>

        <span class="n">size</span> <span class="o">=</span> <span class="mf">1.</span> <span class="o">/</span> <span class="n">alpha</span> <span class="o">*</span> <span class="n">mu</span><span class="o">**</span><span class="n">p</span>
        <span class="n">prob</span> <span class="o">=</span> <span class="n">size</span> <span class="o">/</span> <span class="p">(</span><span class="n">size</span> <span class="o">+</span> <span class="n">mu</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">prob</span><span class="p">)</span></div></div>


<span class="c1">### Results Class ###</span>

<span class="k">class</span> <span class="nc">DiscreteResults</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="n">LikelihoodModelResults</span><span class="p">):</span>
    <span class="vm">__doc__</span> <span class="o">=</span> <span class="n">_discrete_results_docs</span> <span class="o">%</span> <span class="p">{</span><span class="s2">"one_line_description"</span> <span class="p">:</span>
        <span class="s2">"A results class for the discrete dependent variable models."</span><span class="p">,</span>
        <span class="s2">"extra_attr"</span> <span class="p">:</span> <span class="s2">""</span><span class="p">}</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">mlefit</span><span class="p">,</span> <span class="n">cov_type</span><span class="o">=</span><span class="s1">'nonrobust'</span><span class="p">,</span> <span class="n">cov_kwds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">use_t</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1">#super(DiscreteResults, self).__init__(model, params,</span>
        <span class="c1">#        np.linalg.inv(-hessian), scale=1.)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">df_model</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">df_model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">df_resid</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">df_resid</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">exog</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">mlefit</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">'cov_type'</span><span class="p">):</span>
            <span class="c1"># do this only if super, i.e. mlefit did not already add cov_type</span>
            <span class="c1"># robust covariance</span>
            <span class="k">if</span> <span class="n">use_t</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">use_t</span> <span class="o">=</span> <span class="n">use_t</span>
            <span class="k">if</span> <span class="n">cov_type</span> <span class="o">==</span> <span class="s1">'nonrobust'</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cov_type</span> <span class="o">=</span> <span class="s1">'nonrobust'</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cov_kwds</span> <span class="o">=</span> <span class="p">{</span><span class="s1">'description'</span> <span class="p">:</span> <span class="s1">'Standard Errors assume that the '</span> <span class="o">+</span>
                                 <span class="s1">'covariance matrix of the errors is correctly '</span> <span class="o">+</span>
                                 <span class="s1">'specified.'</span><span class="p">}</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">cov_kwds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">cov_kwds</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="kn">from</span> <span class="nn">statsmodels.base.covtype</span> <span class="kn">import</span> <span class="n">get_robustcov_results</span>
                <span class="n">get_robustcov_results</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cov_type</span><span class="o">=</span><span class="n">cov_type</span><span class="p">,</span> <span class="n">use_self</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                           <span class="o">**</span><span class="n">cov_kwds</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># remove unpicklable methods</span>
        <span class="n">mle_settings</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">'mle_settings'</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mle_settings</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="s1">'callback'</span> <span class="ow">in</span> <span class="n">mle_settings</span><span class="p">:</span>
                <span class="n">mle_settings</span><span class="p">[</span><span class="s1">'callback'</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="s1">'cov_params_func'</span> <span class="ow">in</span> <span class="n">mle_settings</span><span class="p">:</span>
                <span class="n">mle_settings</span><span class="p">[</span><span class="s1">'cov_params_func'</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">prsquared</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        McFadden's pseudo-R-squared. `1 - (llf / llnull)`</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="mi">1</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">llf</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">llnull</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">llr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Likelihood ratio chi-squared statistic; `-2*(llnull - llf)`</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">llnull</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">llf</span><span class="p">)</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">llr_pvalue</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        The chi-squared probability of getting a log-likelihood ratio</span>
<span class="sd">        statistic greater than llr.  llr has a chi-squared distribution</span>
<span class="sd">        with degrees of freedom `df_model`.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">stats</span><span class="o">.</span><span class="n">distributions</span><span class="o">.</span><span class="n">chi2</span><span class="o">.</span><span class="n">sf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">llr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">df_model</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">set_null_options</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">llnull</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">attach_results</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Set the fit options for the Null (constant-only) model.</span>

<span class="sd">        This resets the cache for related attributes which is potentially</span>
<span class="sd">        fragile. This only sets the option, the null model is estimated</span>
<span class="sd">        when llnull is accessed, if llnull is not yet in cache.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        llnull : {None, float}</span>
<span class="sd">            If llnull is not None, then the value will be directly assigned to</span>
<span class="sd">            the cached attribute "llnull".</span>
<span class="sd">        attach_results : bool</span>
<span class="sd">            Sets an internal flag whether the results instance of the null</span>
<span class="sd">            model should be attached. By default without calling this method,</span>
<span class="sd">            thenull model results are not attached and only the loglikelihood</span>
<span class="sd">            value llnull is stored.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Additional keyword arguments used as fit keyword arguments for the</span>
<span class="sd">            null model. The override and model default values.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Modifies attributes of this instance, and so has no return.</span>
<span class="sd">        """</span>
        <span class="c1"># reset cache, note we need to add here anything that depends on</span>
        <span class="c1"># llnullor the null model. If something is missing, then the attribute</span>
        <span class="c1"># might be incorrect.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">'llnull'</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">'llr'</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">'llr_pvalue'</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">'prsquared'</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">'res_null'</span><span class="p">):</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">res_null</span>

        <span class="k">if</span> <span class="n">llnull</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="s1">'llnull'</span><span class="p">]</span> <span class="o">=</span> <span class="n">llnull</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_attach_nullmodel</span> <span class="o">=</span> <span class="n">attach_results</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_optim_kwds_null</span> <span class="o">=</span> <span class="n">kwargs</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">llnull</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Value of the constant-only loglikelihood</span>
<span class="sd">        """</span>
        <span class="n">model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span>
        <span class="n">kwds</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">_get_init_kwds</span><span class="p">()</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="s1">'_null_drop_keys'</span><span class="p">,</span> <span class="p">[]):</span>
            <span class="k">del</span> <span class="n">kwds</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="c1"># TODO: what parameters to pass to fit?</span>
        <span class="n">mod_null</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">endog</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="p">),</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
        <span class="c1"># TODO: consider catching and warning on convergence failure?</span>
        <span class="c1"># in the meantime, try hard to converge. see</span>
        <span class="c1"># TestPoissonConstrained1a.test_smoke</span>

        <span class="n">optim_kwds</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">'_optim_kwds_null'</span><span class="p">,</span> <span class="p">{})</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">if</span> <span class="s1">'start_params'</span> <span class="ow">in</span> <span class="n">optim_kwds</span><span class="p">:</span>
            <span class="c1"># user provided</span>
            <span class="n">sp_null</span> <span class="o">=</span> <span class="n">optim_kwds</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">'start_params'</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="s1">'_get_start_params_null'</span><span class="p">):</span>
            <span class="c1"># get moment estimates if available</span>
            <span class="n">sp_null</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">_get_start_params_null</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sp_null</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">opt_kwds</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="s1">'bfgs'</span><span class="p">,</span> <span class="n">warn_convergence</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="mi">10000</span><span class="p">,</span>
                        <span class="n">disp</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">opt_kwds</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">optim_kwds</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">optim_kwds</span><span class="p">:</span>
            <span class="n">res_null</span> <span class="o">=</span> <span class="n">mod_null</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">start_params</span><span class="o">=</span><span class="n">sp_null</span><span class="p">,</span> <span class="o">**</span><span class="n">opt_kwds</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># this should be a reasonably method case across versions</span>
            <span class="n">res_null</span> <span class="o">=</span> <span class="n">mod_null</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">start_params</span><span class="o">=</span><span class="n">sp_null</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">'nm'</span><span class="p">,</span>
                                    <span class="n">warn_convergence</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                    <span class="n">maxiter</span><span class="o">=</span><span class="mi">10000</span><span class="p">,</span> <span class="n">disp</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">res_null</span> <span class="o">=</span> <span class="n">mod_null</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">start_params</span><span class="o">=</span><span class="n">res_null</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">'bfgs'</span><span class="p">,</span>
                                    <span class="n">warn_convergence</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                    <span class="n">maxiter</span><span class="o">=</span><span class="mi">10000</span><span class="p">,</span> <span class="n">disp</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">'_attach_nullmodel'</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">res_null</span> <span class="o">=</span> <span class="n">res_null</span>

        <span class="k">return</span> <span class="n">res_null</span><span class="o">.</span><span class="n">llf</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">fittedvalues</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Linear predictor XB.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">exog</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">exog</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">resid_response</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Respnose residuals. The response residuals are defined as</span>
<span class="sd">        `endog - fittedvalues`</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">endog</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">predict</span><span class="p">()</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">aic</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Akaike information criterion.  `-2*(llf - p)` where `p` is the number</span>
<span class="sd">        of regressors including the intercept.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">llf</span> <span class="o">-</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">df_model</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">bic</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Bayesian information criterion. `-2*llf + ln(nobs)*p` where `p` is the</span>
<span class="sd">        number of regressors including the intercept.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">llf</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">df_model</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_endog_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">yname</span><span class="p">,</span> <span class="n">yname_list</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">yname</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">yname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">endog_names</span>
        <span class="k">if</span> <span class="n">yname_list</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">yname_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">endog_names</span>
        <span class="k">return</span> <span class="n">yname</span><span class="p">,</span> <span class="n">yname_list</span>

    <span class="k">def</span> <span class="nf">get_margeff</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">at</span><span class="o">=</span><span class="s1">'overall'</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">'dydx'</span><span class="p">,</span> <span class="n">atexog</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">dummy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">"""Get marginal effects of the fitted model.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        at : str, optional</span>
<span class="sd">            Options are:</span>

<span class="sd">            - 'overall', The average of the marginal effects at each</span>
<span class="sd">              observation.</span>
<span class="sd">            - 'mean', The marginal effects at the mean of each regressor.</span>
<span class="sd">            - 'median', The marginal effects at the median of each regressor.</span>
<span class="sd">            - 'zero', The marginal effects at zero for each regressor.</span>
<span class="sd">            - 'all', The marginal effects at each observation. If `at` is all</span>
<span class="sd">              only margeff will be available from the returned object.</span>

<span class="sd">            Note that if `exog` is specified, then marginal effects for all</span>
<span class="sd">            variables not specified by `exog` are calculated using the `at`</span>
<span class="sd">            option.</span>
<span class="sd">        method : str, optional</span>
<span class="sd">            Options are:</span>

<span class="sd">            - 'dydx' - dy/dx - No transformation is made and marginal effects</span>
<span class="sd">              are returned.  This is the default.</span>
<span class="sd">            - 'eyex' - estimate elasticities of variables in `exog` --</span>
<span class="sd">              d(lny)/d(lnx)</span>
<span class="sd">            - 'dyex' - estimate semi-elasticity -- dy/d(lnx)</span>
<span class="sd">            - 'eydx' - estimate semi-elasticity -- d(lny)/dx</span>

<span class="sd">            Note that tranformations are done after each observation is</span>
<span class="sd">            calculated.  Semi-elasticities for binary variables are computed</span>
<span class="sd">            using the midpoint method. 'dyex' and 'eyex' do not make sense</span>
<span class="sd">            for discrete variables. For interpretations of these methods</span>
<span class="sd">            see notes below.</span>
<span class="sd">        atexog : array_like, optional</span>
<span class="sd">            Optionally, you can provide the exogenous variables over which to</span>
<span class="sd">            get the marginal effects.  This should be a dictionary with the key</span>
<span class="sd">            as the zero-indexed column number and the value of the dictionary.</span>
<span class="sd">            Default is None for all independent variables less the constant.</span>
<span class="sd">        dummy : bool, optional</span>
<span class="sd">            If False, treats binary variables (if present) as continuous.  This</span>
<span class="sd">            is the default.  Else if True, treats binary variables as</span>
<span class="sd">            changing from 0 to 1.  Note that any variable that is either 0 or 1</span>
<span class="sd">            is treated as binary.  Each binary variable is treated separately</span>
<span class="sd">            for now.</span>
<span class="sd">        count : bool, optional</span>
<span class="sd">            If False, treats count variables (if present) as continuous.  This</span>
<span class="sd">            is the default.  Else if True, the marginal effect is the</span>
<span class="sd">            change in probabilities when each observation is increased by one.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        DiscreteMargins : marginal effects instance</span>
<span class="sd">            Returns an object that holds the marginal effects, standard</span>
<span class="sd">            errors, confidence intervals, etc. See</span>
<span class="sd">            `statsmodels.discrete.discrete_margins.DiscreteMargins` for more</span>
<span class="sd">            information.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Interpretations of methods:</span>

<span class="sd">        - 'dydx' - change in `endog` for a change in `exog`.</span>
<span class="sd">        - 'eyex' - proportional change in `endog` for a proportional change</span>
<span class="sd">          in `exog`.</span>
<span class="sd">        - 'dyex' - change in `endog` for a proportional change in `exog`.</span>
<span class="sd">        - 'eydx' - proportional change in `endog` for a change in `exog`.</span>

<span class="sd">        When using after Poisson, returns the expected number of events per</span>
<span class="sd">        period, assuming that the model is loglinear.</span>
<span class="sd">        """</span>
        <span class="kn">from</span> <span class="nn">statsmodels.discrete.discrete_margins</span> <span class="kn">import</span> <span class="n">DiscreteMargins</span>
        <span class="k">return</span> <span class="n">DiscreteMargins</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="p">(</span><span class="n">at</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">atexog</span><span class="p">,</span> <span class="n">dummy</span><span class="p">,</span> <span class="n">count</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">summary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">yname</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">xname</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=.</span><span class="mi">05</span><span class="p">,</span>
                <span class="n">yname_list</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Summarize the Regression Results.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        yname : str, optional</span>
<span class="sd">            The name of the endog variable in the tables. The default is `y`.</span>
<span class="sd">        xname : list[str], optional</span>
<span class="sd">            The names for the exogenous variables, default is "var_xx".</span>
<span class="sd">            Must match the number of parameters in the model.</span>
<span class="sd">        title : str, optional</span>
<span class="sd">            Title for the top table. If not None, then this replaces the</span>
<span class="sd">            default title.</span>
<span class="sd">        alpha : float</span>
<span class="sd">            The significance level for the confidence intervals.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Summary</span>
<span class="sd">            Class that holds the summary tables and text, which can be printed</span>
<span class="sd">            or converted to various output formats.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        statsmodels.iolib.summary.Summary : Class that hold summary results.</span>
<span class="sd">        """</span>

        <span class="n">top_left</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">'Dep. Variable:'</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                     <span class="p">(</span><span class="s1">'Model:'</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">]),</span>
                     <span class="p">(</span><span class="s1">'Method:'</span><span class="p">,</span> <span class="p">[</span><span class="s1">'MLE'</span><span class="p">]),</span>
                     <span class="p">(</span><span class="s1">'Date:'</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                     <span class="p">(</span><span class="s1">'Time:'</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                     <span class="p">(</span><span class="s1">'converged:'</span><span class="p">,</span> <span class="p">[</span><span class="s2">"</span><span class="si">%s</span><span class="s2">"</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">mle_retvals</span><span class="p">[</span><span class="s1">'converged'</span><span class="p">]]),</span>
                    <span class="p">]</span>

        <span class="n">top_right</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">'No. Observations:'</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                     <span class="p">(</span><span class="s1">'Df Residuals:'</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                     <span class="p">(</span><span class="s1">'Df Model:'</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                     <span class="p">(</span><span class="s1">'Pseudo R-squ.:'</span><span class="p">,</span> <span class="p">[</span><span class="s2">"</span><span class="si">%#6.4g</span><span class="s2">"</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">prsquared</span><span class="p">]),</span>
                     <span class="p">(</span><span class="s1">'Log-Likelihood:'</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                     <span class="p">(</span><span class="s1">'LL-Null:'</span><span class="p">,</span> <span class="p">[</span><span class="s2">"</span><span class="si">%#8.5g</span><span class="s2">"</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">llnull</span><span class="p">]),</span>
                     <span class="p">(</span><span class="s1">'LLR p-value:'</span><span class="p">,</span> <span class="p">[</span><span class="s2">"</span><span class="si">%#6.4g</span><span class="s2">"</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">llr_pvalue</span><span class="p">])</span>
                     <span class="p">]</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">'cov_type'</span><span class="p">):</span>
            <span class="n">top_left</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s1">'Covariance Type:'</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">cov_type</span><span class="p">]))</span>

        <span class="k">if</span> <span class="n">title</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">title</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s1">' '</span> <span class="o">+</span> <span class="s2">"Regression Results"</span>

        <span class="c1"># boiler plate</span>
        <span class="kn">from</span> <span class="nn">statsmodels.iolib.summary</span> <span class="kn">import</span> <span class="n">Summary</span>
        <span class="n">smry</span> <span class="o">=</span> <span class="n">Summary</span><span class="p">()</span>
        <span class="n">yname</span><span class="p">,</span> <span class="n">yname_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_endog_name</span><span class="p">(</span><span class="n">yname</span><span class="p">,</span> <span class="n">yname_list</span><span class="p">)</span>

        <span class="c1"># for top of table</span>
        <span class="n">smry</span><span class="o">.</span><span class="n">add_table_2cols</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gleft</span><span class="o">=</span><span class="n">top_left</span><span class="p">,</span> <span class="n">gright</span><span class="o">=</span><span class="n">top_right</span><span class="p">,</span>
                             <span class="n">yname</span><span class="o">=</span><span class="n">yname</span><span class="p">,</span> <span class="n">xname</span><span class="o">=</span><span class="n">xname</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">)</span>

        <span class="c1"># for parameters, etc</span>
        <span class="n">smry</span><span class="o">.</span><span class="n">add_table_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">yname</span><span class="o">=</span><span class="n">yname_list</span><span class="p">,</span> <span class="n">xname</span><span class="o">=</span><span class="n">xname</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span>
                              <span class="n">use_t</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">use_t</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">'constraints'</span><span class="p">):</span>
            <span class="n">smry</span><span class="o">.</span><span class="n">add_extra_txt</span><span class="p">([</span><span class="s1">'Model has been estimated subject to linear '</span>
                                <span class="s1">'equality constraints.'</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">smry</span>

    <span class="k">def</span> <span class="nf">summary2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">yname</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">xname</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=.</span><span class="mi">05</span><span class="p">,</span>
                 <span class="n">float_format</span><span class="o">=</span><span class="s2">"</span><span class="si">%.4f</span><span class="s2">"</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Experimental function to summarize regression results.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        yname : str</span>
<span class="sd">            Name of the dependent variable (optional).</span>
<span class="sd">        xname : list[str], optional</span>
<span class="sd">            List of strings of length equal to the number of parameters</span>
<span class="sd">            Names of the independent variables (optional).</span>
<span class="sd">        title : str, optional</span>
<span class="sd">            Title for the top table. If not None, then this replaces the</span>
<span class="sd">            default title.</span>
<span class="sd">        alpha : float</span>
<span class="sd">            The significance level for the confidence intervals.</span>
<span class="sd">        float_format : str</span>
<span class="sd">            The print format for floats in parameters summary.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Summary</span>
<span class="sd">            Instance that contains the summary tables and text, which can be</span>
<span class="sd">            printed or converted to various output formats.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        statsmodels.iolib.summary2.Summary : Class that holds summary results.</span>
<span class="sd">        """</span>
        <span class="kn">from</span> <span class="nn">statsmodels.iolib</span> <span class="kn">import</span> <span class="n">summary2</span>
        <span class="n">smry</span> <span class="o">=</span> <span class="n">summary2</span><span class="o">.</span><span class="n">Summary</span><span class="p">()</span>
        <span class="n">smry</span><span class="o">.</span><span class="n">add_base</span><span class="p">(</span><span class="n">results</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">float_format</span><span class="o">=</span><span class="n">float_format</span><span class="p">,</span>
                      <span class="n">xname</span><span class="o">=</span><span class="n">xname</span><span class="p">,</span> <span class="n">yname</span><span class="o">=</span><span class="n">yname</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">'constraints'</span><span class="p">):</span>
            <span class="n">smry</span><span class="o">.</span><span class="n">add_text</span><span class="p">(</span><span class="s1">'Model has been estimated subject to linear '</span>
                          <span class="s1">'equality constraints.'</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">smry</span>


<span class="k">class</span> <span class="nc">CountResults</span><span class="p">(</span><span class="n">DiscreteResults</span><span class="p">):</span>
    <span class="vm">__doc__</span> <span class="o">=</span> <span class="n">_discrete_results_docs</span> <span class="o">%</span> <span class="p">{</span>
        <span class="s2">"one_line_description"</span><span class="p">:</span> <span class="s2">"A results class for count data"</span><span class="p">,</span>
        <span class="s2">"extra_attr"</span><span class="p">:</span> <span class="s2">""</span><span class="p">}</span>
    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">resid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Residuals</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The residuals for Count models are defined as</span>

<span class="sd">        .. math:: y - p</span>

<span class="sd">        where :math:`p = \\exp(X\\beta)`. Any exposure and offset variables</span>
<span class="sd">        are also handled.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">endog</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">predict</span><span class="p">()</span>


<span class="k">class</span> <span class="nc">NegativeBinomialResults</span><span class="p">(</span><span class="n">CountResults</span><span class="p">):</span>
    <span class="vm">__doc__</span> <span class="o">=</span> <span class="n">_discrete_results_docs</span> <span class="o">%</span> <span class="p">{</span>
        <span class="s2">"one_line_description"</span><span class="p">:</span> <span class="s2">"A results class for NegativeBinomial 1 and 2"</span><span class="p">,</span>
        <span class="s2">"extra_attr"</span><span class="p">:</span> <span class="s2">""</span><span class="p">}</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">lnalpha</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""Natural log of alpha"""</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">lnalpha_std_err</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""Natural log of standardized error"""</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">bse</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">aic</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># + 1 because we estimate alpha</span>
        <span class="n">k_extra</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">,</span> <span class="s1">'k_extra'</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">llf</span> <span class="o">-</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">df_model</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_constant</span> <span class="o">+</span> <span class="n">k_extra</span><span class="p">))</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">bic</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># + 1 because we estimate alpha</span>
        <span class="n">k_extra</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">,</span> <span class="s1">'k_extra'</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">llf</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">df_model</span> <span class="o">+</span>
                                                <span class="bp">self</span><span class="o">.</span><span class="n">k_constant</span> <span class="o">+</span> <span class="n">k_extra</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">GeneralizedPoissonResults</span><span class="p">(</span><span class="n">NegativeBinomialResults</span><span class="p">):</span>
    <span class="vm">__doc__</span> <span class="o">=</span> <span class="n">_discrete_results_docs</span> <span class="o">%</span> <span class="p">{</span>
        <span class="s2">"one_line_description"</span><span class="p">:</span> <span class="s2">"A results class for Generalized Poisson"</span><span class="p">,</span>
        <span class="s2">"extra_attr"</span><span class="p">:</span> <span class="s2">""</span><span class="p">}</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">_dispersion_factor</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">p</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">,</span> <span class="s1">'parameterization'</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predict</span><span class="p">()</span>
        <span class="k">return</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">mu</span><span class="o">**</span><span class="n">p</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>

<span class="k">class</span> <span class="nc">L1CountResults</span><span class="p">(</span><span class="n">DiscreteResults</span><span class="p">):</span>
    <span class="vm">__doc__</span> <span class="o">=</span> <span class="n">_discrete_results_docs</span> <span class="o">%</span> <span class="p">{</span><span class="s2">"one_line_description"</span> <span class="p">:</span>
            <span class="s2">"A results class for count data fit by l1 regularization"</span><span class="p">,</span>
            <span class="s2">"extra_attr"</span> <span class="p">:</span> <span class="n">_l1_results_attr</span><span class="p">}</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">cntfit</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">L1CountResults</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">cntfit</span><span class="p">)</span>
        <span class="c1"># self.trimmed is a boolean array with T/F telling whether or not that</span>
        <span class="c1"># entry in params has been set zero'd out.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">trimmed</span> <span class="o">=</span> <span class="n">cntfit</span><span class="o">.</span><span class="n">mle_retvals</span><span class="p">[</span><span class="s1">'trimmed'</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nnz_params</span> <span class="o">=</span> <span class="p">(</span><span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">trimmed</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

        <span class="c1"># Set degrees of freedom.  In doing so,</span>
        <span class="c1"># adjust for extra parameter in NegativeBinomial nb1 and nb2</span>
        <span class="c1"># extra parameter is not included in df_model</span>
        <span class="n">k_extra</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">,</span> <span class="s1">'k_extra'</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">df_model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nnz_params</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">k_extra</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">df_resid</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">endog</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">nnz_params</span><span class="p">)</span> <span class="o">+</span> <span class="n">k_extra</span>

<span class="k">class</span> <span class="nc">PoissonResults</span><span class="p">(</span><span class="n">CountResults</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">predict_prob</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">exog</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">exposure</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">transform</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Return predicted probability of each count level for each observation</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n : array_like or int</span>
<span class="sd">            The counts for which you want the probabilities. If n is None</span>
<span class="sd">            then the probabilities for each count from 0 to max(y) are</span>
<span class="sd">            given.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ndarray</span>
<span class="sd">            A nobs x n array where len(`n`) columns are indexed by the count</span>
<span class="sd">            n. If n is None, then column 0 is the probability that each</span>
<span class="sd">            observation is 0, column 1 is the probability that each</span>
<span class="sd">            observation is 1, etc.</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">endog</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">exog</span><span class="o">=</span><span class="n">exog</span><span class="p">,</span> <span class="n">exposure</span><span class="o">=</span><span class="n">exposure</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">,</span>
                          <span class="n">transform</span><span class="o">=</span><span class="n">transform</span><span class="p">,</span> <span class="n">linear</span><span class="o">=</span><span class="kc">False</span><span class="p">)[:,</span><span class="kc">None</span><span class="p">]</span>
        <span class="c1"># uses broadcasting</span>
        <span class="k">return</span> <span class="n">stats</span><span class="o">.</span><span class="n">poisson</span><span class="o">.</span><span class="n">pmf</span><span class="p">(</span><span class="n">counts</span><span class="p">,</span> <span class="n">mu</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">resid_pearson</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Pearson residuals</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Pearson residuals are defined to be</span>

<span class="sd">        .. math:: r_j = \\frac{(y - M_jp_j)}{\\sqrt{M_jp_j(1-p_j)}}</span>

<span class="sd">        where :math:`p_j=cdf(X\\beta)` and :math:`M_j` is the total number of</span>
<span class="sd">        observations sharing the covariate pattern :math:`j`.</span>

<span class="sd">        For now :math:`M_j` is always set to 1.</span>
<span class="sd">        """</span>
        <span class="c1"># Pearson residuals</span>
        <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predict</span><span class="p">()</span>  <span class="c1"># fittedvalues is still linear</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">endog</span> <span class="o">-</span> <span class="n">p</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">L1PoissonResults</span><span class="p">(</span><span class="n">L1CountResults</span><span class="p">,</span> <span class="n">PoissonResults</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">L1NegativeBinomialResults</span><span class="p">(</span><span class="n">L1CountResults</span><span class="p">,</span> <span class="n">NegativeBinomialResults</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">L1GeneralizedPoissonResults</span><span class="p">(</span><span class="n">L1CountResults</span><span class="p">,</span> <span class="n">GeneralizedPoissonResults</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">OrderedResults</span><span class="p">(</span><span class="n">DiscreteResults</span><span class="p">):</span>
    <span class="vm">__doc__</span> <span class="o">=</span> <span class="n">_discrete_results_docs</span> <span class="o">%</span> <span class="p">{</span><span class="s2">"one_line_description"</span> <span class="p">:</span> <span class="s2">"A results class for ordered discrete data."</span> <span class="p">,</span> <span class="s2">"extra_attr"</span> <span class="p">:</span> <span class="s2">""</span><span class="p">}</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">BinaryResults</span><span class="p">(</span><span class="n">DiscreteResults</span><span class="p">):</span>
    <span class="vm">__doc__</span> <span class="o">=</span> <span class="n">_discrete_results_docs</span> <span class="o">%</span> <span class="p">{</span><span class="s2">"one_line_description"</span> <span class="p">:</span> <span class="s2">"A results class for binary data"</span><span class="p">,</span> <span class="s2">"extra_attr"</span> <span class="p">:</span> <span class="s2">""</span><span class="p">}</span>

    <span class="k">def</span> <span class="nf">pred_table</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=.</span><span class="mi">5</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Prediction table</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        threshold : scalar</span>
<span class="sd">            Number between 0 and 1. Threshold above which a prediction is</span>
<span class="sd">            considered 1 and below which a prediction is considered 0.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        pred_table[i,j] refers to the number of times "i" was observed and</span>
<span class="sd">        the model predicted "j". Correct predictions are along the diagonal.</span>
<span class="sd">        """</span>
        <span class="n">model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span>
        <span class="n">actual</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">endog</span>
        <span class="n">pred</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">predict</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram2d</span><span class="p">(</span><span class="n">actual</span><span class="p">,</span> <span class="n">pred</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">bins</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="nd">@Appender</span><span class="p">(</span><span class="n">DiscreteResults</span><span class="o">.</span><span class="n">summary</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">summary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">yname</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">xname</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=.</span><span class="mi">05</span><span class="p">,</span>
                <span class="n">yname_list</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">smry</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">BinaryResults</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">summary</span><span class="p">(</span><span class="n">yname</span><span class="p">,</span> <span class="n">xname</span><span class="p">,</span> <span class="n">title</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span>
                                                  <span class="n">yname_list</span><span class="p">)</span>
        <span class="n">fittedvalues</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fittedvalues</span><span class="p">)</span>
        <span class="n">absprederror</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">endog</span> <span class="o">-</span> <span class="n">fittedvalues</span><span class="p">)</span>
        <span class="n">predclose_sum</span> <span class="o">=</span> <span class="p">(</span><span class="n">absprederror</span> <span class="o">&lt;</span> <span class="mf">1e-4</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">predclose_frac</span> <span class="o">=</span> <span class="n">predclose_sum</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">fittedvalues</span><span class="p">)</span>

        <span class="c1"># add warnings/notes</span>
        <span class="n">etext</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">predclose_sum</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">fittedvalues</span><span class="p">):</span>  <span class="c1"># TODO: nobs?</span>
            <span class="n">wstr</span> <span class="o">=</span> <span class="s2">"Complete Separation: The results show that there is"</span>
            <span class="n">wstr</span> <span class="o">+=</span> <span class="s2">"complete separation.</span><span class="se">\n</span><span class="s2">"</span>
            <span class="n">wstr</span> <span class="o">+=</span> <span class="s2">"In this case the Maximum Likelihood Estimator does "</span>
            <span class="n">wstr</span> <span class="o">+=</span> <span class="s2">"not exist and the parameters</span><span class="se">\n</span><span class="s2">"</span>
            <span class="n">wstr</span> <span class="o">+=</span> <span class="s2">"are not identified."</span>
            <span class="n">etext</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">wstr</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">predclose_frac</span> <span class="o">&gt;</span> <span class="mf">0.1</span><span class="p">:</span>  <span class="c1"># TODO: get better diagnosis</span>
            <span class="n">wstr</span> <span class="o">=</span> <span class="s2">"Possibly complete quasi-separation: A fraction "</span>
            <span class="n">wstr</span> <span class="o">+=</span> <span class="s2">"</span><span class="si">%4.2f</span><span class="s2"> of observations can be</span><span class="se">\n</span><span class="s2">"</span> <span class="o">%</span> <span class="n">predclose_frac</span>
            <span class="n">wstr</span> <span class="o">+=</span> <span class="s2">"perfectly predicted. This might indicate that there "</span>
            <span class="n">wstr</span> <span class="o">+=</span> <span class="s2">"is complete</span><span class="se">\n</span><span class="s2">quasi-separation. In this case some "</span>
            <span class="n">wstr</span> <span class="o">+=</span> <span class="s2">"parameters will not be identified."</span>
            <span class="n">etext</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">wstr</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">etext</span><span class="p">:</span>
            <span class="n">smry</span><span class="o">.</span><span class="n">add_extra_txt</span><span class="p">(</span><span class="n">etext</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">smry</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">resid_dev</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Deviance residuals</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Deviance residuals are defined</span>

<span class="sd">        .. math:: d_j = \\pm\\left(2\\left[Y_j\\ln\\left(\\frac{Y_j}{M_jp_j}\\right) + (M_j - Y_j\\ln\\left(\\frac{M_j-Y_j}{M_j(1-p_j)} \\right) \\right] \\right)^{1/2}</span>

<span class="sd">        where</span>

<span class="sd">        :math:`p_j = cdf(X\\beta)` and :math:`M_j` is the total number of</span>
<span class="sd">        observations sharing the covariate pattern :math:`j`.</span>

<span class="sd">        For now :math:`M_j` is always set to 1.</span>
<span class="sd">        """</span>
        <span class="c1">#These are the deviance residuals</span>
        <span class="c1">#model = self.model</span>
        <span class="n">endog</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">endog</span>
        <span class="c1">#exog = model.exog</span>
        <span class="c1"># M = # of individuals that share a covariate pattern</span>
        <span class="c1"># so M[i] = 2 for i = two share a covariate pattern</span>
        <span class="n">M</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predict</span><span class="p">()</span>
        <span class="c1">#Y_0 = np.where(exog == 0)</span>
        <span class="c1">#Y_M = np.where(exog == M)</span>
        <span class="c1">#NOTE: Common covariate patterns are not yet handled</span>
        <span class="n">res</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">endog</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">M</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">p</span><span class="p">)))</span> <span class="o">+</span> \
                <span class="n">endog</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">M</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">p</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">res</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">resid_pearson</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Pearson residuals</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Pearson residuals are defined to be</span>

<span class="sd">        .. math:: r_j = \\frac{(y - M_jp_j)}{\\sqrt{M_jp_j(1-p_j)}}</span>

<span class="sd">        where :math:`p_j=cdf(X\\beta)` and :math:`M_j` is the total number of</span>
<span class="sd">        observations sharing the covariate pattern :math:`j`.</span>

<span class="sd">        For now :math:`M_j` is always set to 1.</span>
<span class="sd">        """</span>
        <span class="c1"># Pearson residuals</span>
        <span class="c1">#model = self.model</span>
        <span class="n">endog</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">endog</span>
        <span class="c1">#exog = model.exog</span>
        <span class="c1"># M = # of individuals that share a covariate pattern</span>
        <span class="c1"># so M[i] = 2 for i = two share a covariate pattern</span>
        <span class="c1"># use unique row pattern?</span>
        <span class="n">M</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predict</span><span class="p">()</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">endog</span> <span class="o">-</span> <span class="n">M</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">M</span><span class="o">*</span><span class="n">p</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">p</span><span class="p">))</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">resid_response</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        The response residuals</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Response residuals are defined to be</span>

<span class="sd">        .. math:: y - p</span>

<span class="sd">        where :math:`p=cdf(X\\beta)`.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">endog</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">predict</span><span class="p">()</span>


<div class="viewcode-block" id="LogitResults"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.LogitResults.html#statsmodels.discrete.count_model.LogitResults">[docs]</a><span class="k">class</span> <span class="nc">LogitResults</span><span class="p">(</span><span class="n">BinaryResults</span><span class="p">):</span>
    <span class="vm">__doc__</span> <span class="o">=</span> <span class="n">_discrete_results_docs</span> <span class="o">%</span> <span class="p">{</span>
        <span class="s2">"one_line_description"</span><span class="p">:</span> <span class="s2">"A results class for Logit Model"</span><span class="p">,</span>
        <span class="s2">"extra_attr"</span><span class="p">:</span> <span class="s2">""</span><span class="p">}</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">resid_generalized</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Generalized residuals</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The generalized residuals for the Logit model are defined</span>

<span class="sd">        .. math:: y - p</span>

<span class="sd">        where :math:`p=cdf(X\\beta)`. This is the same as the `resid_response`</span>
<span class="sd">        for the Logit model.</span>
<span class="sd">        """</span>
        <span class="c1"># Generalized residuals</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">endog</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">predict</span><span class="p">()</span></div>


<span class="k">class</span> <span class="nc">ProbitResults</span><span class="p">(</span><span class="n">BinaryResults</span><span class="p">):</span>
    <span class="vm">__doc__</span> <span class="o">=</span> <span class="n">_discrete_results_docs</span> <span class="o">%</span> <span class="p">{</span>
        <span class="s2">"one_line_description"</span><span class="p">:</span> <span class="s2">"A results class for Probit Model"</span><span class="p">,</span>
        <span class="s2">"extra_attr"</span><span class="p">:</span> <span class="s2">""</span><span class="p">}</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">resid_generalized</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Generalized residuals</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The generalized residuals for the Probit model are defined</span>

<span class="sd">        .. math:: y\\frac{\\phi(X\\beta)}{\\Phi(X\\beta)}-(1-y)\\frac{\\phi(X\\beta)}{1-\\Phi(X\\beta)}</span>
<span class="sd">        """</span>
        <span class="c1"># generalized residuals</span>
        <span class="n">model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span>
        <span class="n">endog</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">endog</span>
        <span class="n">XB</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">linear</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">pdf</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="n">XB</span><span class="p">)</span>
        <span class="n">cdf</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">XB</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">endog</span> <span class="o">*</span> <span class="n">pdf</span><span class="o">/</span><span class="n">cdf</span> <span class="o">-</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">endog</span><span class="p">)</span><span class="o">*</span><span class="n">pdf</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">cdf</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">L1BinaryResults</span><span class="p">(</span><span class="n">BinaryResults</span><span class="p">):</span>
    <span class="vm">__doc__</span> <span class="o">=</span> <span class="n">_discrete_results_docs</span> <span class="o">%</span> <span class="p">{</span><span class="s2">"one_line_description"</span> <span class="p">:</span>
    <span class="s2">"Results instance for binary data fit by l1 regularization"</span><span class="p">,</span>
    <span class="s2">"extra_attr"</span> <span class="p">:</span> <span class="n">_l1_results_attr</span><span class="p">}</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">bnryfit</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">L1BinaryResults</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">bnryfit</span><span class="p">)</span>
        <span class="c1"># self.trimmed is a boolean array with T/F telling whether or not that</span>
        <span class="c1"># entry in params has been set zero'd out.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">trimmed</span> <span class="o">=</span> <span class="n">bnryfit</span><span class="o">.</span><span class="n">mle_retvals</span><span class="p">[</span><span class="s1">'trimmed'</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nnz_params</span> <span class="o">=</span> <span class="p">(</span><span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">trimmed</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">df_model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nnz_params</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">df_resid</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">endog</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">nnz_params</span><span class="p">)</span>


<div class="viewcode-block" id="MultinomialResults"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.MultinomialResults.html#statsmodels.discrete.count_model.MultinomialResults">[docs]</a><span class="k">class</span> <span class="nc">MultinomialResults</span><span class="p">(</span><span class="n">DiscreteResults</span><span class="p">):</span>
    <span class="vm">__doc__</span> <span class="o">=</span> <span class="n">_discrete_results_docs</span> <span class="o">%</span> <span class="p">{</span><span class="s2">"one_line_description"</span> <span class="p">:</span>
            <span class="s2">"A results class for multinomial data"</span><span class="p">,</span> <span class="s2">"extra_attr"</span> <span class="p">:</span> <span class="s2">""</span><span class="p">}</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">mlefit</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">MultinomialResults</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">mlefit</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">J</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">J</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">K</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">K</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_maybe_convert_ynames_int</span><span class="p">(</span><span class="n">ynames</span><span class="p">):</span>
        <span class="c1"># see if they're integers</span>
        <span class="n">issue_warning</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s1">'endog contains values are that not int-like. Uses string '</span>
               <span class="s1">'representation of value. Use integer-valued endog to '</span>
               <span class="s1">'suppress this warning.'</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ynames</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">ynames</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">%</span> <span class="mi">1</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">ynames</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">ynames</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">issue_warning</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="n">ynames</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">ynames</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="n">ynames</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">ynames</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">issue_warning</span><span class="p">:</span>
            <span class="kn">import</span> <span class="nn">warnings</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">SpecificationWarning</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">ynames</span>

    <span class="k">def</span> <span class="nf">_get_endog_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">yname</span><span class="p">,</span> <span class="n">yname_list</span><span class="p">,</span> <span class="nb">all</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        If all is False, the first variable name is dropped</span>
<span class="sd">        """</span>
        <span class="n">model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span>
        <span class="k">if</span> <span class="n">yname</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">yname</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">endog_names</span>
        <span class="k">if</span> <span class="n">yname_list</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ynames</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">_ynames_map</span>
            <span class="n">ynames</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maybe_convert_ynames_int</span><span class="p">(</span><span class="n">ynames</span><span class="p">)</span>
            <span class="c1"># use range below to ensure sortedness</span>
            <span class="n">ynames</span> <span class="o">=</span> <span class="p">[</span><span class="n">ynames</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">J</span><span class="p">))]</span>
            <span class="n">ynames</span> <span class="o">=</span> <span class="p">[</span><span class="s1">'='</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">yname</span><span class="p">,</span> <span class="n">name</span><span class="p">])</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">ynames</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">:</span>
                <span class="n">yname_list</span> <span class="o">=</span> <span class="n">ynames</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="c1"># assumes first variable is dropped</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">yname_list</span> <span class="o">=</span> <span class="n">ynames</span>
        <span class="k">return</span> <span class="n">yname</span><span class="p">,</span> <span class="n">yname_list</span>

<div class="viewcode-block" id="MultinomialResults.pred_table"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.MultinomialResults.pred_table.html#statsmodels.discrete.count_model.MultinomialResults.pred_table">[docs]</a>    <span class="k">def</span> <span class="nf">pred_table</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Returns the J x J prediction table.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        pred_table[i,j] refers to the number of times "i" was observed and</span>
<span class="sd">        the model predicted "j". Correct predictions are along the diagonal.</span>
<span class="sd">        """</span>
        <span class="n">ju</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">J</span> <span class="o">-</span> <span class="mi">1</span>  <span class="c1"># highest index</span>
        <span class="c1"># these are the actual, predicted indices</span>
        <span class="c1">#idx = lzip(self.model.endog, self.predict().argmax(1))</span>
        <span class="n">bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(([</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">ju</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">ju</span><span class="p">),</span> <span class="p">[</span><span class="n">ju</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram2d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">endog</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">predict</span><span class="p">()</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
                              <span class="n">bins</span><span class="o">=</span><span class="n">bins</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span></div>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">bse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">bse</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cov_params</span><span class="p">()))</span>
        <span class="k">return</span> <span class="n">bse</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">'F'</span><span class="p">)</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">aic</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">llf</span> <span class="o">-</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">df_model</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">J</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">bic</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">llf</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">df_model</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">J</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

<div class="viewcode-block" id="MultinomialResults.conf_int"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.MultinomialResults.conf_int.html#statsmodels.discrete.count_model.MultinomialResults.conf_int">[docs]</a>    <span class="k">def</span> <span class="nf">conf_int</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=.</span><span class="mi">05</span><span class="p">,</span> <span class="n">cols</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">confint</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">DiscreteResults</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">conf_int</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span>
                                                            <span class="n">cols</span><span class="o">=</span><span class="n">cols</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">confint</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span></div>

<div class="viewcode-block" id="MultinomialResults.margeff"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.MultinomialResults.margeff.html#statsmodels.discrete.count_model.MultinomialResults.margeff">[docs]</a>    <span class="k">def</span> <span class="nf">margeff</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">"Use get_margeff instead"</span><span class="p">)</span></div>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">resid_misclassified</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Residuals indicating which observations are misclassified.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The residuals for the multinomial model are defined as</span>

<span class="sd">        .. math:: argmax(y_i) \\neq argmax(p_i)</span>

<span class="sd">        where :math:`argmax(y_i)` is the index of the category for the</span>
<span class="sd">        endogenous variable and :math:`argmax(p_i)` is the index of the</span>
<span class="sd">        predicted probabilities for each category. That is, the residual</span>
<span class="sd">        is a binary indicator that is 0 if the category with the highest</span>
<span class="sd">        predicted probability is the same as that of the observed variable</span>
<span class="sd">        and 1 otherwise.</span>
<span class="sd">        """</span>
        <span class="c1"># it's 0 or 1 - 0 for correct prediction and 1 for a missed one</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">wendog</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">!=</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">predict</span><span class="p">()</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>

<div class="viewcode-block" id="MultinomialResults.summary2"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.MultinomialResults.summary2.html#statsmodels.discrete.count_model.MultinomialResults.summary2">[docs]</a>    <span class="k">def</span> <span class="nf">summary2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">float_format</span><span class="o">=</span><span class="s2">"</span><span class="si">%.4f</span><span class="s2">"</span><span class="p">):</span>
        <span class="sd">"""Experimental function to summarize regression results</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        alpha : float</span>
<span class="sd">            significance level for the confidence intervals</span>
<span class="sd">        float_format : str</span>
<span class="sd">            print format for floats in parameters summary</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        smry : Summary instance</span>
<span class="sd">            this holds the summary tables and text, which can be printed or</span>
<span class="sd">            converted to various output formats.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        statsmodels.iolib.summary2.Summary : class to hold summary results</span>
<span class="sd">        """</span>

        <span class="kn">from</span> <span class="nn">statsmodels.iolib</span> <span class="kn">import</span> <span class="n">summary2</span>
        <span class="n">smry</span> <span class="o">=</span> <span class="n">summary2</span><span class="o">.</span><span class="n">Summary</span><span class="p">()</span>
        <span class="n">smry</span><span class="o">.</span><span class="n">add_dict</span><span class="p">(</span><span class="n">summary2</span><span class="o">.</span><span class="n">summary_model</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="c1"># One data frame per value of endog</span>
        <span class="n">eqn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">confint</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">conf_int</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">eqn</span><span class="p">):</span>
            <span class="n">coefs</span> <span class="o">=</span> <span class="n">summary2</span><span class="o">.</span><span class="n">summary_params</span><span class="p">((</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span>
                                             <span class="bp">self</span><span class="o">.</span><span class="n">bse</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span>
                                             <span class="bp">self</span><span class="o">.</span><span class="n">tvalues</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span>
                                             <span class="bp">self</span><span class="o">.</span><span class="n">pvalues</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span>
                                             <span class="n">confint</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span>
                                            <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">)</span>
            <span class="c1"># Header must show value of endog</span>
            <span class="n">level_str</span> <span class="o">=</span>  <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">endog_names</span> <span class="o">+</span> <span class="s1">' = '</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">coefs</span><span class="p">[</span><span class="n">level_str</span><span class="p">]</span> <span class="o">=</span> <span class="n">coefs</span><span class="o">.</span><span class="n">index</span>
            <span class="n">coefs</span> <span class="o">=</span> <span class="n">coefs</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]]</span>
            <span class="n">smry</span><span class="o">.</span><span class="n">add_df</span><span class="p">(</span><span class="n">coefs</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                        <span class="n">float_format</span><span class="o">=</span><span class="n">float_format</span><span class="p">)</span>
            <span class="n">smry</span><span class="o">.</span><span class="n">add_title</span><span class="p">(</span><span class="n">results</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">smry</span></div></div>


<span class="k">class</span> <span class="nc">L1MultinomialResults</span><span class="p">(</span><span class="n">MultinomialResults</span><span class="p">):</span>
    <span class="vm">__doc__</span> <span class="o">=</span> <span class="n">_discrete_results_docs</span> <span class="o">%</span> <span class="p">{</span><span class="s2">"one_line_description"</span> <span class="p">:</span>
        <span class="s2">"A results class for multinomial data fit by l1 regularization"</span><span class="p">,</span>
        <span class="s2">"extra_attr"</span> <span class="p">:</span> <span class="n">_l1_results_attr</span><span class="p">}</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">mlefit</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">L1MultinomialResults</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">mlefit</span><span class="p">)</span>
        <span class="c1"># self.trimmed is a boolean array with T/F telling whether or not that</span>
        <span class="c1"># entry in params has been set zero'd out.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">trimmed</span> <span class="o">=</span> <span class="n">mlefit</span><span class="o">.</span><span class="n">mle_retvals</span><span class="p">[</span><span class="s1">'trimmed'</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nnz_params</span> <span class="o">=</span> <span class="p">(</span><span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">trimmed</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

        <span class="c1"># Note: J-1 constants</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">df_model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nnz_params</span> <span class="o">-</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">J</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">df_resid</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">endog</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">nnz_params</span><span class="p">)</span>


<span class="c1">#### Results Wrappers ####</span>

<span class="k">class</span> <span class="nc">OrderedResultsWrapper</span><span class="p">(</span><span class="n">lm</span><span class="o">.</span><span class="n">RegressionResultsWrapper</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="n">wrap</span><span class="o">.</span><span class="n">populate_wrapper</span><span class="p">(</span><span class="n">OrderedResultsWrapper</span><span class="p">,</span> <span class="n">OrderedResults</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">CountResultsWrapper</span><span class="p">(</span><span class="n">lm</span><span class="o">.</span><span class="n">RegressionResultsWrapper</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="n">wrap</span><span class="o">.</span><span class="n">populate_wrapper</span><span class="p">(</span><span class="n">CountResultsWrapper</span><span class="p">,</span> <span class="n">CountResults</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">NegativeBinomialResultsWrapper</span><span class="p">(</span><span class="n">lm</span><span class="o">.</span><span class="n">RegressionResultsWrapper</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="n">wrap</span><span class="o">.</span><span class="n">populate_wrapper</span><span class="p">(</span><span class="n">NegativeBinomialResultsWrapper</span><span class="p">,</span>
                      <span class="n">NegativeBinomialResults</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">GeneralizedPoissonResultsWrapper</span><span class="p">(</span><span class="n">lm</span><span class="o">.</span><span class="n">RegressionResultsWrapper</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="n">wrap</span><span class="o">.</span><span class="n">populate_wrapper</span><span class="p">(</span><span class="n">GeneralizedPoissonResultsWrapper</span><span class="p">,</span>
                      <span class="n">GeneralizedPoissonResults</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">PoissonResultsWrapper</span><span class="p">(</span><span class="n">lm</span><span class="o">.</span><span class="n">RegressionResultsWrapper</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="n">wrap</span><span class="o">.</span><span class="n">populate_wrapper</span><span class="p">(</span><span class="n">PoissonResultsWrapper</span><span class="p">,</span> <span class="n">PoissonResults</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">L1CountResultsWrapper</span><span class="p">(</span><span class="n">lm</span><span class="o">.</span><span class="n">RegressionResultsWrapper</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">class</span> <span class="nc">L1PoissonResultsWrapper</span><span class="p">(</span><span class="n">lm</span><span class="o">.</span><span class="n">RegressionResultsWrapper</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="n">wrap</span><span class="o">.</span><span class="n">populate_wrapper</span><span class="p">(</span><span class="n">L1PoissonResultsWrapper</span><span class="p">,</span> <span class="n">L1PoissonResults</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">L1NegativeBinomialResultsWrapper</span><span class="p">(</span><span class="n">lm</span><span class="o">.</span><span class="n">RegressionResultsWrapper</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="n">wrap</span><span class="o">.</span><span class="n">populate_wrapper</span><span class="p">(</span><span class="n">L1NegativeBinomialResultsWrapper</span><span class="p">,</span>
                      <span class="n">L1NegativeBinomialResults</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">L1GeneralizedPoissonResultsWrapper</span><span class="p">(</span><span class="n">lm</span><span class="o">.</span><span class="n">RegressionResultsWrapper</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="n">wrap</span><span class="o">.</span><span class="n">populate_wrapper</span><span class="p">(</span><span class="n">L1GeneralizedPoissonResultsWrapper</span><span class="p">,</span>
                      <span class="n">L1GeneralizedPoissonResults</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">BinaryResultsWrapper</span><span class="p">(</span><span class="n">lm</span><span class="o">.</span><span class="n">RegressionResultsWrapper</span><span class="p">):</span>
    <span class="n">_attrs</span> <span class="o">=</span> <span class="p">{</span><span class="s2">"resid_dev"</span><span class="p">:</span> <span class="s2">"rows"</span><span class="p">,</span>
              <span class="s2">"resid_generalized"</span><span class="p">:</span> <span class="s2">"rows"</span><span class="p">,</span>
              <span class="s2">"resid_pearson"</span><span class="p">:</span> <span class="s2">"rows"</span><span class="p">,</span>
              <span class="s2">"resid_response"</span><span class="p">:</span> <span class="s2">"rows"</span>
              <span class="p">}</span>
    <span class="n">_wrap_attrs</span> <span class="o">=</span> <span class="n">wrap</span><span class="o">.</span><span class="n">union_dicts</span><span class="p">(</span><span class="n">lm</span><span class="o">.</span><span class="n">RegressionResultsWrapper</span><span class="o">.</span><span class="n">_wrap_attrs</span><span class="p">,</span>
                                   <span class="n">_attrs</span><span class="p">)</span>


<span class="n">wrap</span><span class="o">.</span><span class="n">populate_wrapper</span><span class="p">(</span><span class="n">BinaryResultsWrapper</span><span class="p">,</span> <span class="n">BinaryResults</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">L1BinaryResultsWrapper</span><span class="p">(</span><span class="n">lm</span><span class="o">.</span><span class="n">RegressionResultsWrapper</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="n">wrap</span><span class="o">.</span><span class="n">populate_wrapper</span><span class="p">(</span><span class="n">L1BinaryResultsWrapper</span><span class="p">,</span> <span class="n">L1BinaryResults</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">MultinomialResultsWrapper</span><span class="p">(</span><span class="n">lm</span><span class="o">.</span><span class="n">RegressionResultsWrapper</span><span class="p">):</span>
    <span class="n">_attrs</span> <span class="o">=</span> <span class="p">{</span><span class="s2">"resid_misclassified"</span><span class="p">:</span> <span class="s2">"rows"</span><span class="p">}</span>
    <span class="n">_wrap_attrs</span> <span class="o">=</span> <span class="n">wrap</span><span class="o">.</span><span class="n">union_dicts</span><span class="p">(</span><span class="n">lm</span><span class="o">.</span><span class="n">RegressionResultsWrapper</span><span class="o">.</span><span class="n">_wrap_attrs</span><span class="p">,</span>
                                   <span class="n">_attrs</span><span class="p">)</span>
    <span class="n">_methods</span> <span class="o">=</span> <span class="p">{</span><span class="s1">'conf_int'</span><span class="p">:</span> <span class="s1">'multivariate_confint'</span><span class="p">}</span>
    <span class="n">_wrap_methods</span> <span class="o">=</span> <span class="n">wrap</span><span class="o">.</span><span class="n">union_dicts</span><span class="p">(</span><span class="n">lm</span><span class="o">.</span><span class="n">RegressionResultsWrapper</span><span class="o">.</span><span class="n">_wrap_methods</span><span class="p">,</span>
                                     <span class="n">_methods</span><span class="p">)</span>


<span class="n">wrap</span><span class="o">.</span><span class="n">populate_wrapper</span><span class="p">(</span><span class="n">MultinomialResultsWrapper</span><span class="p">,</span> <span class="n">MultinomialResults</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">L1MultinomialResultsWrapper</span><span class="p">(</span><span class="n">lm</span><span class="o">.</span><span class="n">RegressionResultsWrapper</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="n">wrap</span><span class="o">.</span><span class="n">populate_wrapper</span><span class="p">(</span><span class="n">L1MultinomialResultsWrapper</span><span class="p">,</span> <span class="n">L1MultinomialResults</span><span class="p">)</span>
</pre></div>

          </article>
        </div>
      </div>
    </main>
  </div>
  <footer class="md-footer">
    <div class="md-footer-nav">
      <nav class="md-footer-nav__inner md-grid">
          
          
        </a>
        
      </nav>
    </div>
    <div class="md-footer-meta md-typeset">
      <div class="md-footer-meta__inner md-grid">
        <div class="md-footer-copyright">
          <div class="md-footer-copyright__highlight">
              &#169; Copyright 2009-2019, Josef Perktold, Skipper Seabold, Jonathan Taylor, statsmodels-developers.
              
          </div>
            Last updated on
              Feb 02, 2021.
            <br/>
            Created using
            <a href="http://www.sphinx-doc.org/">Sphinx</a> 3.4.3.
             and
            <a href="https://github.com/bashtage/sphinx-material/">Material for
              Sphinx</a>
        </div>
      </div>
    </div>
  </footer>
  <script src="../../../_static/javascripts/application.js"></script>
  <script>app.initialize({version: "1.0.4", url: {base: ".."}})</script>
  </body>
</html>