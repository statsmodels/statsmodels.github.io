

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>statsmodels.tsa.statespace.mlemodel &#8212; statsmodels 0.9.0 documentation</title>
    <link rel="stylesheet" href="../../../../_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
    <script type="text/javascript" src="../../../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="shortcut icon" href="../../../../_static/statsmodels_hybi_favico.ico"/>
    <link rel="author" title="About these documents" href="../../../../about.html" />
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
<link rel="stylesheet" href="../../../../_static/examples.css" type="text/css" />
<link rel="stylesheet" href="../../../../_static/facebox.css" type="text/css" />
<script type="text/javascript" src="../../../../_static/scripts.js">
</script>
<script type="text/javascript" src="../../../../_static/facebox.js">
</script>
<script type="text/javascript">
$.facebox.settings.closeImage = "../../../../_static/closelabel.png"
$.facebox.settings.loadingImage = "../../../../_static/loading.gif"
</script>

  </head><body>
<div class="headerwrap">
    <div class = "header">
        
        <a href = "../../../../index.html">
<img src="../../../../_static/statsmodels_hybi_banner.png" alt="Logo"
    style="padding-left: 15px"/></a>
        
    </div>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
<li><a href ="../../../../install.html">Install</a></li> &nbsp;|&nbsp;
<li><a href="https://groups.google.com/forum/?hl=en#!forum/pystatsmodels">Support</a></li> &nbsp;|&nbsp;
<li><a href="https://github.com/statsmodels/statsmodels/issues">Bugs</a></li> &nbsp;|&nbsp;
<li><a href="../../../../dev/index.html">Develop</a></li> &nbsp;|&nbsp;
<li><a href="../../../../examples/index.html">Examples</a></li> &nbsp;|&nbsp;
<li><a href="../../../../faq.html">FAQ</a></li> &nbsp;|&nbsp;

          <li class="nav-item nav-item-1"><a href="../../../index.html" accesskey="U">Module code</a> |</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            




  <h1>Source code for statsmodels.tsa.statespace.mlemodel</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">State Space Model</span>

<span class="sd">Author: Chad Fulton</span>
<span class="sd">License: Simplified-BSD</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">division</span><span class="p">,</span> <span class="n">absolute_import</span><span class="p">,</span> <span class="n">print_function</span>
<span class="kn">from</span> <span class="nn">statsmodels.compat.python</span> <span class="k">import</span> <span class="n">long</span>

<span class="k">try</span><span class="p">:</span> <span class="n">unicode</span>
<span class="k">except</span> <span class="ne">NameError</span><span class="p">:</span> <span class="n">unicode</span> <span class="o">=</span> <span class="nb">str</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="k">import</span> <span class="n">norm</span>

<span class="kn">from</span> <span class="nn">.simulation_smoother</span> <span class="k">import</span> <span class="n">SimulationSmoother</span>
<span class="kn">from</span> <span class="nn">.kalman_smoother</span> <span class="k">import</span> <span class="n">SmootherResults</span>
<span class="kn">from</span> <span class="nn">.kalman_filter</span> <span class="k">import</span> <span class="p">(</span><span class="n">INVERT_UNIVARIATE</span><span class="p">,</span> <span class="n">SOLVE_LU</span><span class="p">)</span>
<span class="kn">import</span> <span class="nn">statsmodels.tsa.base.tsa_model</span> <span class="k">as</span> <span class="nn">tsbase</span>
<span class="kn">import</span> <span class="nn">statsmodels.base.wrapper</span> <span class="k">as</span> <span class="nn">wrap</span>
<span class="kn">from</span> <span class="nn">statsmodels.tools.numdiff</span> <span class="k">import</span> <span class="p">(</span><span class="n">_get_epsilon</span><span class="p">,</span> <span class="n">approx_hess_cs</span><span class="p">,</span>
                                       <span class="n">approx_fprime_cs</span><span class="p">,</span> <span class="n">approx_fprime</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">statsmodels.tools.decorators</span> <span class="k">import</span> <span class="n">cache_readonly</span><span class="p">,</span> <span class="n">resettable_cache</span>
<span class="kn">from</span> <span class="nn">statsmodels.tools.eval_measures</span> <span class="k">import</span> <span class="n">aic</span><span class="p">,</span> <span class="n">bic</span><span class="p">,</span> <span class="n">hqic</span>
<span class="kn">from</span> <span class="nn">statsmodels.tools.tools</span> <span class="k">import</span> <span class="n">pinv_extended</span><span class="p">,</span> <span class="n">Bunch</span>
<span class="kn">from</span> <span class="nn">statsmodels.tools.sm_exceptions</span> <span class="k">import</span> <span class="n">PrecisionWarning</span>
<span class="kn">import</span> <span class="nn">statsmodels.genmod._prediction</span> <span class="k">as</span> <span class="nn">pred</span>
<span class="kn">from</span> <span class="nn">statsmodels.genmod.families.links</span> <span class="k">import</span> <span class="n">identity</span>
<span class="kn">import</span> <span class="nn">warnings</span>


<span class="k">def</span> <span class="nf">_handle_args</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">defaults</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">output_args</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># We need to handle positional arguments in two ways, in case this was</span>
    <span class="c1"># called by a Scipy optimization routine</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># the fit() method will pass a dictionary</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">flags</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># otherwise, a user may have just used positional arguments...</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">flags</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">args</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">names</span><span class="p">)):</span>
            <span class="n">output_args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">flags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">names</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">defaults</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>

        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">flags</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;loglike() got multiple values for keyword&quot;</span>
                                <span class="s2">&quot; argument &#39;</span><span class="si">%s</span><span class="s2">&#39;&quot;</span> <span class="o">%</span> <span class="n">name</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">names</span><span class="p">)):</span>
            <span class="n">output_args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">names</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">defaults</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>

    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">output_args</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">kwargs</span><span class="p">,)</span>


<div class="viewcode-block" id="MLEModel"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEModel.html#statsmodels.regression.recursive_ls.MLEModel">[docs]</a><span class="k">class</span> <span class="nc">MLEModel</span><span class="p">(</span><span class="n">tsbase</span><span class="o">.</span><span class="n">TimeSeriesModel</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    State space model for maximum likelihood estimation</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    endog : array_like</span>
<span class="sd">        The observed time-series process :math:`y`</span>
<span class="sd">    k_states : int</span>
<span class="sd">        The dimension of the unobserved state process.</span>
<span class="sd">    exog : array_like, optional</span>
<span class="sd">        Array of exogenous regressors, shaped nobs x k. Default is no</span>
<span class="sd">        exogenous regressors.</span>
<span class="sd">    dates : array-like of datetime, optional</span>
<span class="sd">        An array-like object of datetime objects. If a Pandas object is given</span>
<span class="sd">        for endog, it is assumed to have a DateIndex.</span>
<span class="sd">    freq : str, optional</span>
<span class="sd">        The frequency of the time-series. A Pandas offset or &#39;B&#39;, &#39;D&#39;, &#39;W&#39;,</span>
<span class="sd">        &#39;M&#39;, &#39;A&#39;, or &#39;Q&#39;. This is optional if dates are given.</span>
<span class="sd">    **kwargs</span>
<span class="sd">        Keyword arguments may be used to provide default values for state space</span>
<span class="sd">        matrices or for Kalman filtering options. See `Representation`, and</span>
<span class="sd">        `KalmanFilter` for more details.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    ssm : KalmanFilter</span>
<span class="sd">        Underlying state space representation.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This class wraps the state space model with Kalman filtering to add in</span>
<span class="sd">    functionality for maximum likelihood estimation. In particular, it adds</span>
<span class="sd">    the concept of updating the state space representation based on a defined</span>
<span class="sd">    set of parameters, through the `update` method or `updater` attribute (see</span>
<span class="sd">    below for more details on which to use when), and it adds a `fit` method</span>
<span class="sd">    which uses a numerical optimizer to select the parameters that maximize</span>
<span class="sd">    the likelihood of the model.</span>

<span class="sd">    The `start_params` `update` method must be overridden in the</span>
<span class="sd">    child class (and the `transform` and `untransform` methods, if needed).</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    MLEResults</span>
<span class="sd">    statsmodels.tsa.statespace.kalman_filter.KalmanFilter</span>
<span class="sd">    statsmodels.tsa.statespace.representation.Representation</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">endog</span><span class="p">,</span> <span class="n">k_states</span><span class="p">,</span> <span class="n">exog</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dates</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># Initialize the model base</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">MLEModel</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">endog</span><span class="o">=</span><span class="n">endog</span><span class="p">,</span> <span class="n">exog</span><span class="o">=</span><span class="n">exog</span><span class="p">,</span>
                                       <span class="n">dates</span><span class="o">=</span><span class="n">dates</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="n">freq</span><span class="p">,</span>
                                       <span class="n">missing</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">)</span>

        <span class="c1"># Store kwargs to recreate model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_init_kwargs</span> <span class="o">=</span> <span class="n">kwargs</span>

        <span class="c1"># Prepared the endog array: C-ordered, shape=(nobs x k_endog)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">endog</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">exog</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prepare_data</span><span class="p">()</span>

        <span class="c1"># Dimensions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">endog</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k_states</span> <span class="o">=</span> <span class="n">k_states</span>

        <span class="c1"># Initialize the state-space representation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initialize_statespace</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

<div class="viewcode-block" id="MLEModel.prepare_data"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEModel.prepare_data.html#statsmodels.regression.recursive_ls.MLEModel.prepare_data">[docs]</a>    <span class="k">def</span> <span class="nf">prepare_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Prepare data for use in the state space representation</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">endog</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">orig_endog</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
        <span class="n">exog</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">orig_exog</span>
        <span class="k">if</span> <span class="n">exog</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">exog</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">exog</span><span class="p">)</span>

        <span class="c1"># Base class may allow 1-dim data, whereas we need 2-dim</span>
        <span class="k">if</span> <span class="n">endog</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">endog</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">endog</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># this will be C-contiguous</span>

        <span class="k">return</span> <span class="n">endog</span><span class="p">,</span> <span class="n">exog</span></div>

<div class="viewcode-block" id="MLEModel.initialize_statespace"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEModel.initialize_statespace.html#statsmodels.regression.recursive_ls.MLEModel.initialize_statespace">[docs]</a>    <span class="k">def</span> <span class="nf">initialize_statespace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the state space representation</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Additional keyword arguments to pass to the state space class</span>
<span class="sd">            constructor.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># (Now self.endog is C-ordered and in long format (nobs x k_endog). To</span>
        <span class="c1"># get F-ordered and in wide format just need to transpose)</span>
        <span class="n">endog</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">endog</span><span class="o">.</span><span class="n">T</span>

        <span class="c1"># Instantiate the state space object</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span> <span class="o">=</span> <span class="n">SimulationSmoother</span><span class="p">(</span><span class="n">endog</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_states</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c1"># Bind the data to the model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">endog</span><span class="p">)</span>

        <span class="c1"># Other dimensions, now that `ssm` is available</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">k_endog</span></div>

    <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="fm">__setitem__</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

<div class="viewcode-block" id="MLEModel.set_filter_method"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEModel.set_filter_method.html#statsmodels.regression.recursive_ls.MLEModel.set_filter_method">[docs]</a>    <span class="k">def</span> <span class="nf">set_filter_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filter_method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the filtering method</span>

<span class="sd">        The filtering method controls aspects of which Kalman filtering</span>
<span class="sd">        approach will be used.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filter_method : integer, optional</span>
<span class="sd">            Bitmask value to set the filter method to. See notes for details.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Keyword arguments may be used to influence the filter method by</span>
<span class="sd">            setting individual boolean flags. See notes for details.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method is rarely used. See the corresponding function in the</span>
<span class="sd">        `KalmanFilter` class for details.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">set_filter_method</span><span class="p">(</span><span class="n">filter_method</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="MLEModel.set_inversion_method"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEModel.set_inversion_method.html#statsmodels.regression.recursive_ls.MLEModel.set_inversion_method">[docs]</a>    <span class="k">def</span> <span class="nf">set_inversion_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inversion_method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the inversion method</span>

<span class="sd">        The Kalman filter may contain one matrix inversion: that of the</span>
<span class="sd">        forecast error covariance matrix. The inversion method controls how and</span>
<span class="sd">        if that inverse is performed.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        inversion_method : integer, optional</span>
<span class="sd">            Bitmask value to set the inversion method to. See notes for</span>
<span class="sd">            details.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Keyword arguments may be used to influence the inversion method by</span>
<span class="sd">            setting individual boolean flags. See notes for details.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method is rarely used. See the corresponding function in the</span>
<span class="sd">        `KalmanFilter` class for details.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">set_inversion_method</span><span class="p">(</span><span class="n">inversion_method</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="MLEModel.set_stability_method"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEModel.set_stability_method.html#statsmodels.regression.recursive_ls.MLEModel.set_stability_method">[docs]</a>    <span class="k">def</span> <span class="nf">set_stability_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stability_method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the numerical stability method</span>

<span class="sd">        The Kalman filter is a recursive algorithm that may in some cases</span>
<span class="sd">        suffer issues with numerical stability. The stability method controls</span>
<span class="sd">        what, if any, measures are taken to promote stability.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        stability_method : integer, optional</span>
<span class="sd">            Bitmask value to set the stability method to. See notes for</span>
<span class="sd">            details.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Keyword arguments may be used to influence the stability method by</span>
<span class="sd">            setting individual boolean flags. See notes for details.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method is rarely used. See the corresponding function in the</span>
<span class="sd">        `KalmanFilter` class for details.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">set_stability_method</span><span class="p">(</span><span class="n">stability_method</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="MLEModel.set_conserve_memory"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEModel.set_conserve_memory.html#statsmodels.regression.recursive_ls.MLEModel.set_conserve_memory">[docs]</a>    <span class="k">def</span> <span class="nf">set_conserve_memory</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">conserve_memory</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the memory conservation method</span>

<span class="sd">        By default, the Kalman filter computes a number of intermediate</span>
<span class="sd">        matrices at each iteration. The memory conservation options control</span>
<span class="sd">        which of those matrices are stored.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        conserve_memory : integer, optional</span>
<span class="sd">            Bitmask value to set the memory conservation method to. See notes</span>
<span class="sd">            for details.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Keyword arguments may be used to influence the memory conservation</span>
<span class="sd">            method by setting individual boolean flags.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method is rarely used. See the corresponding function in the</span>
<span class="sd">        `KalmanFilter` class for details.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">set_conserve_memory</span><span class="p">(</span><span class="n">conserve_memory</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="MLEModel.set_smoother_output"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEModel.set_smoother_output.html#statsmodels.regression.recursive_ls.MLEModel.set_smoother_output">[docs]</a>    <span class="k">def</span> <span class="nf">set_smoother_output</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">smoother_output</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the smoother output</span>

<span class="sd">        The smoother can produce several types of results. The smoother output</span>
<span class="sd">        variable controls which are calculated and returned.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        smoother_output : integer, optional</span>
<span class="sd">            Bitmask value to set the smoother output to. See notes for details.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Keyword arguments may be used to influence the smoother output by</span>
<span class="sd">            setting individual boolean flags.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method is rarely used. See the corresponding function in the</span>
<span class="sd">        `KalmanSmoother` class for details.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">set_smoother_output</span><span class="p">(</span><span class="n">smoother_output</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="MLEModel.initialize_known"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEModel.initialize_known.html#statsmodels.regression.recursive_ls.MLEModel.initialize_known">[docs]</a>    <span class="k">def</span> <span class="nf">initialize_known</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">initial_state</span><span class="p">,</span> <span class="n">initial_state_cov</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">initialize_known</span><span class="p">(</span><span class="n">initial_state</span><span class="p">,</span> <span class="n">initial_state_cov</span><span class="p">)</span></div>

<div class="viewcode-block" id="MLEModel.initialize_approximate_diffuse"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEModel.initialize_approximate_diffuse.html#statsmodels.regression.recursive_ls.MLEModel.initialize_approximate_diffuse">[docs]</a>    <span class="k">def</span> <span class="nf">initialize_approximate_diffuse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variance</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">initialize_approximate_diffuse</span><span class="p">(</span><span class="n">variance</span><span class="p">)</span></div>

<div class="viewcode-block" id="MLEModel.initialize_stationary"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEModel.initialize_stationary.html#statsmodels.regression.recursive_ls.MLEModel.initialize_stationary">[docs]</a>    <span class="k">def</span> <span class="nf">initialize_stationary</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">initialize_stationary</span><span class="p">()</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">initialization</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">initialization</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">initial_variance</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">initial_variance</span>

    <span class="nd">@initial_variance</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">initial_variance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">initial_variance</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">loglikelihood_burn</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">loglikelihood_burn</span>

    <span class="nd">@loglikelihood_burn</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">loglikelihood_burn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">loglikelihood_burn</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">tolerance</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">tolerance</span>

    <span class="nd">@tolerance</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">tolerance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">tolerance</span> <span class="o">=</span> <span class="n">value</span>

<div class="viewcode-block" id="MLEModel.fit"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEModel.fit.html#statsmodels.regression.recursive_ls.MLEModel.fit">[docs]</a>    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">cov_type</span><span class="o">=</span><span class="s1">&#39;opg&#39;</span><span class="p">,</span> <span class="n">cov_kwds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;lbfgs&#39;</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span>
            <span class="n">full_output</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">disp</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">return_params</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">optim_score</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">optim_complex_step</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">optim_hessian</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">flags</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fits the model by maximum likelihood via Kalman filter.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        start_params : array_like, optional</span>
<span class="sd">            Initial guess of the solution for the loglikelihood maximization.</span>
<span class="sd">            If None, the default is given by Model.start_params.</span>
<span class="sd">        transformed : boolean, optional</span>
<span class="sd">            Whether or not `start_params` is already transformed. Default is</span>
<span class="sd">            True.</span>
<span class="sd">        cov_type : str, optional</span>
<span class="sd">            The `cov_type` keyword governs the method for calculating the</span>
<span class="sd">            covariance matrix of parameter estimates. Can be one of:</span>

<span class="sd">            - &#39;opg&#39; for the outer product of gradient estimator</span>
<span class="sd">            - &#39;oim&#39; for the observed information matrix estimator, calculated</span>
<span class="sd">              using the method of Harvey (1989)</span>
<span class="sd">            - &#39;approx&#39; for the observed information matrix estimator,</span>
<span class="sd">              calculated using a numerical approximation of the Hessian matrix.</span>
<span class="sd">            - &#39;robust&#39; for an approximate (quasi-maximum likelihood) covariance</span>
<span class="sd">              matrix that may be valid even in the presense of some</span>
<span class="sd">              misspecifications. Intermediate calculations use the &#39;oim&#39;</span>
<span class="sd">              method.</span>
<span class="sd">            - &#39;robust_approx&#39; is the same as &#39;robust&#39; except that the</span>
<span class="sd">              intermediate calculations use the &#39;approx&#39; method.</span>
<span class="sd">            - &#39;none&#39; for no covariance matrix calculation.</span>
<span class="sd">        cov_kwds : dict or None, optional</span>
<span class="sd">            A dictionary of arguments affecting covariance matrix computation.</span>

<span class="sd">            **opg, oim, approx, robust, robust_approx**</span>

<span class="sd">            - &#39;approx_complex_step&#39; : boolean, optional - If True, numerical</span>
<span class="sd">              approximations are computed using complex-step methods. If False,</span>
<span class="sd">              numerical approximations are computed using finite difference</span>
<span class="sd">              methods. Default is True.</span>
<span class="sd">            - &#39;approx_centered&#39; : boolean, optional - If True, numerical</span>
<span class="sd">              approximations computed using finite difference methods use a</span>
<span class="sd">              centered approximation. Default is False.</span>
<span class="sd">        method : str, optional</span>
<span class="sd">            The `method` determines which solver from `scipy.optimize`</span>
<span class="sd">            is used, and it can be chosen from among the following strings:</span>

<span class="sd">            - &#39;newton&#39; for Newton-Raphson, &#39;nm&#39; for Nelder-Mead</span>
<span class="sd">            - &#39;bfgs&#39; for Broyden-Fletcher-Goldfarb-Shanno (BFGS)</span>
<span class="sd">            - &#39;lbfgs&#39; for limited-memory BFGS with optional box constraints</span>
<span class="sd">            - &#39;powell&#39; for modified Powell&#39;s method</span>
<span class="sd">            - &#39;cg&#39; for conjugate gradient</span>
<span class="sd">            - &#39;ncg&#39; for Newton-conjugate gradient</span>
<span class="sd">            - &#39;basinhopping&#39; for global basin-hopping solver</span>

<span class="sd">            The explicit arguments in `fit` are passed to the solver,</span>
<span class="sd">            with the exception of the basin-hopping solver. Each</span>
<span class="sd">            solver has several optional arguments that are not the same across</span>
<span class="sd">            solvers. See the notes section below (or scipy.optimize) for the</span>
<span class="sd">            available arguments and for the list of explicit arguments that the</span>
<span class="sd">            basin-hopping solver supports.</span>
<span class="sd">        maxiter : int, optional</span>
<span class="sd">            The maximum number of iterations to perform.</span>
<span class="sd">        full_output : boolean, optional</span>
<span class="sd">            Set to True to have all available output in the Results object&#39;s</span>
<span class="sd">            mle_retvals attribute. The output is dependent on the solver.</span>
<span class="sd">            See LikelihoodModelResults notes section for more information.</span>
<span class="sd">        disp : boolean, optional</span>
<span class="sd">            Set to True to print convergence messages.</span>
<span class="sd">        callback : callable callback(xk), optional</span>
<span class="sd">            Called after each iteration, as callback(xk), where xk is the</span>
<span class="sd">            current parameter vector.</span>
<span class="sd">        return_params : boolean, optional</span>
<span class="sd">            Whether or not to return only the array of maximizing parameters.</span>
<span class="sd">            Default is False.</span>
<span class="sd">        optim_score : {&#39;harvey&#39;, &#39;approx&#39;} or None, optional</span>
<span class="sd">            The method by which the score vector is calculated. &#39;harvey&#39; uses</span>
<span class="sd">            the method from Harvey (1989), &#39;approx&#39; uses either finite</span>
<span class="sd">            difference or complex step differentiation depending upon the</span>
<span class="sd">            value of `optim_complex_step`, and None uses the built-in gradient</span>
<span class="sd">            approximation of the optimizer. Default is None. This keyword is</span>
<span class="sd">            only relevant if the optimization method uses the score.</span>
<span class="sd">        optim_complex_step : bool, optional</span>
<span class="sd">            Whether or not to use complex step differentiation when</span>
<span class="sd">            approximating the score; if False, finite difference approximation</span>
<span class="sd">            is used. Default is True. This keyword is only relevant if</span>
<span class="sd">            `optim_score` is set to &#39;harvey&#39; or &#39;approx&#39;.</span>
<span class="sd">        optim_hessian : {&#39;opg&#39;,&#39;oim&#39;,&#39;approx&#39;}, optional</span>
<span class="sd">            The method by which the Hessian is numerically approximated. &#39;opg&#39;</span>
<span class="sd">            uses outer product of gradients, &#39;oim&#39; uses the information</span>
<span class="sd">            matrix formula from Harvey (1989), and &#39;approx&#39; uses numerical</span>
<span class="sd">            approximation. This keyword is only relevant if the</span>
<span class="sd">            optimization method uses the Hessian matrix.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Additional keyword arguments to pass to the optimizer.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        MLEResults</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        statsmodels.base.model.LikelihoodModel.fit</span>
<span class="sd">        MLEResults</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">start_params</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">start_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">start_params</span>
            <span class="n">transformed</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># Update the score method</span>
        <span class="k">if</span> <span class="n">optim_score</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;lbfgs&#39;</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;approx_grad&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
            <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;epsilon&#39;</span><span class="p">,</span> <span class="mf">1e-5</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">optim_score</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">optim_score</span> <span class="o">=</span> <span class="s1">&#39;approx&#39;</span>

        <span class="c1"># Check for complex step differentiation</span>
        <span class="k">if</span> <span class="n">optim_complex_step</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">optim_complex_step</span> <span class="o">=</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">_complex_endog</span>
        <span class="k">elif</span> <span class="n">optim_complex_step</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">_complex_endog</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Cannot use complex step derivatives when data&#39;</span>
                             <span class="s1">&#39; or parameters are complex.&#39;</span><span class="p">)</span>

        <span class="c1"># Unconstrain the starting parameters</span>
        <span class="k">if</span> <span class="n">transformed</span><span class="p">:</span>
            <span class="n">start_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">untransform_params</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">start_params</span><span class="p">))</span>

        <span class="c1"># Maximum likelihood estimation</span>
        <span class="k">if</span> <span class="n">flags</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">flags</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">flags</span><span class="o">.</span><span class="n">update</span><span class="p">({</span>
            <span class="s1">&#39;transformed&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
            <span class="s1">&#39;score_method&#39;</span><span class="p">:</span> <span class="n">optim_score</span><span class="p">,</span>
            <span class="s1">&#39;approx_complex_step&#39;</span><span class="p">:</span> <span class="n">optim_complex_step</span>
        <span class="p">})</span>
        <span class="k">if</span> <span class="n">optim_hessian</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">flags</span><span class="p">[</span><span class="s1">&#39;hessian_method&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">optim_hessian</span>
        <span class="n">fargs</span> <span class="o">=</span> <span class="p">(</span><span class="n">flags</span><span class="p">,)</span>
        <span class="n">mlefit</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">MLEModel</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">start_params</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
                                           <span class="n">fargs</span><span class="o">=</span><span class="n">fargs</span><span class="p">,</span>
                                           <span class="n">maxiter</span><span class="o">=</span><span class="n">maxiter</span><span class="p">,</span>
                                           <span class="n">full_output</span><span class="o">=</span><span class="n">full_output</span><span class="p">,</span>
                                           <span class="n">disp</span><span class="o">=</span><span class="n">disp</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="n">callback</span><span class="p">,</span>
                                           <span class="n">skip_hessian</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Just return the fitted parameters if requested</span>
        <span class="k">if</span> <span class="n">return_params</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_params</span><span class="p">(</span><span class="n">mlefit</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>
        <span class="c1"># Otherwise construct the results class if desired</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">smooth</span><span class="p">(</span><span class="n">mlefit</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                              <span class="n">cov_type</span><span class="o">=</span><span class="n">cov_type</span><span class="p">,</span> <span class="n">cov_kwds</span><span class="o">=</span><span class="n">cov_kwds</span><span class="p">)</span>

            <span class="n">res</span><span class="o">.</span><span class="n">mlefit</span> <span class="o">=</span> <span class="n">mlefit</span>
            <span class="n">res</span><span class="o">.</span><span class="n">mle_retvals</span> <span class="o">=</span> <span class="n">mlefit</span><span class="o">.</span><span class="n">mle_retvals</span>
            <span class="n">res</span><span class="o">.</span><span class="n">mle_settings</span> <span class="o">=</span> <span class="n">mlefit</span><span class="o">.</span><span class="n">mle_settings</span>

            <span class="k">return</span> <span class="n">res</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_res_classes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;fit&#39;</span><span class="p">:</span> <span class="p">(</span><span class="n">MLEResults</span><span class="p">,</span> <span class="n">MLEResultsWrapper</span><span class="p">)}</span>

    <span class="k">def</span> <span class="nf">_wrap_results</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">return_raw</span><span class="p">,</span> <span class="n">cov_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                      <span class="n">cov_kwds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">results_class</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">wrapper_class</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">return_raw</span><span class="p">:</span>
            <span class="c1"># Wrap in a results object</span>
            <span class="n">result_kwargs</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">if</span> <span class="n">cov_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">result_kwargs</span><span class="p">[</span><span class="s1">&#39;cov_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cov_type</span>
            <span class="k">if</span> <span class="n">cov_kwds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">result_kwargs</span><span class="p">[</span><span class="s1">&#39;cov_kwds&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cov_kwds</span>

            <span class="k">if</span> <span class="n">results_class</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">results_class</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_res_classes</span><span class="p">[</span><span class="s1">&#39;fit&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">wrapper_class</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">wrapper_class</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_res_classes</span><span class="p">[</span><span class="s1">&#39;fit&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>

            <span class="n">res</span> <span class="o">=</span> <span class="n">results_class</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="o">**</span><span class="n">result_kwargs</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">wrapper_class</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

<div class="viewcode-block" id="MLEModel.filter"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEModel.filter.html#statsmodels.regression.recursive_ls.MLEModel.filter">[docs]</a>    <span class="k">def</span> <span class="nf">filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">complex_step</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
               <span class="n">cov_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cov_kwds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">return_ssm</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
               <span class="n">results_class</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">results_wrapper_class</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Kalman filtering</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array_like</span>
<span class="sd">            Array of parameters at which to evaluate the loglikelihood</span>
<span class="sd">            function.</span>
<span class="sd">        transformed : boolean, optional</span>
<span class="sd">            Whether or not `params` is already transformed. Default is True.</span>
<span class="sd">        return_ssm : boolean,optional</span>
<span class="sd">            Whether or not to return only the state space output or a full</span>
<span class="sd">            results object. Default is to return a full results object.</span>
<span class="sd">        cov_type : str, optional</span>
<span class="sd">            See `MLEResults.fit` for a description of covariance matrix types</span>
<span class="sd">            for results object.</span>
<span class="sd">        cov_kwds : dict or None, optional</span>
<span class="sd">            See `MLEResults.get_robustcov_results` for a description required</span>
<span class="sd">            keywords for alternative covariance estimators</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Additional keyword arguments to pass to the Kalman filter. See</span>
<span class="sd">            `KalmanFilter.filter` for more details.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">transformed</span><span class="p">:</span>
            <span class="n">params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_params</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">complex_step</span><span class="o">=</span><span class="n">complex_step</span><span class="p">)</span>

        <span class="c1"># Save the parameter names</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">param_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_names</span>

        <span class="k">if</span> <span class="n">complex_step</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;inversion_method&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">INVERT_UNIVARIATE</span> <span class="o">|</span> <span class="n">SOLVE_LU</span>

        <span class="c1"># Get the state space output</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">complex_step</span><span class="o">=</span><span class="n">complex_step</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Wrap in a results object</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_results</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">return_ssm</span><span class="p">,</span> <span class="n">cov_type</span><span class="p">,</span>
                                  <span class="n">cov_kwds</span><span class="p">,</span> <span class="n">results_class</span><span class="p">,</span>
                                  <span class="n">results_wrapper_class</span><span class="p">)</span></div>

<div class="viewcode-block" id="MLEModel.smooth"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEModel.smooth.html#statsmodels.regression.recursive_ls.MLEModel.smooth">[docs]</a>    <span class="k">def</span> <span class="nf">smooth</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">complex_step</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
               <span class="n">cov_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cov_kwds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">return_ssm</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
               <span class="n">results_class</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">results_wrapper_class</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Kalman smoothing</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array_like</span>
<span class="sd">            Array of parameters at which to evaluate the loglikelihood</span>
<span class="sd">            function.</span>
<span class="sd">        transformed : boolean, optional</span>
<span class="sd">            Whether or not `params` is already transformed. Default is True.</span>
<span class="sd">        return_ssm : boolean,optional</span>
<span class="sd">            Whether or not to return only the state space output or a full</span>
<span class="sd">            results object. Default is to return a full results object.</span>
<span class="sd">        cov_type : str, optional</span>
<span class="sd">            See `MLEResults.fit` for a description of covariance matrix types</span>
<span class="sd">            for results object.</span>
<span class="sd">        cov_kwds : dict or None, optional</span>
<span class="sd">            See `MLEResults.get_robustcov_results` for a description required</span>
<span class="sd">            keywords for alternative covariance estimators</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Additional keyword arguments to pass to the Kalman filter. See</span>
<span class="sd">            `KalmanFilter.filter` for more details.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">transformed</span><span class="p">:</span>
            <span class="n">params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_params</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">complex_step</span><span class="o">=</span><span class="n">complex_step</span><span class="p">)</span>

        <span class="c1"># Save the parameter names</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">param_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_names</span>

        <span class="k">if</span> <span class="n">complex_step</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;inversion_method&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">INVERT_UNIVARIATE</span> <span class="o">|</span> <span class="n">SOLVE_LU</span>

        <span class="c1"># Get the state space output</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">smooth</span><span class="p">(</span><span class="n">complex_step</span><span class="o">=</span><span class="n">complex_step</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Wrap in a results object</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_results</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">return_ssm</span><span class="p">,</span> <span class="n">cov_type</span><span class="p">,</span>
                                  <span class="n">cov_kwds</span><span class="p">,</span> <span class="n">results_class</span><span class="p">,</span>
                                  <span class="n">results_wrapper_class</span><span class="p">)</span></div>

    <span class="n">_loglike_param_names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;transformed&#39;</span><span class="p">,</span> <span class="s1">&#39;complex_step&#39;</span><span class="p">]</span>
    <span class="n">_loglike_param_defaults</span> <span class="o">=</span> <span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">]</span>

<div class="viewcode-block" id="MLEModel.loglike"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEModel.loglike.html#statsmodels.regression.recursive_ls.MLEModel.loglike">[docs]</a>    <span class="k">def</span> <span class="nf">loglike</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Loglikelihood evaluation</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array_like</span>
<span class="sd">            Array of parameters at which to evaluate the loglikelihood</span>
<span class="sd">            function.</span>
<span class="sd">        transformed : boolean, optional</span>
<span class="sd">            Whether or not `params` is already transformed. Default is True.</span>
<span class="sd">        kwargs</span>
<span class="sd">            Additional keyword arguments to pass to the Kalman filter. See</span>
<span class="sd">            `KalmanFilter.filter` for more details.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        [1]_ recommend maximizing the average likelihood to avoid scale issues;</span>
<span class="sd">        this is done automatically by the base Model fit method.</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        .. [1] Koopman, Siem Jan, Neil Shephard, and Jurgen A. Doornik. 1999.</span>
<span class="sd">           Statistical Algorithms for Models in State Space Using SsfPack 2.2.</span>
<span class="sd">           Econometrics Journal 2 (1): 107-60. doi:10.1111/1368-423X.00023.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        update : modifies the internal state of the state space model to</span>
<span class="sd">                 reflect new params</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">transformed</span><span class="p">,</span> <span class="n">complex_step</span><span class="p">,</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="n">_handle_args</span><span class="p">(</span>
            <span class="n">MLEModel</span><span class="o">.</span><span class="n">_loglike_param_names</span><span class="p">,</span> <span class="n">MLEModel</span><span class="o">.</span><span class="n">_loglike_param_defaults</span><span class="p">,</span>
            <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">transformed</span><span class="p">:</span>
            <span class="n">params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_params</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">complex_step</span><span class="o">=</span><span class="n">complex_step</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">complex_step</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;inversion_method&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">INVERT_UNIVARIATE</span> <span class="o">|</span> <span class="n">SOLVE_LU</span>

        <span class="n">loglike</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">loglike</span><span class="p">(</span><span class="n">complex_step</span><span class="o">=</span><span class="n">complex_step</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Koopman, Shephard, and Doornik recommend maximizing the average</span>
        <span class="c1"># likelihood to avoid scale issues, but the averaging is done</span>
        <span class="c1"># automatically in the base model `fit` method</span>
        <span class="k">return</span> <span class="n">loglike</span></div>

<div class="viewcode-block" id="MLEModel.loglikeobs"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEModel.loglikeobs.html#statsmodels.regression.recursive_ls.MLEModel.loglikeobs">[docs]</a>    <span class="k">def</span> <span class="nf">loglikeobs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">complex_step</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                   <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Loglikelihood evaluation</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array_like</span>
<span class="sd">            Array of parameters at which to evaluate the loglikelihood</span>
<span class="sd">            function.</span>
<span class="sd">        transformed : boolean, optional</span>
<span class="sd">            Whether or not `params` is already transformed. Default is True.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Additional keyword arguments to pass to the Kalman filter. See</span>
<span class="sd">            `KalmanFilter.filter` for more details.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        [1]_ recommend maximizing the average likelihood to avoid scale issues;</span>
<span class="sd">        this is done automatically by the base Model fit method.</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        .. [1] Koopman, Siem Jan, Neil Shephard, and Jurgen A. Doornik. 1999.</span>
<span class="sd">           Statistical Algorithms for Models in State Space Using SsfPack 2.2.</span>
<span class="sd">           Econometrics Journal 2 (1): 107-60. doi:10.1111/1368-423X.00023.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        update : modifies the internal state of the Model to reflect new params</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">transformed</span><span class="p">:</span>
            <span class="n">params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_params</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>

        <span class="c1"># If we&#39;re using complex-step differentiation, then we can&#39;t use</span>
        <span class="c1"># Cholesky factorization</span>
        <span class="k">if</span> <span class="n">complex_step</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;inversion_method&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">INVERT_UNIVARIATE</span> <span class="o">|</span> <span class="n">SOLVE_LU</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">complex_step</span><span class="o">=</span><span class="n">complex_step</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">loglikeobs</span><span class="p">(</span><span class="n">complex_step</span><span class="o">=</span><span class="n">complex_step</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="MLEModel.simulation_smoother"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEModel.simulation_smoother.html#statsmodels.regression.recursive_ls.MLEModel.simulation_smoother">[docs]</a>    <span class="k">def</span> <span class="nf">simulation_smoother</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">simulation_output</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieve a simulation smoother for the state space model.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        simulation_output : int, optional</span>
<span class="sd">            Determines which simulation smoother output is calculated.</span>
<span class="sd">            Default is all (including state and disturbances).</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Additional keyword arguments, used to set the simulation output.</span>
<span class="sd">            See `set_simulation_output` for more details.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        SimulationSmoothResults</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">simulation_smoother</span><span class="p">(</span>
            <span class="n">simulation_output</span><span class="o">=</span><span class="n">simulation_output</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_forecasts_error_partial_derivatives</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                             <span class="n">approx_complex_step</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                             <span class="n">approx_centered</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                             <span class="n">res</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># We can&#39;t use complex-step differentiation with non-transformed</span>
        <span class="c1"># parameters</span>
        <span class="k">if</span> <span class="n">approx_complex_step</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">approx_complex_step</span> <span class="o">=</span> <span class="n">transformed</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">transformed</span> <span class="ow">and</span> <span class="n">approx_complex_step</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot use complex-step approximations to&quot;</span>
                             <span class="s2">&quot; calculate the observed_information_matrix&quot;</span>
                             <span class="s2">&quot; with untransformed parameters.&quot;</span><span class="p">)</span>

        <span class="c1"># If we&#39;re using complex-step differentiation, then we can&#39;t use</span>
        <span class="c1"># Cholesky factorization</span>
        <span class="k">if</span> <span class="n">approx_complex_step</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;inversion_method&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">INVERT_UNIVARIATE</span> <span class="o">|</span> <span class="n">SOLVE_LU</span>

        <span class="c1"># Get values at the params themselves</span>
        <span class="k">if</span> <span class="n">res</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="n">transformed</span><span class="p">,</span>
                        <span class="n">complex_step</span><span class="o">=</span><span class="n">approx_complex_step</span><span class="p">)</span>
            <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">complex_step</span><span class="o">=</span><span class="n">approx_complex_step</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Setup</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>

        <span class="c1"># Compute partial derivatives w.r.t. forecast error and forecast</span>
        <span class="c1"># error covariance</span>
        <span class="n">partials_forecasts_error</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
        <span class="p">)</span>
        <span class="n">partials_forecasts_error_cov</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">approx_complex_step</span><span class="p">:</span>
            <span class="n">epsilon</span> <span class="o">=</span> <span class="n">_get_epsilon</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
            <span class="n">increments</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">epsilon</span>

            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ih</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">increments</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">params</span> <span class="o">+</span> <span class="n">ih</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="n">transformed</span><span class="p">,</span>
                            <span class="n">complex_step</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">_res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">complex_step</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

                <span class="n">partials_forecasts_error</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">_res</span><span class="o">.</span><span class="n">forecasts_error</span><span class="o">.</span><span class="n">imag</span> <span class="o">/</span> <span class="n">epsilon</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="p">)</span>

                <span class="n">partials_forecasts_error_cov</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">_res</span><span class="o">.</span><span class="n">forecasts_error_cov</span><span class="o">.</span><span class="n">imag</span> <span class="o">/</span> <span class="n">epsilon</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">approx_centered</span><span class="p">:</span>
            <span class="n">epsilon</span> <span class="o">=</span> <span class="n">_get_epsilon</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
            <span class="n">ei</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,),</span> <span class="nb">float</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="n">ei</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">epsilon</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">params</span> <span class="o">+</span> <span class="n">ei</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="n">transformed</span><span class="p">,</span>
                            <span class="n">complex_step</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="n">_res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">complex_step</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

                <span class="n">partials_forecasts_error</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">_res</span><span class="o">.</span><span class="n">forecasts_error</span> <span class="o">-</span> <span class="n">res</span><span class="o">.</span><span class="n">forecasts_error</span><span class="p">)</span> <span class="o">/</span> <span class="n">epsilon</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

                <span class="n">partials_forecasts_error_cov</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">_res</span><span class="o">.</span><span class="n">forecasts_error_cov</span> <span class="o">-</span>
                    <span class="n">res</span><span class="o">.</span><span class="n">forecasts_error_cov</span><span class="p">)</span> <span class="o">/</span> <span class="n">epsilon</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">ei</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">epsilon</span> <span class="o">=</span> <span class="n">_get_epsilon</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.</span>
            <span class="n">ei</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,),</span> <span class="nb">float</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="n">ei</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">epsilon</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">params</span> <span class="o">+</span> <span class="n">ei</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="n">transformed</span><span class="p">,</span>
                            <span class="n">complex_step</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="n">_res1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">complex_step</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">params</span> <span class="o">-</span> <span class="n">ei</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="n">transformed</span><span class="p">,</span>
                            <span class="n">complex_step</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="n">_res2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">complex_step</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

                <span class="n">partials_forecasts_error</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="p">(</span><span class="n">_res1</span><span class="o">.</span><span class="n">forecasts_error</span> <span class="o">-</span> <span class="n">_res2</span><span class="o">.</span><span class="n">forecasts_error</span><span class="p">)</span> <span class="o">/</span>
                    <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">epsilon</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>

                <span class="n">partials_forecasts_error_cov</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="p">(</span><span class="n">_res1</span><span class="o">.</span><span class="n">forecasts_error_cov</span> <span class="o">-</span> <span class="n">_res2</span><span class="o">.</span><span class="n">forecasts_error_cov</span><span class="p">)</span> <span class="o">/</span>
                    <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">epsilon</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>

                <span class="n">ei</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="k">return</span> <span class="n">partials_forecasts_error</span><span class="p">,</span> <span class="n">partials_forecasts_error_cov</span>

<div class="viewcode-block" id="MLEModel.observed_information_matrix"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEModel.observed_information_matrix.html#statsmodels.regression.recursive_ls.MLEModel.observed_information_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">observed_information_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                    <span class="n">approx_complex_step</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                    <span class="n">approx_centered</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Observed information matrix</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array_like, optional</span>
<span class="sd">            Array of parameters at which to evaluate the loglikelihood</span>
<span class="sd">            function.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Additional keyword arguments to pass to the Kalman filter. See</span>
<span class="sd">            `KalmanFilter.filter` for more details.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method is from Harvey (1989), which shows that the information</span>
<span class="sd">        matrix only depends on terms from the gradient. This implementation is</span>
<span class="sd">        partially analytic and partially numeric approximation, therefore,</span>
<span class="sd">        because it uses the analytic formula for the information matrix, with</span>
<span class="sd">        numerically computed elements of the gradient.</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        Harvey, Andrew C. 1990.</span>
<span class="sd">        Forecasting, Structural Time Series Models and the Kalman Filter.</span>
<span class="sd">        Cambridge University Press.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Setup</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>

        <span class="c1"># We can&#39;t use complex-step differentiation with non-transformed</span>
        <span class="c1"># parameters</span>
        <span class="k">if</span> <span class="n">approx_complex_step</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">approx_complex_step</span> <span class="o">=</span> <span class="n">transformed</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">transformed</span> <span class="ow">and</span> <span class="n">approx_complex_step</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot use complex-step approximations to&quot;</span>
                             <span class="s2">&quot; calculate the observed_information_matrix&quot;</span>
                             <span class="s2">&quot; with untransformed parameters.&quot;</span><span class="p">)</span>

        <span class="c1"># Get values at the params themselves</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="n">transformed</span><span class="p">,</span>
                    <span class="n">complex_step</span><span class="o">=</span><span class="n">approx_complex_step</span><span class="p">)</span>
        <span class="c1"># If we&#39;re using complex-step differentiation, then we can&#39;t use</span>
        <span class="c1"># Cholesky factorization</span>
        <span class="k">if</span> <span class="n">approx_complex_step</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;inversion_method&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">INVERT_UNIVARIATE</span> <span class="o">|</span> <span class="n">SOLVE_LU</span>
        <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">complex_step</span><span class="o">=</span><span class="n">approx_complex_step</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">dtype</span>

        <span class="c1"># Save this for inversion later</span>
        <span class="n">inv_forecasts_error_cov</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">forecasts_error_cov</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="n">partials_forecasts_error</span><span class="p">,</span> <span class="n">partials_forecasts_error_cov</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_forecasts_error_partial_derivatives</span><span class="p">(</span>
                <span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="n">transformed</span><span class="p">,</span>
                <span class="n">approx_complex_step</span><span class="o">=</span><span class="n">approx_complex_step</span><span class="p">,</span>
                <span class="n">approx_centered</span><span class="o">=</span><span class="n">approx_centered</span><span class="p">,</span> <span class="n">res</span><span class="o">=</span><span class="n">res</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>

        <span class="c1"># Compute the information matrix</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="p">,</span> <span class="n">n</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

        <span class="n">information_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">loglikelihood_burn</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="p">):</span>
            <span class="n">inv_forecasts_error_cov</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">forecasts_error_cov</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">t</span><span class="p">])</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="n">tmp</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">t</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
                    <span class="n">inv_forecasts_error_cov</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">t</span><span class="p">],</span>
                    <span class="n">partials_forecasts_error_cov</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">t</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span>
                <span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                    <span class="n">information_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span>
                        <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">tmp</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">t</span><span class="p">,</span> <span class="n">i</span><span class="p">],</span>
                                              <span class="n">tmp</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">t</span><span class="p">,</span> <span class="n">j</span><span class="p">]))</span>
                    <span class="p">)</span>
                    <span class="n">information_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span>
                        <span class="n">partials_forecasts_error</span><span class="p">[:,</span> <span class="n">t</span><span class="p">,</span> <span class="n">i</span><span class="p">],</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">inv_forecasts_error_cov</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">t</span><span class="p">],</span>
                               <span class="n">partials_forecasts_error</span><span class="p">[:,</span> <span class="n">t</span><span class="p">,</span> <span class="n">j</span><span class="p">])</span>
                    <span class="p">)</span>
        <span class="k">return</span> <span class="n">information_matrix</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nobs</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">loglikelihood_burn</span><span class="p">)</span></div>

<div class="viewcode-block" id="MLEModel.opg_information_matrix"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEModel.opg_information_matrix.html#statsmodels.regression.recursive_ls.MLEModel.opg_information_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">opg_information_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                               <span class="n">approx_complex_step</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Outer product of gradients information matrix</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array_like, optional</span>
<span class="sd">            Array of parameters at which to evaluate the loglikelihood</span>
<span class="sd">            function.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Additional arguments to the `loglikeobs` method.</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        Berndt, Ernst R., Bronwyn Hall, Robert Hall, and Jerry Hausman. 1974.</span>
<span class="sd">        Estimation and Inference in Nonlinear Structural Models.</span>
<span class="sd">        NBER Chapters. National Bureau of Economic Research, Inc.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># We can&#39;t use complex-step differentiation with non-transformed</span>
        <span class="c1"># parameters</span>
        <span class="k">if</span> <span class="n">approx_complex_step</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">approx_complex_step</span> <span class="o">=</span> <span class="n">transformed</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">transformed</span> <span class="ow">and</span> <span class="n">approx_complex_step</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot use complex-step approximations to&quot;</span>
                             <span class="s2">&quot; calculate the observed_information_matrix&quot;</span>
                             <span class="s2">&quot; with untransformed parameters.&quot;</span><span class="p">)</span>

        <span class="n">score_obs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">score_obs</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="n">transformed</span><span class="p">,</span>
                                   <span class="n">approx_complex_step</span><span class="o">=</span><span class="n">approx_complex_step</span><span class="p">,</span>
                                   <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">score_obs</span><span class="p">,</span> <span class="n">score_obs</span><span class="p">)</span> <span class="o">/</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nobs</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">loglikelihood_burn</span><span class="p">)</span>
        <span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_score_complex_step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># the default epsilon can be too small</span>
        <span class="c1"># inversion_method = INVERT_UNIVARIATE | SOLVE_LU</span>
        <span class="n">epsilon</span> <span class="o">=</span> <span class="n">_get_epsilon</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="mf">2.</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">))</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;transformed&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;complex_step&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">approx_fprime_cs</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">loglike</span><span class="p">,</span> <span class="n">epsilon</span><span class="o">=</span><span class="n">epsilon</span><span class="p">,</span>
                                <span class="n">kwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_score_finite_difference</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">approx_centered</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                 <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;transformed&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">approx_fprime</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">loglike</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">,</span>
                             <span class="n">centered</span><span class="o">=</span><span class="n">approx_centered</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_score_harvey</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">approx_complex_step</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">score_obs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_score_obs_harvey</span><span class="p">(</span>
            <span class="n">params</span><span class="p">,</span> <span class="n">approx_complex_step</span><span class="o">=</span><span class="n">approx_complex_step</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">score_obs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_score_obs_harvey</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">approx_complex_step</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                          <span class="n">approx_centered</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Score</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array_like, optional</span>
<span class="sd">            Array of parameters at which to evaluate the loglikelihood</span>
<span class="sd">            function.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Additional keyword arguments to pass to the Kalman filter. See</span>
<span class="sd">            `KalmanFilter.filter` for more details.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method is from Harvey (1989), section 3.4.5</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        Harvey, Andrew C. 1990.</span>
<span class="sd">        Forecasting, Structural Time Series Models and the Kalman Filter.</span>
<span class="sd">        Cambridge University Press.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>

        <span class="c1"># Get values at the params themselves</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">complex_step</span><span class="o">=</span><span class="n">approx_complex_step</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">approx_complex_step</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;inversion_method&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">INVERT_UNIVARIATE</span> <span class="o">|</span> <span class="n">SOLVE_LU</span>
        <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">complex_step</span><span class="o">=</span><span class="n">approx_complex_step</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Get forecasts error partials</span>
        <span class="n">partials_forecasts_error</span><span class="p">,</span> <span class="n">partials_forecasts_error_cov</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_forecasts_error_partial_derivatives</span><span class="p">(</span>
                <span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">approx_complex_step</span><span class="o">=</span><span class="n">approx_complex_step</span><span class="p">,</span>
                <span class="n">approx_centered</span><span class="o">=</span><span class="n">approx_centered</span><span class="p">,</span> <span class="n">res</span><span class="o">=</span><span class="n">res</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>

        <span class="c1"># Compute partial derivatives w.r.t. likelihood function</span>
        <span class="n">partials</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
        <span class="n">k_endog</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="p">):</span>
            <span class="n">inv_forecasts_error_cov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span>
                    <span class="n">res</span><span class="o">.</span><span class="n">forecasts_error_cov</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">t</span><span class="p">])</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="n">partials</span><span class="p">[</span><span class="n">t</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">inv_forecasts_error_cov</span><span class="p">,</span>
                           <span class="n">partials_forecasts_error_cov</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">t</span><span class="p">,</span> <span class="n">i</span><span class="p">]),</span>
                    <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">k_endog</span><span class="p">)</span> <span class="o">-</span>
                     <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">inv_forecasts_error_cov</span><span class="p">,</span>
                            <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">forecasts_error</span><span class="p">[:,</span> <span class="n">t</span><span class="p">],</span>
                                     <span class="n">res</span><span class="o">.</span><span class="n">forecasts_error</span><span class="p">[:,</span> <span class="n">t</span><span class="p">])))))</span>
                <span class="c1"># 2 * dv / di * F^{-1} v_t</span>
                <span class="c1"># where x = F^{-1} v_t or F x = v</span>
                <span class="n">partials</span><span class="p">[</span><span class="n">t</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
                    <span class="n">partials_forecasts_error</span><span class="p">[:,</span> <span class="n">t</span><span class="p">,</span> <span class="n">i</span><span class="p">],</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">inv_forecasts_error_cov</span><span class="p">,</span> <span class="n">res</span><span class="o">.</span><span class="n">forecasts_error</span><span class="p">[:,</span> <span class="n">t</span><span class="p">]))</span>

        <span class="k">return</span> <span class="o">-</span><span class="n">partials</span> <span class="o">/</span> <span class="mf">2.</span>

    <span class="n">_score_param_names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;transformed&#39;</span><span class="p">,</span> <span class="s1">&#39;score_method&#39;</span><span class="p">,</span>
                          <span class="s1">&#39;approx_complex_step&#39;</span><span class="p">,</span> <span class="s1">&#39;approx_centered&#39;</span><span class="p">]</span>
    <span class="n">_score_param_defaults</span> <span class="o">=</span> <span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="s1">&#39;approx&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">False</span><span class="p">]</span>

<div class="viewcode-block" id="MLEModel.score"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEModel.score.html#statsmodels.regression.recursive_ls.MLEModel.score">[docs]</a>    <span class="k">def</span> <span class="nf">score</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the score function at params.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array_like</span>
<span class="sd">            Array of parameters at which to evaluate the score.</span>
<span class="sd">        args</span>
<span class="sd">            Additional positional arguments to the `loglike` method.</span>
<span class="sd">        kwargs</span>
<span class="sd">            Additional keyword arguments to the `loglike` method.</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">        score : array</span>
<span class="sd">            Score, evaluated at `params`.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This is a numerical approximation, calculated using first-order complex</span>
<span class="sd">        step differentiation on the `loglike` method.</span>

<span class="sd">        Both \*args and \*\*kwargs are necessary because the optimizer from</span>
<span class="sd">        `fit` must call this function and only supports passing arguments via</span>
<span class="sd">        \*args (for example `scipy.optimize.fmin_l_bfgs`).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">transformed</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">approx_complex_step</span><span class="p">,</span> <span class="n">approx_centered</span><span class="p">,</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">_handle_args</span><span class="p">(</span><span class="n">MLEModel</span><span class="o">.</span><span class="n">_score_param_names</span><span class="p">,</span>
                         <span class="n">MLEModel</span><span class="o">.</span><span class="n">_score_param_defaults</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>
        <span class="c1"># For fit() calls, the method is called &#39;score_method&#39; (to distinguish</span>
        <span class="c1"># it from the method used for fit) but generally in kwargs the method</span>
        <span class="c1"># will just be called &#39;method&#39;</span>
        <span class="k">if</span> <span class="s1">&#39;method&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">method</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;method&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">approx_complex_step</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">approx_complex_step</span> <span class="o">=</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">_complex_endog</span>
        <span class="k">if</span> <span class="n">approx_complex_step</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">_complex_endog</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Cannot use complex step derivatives when data&#39;</span>
                             <span class="s1">&#39; or parameters are complex.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">transformed</span><span class="p">:</span>
            <span class="n">transform_score</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_jacobian</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
            <span class="n">params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_params</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;harvey&#39;</span><span class="p">:</span>
            <span class="n">score</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_score_harvey</span><span class="p">(</span>
                <span class="n">params</span><span class="p">,</span> <span class="n">approx_complex_step</span><span class="o">=</span><span class="n">approx_complex_step</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;approx&#39;</span> <span class="ow">and</span> <span class="n">approx_complex_step</span><span class="p">:</span>
            <span class="n">score</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_score_complex_step</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;approx&#39;</span><span class="p">:</span>
            <span class="n">score</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_score_finite_difference</span><span class="p">(</span>
                <span class="n">params</span><span class="p">,</span> <span class="n">approx_centered</span><span class="o">=</span><span class="n">approx_centered</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Invalid score method.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">transformed</span><span class="p">:</span>
            <span class="n">score</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">transform_score</span><span class="p">,</span> <span class="n">score</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">score</span></div>

<div class="viewcode-block" id="MLEModel.score_obs"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEModel.score_obs.html#statsmodels.regression.recursive_ls.MLEModel.score_obs">[docs]</a>    <span class="k">def</span> <span class="nf">score_obs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;approx&#39;</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                  <span class="n">approx_complex_step</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">approx_centered</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the score per observation, evaluated at params</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array_like</span>
<span class="sd">            Array of parameters at which to evaluate the score.</span>
<span class="sd">        kwargs</span>
<span class="sd">            Additional arguments to the `loglike` method.</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">        score : array</span>
<span class="sd">            Score per observation, evaluated at `params`.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This is a numerical approximation, calculated using first-order complex</span>
<span class="sd">        step differentiation on the `loglikeobs` method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">transformed</span> <span class="ow">and</span> <span class="n">approx_complex_step</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot use complex-step approximations to&quot;</span>
                             <span class="s2">&quot; calculate the score at each observation&quot;</span>
                             <span class="s2">&quot; with untransformed parameters.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">approx_complex_step</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">approx_complex_step</span> <span class="o">=</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">_complex_endog</span>
        <span class="k">if</span> <span class="n">approx_complex_step</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">_complex_endog</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Cannot use complex step derivatives when data&#39;</span>
                             <span class="s1">&#39; or parameters are complex.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;harvey&#39;</span><span class="p">:</span>
            <span class="n">score</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_score_obs_harvey</span><span class="p">(</span>
                <span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="n">transformed</span><span class="p">,</span>
                <span class="n">approx_complex_step</span><span class="o">=</span><span class="n">approx_complex_step</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;approx&#39;</span> <span class="ow">and</span> <span class="n">approx_complex_step</span><span class="p">:</span>
            <span class="c1"># the default epsilon can be too small</span>
            <span class="n">epsilon</span> <span class="o">=</span> <span class="n">_get_epsilon</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="mf">2.</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">))</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;complex_step&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;transformed&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">score</span> <span class="o">=</span> <span class="n">approx_fprime_cs</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">loglikeobs</span><span class="p">,</span> <span class="n">epsilon</span><span class="o">=</span><span class="n">epsilon</span><span class="p">,</span>
                                     <span class="n">kwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;approx&#39;</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;transformed&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">transformed</span>
            <span class="n">score</span> <span class="o">=</span> <span class="n">approx_fprime</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">loglikeobs</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">,</span>
                                  <span class="n">centered</span><span class="o">=</span><span class="n">approx_centered</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Invalid scoreobs method.&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">score</span></div>

    <span class="n">_hessian_param_names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;transformed&#39;</span><span class="p">,</span> <span class="s1">&#39;hessian_method&#39;</span><span class="p">,</span>
                            <span class="s1">&#39;approx_complex_step&#39;</span><span class="p">,</span> <span class="s1">&#39;approx_centered&#39;</span><span class="p">]</span>
    <span class="n">_hessian_param_defaults</span> <span class="o">=</span> <span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="s1">&#39;approx&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">False</span><span class="p">]</span>

<div class="viewcode-block" id="MLEModel.hessian"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEModel.hessian.html#statsmodels.regression.recursive_ls.MLEModel.hessian">[docs]</a>    <span class="k">def</span> <span class="nf">hessian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Hessian matrix of the likelihood function, evaluated at the given</span>
<span class="sd">        parameters</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array_like</span>
<span class="sd">            Array of parameters at which to evaluate the hessian.</span>
<span class="sd">        args</span>
<span class="sd">            Additional positional arguments to the `loglike` method.</span>
<span class="sd">        kwargs</span>
<span class="sd">            Additional keyword arguments to the `loglike` method.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        hessian : array</span>
<span class="sd">            Hessian matrix evaluated at `params`</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This is a numerical approximation.</span>

<span class="sd">        Both \*args and \*\*kwargs are necessary because the optimizer from</span>
<span class="sd">        `fit` must call this function and only supports passing arguments via</span>
<span class="sd">        \*args (for example `scipy.optimize.fmin_l_bfgs`).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">transformed</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">approx_complex_step</span><span class="p">,</span> <span class="n">approx_centered</span><span class="p">,</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">_handle_args</span><span class="p">(</span><span class="n">MLEModel</span><span class="o">.</span><span class="n">_hessian_param_names</span><span class="p">,</span>
                         <span class="n">MLEModel</span><span class="o">.</span><span class="n">_hessian_param_defaults</span><span class="p">,</span>
                         <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>
        <span class="c1"># For fit() calls, the method is called &#39;hessian_method&#39; (to</span>
        <span class="c1"># distinguish it from the method used for fit) but generally in kwargs</span>
        <span class="c1"># the method will just be called &#39;method&#39;</span>
        <span class="k">if</span> <span class="s1">&#39;method&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">method</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;method&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">transformed</span> <span class="ow">and</span> <span class="n">approx_complex_step</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot use complex-step approximations to&quot;</span>
                             <span class="s2">&quot; calculate the hessian with untransformed&quot;</span>
                             <span class="s2">&quot; parameters.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">approx_complex_step</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">approx_complex_step</span> <span class="o">=</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">_complex_endog</span>
        <span class="k">if</span> <span class="n">approx_complex_step</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">_complex_endog</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Cannot use complex step derivatives when data&#39;</span>
                             <span class="s1">&#39; or parameters are complex.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;oim&#39;</span><span class="p">:</span>
            <span class="n">hessian</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hessian_oim</span><span class="p">(</span>
                <span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="n">transformed</span><span class="p">,</span>
                <span class="n">approx_complex_step</span><span class="o">=</span><span class="n">approx_complex_step</span><span class="p">,</span>
                <span class="n">approx_centered</span><span class="o">=</span><span class="n">approx_centered</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;opg&#39;</span><span class="p">:</span>
            <span class="n">hessian</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hessian_opg</span><span class="p">(</span>
                <span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="n">transformed</span><span class="p">,</span>
                <span class="n">approx_complex_step</span><span class="o">=</span><span class="n">approx_complex_step</span><span class="p">,</span>
                <span class="n">approx_centered</span><span class="o">=</span><span class="n">approx_centered</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;approx&#39;</span> <span class="ow">and</span> <span class="n">approx_complex_step</span><span class="p">:</span>
            <span class="n">hessian</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hessian_complex_step</span><span class="p">(</span>
                <span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="n">transformed</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;approx&#39;</span><span class="p">:</span>
            <span class="n">hessian</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hessian_finite_difference</span><span class="p">(</span>
                <span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="n">transformed</span><span class="p">,</span>
                <span class="n">approx_centered</span><span class="o">=</span><span class="n">approx_centered</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Invalid Hessian calculation method.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">hessian</span></div>

    <span class="k">def</span> <span class="nf">_hessian_oim</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Hessian matrix computed using the Harvey (1989) information matrix</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">observed_information_matrix</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_hessian_opg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Hessian matrix computed using the outer product of gradients</span>
<span class="sd">        information matrix</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">opg_information_matrix</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_hessian_finite_difference</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">approx_centered</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                   <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Calculation of the Hessian using finite differences&#39;</span>
                      <span class="s1">&#39; is usually subject to substantial approximation&#39;</span>
                      <span class="s1">&#39; errors.&#39;</span><span class="p">,</span> <span class="n">PrecisionWarning</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">approx_centered</span><span class="p">:</span>
            <span class="n">epsilon</span> <span class="o">=</span> <span class="n">_get_epsilon</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">epsilon</span> <span class="o">=</span> <span class="n">_get_epsilon</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">))</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="n">hessian</span> <span class="o">=</span> <span class="n">approx_fprime</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_score_finite_difference</span><span class="p">,</span>
                                <span class="n">epsilon</span><span class="o">=</span><span class="n">epsilon</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">,</span>
                                <span class="n">centered</span><span class="o">=</span><span class="n">approx_centered</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">hessian</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nobs</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">loglikelihood_burn</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_hessian_complex_step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Hessian matrix computed by second-order complex-step differentiation</span>
<span class="sd">        on the `loglike` function.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># the default epsilon can be too small</span>
        <span class="n">epsilon</span> <span class="o">=</span> <span class="n">_get_epsilon</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="mf">3.</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">))</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;transformed&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;complex_step&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">hessian</span> <span class="o">=</span> <span class="n">approx_hess_cs</span><span class="p">(</span>
            <span class="n">params</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">loglike</span><span class="p">,</span> <span class="n">epsilon</span><span class="o">=</span><span class="n">epsilon</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">hessian</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nobs</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">loglikelihood_burn</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">start_params</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        (array) Starting parameters for maximum likelihood estimation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_start_params&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_start_params</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">param_names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        (list of str) List of human readable parameter names (for parameters</span>
<span class="sd">        actually included in the model).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_param_names&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_param_names</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;param.</span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">start_params</span><span class="p">))]</span>
            <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
                <span class="n">names</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">return</span> <span class="n">names</span>

<div class="viewcode-block" id="MLEModel.transform_jacobian"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEModel.transform_jacobian.html#statsmodels.regression.recursive_ls.MLEModel.transform_jacobian">[docs]</a>    <span class="k">def</span> <span class="nf">transform_jacobian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unconstrained</span><span class="p">,</span> <span class="n">approx_centered</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Jacobian matrix for the parameter transformation function</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        unconstrained : array_like</span>
<span class="sd">            Array of unconstrained parameters used by the optimizer.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        jacobian : array</span>
<span class="sd">            Jacobian matrix of the transformation, evaluated at `unconstrained`</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This is a numerical approximation using finite differences. Note that</span>
<span class="sd">        in general complex step methods cannot be used because it is not</span>
<span class="sd">        guaranteed that the `transform_params` method is a real function (e.g.</span>
<span class="sd">        if Cholesky decomposition is used).</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        transform_params</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">approx_fprime</span><span class="p">(</span><span class="n">unconstrained</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_params</span><span class="p">,</span>
                             <span class="n">centered</span><span class="o">=</span><span class="n">approx_centered</span><span class="p">)</span></div>

<div class="viewcode-block" id="MLEModel.transform_params"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEModel.transform_params.html#statsmodels.regression.recursive_ls.MLEModel.transform_params">[docs]</a>    <span class="k">def</span> <span class="nf">transform_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unconstrained</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Transform unconstrained parameters used by the optimizer to constrained</span>
<span class="sd">        parameters used in likelihood evaluation</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        unconstrained : array_like</span>
<span class="sd">            Array of unconstrained parameters used by the optimizer, to be</span>
<span class="sd">            transformed.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        constrained : array_like</span>
<span class="sd">            Array of constrained parameters which may be used in likelihood</span>
<span class="sd">            evalation.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This is a noop in the base class, subclasses should override where</span>
<span class="sd">        appropriate.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">unconstrained</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span></div>

<div class="viewcode-block" id="MLEModel.untransform_params"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEModel.untransform_params.html#statsmodels.regression.recursive_ls.MLEModel.untransform_params">[docs]</a>    <span class="k">def</span> <span class="nf">untransform_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">constrained</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Transform constrained parameters used in likelihood evaluation</span>
<span class="sd">        to unconstrained parameters used by the optimizer</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        constrained : array_like</span>
<span class="sd">            Array of constrained parameters used in likelihood evalution, to be</span>
<span class="sd">            transformed.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        unconstrained : array_like</span>
<span class="sd">            Array of unconstrained parameters used by the optimizer.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This is a noop in the base class, subclasses should override where</span>
<span class="sd">        appropriate.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">constrained</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span></div>

<div class="viewcode-block" id="MLEModel.update"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEModel.update.html#statsmodels.regression.recursive_ls.MLEModel.update">[docs]</a>    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">complex_step</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update the parameters of the model</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array_like</span>
<span class="sd">            Array of new parameters.</span>
<span class="sd">        transformed : boolean, optional</span>
<span class="sd">            Whether or not `params` is already transformed. If set to False,</span>
<span class="sd">            `transform_params` is called. Default is True.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        params : array_like</span>
<span class="sd">            Array of parameters.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Since Model is a base class, this method should be overridden by</span>
<span class="sd">        subclasses to perform actual updating steps.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">transformed</span><span class="p">:</span>
            <span class="n">params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_params</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">params</span></div>

<div class="viewcode-block" id="MLEModel.simulate"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEModel.simulate.html#statsmodels.regression.recursive_ls.MLEModel.simulate">[docs]</a>    <span class="k">def</span> <span class="nf">simulate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">nsimulations</span><span class="p">,</span> <span class="n">measurement_shocks</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">state_shocks</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">initial_state</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Simulate a new time series following the state space model</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array_like</span>
<span class="sd">            Array of model parameters.</span>
<span class="sd">        nsimulations : int</span>
<span class="sd">            The number of observations to simulate. If the model is</span>
<span class="sd">            time-invariant this can be any number. If the model is</span>
<span class="sd">            time-varying, then this number must be less than or equal to the</span>
<span class="sd">            number</span>
<span class="sd">        measurement_shocks : array_like, optional</span>
<span class="sd">            If specified, these are the shocks to the measurement equation,</span>
<span class="sd">            :math:`\varepsilon_t`. If unspecified, these are automatically</span>
<span class="sd">            generated using a pseudo-random number generator. If specified,</span>
<span class="sd">            must be shaped `nsimulations` x `k_endog`, where `k_endog` is the</span>
<span class="sd">            same as in the state space model.</span>
<span class="sd">        state_shocks : array_like, optional</span>
<span class="sd">            If specified, these are the shocks to the state equation,</span>
<span class="sd">            :math:`\eta_t`. If unspecified, these are automatically</span>
<span class="sd">            generated using a pseudo-random number generator. If specified,</span>
<span class="sd">            must be shaped `nsimulations` x `k_posdef` where `k_posdef` is the</span>
<span class="sd">            same as in the state space model.</span>
<span class="sd">        initial_state : array_like, optional</span>
<span class="sd">            If specified, this is the state vector at time zero, which should</span>
<span class="sd">            be shaped (`k_states` x 1), where `k_states` is the same as in the</span>
<span class="sd">            state space model. If unspecified, but the model has been</span>
<span class="sd">            initialized, then that initialization is used. If unspecified and</span>
<span class="sd">            the model has not been initialized, then a vector of zeros is used.</span>
<span class="sd">            Note that this is not included in the returned `simulated_states`</span>
<span class="sd">            array.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        simulated_obs : array</span>
<span class="sd">            An (nsimulations x k_endog) array of simulated observations.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>

        <span class="n">simulated_obs</span><span class="p">,</span> <span class="n">simulated_states</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">simulate</span><span class="p">(</span>
            <span class="n">nsimulations</span><span class="p">,</span> <span class="n">measurement_shocks</span><span class="p">,</span> <span class="n">state_shocks</span><span class="p">,</span> <span class="n">initial_state</span><span class="p">)</span>

        <span class="c1"># Simulated obs is (nobs x k_endog); don&#39;t want to squeeze in</span>
        <span class="c1"># case of nsimulations = 1</span>
        <span class="k">if</span> <span class="n">simulated_obs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">simulated_obs</span> <span class="o">=</span> <span class="n">simulated_obs</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">simulated_obs</span></div>

<div class="viewcode-block" id="MLEModel.impulse_responses"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEModel.impulse_responses.html#statsmodels.regression.recursive_ls.MLEModel.impulse_responses">[docs]</a>    <span class="k">def</span> <span class="nf">impulse_responses</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">steps</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">impulse</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                          <span class="n">orthogonalized</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">cumulative</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Impulse response function</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array_like</span>
<span class="sd">            Array of model parameters.</span>
<span class="sd">        steps : int, optional</span>
<span class="sd">            The number of steps for which impulse responses are calculated.</span>
<span class="sd">            Default is 1. Note that the initial impulse is not counted as a</span>
<span class="sd">            step, so if `steps=1`, the output will have 2 entries.</span>
<span class="sd">        impulse : int or array_like</span>
<span class="sd">            If an integer, the state innovation to pulse; must be between 0</span>
<span class="sd">            and `k_posdef-1`. Alternatively, a custom impulse vector may be</span>
<span class="sd">            provided; must be shaped `k_posdef x 1`.</span>
<span class="sd">        orthogonalized : boolean, optional</span>
<span class="sd">            Whether or not to perform impulse using orthogonalized innovations.</span>
<span class="sd">            Note that this will also affect custum `impulse` vectors. Default</span>
<span class="sd">            is False.</span>
<span class="sd">        cumulative : boolean, optional</span>
<span class="sd">            Whether or not to return cumulative impulse responses. Default is</span>
<span class="sd">            False.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            If the model is time-varying and `steps` is greater than the number</span>
<span class="sd">            of observations, any of the state space representation matrices</span>
<span class="sd">            that are time-varying must have updated values provided for the</span>
<span class="sd">            out-of-sample steps.</span>
<span class="sd">            For example, if `design` is a time-varying component, `nobs` is 10,</span>
<span class="sd">            and `steps` is 15, a (`k_endog` x `k_states` x 5) matrix must be</span>
<span class="sd">            provided with the new design matrix values.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        impulse_responses : array</span>
<span class="sd">            Responses for each endogenous variable due to the impulse</span>
<span class="sd">            given by the `impulse` argument. A (steps + 1 x k_endog) array.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Intercepts in the measurement and state equation are ignored when</span>
<span class="sd">        calculating impulse responses.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
        <span class="n">irfs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">impulse_responses</span><span class="p">(</span>
            <span class="n">steps</span><span class="p">,</span> <span class="n">impulse</span><span class="p">,</span> <span class="n">orthogonalized</span><span class="p">,</span> <span class="n">cumulative</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># IRF is (nobs x k_endog); don&#39;t want to squeeze in case of steps = 1</span>
        <span class="k">if</span> <span class="n">irfs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">irfs</span> <span class="o">=</span> <span class="n">irfs</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">irfs</span></div>

<div class="viewcode-block" id="MLEModel.from_formula"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEModel.from_formula.html#statsmodels.regression.recursive_ls.MLEModel.from_formula">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_formula</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">formula</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">subset</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Not implemented for state space models</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div></div>


<div class="viewcode-block" id="MLEResults"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEResults.html#statsmodels.regression.recursive_ls.MLEResults">[docs]</a><span class="k">class</span> <span class="nc">MLEResults</span><span class="p">(</span><span class="n">tsbase</span><span class="o">.</span><span class="n">TimeSeriesModelResults</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class to hold results from fitting a state space model.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    model : MLEModel instance</span>
<span class="sd">        The fitted model instance</span>
<span class="sd">    params : array</span>
<span class="sd">        Fitted parameters</span>
<span class="sd">    filter_results : KalmanFilter instance</span>
<span class="sd">        The underlying state space model and Kalman filter output</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    model : Model instance</span>
<span class="sd">        A reference to the model that was fit.</span>
<span class="sd">    filter_results : KalmanFilter instance</span>
<span class="sd">        The underlying state space model and Kalman filter output</span>
<span class="sd">    nobs : float</span>
<span class="sd">        The number of observations used to fit the model.</span>
<span class="sd">    params : array</span>
<span class="sd">        The parameters of the model.</span>
<span class="sd">    scale : float</span>
<span class="sd">        This is currently set to 1.0 and not used by the model or its results.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    MLEModel</span>
<span class="sd">    statsmodels.tsa.statespace.kalman_filter.FilterResults</span>
<span class="sd">    statsmodels.tsa.statespace.representation.FrozenRepresentation</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">results</span><span class="p">,</span> <span class="n">cov_type</span><span class="o">=</span><span class="s1">&#39;opg&#39;</span><span class="p">,</span>
                 <span class="n">cov_kwds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">data</span>

        <span class="n">tsbase</span><span class="o">.</span><span class="n">TimeSeriesModelResults</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span>
                                               <span class="n">normalized_cov_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                               <span class="n">scale</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span>

        <span class="c1"># Save the state space representation output</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filter_results</span> <span class="o">=</span> <span class="n">results</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="n">SmootherResults</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">smoother_results</span> <span class="o">=</span> <span class="n">results</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">smoother_results</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Dimensions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_results</span><span class="o">.</span><span class="n">nobs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nobs_effective</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">loglikelihood_burn</span>

        <span class="c1"># Degrees of freedom</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">df_model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">df_resid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs_effective</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">df_model</span>

        <span class="c1"># Setup covariance matrix notes dictionary</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;cov_kwds&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cov_kwds</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cov_type</span> <span class="o">=</span> <span class="n">cov_type</span>

        <span class="c1"># Setup the cache</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span> <span class="o">=</span> <span class="n">resettable_cache</span><span class="p">()</span>

        <span class="c1"># Handle covariance matrix calculation</span>
        <span class="k">if</span> <span class="n">cov_kwds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cov_kwds</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cov_approx_complex_step</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">cov_kwds</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;approx_complex_step&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cov_approx_centered</span> <span class="o">=</span> <span class="n">cov_kwds</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;approx_centered&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_rank</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_get_robustcov_results</span><span class="p">(</span><span class="n">cov_type</span><span class="o">=</span><span class="n">cov_type</span><span class="p">,</span> <span class="n">use_self</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                        <span class="o">**</span><span class="n">cov_kwds</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">LinAlgError</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_rank</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">k_params</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cov_params_default</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">k_params</span><span class="p">,</span> <span class="n">k_params</span><span class="p">))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cov_kwds</span><span class="p">[</span><span class="s1">&#39;cov_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s1">&#39;Covariance matrix could not be calculated: singular.&#39;</span>
                <span class="s1">&#39; information matrix.&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>

        <span class="c1"># References of filter and smoother output</span>
        <span class="n">extra_arrays</span> <span class="o">=</span> <span class="p">[</span>
            <span class="s1">&#39;filtered_state&#39;</span><span class="p">,</span> <span class="s1">&#39;filtered_state_cov&#39;</span><span class="p">,</span> <span class="s1">&#39;predicted_state&#39;</span><span class="p">,</span>
            <span class="s1">&#39;predicted_state_cov&#39;</span><span class="p">,</span> <span class="s1">&#39;forecasts&#39;</span><span class="p">,</span> <span class="s1">&#39;forecasts_error&#39;</span><span class="p">,</span>
            <span class="s1">&#39;forecasts_error_cov&#39;</span><span class="p">,</span> <span class="s1">&#39;standardized_forecasts_error&#39;</span><span class="p">,</span>
            <span class="s1">&#39;scaled_smoothed_estimator&#39;</span><span class="p">,</span>
            <span class="s1">&#39;scaled_smoothed_estimator_cov&#39;</span><span class="p">,</span> <span class="s1">&#39;smoothing_error&#39;</span><span class="p">,</span>
            <span class="s1">&#39;smoothed_state&#39;</span><span class="p">,</span>
            <span class="s1">&#39;smoothed_state_cov&#39;</span><span class="p">,</span> <span class="s1">&#39;smoothed_state_autocov&#39;</span><span class="p">,</span>
            <span class="s1">&#39;smoothed_measurement_disturbance&#39;</span><span class="p">,</span>
            <span class="s1">&#39;smoothed_state_disturbance&#39;</span><span class="p">,</span>
            <span class="s1">&#39;smoothed_measurement_disturbance_cov&#39;</span><span class="p">,</span>
            <span class="s1">&#39;smoothed_state_disturbance_cov&#39;</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">extra_arrays</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filter_results</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>

        <span class="c1"># Handle removing data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data_attr_model</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_data_attr_model&#39;</span><span class="p">,</span> <span class="p">[])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data_attr_model</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="s1">&#39;ssm&#39;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data_attr</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">extra_arrays</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data_attr</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="s1">&#39;filter_results&#39;</span><span class="p">,</span> <span class="s1">&#39;smoother_results&#39;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_in_cache</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;data_in_cache&#39;</span><span class="p">,</span> <span class="p">[])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_in_cache</span><span class="o">.</span><span class="n">extend</span><span class="p">([])</span>

    <span class="k">def</span> <span class="nf">_get_robustcov_results</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cov_type</span><span class="o">=</span><span class="s1">&#39;opg&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create new results instance with specified covariance estimator as</span>
<span class="sd">        default</span>

<span class="sd">        Note: creating new results instance currently not supported.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cov_type : string</span>
<span class="sd">            the type of covariance matrix estimator to use. See Notes below</span>
<span class="sd">        kwargs : depends on cov_type</span>
<span class="sd">            Required or optional arguments for covariance calculation.</span>
<span class="sd">            See Notes below.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        results : results instance</span>
<span class="sd">            This method creates a new results instance with the requested</span>
<span class="sd">            covariance as the default covariance of the parameters.</span>
<span class="sd">            Inferential statistics like p-values and hypothesis tests will be</span>
<span class="sd">            based on this covariance matrix.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The following covariance types and required or optional arguments are</span>
<span class="sd">        currently available:</span>

<span class="sd">        - &#39;opg&#39; for the outer product of gradient estimator</span>
<span class="sd">        - &#39;oim&#39; for the observed information matrix estimator, calculated</span>
<span class="sd">          using the method of Harvey (1989)</span>
<span class="sd">        - &#39;approx&#39; for the observed information matrix estimator,</span>
<span class="sd">          calculated using a numerical approximation of the Hessian matrix.</span>
<span class="sd">          Uses complex step approximation by default, or uses finite</span>
<span class="sd">          differences if `approx_complex_step=False` in the `cov_kwds`</span>
<span class="sd">          dictionary.</span>
<span class="sd">        - &#39;robust&#39; for an approximate (quasi-maximum likelihood) covariance</span>
<span class="sd">          matrix that may be valid even in the presense of some</span>
<span class="sd">          misspecifications. Intermediate calculations use the &#39;oim&#39;</span>
<span class="sd">          method.</span>
<span class="sd">        - &#39;robust_approx&#39; is the same as &#39;robust&#39; except that the</span>
<span class="sd">          intermediate calculations use the &#39;approx&#39; method.</span>
<span class="sd">        - &#39;none&#39; for no covariance matrix calculation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">use_self</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;use_self&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">use_self</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span>
            <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">,</span>
                <span class="n">normalized_cov_params</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">normalized_cov_params</span><span class="p">,</span>
                <span class="n">scale</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">)</span>

        <span class="c1"># Set the new covariance type</span>
        <span class="n">res</span><span class="o">.</span><span class="n">cov_type</span> <span class="o">=</span> <span class="n">cov_type</span>
        <span class="n">res</span><span class="o">.</span><span class="n">cov_kwds</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># Calculate the new covariance matrix</span>
        <span class="n">approx_complex_step</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cov_approx_complex_step</span>
        <span class="k">if</span> <span class="n">approx_complex_step</span><span class="p">:</span>
            <span class="n">approx_type_str</span> <span class="o">=</span> <span class="s1">&#39;complex-step&#39;</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cov_approx_centered</span><span class="p">:</span>
            <span class="n">approx_type_str</span> <span class="o">=</span> <span class="s1">&#39;centered finite differences&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">approx_type_str</span> <span class="o">=</span> <span class="s1">&#39;finite differences&#39;</span>

        <span class="n">k_params</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">k_params</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">res</span><span class="o">.</span><span class="n">cov_params_default</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
            <span class="n">res</span><span class="o">.</span><span class="n">_rank</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">res</span><span class="o">.</span><span class="n">cov_kwds</span><span class="p">[</span><span class="s1">&#39;description&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;No parameters estimated.&#39;</span>
        <span class="k">elif</span> <span class="n">cov_type</span> <span class="o">==</span> <span class="s1">&#39;custom&#39;</span><span class="p">:</span>
            <span class="n">res</span><span class="o">.</span><span class="n">cov_type</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;custom_cov_type&#39;</span><span class="p">]</span>
            <span class="n">res</span><span class="o">.</span><span class="n">cov_params_default</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;custom_cov_params&#39;</span><span class="p">]</span>
            <span class="n">res</span><span class="o">.</span><span class="n">cov_kwds</span><span class="p">[</span><span class="s1">&#39;description&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;custom_description&#39;</span><span class="p">]</span>
            <span class="n">res</span><span class="o">.</span><span class="n">_rank</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">matrix_rank</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">cov_params_default</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">cov_type</span> <span class="o">==</span> <span class="s1">&#39;none&#39;</span><span class="p">:</span>
            <span class="n">res</span><span class="o">.</span><span class="n">cov_params_default</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">k_params</span><span class="p">,</span> <span class="n">k_params</span><span class="p">))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">res</span><span class="o">.</span><span class="n">_rank</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">res</span><span class="o">.</span><span class="n">cov_kwds</span><span class="p">[</span><span class="s1">&#39;description&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;Covariance matrix not calculated.&#39;</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">cov_type</span> <span class="o">==</span> <span class="s1">&#39;approx&#39;</span><span class="p">:</span>
            <span class="n">res</span><span class="o">.</span><span class="n">cov_params_default</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">cov_params_approx</span>
            <span class="n">res</span><span class="o">.</span><span class="n">cov_kwds</span><span class="p">[</span><span class="s1">&#39;description&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s1">&#39;Covariance matrix calculated using numerical (</span><span class="si">%s</span><span class="s1">)&#39;</span>
                <span class="s1">&#39; differentiation.&#39;</span> <span class="o">%</span> <span class="n">approx_type_str</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">cov_type</span> <span class="o">==</span> <span class="s1">&#39;oim&#39;</span><span class="p">:</span>
            <span class="n">res</span><span class="o">.</span><span class="n">cov_params_default</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">cov_params_oim</span>
            <span class="n">res</span><span class="o">.</span><span class="n">cov_kwds</span><span class="p">[</span><span class="s1">&#39;description&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s1">&#39;Covariance matrix calculated using the observed information&#39;</span>
                <span class="s1">&#39; matrix (</span><span class="si">%s</span><span class="s1">) described in Harvey (1989).&#39;</span> <span class="o">%</span> <span class="n">approx_type_str</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">cov_type</span> <span class="o">==</span> <span class="s1">&#39;opg&#39;</span><span class="p">:</span>
            <span class="n">res</span><span class="o">.</span><span class="n">cov_params_default</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">cov_params_opg</span>
            <span class="n">res</span><span class="o">.</span><span class="n">cov_kwds</span><span class="p">[</span><span class="s1">&#39;description&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s1">&#39;Covariance matrix calculated using the outer product of&#39;</span>
                <span class="s1">&#39; gradients (</span><span class="si">%s</span><span class="s1">).&#39;</span> <span class="o">%</span> <span class="n">approx_type_str</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">cov_type</span> <span class="o">==</span> <span class="s1">&#39;robust&#39;</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">cov_type</span> <span class="o">==</span> <span class="s1">&#39;robust_oim&#39;</span><span class="p">:</span>
            <span class="n">res</span><span class="o">.</span><span class="n">cov_params_default</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">cov_params_robust_oim</span>
            <span class="n">res</span><span class="o">.</span><span class="n">cov_kwds</span><span class="p">[</span><span class="s1">&#39;description&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s1">&#39;Quasi-maximum likelihood covariance matrix used for&#39;</span>
                <span class="s1">&#39; robustness to some misspecifications; calculated using the&#39;</span>
                <span class="s1">&#39; observed information matrix (</span><span class="si">%s</span><span class="s1">) described in&#39;</span>
                <span class="s1">&#39; Harvey (1989).&#39;</span> <span class="o">%</span> <span class="n">approx_type_str</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">cov_type</span> <span class="o">==</span> <span class="s1">&#39;robust_approx&#39;</span><span class="p">:</span>
            <span class="n">res</span><span class="o">.</span><span class="n">cov_params_default</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">cov_params_robust_approx</span>
            <span class="n">res</span><span class="o">.</span><span class="n">cov_kwds</span><span class="p">[</span><span class="s1">&#39;description&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s1">&#39;Quasi-maximum likelihood covariance matrix used for&#39;</span>
                <span class="s1">&#39; robustness to some misspecifications; calculated using&#39;</span>
                <span class="s1">&#39; numerical (</span><span class="si">%s</span><span class="s1">) differentiation.&#39;</span> <span class="o">%</span> <span class="n">approx_type_str</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Invalid covariance matrix type.&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">res</span>

<div class="viewcode-block" id="MLEResults.aic"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEResults.aic.html#statsmodels.regression.recursive_ls.MLEResults.aic">[docs]</a>    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">aic</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        (float) Akaike Information Criterion</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># return -2 * self.llf + 2 * self.df_model</span>
        <span class="k">return</span> <span class="n">aic</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">llf</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs_effective</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">df_model</span><span class="p">)</span></div>

<div class="viewcode-block" id="MLEResults.bic"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEResults.bic.html#statsmodels.regression.recursive_ls.MLEResults.bic">[docs]</a>    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">bic</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        (float) Bayes Information Criterion</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># return (-2 * self.llf +</span>
        <span class="c1">#         self.df_model * np.log(self.nobs_effective))</span>
        <span class="k">return</span> <span class="n">bic</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">llf</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs_effective</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">df_model</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_cov_params_approx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">approx_complex_step</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                           <span class="n">approx_centered</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="n">nobs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">nobs</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_results</span><span class="o">.</span><span class="n">loglikelihood_burn</span>

        <span class="n">evaluated_hessian</span> <span class="o">=</span> <span class="n">nobs</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">hessian</span><span class="p">(</span><span class="n">params</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">,</span>
                                    <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                    <span class="n">method</span><span class="o">=</span><span class="s1">&#39;approx&#39;</span><span class="p">,</span>
                                    <span class="n">approx_complex_step</span><span class="o">=</span><span class="n">approx_complex_step</span><span class="p">,</span>
                                    <span class="n">approx_centered</span><span class="o">=</span><span class="n">approx_centered</span><span class="p">)</span>
        <span class="c1"># TODO: Case with &quot;not approx_complex_step&quot; is not hit in</span>
        <span class="c1"># tests as of 2017-05-19</span>

        <span class="p">(</span><span class="n">neg_cov</span><span class="p">,</span> <span class="n">singular_values</span><span class="p">)</span> <span class="o">=</span> <span class="n">pinv_extended</span><span class="p">(</span><span class="n">evaluated_hessian</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rank</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_rank</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">matrix_rank</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">singular_values</span><span class="p">))</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">neg_cov</span>

<div class="viewcode-block" id="MLEResults.cov_params_approx"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEResults.cov_params_approx.html#statsmodels.regression.recursive_ls.MLEResults.cov_params_approx">[docs]</a>    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">cov_params_approx</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        (array) The variance / covariance matrix. Computed using the numerical</span>
<span class="sd">        Hessian approximated by complex step or finite differences methods.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cov_params_approx</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cov_approx_complex_step</span><span class="p">,</span>
                                       <span class="bp">self</span><span class="o">.</span><span class="n">_cov_approx_centered</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_cov_params_oim</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">approx_complex_step</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">approx_centered</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="n">nobs</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">nobs</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_results</span><span class="o">.</span><span class="n">loglikelihood_burn</span><span class="p">)</span>

        <span class="n">evaluated_hessian</span> <span class="o">=</span> <span class="n">nobs</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">hessian</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">,</span>
                                        <span class="n">hessian_method</span><span class="o">=</span><span class="s1">&#39;oim&#39;</span><span class="p">,</span>
                                        <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                        <span class="n">approx_complex_step</span><span class="o">=</span><span class="n">approx_complex_step</span><span class="p">,</span>
                                        <span class="n">approx_centered</span><span class="o">=</span><span class="n">approx_centered</span><span class="p">)</span>

        <span class="p">(</span><span class="n">neg_cov</span><span class="p">,</span> <span class="n">singular_values</span><span class="p">)</span> <span class="o">=</span> <span class="n">pinv_extended</span><span class="p">(</span><span class="n">evaluated_hessian</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rank</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_rank</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">matrix_rank</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">singular_values</span><span class="p">))</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">neg_cov</span>

<div class="viewcode-block" id="MLEResults.cov_params_oim"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEResults.cov_params_oim.html#statsmodels.regression.recursive_ls.MLEResults.cov_params_oim">[docs]</a>    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">cov_params_oim</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        (array) The variance / covariance matrix. Computed using the method</span>
<span class="sd">        from Harvey (1989).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cov_params_oim</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cov_approx_complex_step</span><span class="p">,</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">_cov_approx_centered</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_cov_params_opg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">approx_complex_step</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">approx_centered</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="n">nobs</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">nobs</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_results</span><span class="o">.</span><span class="n">loglikelihood_burn</span><span class="p">)</span>

        <span class="n">evaluated_hessian</span> <span class="o">=</span> <span class="n">nobs</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">_hessian_opg</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">,</span>
                                        <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                        <span class="n">approx_complex_step</span><span class="o">=</span><span class="n">approx_complex_step</span><span class="p">,</span>
                                        <span class="n">approx_centered</span><span class="o">=</span><span class="n">approx_centered</span><span class="p">)</span>

        <span class="p">(</span><span class="n">neg_cov</span><span class="p">,</span> <span class="n">singular_values</span><span class="p">)</span> <span class="o">=</span> <span class="n">pinv_extended</span><span class="p">(</span><span class="n">evaluated_hessian</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rank</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_rank</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">matrix_rank</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">singular_values</span><span class="p">))</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">neg_cov</span>

<div class="viewcode-block" id="MLEResults.cov_params_opg"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEResults.cov_params_opg.html#statsmodels.regression.recursive_ls.MLEResults.cov_params_opg">[docs]</a>    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">cov_params_opg</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        (array) The variance / covariance matrix. Computed using the outer</span>
<span class="sd">        product of gradients method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cov_params_opg</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cov_approx_complex_step</span><span class="p">,</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">_cov_approx_centered</span><span class="p">)</span></div>

<div class="viewcode-block" id="MLEResults.cov_params_robust"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEResults.cov_params_robust.html#statsmodels.regression.recursive_ls.MLEResults.cov_params_robust">[docs]</a>    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">cov_params_robust</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        (array) The QMLE variance / covariance matrix. Alias for</span>
<span class="sd">        `cov_params_robust_oim`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cov_params_robust_oim</span></div>

    <span class="k">def</span> <span class="nf">_cov_params_robust_oim</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">approx_complex_step</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                               <span class="n">approx_centered</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="n">nobs</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">nobs</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_results</span><span class="o">.</span><span class="n">loglikelihood_burn</span><span class="p">)</span>
        <span class="n">cov_opg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cov_params_opg</span><span class="p">(</span><span class="n">approx_complex_step</span><span class="o">=</span><span class="n">approx_complex_step</span><span class="p">,</span>
                                       <span class="n">approx_centered</span><span class="o">=</span><span class="n">approx_centered</span><span class="p">)</span>

        <span class="n">evaluated_hessian</span> <span class="o">=</span> <span class="n">nobs</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">hessian</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">,</span>
                                        <span class="n">hessian_method</span><span class="o">=</span><span class="s1">&#39;oim&#39;</span><span class="p">,</span>
                                        <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                        <span class="n">approx_complex_step</span><span class="o">=</span><span class="n">approx_complex_step</span><span class="p">,</span>
                                        <span class="n">approx_centered</span><span class="o">=</span><span class="n">approx_centered</span><span class="p">)</span>

        <span class="n">cov_params</span><span class="p">,</span> <span class="n">singular_values</span> <span class="o">=</span> <span class="n">pinv_extended</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">evaluated_hessian</span><span class="p">,</span> <span class="n">cov_opg</span><span class="p">),</span> <span class="n">evaluated_hessian</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rank</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_rank</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">matrix_rank</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">singular_values</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">cov_params</span>

<div class="viewcode-block" id="MLEResults.cov_params_robust_oim"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEResults.cov_params_robust_oim.html#statsmodels.regression.recursive_ls.MLEResults.cov_params_robust_oim">[docs]</a>    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">cov_params_robust_oim</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        (array) The QMLE variance / covariance matrix. Computed using the</span>
<span class="sd">        method from Harvey (1989) as the evaluated hessian.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cov_params_robust_oim</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cov_approx_complex_step</span><span class="p">,</span>
                                           <span class="bp">self</span><span class="o">.</span><span class="n">_cov_approx_centered</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_cov_params_robust_approx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">approx_complex_step</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                  <span class="n">approx_centered</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="n">nobs</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">nobs</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_results</span><span class="o">.</span><span class="n">loglikelihood_burn</span><span class="p">)</span>
        <span class="n">cov_opg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cov_params_opg</span><span class="p">(</span><span class="n">approx_complex_step</span><span class="o">=</span><span class="n">approx_complex_step</span><span class="p">,</span>
                                       <span class="n">approx_centered</span><span class="o">=</span><span class="n">approx_centered</span><span class="p">)</span>

        <span class="n">evaluated_hessian</span> <span class="o">=</span> <span class="n">nobs</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">hessian</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">,</span>
                                        <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                        <span class="n">method</span><span class="o">=</span><span class="s1">&#39;approx&#39;</span><span class="p">,</span>
                                        <span class="n">approx_complex_step</span><span class="o">=</span><span class="n">approx_complex_step</span><span class="p">)</span>
        <span class="c1"># TODO: Case with &quot;not approx_complex_step&quot; is not</span>
        <span class="c1"># hit in tests as of 2017-05-19</span>

        <span class="p">(</span><span class="n">cov_params</span><span class="p">,</span> <span class="n">singular_values</span><span class="p">)</span> <span class="o">=</span> <span class="n">pinv_extended</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">evaluated_hessian</span><span class="p">,</span> <span class="n">cov_opg</span><span class="p">),</span> <span class="n">evaluated_hessian</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rank</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_rank</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">matrix_rank</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">singular_values</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">cov_params</span>

<div class="viewcode-block" id="MLEResults.cov_params_robust_approx"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEResults.cov_params_robust_approx.html#statsmodels.regression.recursive_ls.MLEResults.cov_params_robust_approx">[docs]</a>    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">cov_params_robust_approx</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        (array) The QMLE variance / covariance matrix. Computed using the</span>
<span class="sd">        numerical Hessian as the evaluated hessian.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cov_params_robust_approx</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cov_approx_complex_step</span><span class="p">,</span>
                                              <span class="bp">self</span><span class="o">.</span><span class="n">_cov_approx_centered</span><span class="p">)</span></div>

<div class="viewcode-block" id="MLEResults.info_criteria"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEResults.info_criteria.html#statsmodels.regression.recursive_ls.MLEResults.info_criteria">[docs]</a>    <span class="k">def</span> <span class="nf">info_criteria</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">criteria</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;standard&#39;</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Information criteria</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        criteria : {&#39;aic&#39;, &#39;bic&#39;, &#39;hqic&#39;}</span>
<span class="sd">            The information criteria to compute.</span>
<span class="sd">        method : {&#39;standard&#39;, &#39;lutkepohl&#39;}</span>
<span class="sd">            The method for information criteria computation. Default is</span>
<span class="sd">            &#39;standard&#39; method; &#39;lutkepohl&#39; computes the information criteria</span>
<span class="sd">            as in Lütkepohl (2007). See Notes for formulas.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The `&#39;standard&#39;` formulas are:</span>

<span class="sd">        .. math::</span>

<span class="sd">            AIC &amp; = -2 \log L(Y_n | \hat \psi) + 2 k \\</span>
<span class="sd">            BIC &amp; = -2 \log L(Y_n | \hat \psi) + k \log n \\</span>
<span class="sd">            HQIC &amp; = -2 \log L(Y_n | \hat \psi) + 2 k \log \log n \\</span>

<span class="sd">        where :math:`\hat \psi` are the maximum likelihood estimates of the</span>
<span class="sd">        parameters, :math:`n` is the number of observations, and `k` is the</span>
<span class="sd">        number of estimated parameters.</span>

<span class="sd">        Note that the `&#39;standard&#39;` formulas are returned from the `aic`, `bic`,</span>
<span class="sd">        and `hqic` results attributes.</span>

<span class="sd">        The `&#39;lutkepohl&#39;` formuals are (Lütkepohl, 2010):</span>

<span class="sd">        .. math::</span>

<span class="sd">            AIC_L &amp; = \log | Q | + \frac{2 k}{n} \\</span>
<span class="sd">            BIC_L &amp; = \log | Q | + \frac{k \log n}{n} \\</span>
<span class="sd">            HQIC_L &amp; = \log | Q | + \frac{2 k \log \log n}{n} \\</span>

<span class="sd">        where :math:`Q` is the state covariance matrix. Note that the Lütkepohl</span>
<span class="sd">        definitions do not apply to all state space models, and should be used</span>
<span class="sd">        with care outside of SARIMAX and VARMAX models.</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        .. [*] Lütkepohl, Helmut. 2007. *New Introduction to Multiple Time*</span>
<span class="sd">           *Series Analysis.* Berlin: Springer.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">criteria</span> <span class="o">=</span> <span class="n">criteria</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="n">method</span> <span class="o">=</span> <span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;standard&#39;</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">criteria</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;lutkepohl&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_results</span><span class="o">.</span><span class="n">state_cov</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Cannot compute Lütkepohl statistics for&#39;</span>
                                 <span class="s1">&#39; models with time-varying state covariance&#39;</span>
                                 <span class="s1">&#39; matrix.&#39;</span><span class="p">)</span>

            <span class="n">cov</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_results</span><span class="o">.</span><span class="n">state_cov</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">criteria</span> <span class="o">==</span> <span class="s1">&#39;aic&#39;</span><span class="p">:</span>
                <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">slogdet</span><span class="p">(</span><span class="n">cov</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span>
                                 <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">df_model</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs_effective</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">criteria</span> <span class="o">==</span> <span class="s1">&#39;bic&#39;</span><span class="p">:</span>
                <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">slogdet</span><span class="p">(</span><span class="n">cov</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span>
                                 <span class="bp">self</span><span class="o">.</span><span class="n">df_model</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nobs_effective</span><span class="p">)</span> <span class="o">/</span>
                                 <span class="bp">self</span><span class="o">.</span><span class="n">nobs_effective</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">criteria</span> <span class="o">==</span> <span class="s1">&#39;hqic&#39;</span><span class="p">:</span>
                <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">slogdet</span><span class="p">(</span><span class="n">cov</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span>
                                 <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">df_model</span> <span class="o">*</span>
                                 <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nobs_effective</span><span class="p">))</span> <span class="o">/</span>
                                 <span class="bp">self</span><span class="o">.</span><span class="n">nobs_effective</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid information criteria&#39;</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid information criteria computation method&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">out</span></div>

<div class="viewcode-block" id="MLEResults.fittedvalues"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEResults.fittedvalues.html#statsmodels.regression.recursive_ls.MLEResults.fittedvalues">[docs]</a>    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">fittedvalues</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        (array) The predicted values of the model. An (nobs x k_endog) array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># This is a (k_endog x nobs array; don&#39;t want to squeeze in case of</span>
        <span class="c1"># the corner case where nobs = 1 (mostly a concern in the predict or</span>
        <span class="c1"># forecast functions, but here also to maintain consistency)</span>
        <span class="n">fittedvalues</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_results</span><span class="o">.</span><span class="n">forecasts</span>
        <span class="k">if</span> <span class="n">fittedvalues</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">fittedvalues</span> <span class="o">=</span> <span class="n">fittedvalues</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fittedvalues</span> <span class="o">=</span> <span class="n">fittedvalues</span><span class="o">.</span><span class="n">T</span>
        <span class="k">return</span> <span class="n">fittedvalues</span></div>

<div class="viewcode-block" id="MLEResults.hqic"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEResults.hqic.html#statsmodels.regression.recursive_ls.MLEResults.hqic">[docs]</a>    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">hqic</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        (float) Hannan-Quinn Information Criterion</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># return (-2 * self.llf +</span>
        <span class="c1">#         2 * np.log(np.log(self.nobs_effective)) * self.df_model)</span>
        <span class="k">return</span> <span class="n">hqic</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">llf</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs_effective</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">df_model</span><span class="p">)</span></div>

<div class="viewcode-block" id="MLEResults.llf_obs"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEResults.llf_obs.html#statsmodels.regression.recursive_ls.MLEResults.llf_obs">[docs]</a>    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">llf_obs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        (float) The value of the log-likelihood function evaluated at `params`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">loglikeobs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">)</span></div>

<div class="viewcode-block" id="MLEResults.llf"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEResults.llf.html#statsmodels.regression.recursive_ls.MLEResults.llf">[docs]</a>    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">llf</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        (float) The value of the log-likelihood function evaluated at `params`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">llf_obs</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">filter_results</span><span class="o">.</span><span class="n">loglikelihood_burn</span><span class="p">:]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span></div>

<div class="viewcode-block" id="MLEResults.loglikelihood_burn"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEResults.loglikelihood_burn.html#statsmodels.regression.recursive_ls.MLEResults.loglikelihood_burn">[docs]</a>    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">loglikelihood_burn</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        (float) The number of observations during which the likelihood is not</span>
<span class="sd">        evaluated.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_results</span><span class="o">.</span><span class="n">loglikelihood_burn</span></div>

<div class="viewcode-block" id="MLEResults.pvalues"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEResults.pvalues.html#statsmodels.regression.recursive_ls.MLEResults.pvalues">[docs]</a>    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">pvalues</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        (array) The p-values associated with the z-statistics of the</span>
<span class="sd">        coefficients. Note that the coefficients are assumed to have a Normal</span>
<span class="sd">        distribution.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">norm</span><span class="o">.</span><span class="n">sf</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">zvalues</span><span class="p">))</span> <span class="o">*</span> <span class="mi">2</span></div>

<div class="viewcode-block" id="MLEResults.resid"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEResults.resid.html#statsmodels.regression.recursive_ls.MLEResults.resid">[docs]</a>    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">resid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        (array) The model residuals. An (nobs x k_endog) array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># This is a (k_endog x nobs array; don&#39;t want to squeeze in case of</span>
        <span class="c1"># the corner case where nobs = 1 (mostly a concern in the predict or</span>
        <span class="c1"># forecast functions, but here also to maintain consistency)</span>
        <span class="n">resid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_results</span><span class="o">.</span><span class="n">forecasts_error</span>
        <span class="k">if</span> <span class="n">resid</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">resid</span> <span class="o">=</span> <span class="n">resid</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">resid</span> <span class="o">=</span> <span class="n">resid</span><span class="o">.</span><span class="n">T</span>
        <span class="k">return</span> <span class="n">resid</span></div>

<div class="viewcode-block" id="MLEResults.zvalues"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEResults.zvalues.html#statsmodels.regression.recursive_ls.MLEResults.zvalues">[docs]</a>    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">zvalues</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        (array) The z-statistics for the coefficients.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">bse</span></div>

<div class="viewcode-block" id="MLEResults.test_normality"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEResults.test_normality.html#statsmodels.regression.recursive_ls.MLEResults.test_normality">[docs]</a>    <span class="k">def</span> <span class="nf">test_normality</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Test for normality of standardized residuals.</span>

<span class="sd">        Null hypothesis is normality.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        method : string {&#39;jarquebera&#39;} or None</span>
<span class="sd">            The statistical test for normality. Must be &#39;jarquebera&#39; for</span>
<span class="sd">            Jarque-Bera normality test. If None, an attempt is made to select</span>
<span class="sd">            an appropriate test.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        If the first `d` loglikelihood values were burned (i.e. in the</span>
<span class="sd">        specified model, `loglikelihood_burn=d`), then this test is calculated</span>
<span class="sd">        ignoring the first `d` residuals.</span>

<span class="sd">        In the case of missing data, the maintained hypothesis is that the</span>
<span class="sd">        data are missing completely at random. This test is then run on the</span>
<span class="sd">        standardized residuals excluding those corresponding to missing</span>
<span class="sd">        observations.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        statsmodels.stats.stattools.jarque_bera</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">method</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">method</span> <span class="o">=</span> <span class="s1">&#39;jarquebera&#39;</span>

        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;jarquebera&#39;</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">statsmodels.stats.stattools</span> <span class="k">import</span> <span class="n">jarque_bera</span>
            <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">loglikelihood_burn</span>
            <span class="n">output</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">k_endog</span><span class="p">):</span>
                <span class="n">resid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_results</span><span class="o">.</span><span class="n">standardized_forecasts_error</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">d</span><span class="p">:]</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">resid</span><span class="p">)</span>
                <span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">jarque_bera</span><span class="p">(</span><span class="n">resid</span><span class="p">[</span><span class="n">mask</span><span class="p">]))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Invalid normality test method.&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">output</span><span class="p">)</span></div>

<div class="viewcode-block" id="MLEResults.test_heteroskedasticity"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEResults.test_heteroskedasticity.html#statsmodels.regression.recursive_ls.MLEResults.test_heteroskedasticity">[docs]</a>    <span class="k">def</span> <span class="nf">test_heteroskedasticity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">alternative</span><span class="o">=</span><span class="s1">&#39;two-sided&#39;</span><span class="p">,</span>
                                <span class="n">use_f</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Test for heteroskedasticity of standardized residuals</span>

<span class="sd">        Tests whether the sum-of-squares in the first third of the sample is</span>
<span class="sd">        significantly different than the sum-of-squares in the last third</span>
<span class="sd">        of the sample. Analogous to a Goldfeld-Quandt test. The null hypothesis</span>
<span class="sd">        is of no heteroskedasticity.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        method : string {&#39;breakvar&#39;} or None</span>
<span class="sd">            The statistical test for heteroskedasticity. Must be &#39;breakvar&#39;</span>
<span class="sd">            for test of a break in the variance. If None, an attempt is</span>
<span class="sd">            made to select an appropriate test.</span>
<span class="sd">        alternative : string, &#39;increasing&#39;, &#39;decreasing&#39; or &#39;two-sided&#39;</span>
<span class="sd">            This specifies the alternative for the p-value calculation. Default</span>
<span class="sd">            is two-sided.</span>
<span class="sd">        use_f : boolean, optional</span>
<span class="sd">            Whether or not to compare against the asymptotic distribution</span>
<span class="sd">            (chi-squared) or the approximate small-sample distribution (F).</span>
<span class="sd">            Default is True (i.e. default is to compare against an F</span>
<span class="sd">            distribution).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        output : array</span>
<span class="sd">            An array with `(test_statistic, pvalue)` for each endogenous</span>
<span class="sd">            variable. The array is then sized `(k_endog, 2)`. If the method is</span>
<span class="sd">            called as `het = res.test_heteroskedasticity()`, then `het[0]` is</span>
<span class="sd">            an array of size 2 corresponding to the first endogenous variable,</span>
<span class="sd">            where `het[0][0]` is the test statistic, and `het[0][1]` is the</span>
<span class="sd">            p-value.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The null hypothesis is of no heteroskedasticity. That means different</span>
<span class="sd">        things depending on which alternative is selected:</span>

<span class="sd">        - Increasing: Null hypothesis is that the variance is not increasing</span>
<span class="sd">          throughout the sample; that the sum-of-squares in the later</span>
<span class="sd">          subsample is *not* greater than the sum-of-squares in the earlier</span>
<span class="sd">          subsample.</span>
<span class="sd">        - Decreasing: Null hypothesis is that the variance is not decreasing</span>
<span class="sd">          throughout the sample; that the sum-of-squares in the earlier</span>
<span class="sd">          subsample is *not* greater than the sum-of-squares in the later</span>
<span class="sd">          subsample.</span>
<span class="sd">        - Two-sided: Null hypothesis is that the variance is not changing</span>
<span class="sd">          throughout the sample. Both that the sum-of-squares in the earlier</span>
<span class="sd">          subsample is not greater than the sum-of-squares in the later</span>
<span class="sd">          subsample *and* that the sum-of-squares in the later subsample is</span>
<span class="sd">          not greater than the sum-of-squares in the earlier subsample.</span>

<span class="sd">        For :math:`h = [T/3]`, the test statistic is:</span>

<span class="sd">        .. math::</span>

<span class="sd">            H(h) = \sum_{t=T-h+1}^T  \tilde v_t^2</span>
<span class="sd">            \Bigg / \sum_{t=d+1}^{d+1+h} \tilde v_t^2</span>

<span class="sd">        where :math:`d` is the number of periods in which the loglikelihood was</span>
<span class="sd">        burned in the parent model (usually corresponding to diffuse</span>
<span class="sd">        initialization).</span>

<span class="sd">        This statistic can be tested against an :math:`F(h,h)` distribution.</span>
<span class="sd">        Alternatively, :math:`h H(h)` is asymptotically distributed according</span>
<span class="sd">        to :math:`\chi_h^2`; this second test can be applied by passing</span>
<span class="sd">        `asymptotic=True` as an argument.</span>

<span class="sd">        See section 5.4 of [1]_ for the above formula and discussion, as well</span>
<span class="sd">        as additional details.</span>

<span class="sd">        TODO</span>

<span class="sd">        - Allow specification of :math:`h`</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        .. [1] Harvey, Andrew C. 1990. *Forecasting, Structural Time Series*</span>
<span class="sd">               *Models and the Kalman Filter.* Cambridge University Press.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">method</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">method</span> <span class="o">=</span> <span class="s1">&#39;breakvar&#39;</span>

        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;breakvar&#39;</span><span class="p">:</span>
            <span class="c1"># Store some values</span>
            <span class="n">squared_resid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_results</span><span class="o">.</span><span class="n">standardized_forecasts_error</span><span class="o">**</span><span class="mi">2</span>
            <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">loglikelihood_burn</span>

            <span class="n">test_statistics</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">p_values</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">k_endog</span><span class="p">):</span>
                <span class="n">h</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nobs_effective</span> <span class="o">/</span> <span class="mi">3</span><span class="p">))</span>
                <span class="n">numer_resid</span> <span class="o">=</span> <span class="n">squared_resid</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="o">-</span><span class="n">h</span><span class="p">:]</span>
                <span class="n">numer_resid</span> <span class="o">=</span> <span class="n">numer_resid</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">numer_resid</span><span class="p">)]</span>
                <span class="n">numer_dof</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">numer_resid</span><span class="p">)</span>

                <span class="n">denom_resid</span> <span class="o">=</span> <span class="n">squared_resid</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">d</span><span class="p">:</span><span class="n">d</span><span class="o">+</span><span class="n">h</span><span class="p">]</span>
                <span class="n">denom_resid</span> <span class="o">=</span> <span class="n">denom_resid</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">denom_resid</span><span class="p">)]</span>
                <span class="n">denom_dof</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">denom_resid</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">numer_dof</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Early subset of data for variable </span><span class="si">%d</span><span class="s1">&#39;</span>
                                  <span class="s1">&#39;  has too few non-missing observations to&#39;</span>
                                  <span class="s1">&#39; calculate test statistic.&#39;</span> <span class="o">%</span> <span class="n">i</span><span class="p">)</span>
                    <span class="n">numer_resid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="k">if</span> <span class="n">denom_dof</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Later subset of data for variable </span><span class="si">%d</span><span class="s1">&#39;</span>
                                  <span class="s1">&#39;  has too few non-missing observations to&#39;</span>
                                  <span class="s1">&#39; calculate test statistic.&#39;</span> <span class="o">%</span> <span class="n">i</span><span class="p">)</span>
                    <span class="n">denom_resid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

                <span class="n">test_statistic</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">numer_resid</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">denom_resid</span><span class="p">)</span>

                <span class="c1"># Setup functions to calculate the p-values</span>
                <span class="k">if</span> <span class="n">use_f</span><span class="p">:</span>
                    <span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="k">import</span> <span class="n">f</span>
                    <span class="n">pval_lower</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">test_statistics</span><span class="p">:</span> <span class="n">f</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span>
                        <span class="n">test_statistics</span><span class="p">,</span> <span class="n">numer_dof</span><span class="p">,</span> <span class="n">denom_dof</span><span class="p">)</span>
                    <span class="n">pval_upper</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">test_statistics</span><span class="p">:</span> <span class="n">f</span><span class="o">.</span><span class="n">sf</span><span class="p">(</span>
                        <span class="n">test_statistics</span><span class="p">,</span> <span class="n">numer_dof</span><span class="p">,</span> <span class="n">denom_dof</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="k">import</span> <span class="n">chi2</span>
                    <span class="n">pval_lower</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">test_statistics</span><span class="p">:</span> <span class="n">chi2</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span>
                        <span class="n">numer_dof</span> <span class="o">*</span> <span class="n">test_statistics</span><span class="p">,</span> <span class="n">denom_dof</span><span class="p">)</span>
                    <span class="n">pval_upper</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">test_statistics</span><span class="p">:</span> <span class="n">chi2</span><span class="o">.</span><span class="n">sf</span><span class="p">(</span>
                        <span class="n">numer_dof</span> <span class="o">*</span> <span class="n">test_statistics</span><span class="p">,</span> <span class="n">denom_dof</span><span class="p">)</span>

                <span class="c1"># Calculate the one- or two-sided p-values</span>
                <span class="n">alternative</span> <span class="o">=</span> <span class="n">alternative</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">alternative</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="s1">&#39;inc&#39;</span><span class="p">,</span> <span class="s1">&#39;increasing&#39;</span><span class="p">]:</span>
                    <span class="n">p_value</span> <span class="o">=</span> <span class="n">pval_upper</span><span class="p">(</span><span class="n">test_statistic</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">alternative</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;dec&#39;</span><span class="p">,</span> <span class="s1">&#39;decreasing&#39;</span><span class="p">]:</span>
                    <span class="n">test_statistic</span> <span class="o">=</span> <span class="mf">1.</span> <span class="o">/</span> <span class="n">test_statistic</span>
                    <span class="n">p_value</span> <span class="o">=</span> <span class="n">pval_upper</span><span class="p">(</span><span class="n">test_statistic</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">alternative</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;2&#39;</span><span class="p">,</span> <span class="s1">&#39;2-sided&#39;</span><span class="p">,</span> <span class="s1">&#39;two-sided&#39;</span><span class="p">]:</span>
                    <span class="n">p_value</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span>
                        <span class="n">pval_lower</span><span class="p">(</span><span class="n">test_statistic</span><span class="p">),</span>
                        <span class="n">pval_upper</span><span class="p">(</span><span class="n">test_statistic</span><span class="p">)</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid alternative.&#39;</span><span class="p">)</span>

                <span class="n">test_statistics</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">test_statistic</span><span class="p">)</span>
                <span class="n">p_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p_value</span><span class="p">)</span>

            <span class="n">output</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">test_statistics</span><span class="p">,</span> <span class="n">p_values</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Invalid heteroskedasticity test&#39;</span>
                                      <span class="s1">&#39; method.&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">output</span></div>

<div class="viewcode-block" id="MLEResults.test_serial_correlation"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEResults.test_serial_correlation.html#statsmodels.regression.recursive_ls.MLEResults.test_serial_correlation">[docs]</a>    <span class="k">def</span> <span class="nf">test_serial_correlation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">lags</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Ljung-box test for no serial correlation of standardized residuals</span>

<span class="sd">        Null hypothesis is no serial correlation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        method : string {&#39;ljungbox&#39;,&#39;boxpierece&#39;} or None</span>
<span class="sd">            The statistical test for serial correlation. If None, an attempt is</span>
<span class="sd">            made to select an appropriate test.</span>
<span class="sd">        lags : None, int or array_like</span>
<span class="sd">            If lags is an integer then this is taken to be the largest lag</span>
<span class="sd">            that is included, the test result is reported for all smaller lag</span>
<span class="sd">            length.</span>
<span class="sd">            If lags is a list or array, then all lags are included up to the</span>
<span class="sd">            largest lag in the list, however only the tests for the lags in the</span>
<span class="sd">            list are reported.</span>
<span class="sd">            If lags is None, then the default maxlag is 12*(nobs/100)^{1/4}</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        output : array</span>
<span class="sd">            An array with `(test_statistic, pvalue)` for each endogenous</span>
<span class="sd">            variable and each lag. The array is then sized</span>
<span class="sd">            `(k_endog, 2, lags)`. If the method is called as</span>
<span class="sd">            `ljungbox = res.test_serial_correlation()`, then `ljungbox[i]`</span>
<span class="sd">            holds the results of the Ljung-Box test (as would be returned by</span>
<span class="sd">            `statsmodels.stats.diagnostic.acorr_ljungbox`) for the `i` th</span>
<span class="sd">            endogenous variable.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        If the first `d` loglikelihood values were burned (i.e. in the</span>
<span class="sd">        specified model, `loglikelihood_burn=d`), then this test is calculated</span>
<span class="sd">        ignoring the first `d` residuals.</span>

<span class="sd">        Output is nan for any endogenous variable which has missing values.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        statsmodels.stats.diagnostic.acorr_ljungbox</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">method</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">method</span> <span class="o">=</span> <span class="s1">&#39;ljungbox&#39;</span>

        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;ljungbox&#39;</span> <span class="ow">or</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;boxpierce&#39;</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">statsmodels.stats.diagnostic</span> <span class="k">import</span> <span class="n">acorr_ljungbox</span>
            <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">loglikelihood_burn</span>
            <span class="n">output</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="c1"># Default lags for acorr_ljungbox is 40, but may not always have</span>
            <span class="c1"># that many observations</span>
            <span class="k">if</span> <span class="n">lags</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">lags</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="mi">40</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs_effective</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">k_endog</span><span class="p">):</span>
                <span class="n">results</span> <span class="o">=</span> <span class="n">acorr_ljungbox</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">filter_results</span><span class="o">.</span><span class="n">standardized_forecasts_error</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">d</span><span class="p">:],</span>
                    <span class="n">lags</span><span class="o">=</span><span class="n">lags</span><span class="p">,</span> <span class="n">boxpierce</span><span class="o">=</span><span class="p">(</span><span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;boxpierce&#39;</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;ljungbox&#39;</span><span class="p">:</span>
                    <span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="mi">2</span><span class="p">:])</span>

            <span class="n">output</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">output</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Invalid serial correlation test&#39;</span>
                                      <span class="s1">&#39; method.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">output</span></div>

<div class="viewcode-block" id="MLEResults.get_prediction"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEResults.get_prediction.html#statsmodels.regression.recursive_ls.MLEResults.get_prediction">[docs]</a>    <span class="k">def</span> <span class="nf">get_prediction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dynamic</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                       <span class="n">index</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        In-sample prediction and out-of-sample forecasting</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        start : int, str, or datetime, optional</span>
<span class="sd">            Zero-indexed observation number at which to start forecasting,</span>
<span class="sd">            i.e., the first forecast is start. Can also be a date string to</span>
<span class="sd">            parse or a datetime type. Default is the the zeroth observation.</span>
<span class="sd">        end : int, str, or datetime, optional</span>
<span class="sd">            Zero-indexed observation number at which to end forecasting, i.e.,</span>
<span class="sd">            the last forecast is end. Can also be a date string to</span>
<span class="sd">            parse or a datetime type. However, if the dates index does not</span>
<span class="sd">            have a fixed frequency, end must be an integer index if you</span>
<span class="sd">            want out of sample prediction. Default is the last observation in</span>
<span class="sd">            the sample.</span>
<span class="sd">        dynamic : boolean, int, str, or datetime, optional</span>
<span class="sd">            Integer offset relative to `start` at which to begin dynamic</span>
<span class="sd">            prediction. Can also be an absolute date string to parse or a</span>
<span class="sd">            datetime type (these are not interpreted as offsets).</span>
<span class="sd">            Prior to this observation, true endogenous values will be used for</span>
<span class="sd">            prediction; starting with this observation and continuing through</span>
<span class="sd">            the end of prediction, forecasted endogenous values will be used</span>
<span class="sd">            instead.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Additional arguments may required for forecasting beyond the end</span>
<span class="sd">            of the sample. See `FilterResults.predict` for more details.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        forecast : array</span>
<span class="sd">            Array of out of in-sample predictions and / or out-of-sample</span>
<span class="sd">            forecasts. An (npredict x k_endog) array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">_index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Handle start, end, dynamic</span>
        <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">out_of_sample</span><span class="p">,</span> <span class="n">prediction_index</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">_get_prediction_index</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">index</span><span class="p">))</span>

        <span class="c1"># Handle `dynamic`</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dynamic</span><span class="p">,</span> <span class="p">(</span><span class="nb">bytes</span><span class="p">,</span> <span class="n">unicode</span><span class="p">)):</span>
            <span class="n">dynamic</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">_get_index_loc</span><span class="p">(</span><span class="n">dynamic</span><span class="p">)</span>

        <span class="c1"># Perform the prediction</span>
        <span class="c1"># This is a (k_endog x npredictions) array; don&#39;t want to squeeze in</span>
        <span class="c1"># case of npredictions = 1</span>
        <span class="n">prediction_results</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_results</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span>
            <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">+</span> <span class="n">out_of_sample</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dynamic</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Return a new mlemodel.PredictionResults object</span>
        <span class="k">return</span> <span class="n">PredictionResultsWrapper</span><span class="p">(</span><span class="n">PredictionResults</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">prediction_results</span><span class="p">,</span> <span class="n">row_labels</span><span class="o">=</span><span class="n">prediction_index</span><span class="p">))</span></div>

<div class="viewcode-block" id="MLEResults.get_forecast"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEResults.get_forecast.html#statsmodels.regression.recursive_ls.MLEResults.get_forecast">[docs]</a>    <span class="k">def</span> <span class="nf">get_forecast</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">steps</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Out-of-sample forecasts</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        steps : int, str, or datetime, optional</span>
<span class="sd">            If an integer, the number of steps to forecast from the end of the</span>
<span class="sd">            sample. Can also be a date string to parse or a datetime type.</span>
<span class="sd">            However, if the dates index does not have a fixed frequency, steps</span>
<span class="sd">            must be an integer. Default</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Additional arguments may required for forecasting beyond the end</span>
<span class="sd">            of the sample. See `FilterResults.predict` for more details.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        forecast : array</span>
<span class="sd">            Array of out of sample forecasts. A (steps x k_endog) array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">steps</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">long</span><span class="p">)):</span>
            <span class="n">end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span> <span class="o">+</span> <span class="n">steps</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">end</span> <span class="o">=</span> <span class="n">steps</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_prediction</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="n">end</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="MLEResults.predict"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEResults.predict.html#statsmodels.regression.recursive_ls.MLEResults.predict">[docs]</a>    <span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dynamic</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        In-sample prediction and out-of-sample forecasting</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        start : int, str, or datetime, optional</span>
<span class="sd">            Zero-indexed observation number at which to start forecasting,</span>
<span class="sd">            i.e., the first forecast is start. Can also be a date string to</span>
<span class="sd">            parse or a datetime type. Default is the the zeroth observation.</span>
<span class="sd">        end : int, str, or datetime, optional</span>
<span class="sd">            Zero-indexed observation number at which to end forecasting, i.e.,</span>
<span class="sd">            the last forecast is end. Can also be a date string to</span>
<span class="sd">            parse or a datetime type. However, if the dates index does not</span>
<span class="sd">            have a fixed frequency, end must be an integer index if you</span>
<span class="sd">            want out of sample prediction. Default is the last observation in</span>
<span class="sd">            the sample.</span>
<span class="sd">        dynamic : boolean, int, str, or datetime, optional</span>
<span class="sd">            Integer offset relative to `start` at which to begin dynamic</span>
<span class="sd">            prediction. Can also be an absolute date string to parse or a</span>
<span class="sd">            datetime type (these are not interpreted as offsets).</span>
<span class="sd">            Prior to this observation, true endogenous values will be used for</span>
<span class="sd">            prediction; starting with this observation and continuing through</span>
<span class="sd">            the end of prediction, forecasted endogenous values will be used</span>
<span class="sd">            instead.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Additional arguments may required for forecasting beyond the end</span>
<span class="sd">            of the sample. See `FilterResults.predict` for more details.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        forecast : array</span>
<span class="sd">            Array of out of in-sample predictions and / or out-of-sample</span>
<span class="sd">            forecasts. An (npredict x k_endog) array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Perform the prediction</span>
        <span class="n">prediction_results</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_prediction</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">dynamic</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">prediction_results</span><span class="o">.</span><span class="n">predicted_mean</span></div>

<div class="viewcode-block" id="MLEResults.forecast"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEResults.forecast.html#statsmodels.regression.recursive_ls.MLEResults.forecast">[docs]</a>    <span class="k">def</span> <span class="nf">forecast</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">steps</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Out-of-sample forecasts</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        steps : int, str, or datetime, optional</span>
<span class="sd">            If an integer, the number of steps to forecast from the end of the</span>
<span class="sd">            sample. Can also be a date string to parse or a datetime type.</span>
<span class="sd">            However, if the dates index does not have a fixed frequency, steps</span>
<span class="sd">            must be an integer. Default</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Additional arguments may required for forecasting beyond the end</span>
<span class="sd">            of the sample. See `FilterResults.predict` for more details.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        forecast : array</span>
<span class="sd">            Array of out of sample forecasts. A (steps x k_endog) array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">steps</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">long</span><span class="p">)):</span>
            <span class="n">end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span> <span class="o">+</span> <span class="n">steps</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">end</span> <span class="o">=</span> <span class="n">steps</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="n">end</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="MLEResults.simulate"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEResults.simulate.html#statsmodels.regression.recursive_ls.MLEResults.simulate">[docs]</a>    <span class="k">def</span> <span class="nf">simulate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nsimulations</span><span class="p">,</span> <span class="n">measurement_shocks</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">state_shocks</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">initial_state</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Simulate a new time series following the state space model</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nsimulations : int</span>
<span class="sd">            The number of observations to simulate. If the model is</span>
<span class="sd">            time-invariant this can be any number. If the model is</span>
<span class="sd">            time-varying, then this number must be less than or equal to the</span>
<span class="sd">            number</span>
<span class="sd">        measurement_shocks : array_like, optional</span>
<span class="sd">            If specified, these are the shocks to the measurement equation,</span>
<span class="sd">            :math:`\varepsilon_t`. If unspecified, these are automatically</span>
<span class="sd">            generated using a pseudo-random number generator. If specified,</span>
<span class="sd">            must be shaped `nsimulations` x `k_endog`, where `k_endog` is the</span>
<span class="sd">            same as in the state space model.</span>
<span class="sd">        state_shocks : array_like, optional</span>
<span class="sd">            If specified, these are the shocks to the state equation,</span>
<span class="sd">            :math:`\eta_t`. If unspecified, these are automatically</span>
<span class="sd">            generated using a pseudo-random number generator. If specified,</span>
<span class="sd">            must be shaped `nsimulations` x `k_posdef` where `k_posdef` is the</span>
<span class="sd">            same as in the state space model.</span>
<span class="sd">        initial_state : array_like, optional</span>
<span class="sd">            If specified, this is the state vector at time zero, which should</span>
<span class="sd">            be shaped (`k_states` x 1), where `k_states` is the same as in the</span>
<span class="sd">            state space model. If unspecified, but the model has been</span>
<span class="sd">            initialized, then that initialization is used. If unspecified and</span>
<span class="sd">            the model has not been initialized, then a vector of zeros is used.</span>
<span class="sd">            Note that this is not included in the returned `simulated_states`</span>
<span class="sd">            array.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        simulated_obs : array</span>
<span class="sd">            An (nsimulations x k_endog) array of simulated observations.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">simulate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="n">nsimulations</span><span class="p">,</span>
                                   <span class="n">measurement_shocks</span><span class="p">,</span> <span class="n">state_shocks</span><span class="p">,</span>
                                   <span class="n">initial_state</span><span class="p">)</span></div>

<div class="viewcode-block" id="MLEResults.impulse_responses"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEResults.impulse_responses.html#statsmodels.regression.recursive_ls.MLEResults.impulse_responses">[docs]</a>    <span class="k">def</span> <span class="nf">impulse_responses</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">steps</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">impulse</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">orthogonalized</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                          <span class="n">cumulative</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Impulse response function</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        steps : int, optional</span>
<span class="sd">            The number of steps for which impulse responses are calculated.</span>
<span class="sd">            Default is 1. Note that the initial impulse is not counted as a</span>
<span class="sd">            step, so if `steps=1`, the output will have 2 entries.</span>
<span class="sd">        impulse : int or array_like</span>
<span class="sd">            If an integer, the state innovation to pulse; must be between 0</span>
<span class="sd">            and `k_posdef-1`. Alternatively, a custom impulse vector may be</span>
<span class="sd">            provided; must be shaped `k_posdef x 1`.</span>
<span class="sd">        orthogonalized : boolean, optional</span>
<span class="sd">            Whether or not to perform impulse using orthogonalized innovations.</span>
<span class="sd">            Note that this will also affect custum `impulse` vectors. Default</span>
<span class="sd">            is False.</span>
<span class="sd">        cumulative : boolean, optional</span>
<span class="sd">            Whether or not to return cumulative impulse responses. Default is</span>
<span class="sd">            False.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            If the model is time-varying and `steps` is greater than the number</span>
<span class="sd">            of observations, any of the state space representation matrices</span>
<span class="sd">            that are time-varying must have updated values provided for the</span>
<span class="sd">            out-of-sample steps.</span>
<span class="sd">            For example, if `design` is a time-varying component, `nobs` is 10,</span>
<span class="sd">            and `steps` is 15, a (`k_endog` x `k_states` x 5) matrix must be</span>
<span class="sd">            provided with the new design matrix values.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        impulse_responses : array</span>
<span class="sd">            Responses for each endogenous variable due to the impulse</span>
<span class="sd">            given by the `impulse` argument. A (steps + 1 x k_endog) array.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Intercepts in the measurement and state equation are ignored when</span>
<span class="sd">        calculating impulse responses.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">impulse_responses</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="n">steps</span><span class="p">,</span> <span class="n">impulse</span><span class="p">,</span>
                                            <span class="n">orthogonalized</span><span class="p">,</span> <span class="n">cumulative</span><span class="p">,</span>
                                            <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="MLEResults.plot_diagnostics"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEResults.plot_diagnostics.html#statsmodels.regression.recursive_ls.MLEResults.plot_diagnostics">[docs]</a>    <span class="k">def</span> <span class="nf">plot_diagnostics</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variable</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">lags</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">fig</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Diagnostic plots for standardized residuals of one endogenous variable</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        variable : integer, optional</span>
<span class="sd">            Index of the endogenous variable for which the diagnostic plots</span>
<span class="sd">            should be created. Default is 0.</span>
<span class="sd">        lags : integer, optional</span>
<span class="sd">            Number of lags to include in the correlogram. Default is 10.</span>
<span class="sd">        fig : Matplotlib Figure instance, optional</span>
<span class="sd">            If given, subplots are created in this figure instead of in a new</span>
<span class="sd">            figure. Note that the 2x2 grid will be created in the provided</span>
<span class="sd">            figure using `fig.add_subplot()`.</span>
<span class="sd">        figsize : tuple, optional</span>
<span class="sd">            If a figure is created, this argument allows specifying a size.</span>
<span class="sd">            The tuple is (width, height).</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Produces a 2x2 plot grid with the following plots (ordered clockwise</span>
<span class="sd">        from top left):</span>

<span class="sd">        1. Standardized residuals over time</span>
<span class="sd">        2. Histogram plus estimated density of standardized residulas, along</span>
<span class="sd">           with a Normal(0,1) density plotted for reference.</span>
<span class="sd">        3. Normal Q-Q plot, with Normal reference line.</span>
<span class="sd">        4. Correlogram</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        statsmodels.graphics.gofplots.qqplot</span>
<span class="sd">        statsmodels.graphics.tsaplots.plot_acf</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">statsmodels.graphics.utils</span> <span class="k">import</span> <span class="n">_import_mpl</span><span class="p">,</span> <span class="n">create_mpl_fig</span>
        <span class="n">_import_mpl</span><span class="p">()</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">create_mpl_fig</span><span class="p">(</span><span class="n">fig</span><span class="p">,</span> <span class="n">figsize</span><span class="p">)</span>
        <span class="c1"># Eliminate residuals associated with burned likelihoods</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">loglikelihood_burn</span>
        <span class="n">resid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_results</span><span class="o">.</span><span class="n">standardized_forecasts_error</span><span class="p">[</span><span class="n">variable</span><span class="p">,</span> <span class="n">d</span><span class="p">:]</span>

        <span class="c1"># Top-left: residuals vs time</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">221</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="s1">&#39;dates&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">dates</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">dates</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">loglikelihood_burn</span><span class="p">:]</span><span class="o">.</span><span class="n">_mpl_repr</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">resid</span><span class="p">))</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">resid</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">hlines</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Standardized residual&#39;</span><span class="p">)</span>

        <span class="c1"># Top-right: histogram, Gaussian kernel density, Normal density</span>
        <span class="c1"># Can only do histogram and Gaussian kernel density on the non-null</span>
        <span class="c1"># elements</span>
        <span class="n">resid_nonmissing</span> <span class="o">=</span> <span class="n">resid</span><span class="p">[</span><span class="o">~</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">resid</span><span class="p">))]</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">222</span><span class="p">)</span>
        <span class="c1"># temporarily disable Deprecation warning, normed -&gt; density</span>
        <span class="c1"># hist needs to use `density` in future when minimum matplotlib has it</span>
        <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">(</span><span class="n">record</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">as</span> <span class="n">w</span><span class="p">:</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">resid_nonmissing</span><span class="p">,</span> <span class="n">normed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Hist&#39;</span><span class="p">)</span>
        <span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="k">import</span> <span class="n">gaussian_kde</span><span class="p">,</span> <span class="n">norm</span>
        <span class="n">kde</span> <span class="o">=</span> <span class="n">gaussian_kde</span><span class="p">(</span><span class="n">resid_nonmissing</span><span class="p">)</span>
        <span class="n">xlim</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mf">1.96</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="mf">1.96</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">xlim</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">xlim</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">kde</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;KDE&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">norm</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;N(0,1)&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="n">xlim</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Histogram plus estimated density&#39;</span><span class="p">)</span>

        <span class="c1"># Bottom-left: QQ plot</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">223</span><span class="p">)</span>
        <span class="kn">from</span> <span class="nn">statsmodels.graphics.gofplots</span> <span class="k">import</span> <span class="n">qqplot</span>
        <span class="n">qqplot</span><span class="p">(</span><span class="n">resid_nonmissing</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="s1">&#39;s&#39;</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Normal Q-Q&#39;</span><span class="p">)</span>

        <span class="c1"># Bottom-right: Correlogram</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">224</span><span class="p">)</span>
        <span class="kn">from</span> <span class="nn">statsmodels.graphics.tsaplots</span> <span class="k">import</span> <span class="n">plot_acf</span>
        <span class="n">plot_acf</span><span class="p">(</span><span class="n">resid</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">lags</span><span class="o">=</span><span class="n">lags</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Correlogram&#39;</span><span class="p">)</span>

        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">fig</span></div>

<div class="viewcode-block" id="MLEResults.summary"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEResults.summary.html#statsmodels.regression.recursive_ls.MLEResults.summary">[docs]</a>    <span class="k">def</span> <span class="nf">summary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=.</span><span class="mi">05</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">model_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">display_params</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Summarize the Model</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        alpha : float, optional</span>
<span class="sd">            Significance level for the confidence intervals. Default is 0.05.</span>
<span class="sd">        start : int, optional</span>
<span class="sd">            Integer of the start observation. Default is 0.</span>
<span class="sd">        model_name : string</span>
<span class="sd">            The name of the model used. Default is to use model class name.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        summary : Summary instance</span>
<span class="sd">            This holds the summary table and text, which can be printed or</span>
<span class="sd">            converted to various output formats.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        statsmodels.iolib.summary.Summary</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">statsmodels.iolib.summary</span> <span class="k">import</span> <span class="n">Summary</span>

        <span class="c1"># Model specification results</span>
        <span class="n">model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span>
        <span class="k">if</span> <span class="n">title</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">title</span> <span class="o">=</span> <span class="s1">&#39;Statespace Model Results&#39;</span>

        <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">_index_dates</span><span class="p">:</span>
            <span class="n">ix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">_index</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">ix</span><span class="p">[</span><span class="n">start</span><span class="p">]</span>
            <span class="n">sample</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;</span><span class="si">%02d</span><span class="s1">-</span><span class="si">%02d</span><span class="s1">-</span><span class="si">%02d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">month</span><span class="p">,</span> <span class="n">d</span><span class="o">.</span><span class="n">day</span><span class="p">,</span> <span class="n">d</span><span class="o">.</span><span class="n">year</span><span class="p">)]</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">ix</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">sample</span> <span class="o">+=</span> <span class="p">[</span><span class="s1">&#39;- &#39;</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="si">%02d</span><span class="s1">-</span><span class="si">%02d</span><span class="s1">-</span><span class="si">%02d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">month</span><span class="p">,</span> <span class="n">d</span><span class="o">.</span><span class="n">day</span><span class="p">,</span> <span class="n">d</span><span class="o">.</span><span class="n">year</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sample</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">start</span><span class="p">),</span> <span class="s1">&#39; - &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="p">)]</span>

        <span class="c1"># Standardize the model name as a list of str</span>
        <span class="k">if</span> <span class="n">model_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">model_name</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>

        <span class="c1"># Diagnostic tests results</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">het</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">test_heteroskedasticity</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="s1">&#39;breakvar&#39;</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">het</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">]</span><span class="o">*</span><span class="mi">2</span><span class="p">])</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">lb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">test_serial_correlation</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="s1">&#39;ljungbox&#39;</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">lb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">]</span><span class="o">*</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">jb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">test_normality</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="s1">&#39;jarquebera&#39;</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">jb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">]</span><span class="o">*</span><span class="mi">4</span><span class="p">])</span>

        <span class="c1"># Create the tables</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">model_name</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">model_name</span> <span class="o">=</span> <span class="p">[</span><span class="n">model_name</span><span class="p">]</span>

        <span class="n">top_left</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;Dep. Variable:&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)]</span>
        <span class="n">top_left</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s1">&#39;Model:&#39;</span><span class="p">,</span> <span class="p">[</span><span class="n">model_name</span><span class="p">[</span><span class="mi">0</span><span class="p">]]))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">model_name</span><span class="p">)):</span>
            <span class="n">top_left</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;+ &#39;</span> <span class="o">+</span> <span class="n">model_name</span><span class="p">[</span><span class="n">i</span><span class="p">]]))</span>
        <span class="n">top_left</span> <span class="o">+=</span> <span class="p">[</span>
            <span class="p">(</span><span class="s1">&#39;Date:&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
            <span class="p">(</span><span class="s1">&#39;Time:&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
            <span class="p">(</span><span class="s1">&#39;Sample:&#39;</span><span class="p">,</span> <span class="p">[</span><span class="n">sample</span><span class="p">[</span><span class="mi">0</span><span class="p">]]),</span>
            <span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="p">[</span><span class="n">sample</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
        <span class="p">]</span>

        <span class="n">top_right</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="s1">&#39;No. Observations:&#39;</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="p">]),</span>
            <span class="p">(</span><span class="s1">&#39;Log Likelihood&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;</span><span class="si">%#5.3f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">llf</span><span class="p">]),</span>
            <span class="p">(</span><span class="s1">&#39;AIC&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;</span><span class="si">%#5.3f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">aic</span><span class="p">]),</span>
            <span class="p">(</span><span class="s1">&#39;BIC&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;</span><span class="si">%#5.3f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">bic</span><span class="p">]),</span>
            <span class="p">(</span><span class="s1">&#39;HQIC&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;</span><span class="si">%#5.3f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">hqic</span><span class="p">])</span>
        <span class="p">]</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;cov_type&#39;</span><span class="p">):</span>
            <span class="n">top_left</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s1">&#39;Covariance Type:&#39;</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">cov_type</span><span class="p">]))</span>

        <span class="n">format_str</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">array</span><span class="p">:</span> <span class="p">[</span>
            <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s1">&#39;</span><span class="si">{0:.2f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">array</span><span class="p">])</span>
        <span class="p">]</span>
        <span class="n">diagn_left</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;Ljung-Box (Q):&#39;</span><span class="p">,</span> <span class="n">format_str</span><span class="p">(</span><span class="n">lb</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])),</span>
                      <span class="p">(</span><span class="s1">&#39;Prob(Q):&#39;</span><span class="p">,</span> <span class="n">format_str</span><span class="p">(</span><span class="n">lb</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])),</span>
                      <span class="p">(</span><span class="s1">&#39;Heteroskedasticity (H):&#39;</span><span class="p">,</span> <span class="n">format_str</span><span class="p">(</span><span class="n">het</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])),</span>
                      <span class="p">(</span><span class="s1">&#39;Prob(H) (two-sided):&#39;</span><span class="p">,</span> <span class="n">format_str</span><span class="p">(</span><span class="n">het</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]))</span>
                      <span class="p">]</span>

        <span class="n">diagn_right</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;Jarque-Bera (JB):&#39;</span><span class="p">,</span> <span class="n">format_str</span><span class="p">(</span><span class="n">jb</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])),</span>
                       <span class="p">(</span><span class="s1">&#39;Prob(JB):&#39;</span><span class="p">,</span> <span class="n">format_str</span><span class="p">(</span><span class="n">jb</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])),</span>
                       <span class="p">(</span><span class="s1">&#39;Skew:&#39;</span><span class="p">,</span> <span class="n">format_str</span><span class="p">(</span><span class="n">jb</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">])),</span>
                       <span class="p">(</span><span class="s1">&#39;Kurtosis:&#39;</span><span class="p">,</span> <span class="n">format_str</span><span class="p">(</span><span class="n">jb</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">]))</span>
                       <span class="p">]</span>

        <span class="n">summary</span> <span class="o">=</span> <span class="n">Summary</span><span class="p">()</span>
        <span class="n">summary</span><span class="o">.</span><span class="n">add_table_2cols</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gleft</span><span class="o">=</span><span class="n">top_left</span><span class="p">,</span> <span class="n">gright</span><span class="o">=</span><span class="n">top_right</span><span class="p">,</span>
                                <span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">display_params</span><span class="p">:</span>
            <span class="n">summary</span><span class="o">.</span><span class="n">add_table_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span>
                                     <span class="n">xname</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">param_names</span><span class="p">,</span> <span class="n">use_t</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">summary</span><span class="o">.</span><span class="n">add_table_2cols</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gleft</span><span class="o">=</span><span class="n">diagn_left</span><span class="p">,</span> <span class="n">gright</span><span class="o">=</span><span class="n">diagn_right</span><span class="p">,</span>
                                <span class="n">title</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span>

        <span class="c1"># Add warnings/notes, added to text format only</span>
        <span class="n">etext</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;cov_type&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="s1">&#39;description&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cov_kwds</span><span class="p">:</span>
            <span class="n">etext</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cov_kwds</span><span class="p">[</span><span class="s1">&#39;description&#39;</span><span class="p">])</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rank</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">):</span>
            <span class="n">etext</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;Covariance matrix is singular or near-singular,&quot;</span>
                         <span class="s2">&quot; with condition number </span><span class="si">%6.3g</span><span class="s2">. Standard errors may be&quot;</span>
                         <span class="s2">&quot; unstable.&quot;</span> <span class="o">%</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">cond</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cov_params</span><span class="p">()))</span>

        <span class="k">if</span> <span class="n">etext</span><span class="p">:</span>
            <span class="n">etext</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;[</span><span class="si">{0}</span><span class="s2">] </span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>
                     <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">text</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">etext</span><span class="p">)]</span>
            <span class="n">etext</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;Warnings:&quot;</span><span class="p">)</span>
            <span class="n">summary</span><span class="o">.</span><span class="n">add_extra_txt</span><span class="p">(</span><span class="n">etext</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">summary</span></div></div>


<span class="k">class</span> <span class="nc">MLEResultsWrapper</span><span class="p">(</span><span class="n">wrap</span><span class="o">.</span><span class="n">ResultsWrapper</span><span class="p">):</span>
    <span class="n">_attrs</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;zvalues&#39;</span><span class="p">:</span> <span class="s1">&#39;columns&#39;</span><span class="p">,</span>
        <span class="s1">&#39;cov_params_approx&#39;</span><span class="p">:</span> <span class="s1">&#39;cov&#39;</span><span class="p">,</span>
        <span class="s1">&#39;cov_params_default&#39;</span><span class="p">:</span> <span class="s1">&#39;cov&#39;</span><span class="p">,</span>
        <span class="s1">&#39;cov_params_oim&#39;</span><span class="p">:</span> <span class="s1">&#39;cov&#39;</span><span class="p">,</span>
        <span class="s1">&#39;cov_params_opg&#39;</span><span class="p">:</span> <span class="s1">&#39;cov&#39;</span><span class="p">,</span>
        <span class="s1">&#39;cov_params_robust&#39;</span><span class="p">:</span> <span class="s1">&#39;cov&#39;</span><span class="p">,</span>
        <span class="s1">&#39;cov_params_robust_approx&#39;</span><span class="p">:</span> <span class="s1">&#39;cov&#39;</span><span class="p">,</span>
        <span class="s1">&#39;cov_params_robust_oim&#39;</span><span class="p">:</span> <span class="s1">&#39;cov&#39;</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="n">_wrap_attrs</span> <span class="o">=</span> <span class="n">wrap</span><span class="o">.</span><span class="n">union_dicts</span><span class="p">(</span><span class="n">tsbase</span><span class="o">.</span><span class="n">TimeSeriesResultsWrapper</span><span class="o">.</span><span class="n">_wrap_attrs</span><span class="p">,</span>
                                   <span class="n">_attrs</span><span class="p">)</span>
    <span class="n">_methods</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;forecast&#39;</span><span class="p">:</span> <span class="s1">&#39;dates&#39;</span><span class="p">,</span>
        <span class="s1">&#39;simulate&#39;</span><span class="p">:</span> <span class="s1">&#39;ynames&#39;</span><span class="p">,</span>
        <span class="s1">&#39;impulse_responses&#39;</span><span class="p">:</span> <span class="s1">&#39;ynames&#39;</span>
    <span class="p">}</span>
    <span class="n">_wrap_methods</span> <span class="o">=</span> <span class="n">wrap</span><span class="o">.</span><span class="n">union_dicts</span><span class="p">(</span>
        <span class="n">tsbase</span><span class="o">.</span><span class="n">TimeSeriesResultsWrapper</span><span class="o">.</span><span class="n">_wrap_methods</span><span class="p">,</span> <span class="n">_methods</span><span class="p">)</span>
<span class="n">wrap</span><span class="o">.</span><span class="n">populate_wrapper</span><span class="p">(</span><span class="n">MLEResultsWrapper</span><span class="p">,</span> <span class="n">MLEResults</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">PredictionResults</span><span class="p">(</span><span class="n">pred</span><span class="o">.</span><span class="n">PredictionResults</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    prediction_results : kalman_filter.PredictionResults instance</span>
<span class="sd">        Results object from prediction after fitting or filtering a state space</span>
<span class="sd">        model.</span>
<span class="sd">    row_labels : iterable</span>
<span class="sd">        Row labels for the predicted data.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">prediction_results</span><span class="p">,</span> <span class="n">row_labels</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">model</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">k_endog</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">endog</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">prediction_results</span><span class="o">.</span><span class="n">endog</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span>
                              <span class="n">name</span><span class="o">=</span><span class="n">model</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">endog_names</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">endog</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">prediction_results</span><span class="o">.</span><span class="n">endog</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
                                 <span class="n">columns</span><span class="o">=</span><span class="n">model</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">endog_names</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">Bunch</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">model</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span>
            <span class="n">endog</span><span class="o">=</span><span class="n">endog</span><span class="p">,</span> <span class="n">predict_dates</span><span class="o">=</span><span class="n">row_labels</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prediction_results</span> <span class="o">=</span> <span class="n">prediction_results</span>

        <span class="c1"># Get required values</span>
        <span class="n">predicted_mean</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prediction_results</span><span class="o">.</span><span class="n">forecasts</span>
        <span class="k">if</span> <span class="n">predicted_mean</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">predicted_mean</span> <span class="o">=</span> <span class="n">predicted_mean</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">predicted_mean</span> <span class="o">=</span> <span class="n">predicted_mean</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>

        <span class="n">var_pred_mean</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prediction_results</span><span class="o">.</span><span class="n">forecasts_error_cov</span>
        <span class="k">if</span> <span class="n">var_pred_mean</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">var_pred_mean</span> <span class="o">=</span> <span class="n">var_pred_mean</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">var_pred_mean</span> <span class="o">=</span> <span class="n">var_pred_mean</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>

        <span class="c1"># Initialize</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">PredictionResults</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">predicted_mean</span><span class="p">,</span> <span class="n">var_pred_mean</span><span class="p">,</span>
                                                <span class="n">dist</span><span class="o">=</span><span class="s1">&#39;norm&#39;</span><span class="p">,</span>
                                                <span class="n">row_labels</span><span class="o">=</span><span class="n">row_labels</span><span class="p">,</span>
                                                <span class="n">link</span><span class="o">=</span><span class="n">identity</span><span class="p">())</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">se_mean</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">var_pred_mean</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">se_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">var_pred_mean</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">se_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">var_pred_mean</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">diagonal</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">se_mean</span>

    <span class="k">def</span> <span class="nf">conf_int</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;endpoint&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="c1"># TODO: this performs metadata wrapping, and that should be handled</span>
        <span class="c1">#       by attach_* methods. However, they don&#39;t currently support</span>
        <span class="c1">#       this use case.</span>
        <span class="n">conf_int</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">PredictionResults</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">conf_int</span><span class="p">(</span>
            <span class="n">method</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>

        <span class="c1"># Create a dataframe</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">row_labels</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">conf_int</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">conf_int</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">row_labels</span><span class="p">)</span>

            <span class="c1"># Attach the endog names</span>
            <span class="n">ynames</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">ynames</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">type</span><span class="p">(</span><span class="n">ynames</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span><span class="p">:</span>
                <span class="n">ynames</span> <span class="o">=</span> <span class="p">[</span><span class="n">ynames</span><span class="p">]</span>
            <span class="n">names</span> <span class="o">=</span> <span class="p">([</span><span class="s1">&#39;lower </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">name</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">ynames</span><span class="p">]</span> <span class="o">+</span>
                     <span class="p">[</span><span class="s1">&#39;upper </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">name</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">ynames</span><span class="p">])</span>
            <span class="n">conf_int</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="n">names</span>

        <span class="k">return</span> <span class="n">conf_int</span>

    <span class="k">def</span> <span class="nf">summary_frame</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">endog</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">what</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.05</span><span class="p">):</span>
        <span class="c1"># TODO: finish and cleanup</span>
        <span class="c1"># import pandas as pd</span>
        <span class="kn">from</span> <span class="nn">statsmodels.compat.collections</span> <span class="k">import</span> <span class="n">OrderedDict</span>
        <span class="c1"># ci_obs = self.conf_int(alpha=alpha, obs=True) # need to split</span>
        <span class="n">ci_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">conf_int</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">))</span>
        <span class="n">to_include</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">predicted_mean</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">yname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">ynames</span>
            <span class="n">to_include</span><span class="p">[</span><span class="s1">&#39;mean&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predicted_mean</span>
            <span class="n">to_include</span><span class="p">[</span><span class="s1">&#39;mean_se&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">se_mean</span>
            <span class="n">k_endog</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">yname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">ynames</span><span class="p">[</span><span class="n">endog</span><span class="p">]</span>
            <span class="n">to_include</span><span class="p">[</span><span class="s1">&#39;mean&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predicted_mean</span><span class="p">[:,</span> <span class="n">endog</span><span class="p">]</span>
            <span class="n">to_include</span><span class="p">[</span><span class="s1">&#39;mean_se&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">se_mean</span><span class="p">[:,</span> <span class="n">endog</span><span class="p">]</span>
            <span class="n">k_endog</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predicted_mean</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">to_include</span><span class="p">[</span><span class="s1">&#39;mean_ci_lower&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ci_mean</span><span class="p">[:,</span> <span class="n">endog</span><span class="p">]</span>
        <span class="n">to_include</span><span class="p">[</span><span class="s1">&#39;mean_ci_upper&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ci_mean</span><span class="p">[:,</span> <span class="n">k_endog</span> <span class="o">+</span> <span class="n">endog</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">table</span> <span class="o">=</span> <span class="n">to_include</span>
        <span class="c1"># OrderedDict doesn&#39;t work to preserve sequence</span>
        <span class="c1"># pandas dict doesn&#39;t handle 2d_array</span>
        <span class="c1"># data = np.column_stack(list(to_include.values()))</span>
        <span class="c1"># names = ....</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">to_include</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">row_labels</span><span class="p">,</span>
                           <span class="n">columns</span><span class="o">=</span><span class="n">to_include</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">res</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">yname</span>
        <span class="k">return</span> <span class="n">res</span>


<span class="k">class</span> <span class="nc">PredictionResultsWrapper</span><span class="p">(</span><span class="n">wrap</span><span class="o">.</span><span class="n">ResultsWrapper</span><span class="p">):</span>
    <span class="n">_attrs</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;predicted_mean&#39;</span><span class="p">:</span> <span class="s1">&#39;dates&#39;</span><span class="p">,</span>
        <span class="s1">&#39;se_mean&#39;</span><span class="p">:</span> <span class="s1">&#39;dates&#39;</span><span class="p">,</span>
        <span class="s1">&#39;t_values&#39;</span><span class="p">:</span> <span class="s1">&#39;dates&#39;</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="n">_wrap_attrs</span> <span class="o">=</span> <span class="n">wrap</span><span class="o">.</span><span class="n">union_dicts</span><span class="p">(</span><span class="n">_attrs</span><span class="p">)</span>

    <span class="n">_methods</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">_wrap_methods</span> <span class="o">=</span> <span class="n">wrap</span><span class="o">.</span><span class="n">union_dicts</span><span class="p">(</span><span class="n">_methods</span><span class="p">)</span>
<span class="n">wrap</span><span class="o">.</span><span class="n">populate_wrapper</span><span class="p">(</span><span class="n">PredictionResultsWrapper</span><span class="p">,</span> <span class="n">PredictionResults</span><span class="p">)</span>
</pre></div>




          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2009-2017, Josef Perktold, Skipper Seabold, Jonathan Taylor, statsmodels-developers.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.7.4.
    </div>
  </body>
</html>