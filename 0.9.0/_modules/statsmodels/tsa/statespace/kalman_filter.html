

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>statsmodels.tsa.statespace.kalman_filter &#8212; statsmodels 0.9.0 documentation</title>
    <link rel="stylesheet" href="../../../../_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
    <script type="text/javascript" src="../../../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="shortcut icon" href="../../../../_static/statsmodels_hybi_favico.ico"/>
    <link rel="author" title="About these documents" href="../../../../about.html" />
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
<link rel="stylesheet" href="../../../../_static/examples.css" type="text/css" />
<link rel="stylesheet" href="../../../../_static/facebox.css" type="text/css" />
<script type="text/javascript" src="../../../../_static/scripts.js">
</script>
<script type="text/javascript" src="../../../../_static/facebox.js">
</script>
<script type="text/javascript">
$.facebox.settings.closeImage = "../../../../_static/closelabel.png"
$.facebox.settings.loadingImage = "../../../../_static/loading.gif"
</script>

  </head><body>
<div class="headerwrap">
    <div class = "header">
        
        <a href = "../../../../index.html">
<img src="../../../../_static/statsmodels_hybi_banner.png" alt="Logo"
    style="padding-left: 15px"/></a>
        
    </div>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
<li><a href ="../../../../install.html">Install</a></li> &nbsp;|&nbsp;
<li><a href="https://groups.google.com/forum/?hl=en#!forum/pystatsmodels">Support</a></li> &nbsp;|&nbsp;
<li><a href="https://github.com/statsmodels/statsmodels/issues">Bugs</a></li> &nbsp;|&nbsp;
<li><a href="../../../../dev/index.html">Develop</a></li> &nbsp;|&nbsp;
<li><a href="../../../../examples/index.html">Examples</a></li> &nbsp;|&nbsp;
<li><a href="../../../../faq.html">FAQ</a></li> &nbsp;|&nbsp;

          <li class="nav-item nav-item-1"><a href="../../../index.html" accesskey="U">Module code</a> |</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            




  <h1>Source code for statsmodels.tsa.statespace.kalman_filter</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">State Space Representation and Kalman Filter</span>

<span class="sd">Author: Chad Fulton</span>
<span class="sd">License: Simplified-BSD</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">division</span><span class="p">,</span> <span class="n">absolute_import</span><span class="p">,</span> <span class="n">print_function</span>

<span class="kn">from</span> <span class="nn">warnings</span> <span class="k">import</span> <span class="n">warn</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">.representation</span> <span class="k">import</span> <span class="n">OptionWrapper</span><span class="p">,</span> <span class="n">Representation</span><span class="p">,</span> <span class="n">FrozenRepresentation</span>
<span class="kn">from</span> <span class="nn">.tools</span> <span class="k">import</span> <span class="p">(</span><span class="n">validate_vector_shape</span><span class="p">,</span> <span class="n">validate_matrix_shape</span><span class="p">,</span>
                    <span class="n">reorder_missing_matrix</span><span class="p">,</span> <span class="n">reorder_missing_vector</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">tools</span>
<span class="kn">from</span> <span class="nn">statsmodels.tools.sm_exceptions</span> <span class="k">import</span> <span class="n">ValueWarning</span>

<span class="c1"># Define constants</span>
<span class="n">FILTER_CONVENTIONAL</span> <span class="o">=</span> <span class="mh">0x01</span>     <span class="c1"># Durbin and Koopman (2012), Chapter 4</span>
<span class="n">FILTER_EXACT_INITIAL</span> <span class="o">=</span> <span class="mh">0x02</span>    <span class="c1"># ibid., Chapter 5.6</span>
<span class="n">FILTER_AUGMENTED</span> <span class="o">=</span> <span class="mh">0x04</span>        <span class="c1"># ibid., Chapter 5.7</span>
<span class="n">FILTER_SQUARE_ROOT</span> <span class="o">=</span> <span class="mh">0x08</span>      <span class="c1"># ibid., Chapter 6.3</span>
<span class="n">FILTER_UNIVARIATE</span> <span class="o">=</span> <span class="mh">0x10</span>       <span class="c1"># ibid., Chapter 6.4</span>
<span class="n">FILTER_COLLAPSED</span> <span class="o">=</span> <span class="mh">0x20</span>        <span class="c1"># ibid., Chapter 6.5</span>
<span class="n">FILTER_EXTENDED</span> <span class="o">=</span> <span class="mh">0x40</span>         <span class="c1"># ibid., Chapter 10.2</span>
<span class="n">FILTER_UNSCENTED</span> <span class="o">=</span> <span class="mh">0x80</span>        <span class="c1"># ibid., Chapter 10.3</span>

<span class="n">INVERT_UNIVARIATE</span> <span class="o">=</span> <span class="mh">0x01</span>
<span class="n">SOLVE_LU</span> <span class="o">=</span> <span class="mh">0x02</span>
<span class="n">INVERT_LU</span> <span class="o">=</span> <span class="mh">0x04</span>
<span class="n">SOLVE_CHOLESKY</span> <span class="o">=</span> <span class="mh">0x08</span>
<span class="n">INVERT_CHOLESKY</span> <span class="o">=</span> <span class="mh">0x10</span>

<span class="n">STABILITY_FORCE_SYMMETRY</span> <span class="o">=</span> <span class="mh">0x01</span>

<span class="n">MEMORY_STORE_ALL</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">MEMORY_NO_FORECAST</span> <span class="o">=</span> <span class="mh">0x01</span>
<span class="n">MEMORY_NO_PREDICTED</span> <span class="o">=</span> <span class="mh">0x02</span>
<span class="n">MEMORY_NO_FILTERED</span> <span class="o">=</span> <span class="mh">0x04</span>
<span class="n">MEMORY_NO_LIKELIHOOD</span> <span class="o">=</span> <span class="mh">0x08</span>
<span class="n">MEMORY_NO_GAIN</span> <span class="o">=</span> <span class="mh">0x10</span>
<span class="n">MEMORY_NO_SMOOTHING</span> <span class="o">=</span> <span class="mh">0x20</span>
<span class="n">MEMORY_NO_STD_FORECAST</span> <span class="o">=</span> <span class="mh">0x40</span>
<span class="n">MEMORY_CONSERVE</span> <span class="o">=</span> <span class="p">(</span>
    <span class="n">MEMORY_NO_FORECAST</span> <span class="o">|</span> <span class="n">MEMORY_NO_PREDICTED</span> <span class="o">|</span> <span class="n">MEMORY_NO_FILTERED</span> <span class="o">|</span>
    <span class="n">MEMORY_NO_LIKELIHOOD</span> <span class="o">|</span> <span class="n">MEMORY_NO_GAIN</span> <span class="o">|</span> <span class="n">MEMORY_NO_SMOOTHING</span> <span class="o">|</span>
    <span class="n">MEMORY_NO_STD_FORECAST</span>
<span class="p">)</span>

<span class="n">TIMING_INIT_PREDICTED</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">TIMING_INIT_FILTERED</span> <span class="o">=</span> <span class="mi">1</span>


<div class="viewcode-block" id="KalmanFilter"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.kalman_filter.KalmanFilter.html#statsmodels.tsa.statespace.kalman_filter.KalmanFilter">[docs]</a><span class="k">class</span> <span class="nc">KalmanFilter</span><span class="p">(</span><span class="n">Representation</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    State space representation of a time series process, with Kalman filter</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    k_endog : array_like or integer</span>
<span class="sd">        The observed time-series process :math:`y` if array like or the</span>
<span class="sd">        number of variables in the process if an integer.</span>
<span class="sd">    k_states : int</span>
<span class="sd">        The dimension of the unobserved state process.</span>
<span class="sd">    k_posdef : int, optional</span>
<span class="sd">        The dimension of a guaranteed positive definite covariance matrix</span>
<span class="sd">        describing the shocks in the measurement equation. Must be less than</span>
<span class="sd">        or equal to `k_states`. Default is `k_states`.</span>
<span class="sd">    loglikelihood_burn : int, optional</span>
<span class="sd">        The number of initial periods during which the loglikelihood is not</span>
<span class="sd">        recorded. Default is 0.</span>
<span class="sd">    tolerance : float, optional</span>
<span class="sd">        The tolerance at which the Kalman filter determines convergence to</span>
<span class="sd">        steady-state. Default is 1e-19.</span>
<span class="sd">    results_class : class, optional</span>
<span class="sd">        Default results class to use to save filtering output. Default is</span>
<span class="sd">        `FilterResults`. If specified, class must extend from `FilterResults`.</span>
<span class="sd">    **kwargs</span>
<span class="sd">        Keyword arguments may be used to provide values for the filter,</span>
<span class="sd">        inversion, and stability methods. See `set_filter_method`,</span>
<span class="sd">        `set_inversion_method`, and `set_stability_method`.</span>
<span class="sd">        Keyword arguments may be used to provide default values for state space</span>
<span class="sd">        matrices. See `Representation` for more details.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    There are several types of options available for controlling the Kalman</span>
<span class="sd">    filter operation. All options are internally held as bitmasks, but can be</span>
<span class="sd">    manipulated by setting class attributes, which act like boolean flags. For</span>
<span class="sd">    more information, see the `set_*` class method documentation. The options</span>
<span class="sd">    are:</span>

<span class="sd">    filter_method</span>
<span class="sd">        The filtering method controls aspects of which</span>
<span class="sd">        Kalman filtering approach will be used.</span>
<span class="sd">    inversion_method</span>
<span class="sd">        The Kalman filter may contain one matrix inversion: that of the</span>
<span class="sd">        forecast error covariance matrix. The inversion method controls how and</span>
<span class="sd">        if that inverse is performed.</span>
<span class="sd">    stability_method</span>
<span class="sd">        The Kalman filter is a recursive algorithm that may in some cases</span>
<span class="sd">        suffer issues with numerical stability. The stability method controls</span>
<span class="sd">        what, if any, measures are taken to promote stability.</span>
<span class="sd">    conserve_memory</span>
<span class="sd">        By default, the Kalman filter computes a number of intermediate</span>
<span class="sd">        matrices at each iteration. The memory conservation options control</span>
<span class="sd">        which of those matrices are stored.</span>
<span class="sd">    filter_timing</span>
<span class="sd">        By default, the Kalman filter follows Durbin and Koopman, 2012, in</span>
<span class="sd">        initializing the filter with predicted values. Kim and Nelson, 1999,</span>
<span class="sd">        instead initialize the filter with filtered values, which is</span>
<span class="sd">        essentially just a different timing convention.</span>

<span class="sd">    The `filter_method` and `inversion_method` options intentionally allow</span>
<span class="sd">    the possibility that multiple methods will be indicated. In the case that</span>
<span class="sd">    multiple methods are selected, the underlying Kalman filter will attempt to</span>
<span class="sd">    select the optional method given the input data.</span>

<span class="sd">    For example, it may be that INVERT_UNIVARIATE and SOLVE_CHOLESKY are</span>
<span class="sd">    indicated (this is in fact the default case). In this case, if the</span>
<span class="sd">    endogenous vector is 1-dimensional (`k_endog` = 1), then INVERT_UNIVARIATE</span>
<span class="sd">    is used and inversion reduces to simple division, and if it has a larger</span>
<span class="sd">    dimension, the Cholesky decomposition along with linear solving (rather</span>
<span class="sd">    than explicit matrix inversion) is used. If only SOLVE_CHOLESKY had been</span>
<span class="sd">    set, then the Cholesky decomposition method would *always* be used, even in</span>
<span class="sd">    the case of 1-dimensional data.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    FilterResults</span>
<span class="sd">    statsmodels.tsa.statespace.representation.Representation</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">filter_methods</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s1">&#39;filter_conventional&#39;</span><span class="p">,</span> <span class="s1">&#39;filter_exact_initial&#39;</span><span class="p">,</span> <span class="s1">&#39;filter_augmented&#39;</span><span class="p">,</span>
        <span class="s1">&#39;filter_square_root&#39;</span><span class="p">,</span> <span class="s1">&#39;filter_univariate&#39;</span><span class="p">,</span> <span class="s1">&#39;filter_collapsed&#39;</span><span class="p">,</span>
        <span class="s1">&#39;filter_extended&#39;</span><span class="p">,</span> <span class="s1">&#39;filter_unscented&#39;</span>
    <span class="p">]</span>

    <span class="n">filter_conventional</span> <span class="o">=</span> <span class="n">OptionWrapper</span><span class="p">(</span><span class="s1">&#39;filter_method&#39;</span><span class="p">,</span> <span class="n">FILTER_CONVENTIONAL</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    (bool) Flag for conventional Kalman filtering.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">filter_exact_initial</span> <span class="o">=</span> <span class="n">OptionWrapper</span><span class="p">(</span><span class="s1">&#39;filter_method&#39;</span><span class="p">,</span> <span class="n">FILTER_EXACT_INITIAL</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    (bool) Flag for exact initial Kalman filtering. Not implemented.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">filter_augmented</span> <span class="o">=</span> <span class="n">OptionWrapper</span><span class="p">(</span><span class="s1">&#39;filter_method&#39;</span><span class="p">,</span> <span class="n">FILTER_AUGMENTED</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    (bool) Flag for augmented Kalman filtering. Not implemented.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">filter_square_root</span> <span class="o">=</span> <span class="n">OptionWrapper</span><span class="p">(</span><span class="s1">&#39;filter_method&#39;</span><span class="p">,</span> <span class="n">FILTER_SQUARE_ROOT</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    (bool) Flag for square-root Kalman filtering. Not implemented.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">filter_univariate</span> <span class="o">=</span> <span class="n">OptionWrapper</span><span class="p">(</span><span class="s1">&#39;filter_method&#39;</span><span class="p">,</span> <span class="n">FILTER_UNIVARIATE</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    (bool) Flag for univariate filtering of multivariate observation vector.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">filter_collapsed</span> <span class="o">=</span> <span class="n">OptionWrapper</span><span class="p">(</span><span class="s1">&#39;filter_method&#39;</span><span class="p">,</span> <span class="n">FILTER_COLLAPSED</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    (bool) Flag for Kalman filtering with collapsed observation vector.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">filter_extended</span> <span class="o">=</span> <span class="n">OptionWrapper</span><span class="p">(</span><span class="s1">&#39;filter_method&#39;</span><span class="p">,</span> <span class="n">FILTER_EXTENDED</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    (bool) Flag for extended Kalman filtering. Not implemented.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">filter_unscented</span> <span class="o">=</span> <span class="n">OptionWrapper</span><span class="p">(</span><span class="s1">&#39;filter_method&#39;</span><span class="p">,</span> <span class="n">FILTER_UNSCENTED</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    (bool) Flag for unscented Kalman filtering. Not implemented.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">inversion_methods</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s1">&#39;invert_univariate&#39;</span><span class="p">,</span> <span class="s1">&#39;solve_lu&#39;</span><span class="p">,</span> <span class="s1">&#39;invert_lu&#39;</span><span class="p">,</span> <span class="s1">&#39;solve_cholesky&#39;</span><span class="p">,</span>
        <span class="s1">&#39;invert_cholesky&#39;</span>
    <span class="p">]</span>

    <span class="n">invert_univariate</span> <span class="o">=</span> <span class="n">OptionWrapper</span><span class="p">(</span><span class="s1">&#39;inversion_method&#39;</span><span class="p">,</span> <span class="n">INVERT_UNIVARIATE</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    (bool) Flag for univariate inversion method (recommended).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">solve_lu</span> <span class="o">=</span> <span class="n">OptionWrapper</span><span class="p">(</span><span class="s1">&#39;inversion_method&#39;</span><span class="p">,</span> <span class="n">SOLVE_LU</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    (bool) Flag for LU and linear solver inversion method.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">invert_lu</span> <span class="o">=</span> <span class="n">OptionWrapper</span><span class="p">(</span><span class="s1">&#39;inversion_method&#39;</span><span class="p">,</span> <span class="n">INVERT_LU</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    (bool) Flag for LU inversion method.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">solve_cholesky</span> <span class="o">=</span> <span class="n">OptionWrapper</span><span class="p">(</span><span class="s1">&#39;inversion_method&#39;</span><span class="p">,</span> <span class="n">SOLVE_CHOLESKY</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    (bool) Flag for Cholesky and linear solver inversion method (recommended).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">invert_cholesky</span> <span class="o">=</span> <span class="n">OptionWrapper</span><span class="p">(</span><span class="s1">&#39;inversion_method&#39;</span><span class="p">,</span> <span class="n">INVERT_CHOLESKY</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    (bool) Flag for Cholesky inversion method.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">stability_methods</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;stability_force_symmetry&#39;</span><span class="p">]</span>

    <span class="n">stability_force_symmetry</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">OptionWrapper</span><span class="p">(</span><span class="s1">&#39;stability_method&#39;</span><span class="p">,</span> <span class="n">STABILITY_FORCE_SYMMETRY</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    (bool) Flag for enforcing covariance matrix symmetry</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">memory_options</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s1">&#39;memory_store_all&#39;</span><span class="p">,</span> <span class="s1">&#39;memory_no_forecast&#39;</span><span class="p">,</span> <span class="s1">&#39;memory_no_predicted&#39;</span><span class="p">,</span>
        <span class="s1">&#39;memory_no_filtered&#39;</span><span class="p">,</span> <span class="s1">&#39;memory_no_likelihood&#39;</span><span class="p">,</span> <span class="s1">&#39;memory_no_gain&#39;</span><span class="p">,</span>
        <span class="s1">&#39;memory_no_smoothing&#39;</span><span class="p">,</span> <span class="s1">&#39;memory_no_std_forecast&#39;</span><span class="p">,</span> <span class="s1">&#39;memory_conserve&#39;</span>
    <span class="p">]</span>

    <span class="n">memory_store_all</span> <span class="o">=</span> <span class="n">OptionWrapper</span><span class="p">(</span><span class="s1">&#39;conserve_memory&#39;</span><span class="p">,</span> <span class="n">MEMORY_STORE_ALL</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    (bool) Flag for storing all intermediate results in memory (default).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">memory_no_forecast</span> <span class="o">=</span> <span class="n">OptionWrapper</span><span class="p">(</span><span class="s1">&#39;conserve_memory&#39;</span><span class="p">,</span> <span class="n">MEMORY_NO_FORECAST</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    (bool) Flag to prevent storing forecasts.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">memory_no_predicted</span> <span class="o">=</span> <span class="n">OptionWrapper</span><span class="p">(</span><span class="s1">&#39;conserve_memory&#39;</span><span class="p">,</span> <span class="n">MEMORY_NO_PREDICTED</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    (bool) Flag to prevent storing predicted state and covariance matrices.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">memory_no_filtered</span> <span class="o">=</span> <span class="n">OptionWrapper</span><span class="p">(</span><span class="s1">&#39;conserve_memory&#39;</span><span class="p">,</span> <span class="n">MEMORY_NO_FILTERED</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    (bool) Flag to prevent storing filtered state and covariance matrices.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">memory_no_likelihood</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">OptionWrapper</span><span class="p">(</span><span class="s1">&#39;conserve_memory&#39;</span><span class="p">,</span> <span class="n">MEMORY_NO_LIKELIHOOD</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    (bool) Flag to prevent storing likelihood values for each observation.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">memory_no_gain</span> <span class="o">=</span> <span class="n">OptionWrapper</span><span class="p">(</span><span class="s1">&#39;conserve_memory&#39;</span><span class="p">,</span> <span class="n">MEMORY_NO_GAIN</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    (bool) Flag to prevent storing the Kalman gain matrices.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">memory_no_smoothing</span> <span class="o">=</span> <span class="n">OptionWrapper</span><span class="p">(</span><span class="s1">&#39;conserve_memory&#39;</span><span class="p">,</span> <span class="n">MEMORY_NO_SMOOTHING</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    (bool) Flag to prevent storing likelihood values for each observation.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">memory_no_std_forecast</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">OptionWrapper</span><span class="p">(</span><span class="s1">&#39;conserve_memory&#39;</span><span class="p">,</span> <span class="n">MEMORY_NO_STD_FORECAST</span><span class="p">))</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    (bool) Flag to prevent storing standardized forecast errors.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">memory_conserve</span> <span class="o">=</span> <span class="n">OptionWrapper</span><span class="p">(</span><span class="s1">&#39;conserve_memory&#39;</span><span class="p">,</span> <span class="n">MEMORY_CONSERVE</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    (bool) Flag to conserve the maximum amount of memory.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">timing_options</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s1">&#39;timing_init_predicted&#39;</span><span class="p">,</span> <span class="s1">&#39;timing_init_filtered&#39;</span>
    <span class="p">]</span>
    <span class="n">timing_init_predicted</span> <span class="o">=</span> <span class="n">OptionWrapper</span><span class="p">(</span><span class="s1">&#39;filter_timing&#39;</span><span class="p">,</span>
                                          <span class="n">TIMING_INIT_PREDICTED</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    (bool) Flag for the default timing convention (Durbin and Koopman, 2012).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">timing_init_filtered</span> <span class="o">=</span> <span class="n">OptionWrapper</span><span class="p">(</span><span class="s1">&#39;filter_timing&#39;</span><span class="p">,</span> <span class="n">TIMING_INIT_FILTERED</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    (bool) Flag for the alternate timing convention (Kim and Nelson, 2012).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Default filter options</span>
    <span class="n">filter_method</span> <span class="o">=</span> <span class="n">FILTER_CONVENTIONAL</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    (int) Filtering method bitmask.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">inversion_method</span> <span class="o">=</span> <span class="n">INVERT_UNIVARIATE</span> <span class="o">|</span> <span class="n">SOLVE_CHOLESKY</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    (int) Inversion method bitmask.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">stability_method</span> <span class="o">=</span> <span class="n">STABILITY_FORCE_SYMMETRY</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    (int) Stability method bitmask.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">conserve_memory</span> <span class="o">=</span> <span class="n">MEMORY_STORE_ALL</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    (int) Memory conservation bitmask.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">filter_timing</span> <span class="o">=</span> <span class="n">TIMING_INIT_PREDICTED</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    (int) Filter timing.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k_endog</span><span class="p">,</span> <span class="n">k_states</span><span class="p">,</span> <span class="n">k_posdef</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">loglikelihood_burn</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mf">1e-19</span><span class="p">,</span> <span class="n">results_class</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">kalman_filter_classes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">KalmanFilter</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">k_endog</span><span class="p">,</span> <span class="n">k_states</span><span class="p">,</span> <span class="n">k_posdef</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>

        <span class="c1"># Setup the underlying Kalman filter storage</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_kalman_filters</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># Filter options</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loglikelihood_burn</span> <span class="o">=</span> <span class="n">loglikelihood_burn</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">results_class</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">results_class</span> <span class="k">if</span> <span class="n">results_class</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">FilterResults</span>
        <span class="p">)</span>
        <span class="c1"># Options</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prefix_kalman_filter_map</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">kalman_filter_classes</span>
            <span class="k">if</span> <span class="n">kalman_filter_classes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="k">else</span> <span class="n">tools</span><span class="o">.</span><span class="n">prefix_kalman_filter_map</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">set_filter_method</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_inversion_method</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_stability_method</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_conserve_memory</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_filter_timing</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">tolerance</span> <span class="o">=</span> <span class="n">tolerance</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_kalman_filter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">prefix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prefix</span>
        <span class="k">if</span> <span class="n">prefix</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kalman_filters</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kalman_filters</span><span class="p">[</span><span class="n">prefix</span><span class="p">]</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_initialize_filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filter_method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">inversion_method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                           <span class="n">stability_method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">conserve_memory</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                           <span class="n">tolerance</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">filter_timing</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                           <span class="n">loglikelihood_burn</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">filter_method</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">filter_method</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_method</span>
        <span class="k">if</span> <span class="n">inversion_method</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">inversion_method</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inversion_method</span>
        <span class="k">if</span> <span class="n">stability_method</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">stability_method</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stability_method</span>
        <span class="k">if</span> <span class="n">conserve_memory</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">conserve_memory</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">conserve_memory</span>
        <span class="k">if</span> <span class="n">loglikelihood_burn</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">loglikelihood_burn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">loglikelihood_burn</span>
        <span class="k">if</span> <span class="n">filter_timing</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">filter_timing</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_timing</span>
        <span class="k">if</span> <span class="n">tolerance</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tolerance</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tolerance</span>

        <span class="c1"># Make sure we have endog</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">endog</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Must bind a dataset to the model before&#39;</span>
                               <span class="s1">&#39; filtering or smoothing.&#39;</span><span class="p">)</span>

        <span class="c1"># Initialize the representation matrices</span>
        <span class="n">prefix</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">create_statespace</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_representation</span><span class="p">()</span>

        <span class="c1"># Determine if we need to (re-)create the filter</span>
        <span class="c1"># (definitely need to recreate if we recreated the _statespace object)</span>
        <span class="n">create_filter</span> <span class="o">=</span> <span class="n">create_statespace</span> <span class="ow">or</span> <span class="n">prefix</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kalman_filters</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">create_filter</span><span class="p">:</span>
            <span class="n">kalman_filter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kalman_filters</span><span class="p">[</span><span class="n">prefix</span><span class="p">]</span>

            <span class="n">create_filter</span> <span class="o">=</span> <span class="p">(</span>
                <span class="ow">not</span> <span class="n">kalman_filter</span><span class="o">.</span><span class="n">conserve_memory</span> <span class="o">==</span> <span class="n">conserve_memory</span> <span class="ow">or</span>
                <span class="ow">not</span> <span class="n">kalman_filter</span><span class="o">.</span><span class="n">loglikelihood_burn</span> <span class="o">==</span> <span class="n">loglikelihood_burn</span>
            <span class="p">)</span>

        <span class="c1"># If the dtype-specific _kalman_filter does not exist (or if we need</span>
        <span class="c1"># to re-create it), create it</span>
        <span class="k">if</span> <span class="n">create_filter</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">prefix</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kalman_filters</span><span class="p">:</span>
                <span class="c1"># Delete the old filter</span>
                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kalman_filters</span><span class="p">[</span><span class="n">prefix</span><span class="p">]</span>
            <span class="c1"># Setup the filter</span>
            <span class="bp">cls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prefix_kalman_filter_map</span><span class="p">[</span><span class="n">prefix</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_kalman_filters</span><span class="p">[</span><span class="n">prefix</span><span class="p">]</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_statespaces</span><span class="p">[</span><span class="n">prefix</span><span class="p">],</span> <span class="n">filter_method</span><span class="p">,</span> <span class="n">inversion_method</span><span class="p">,</span>
                <span class="n">stability_method</span><span class="p">,</span> <span class="n">conserve_memory</span><span class="p">,</span> <span class="n">filter_timing</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">,</span>
                <span class="n">loglikelihood_burn</span>
            <span class="p">)</span>
        <span class="c1"># Otherwise, update the filter parameters</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">kalman_filter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kalman_filters</span><span class="p">[</span><span class="n">prefix</span><span class="p">]</span>
            <span class="n">kalman_filter</span><span class="o">.</span><span class="n">set_filter_method</span><span class="p">(</span><span class="n">filter_method</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
            <span class="n">kalman_filter</span><span class="o">.</span><span class="n">inversion_method</span> <span class="o">=</span> <span class="n">inversion_method</span>
            <span class="n">kalman_filter</span><span class="o">.</span><span class="n">stability_method</span> <span class="o">=</span> <span class="n">stability_method</span>
            <span class="n">kalman_filter</span><span class="o">.</span><span class="n">filter_timing</span> <span class="o">=</span> <span class="n">filter_timing</span>
            <span class="n">kalman_filter</span><span class="o">.</span><span class="n">tolerance</span> <span class="o">=</span> <span class="n">tolerance</span>
            <span class="c1"># conserve_memory and loglikelihood_burn changes always lead to</span>
            <span class="c1"># re-created filters</span>

        <span class="k">return</span> <span class="n">prefix</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">create_filter</span><span class="p">,</span> <span class="n">create_statespace</span>

<div class="viewcode-block" id="KalmanFilter.set_filter_method"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.kalman_filter.KalmanFilter.set_filter_method.html#statsmodels.tsa.statespace.kalman_filter.KalmanFilter.set_filter_method">[docs]</a>    <span class="k">def</span> <span class="nf">set_filter_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filter_method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the filtering method</span>

<span class="sd">        The filtering method controls aspects of which Kalman filtering</span>
<span class="sd">        approach will be used.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filter_method : integer, optional</span>
<span class="sd">            Bitmask value to set the filter method to. See notes for details.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Keyword arguments may be used to influence the filter method by</span>
<span class="sd">            setting individual boolean flags. See notes for details.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The filtering method is defined by a collection of boolean flags, and</span>
<span class="sd">        is internally stored as a bitmask. The methods available are:</span>

<span class="sd">        FILTER_CONVENTIONAL = 0x01</span>
<span class="sd">            Conventional Kalman filter.</span>
<span class="sd">        FILTER_UNIVARIATE = 0x10</span>
<span class="sd">            Univariate approach to Kalman filtering. Overrides conventional</span>
<span class="sd">            method if both are specified.</span>
<span class="sd">        FILTER_COLLAPSED = 0x20</span>
<span class="sd">            Collapsed approach to Kalman filtering. Will be used *in addition*</span>
<span class="sd">            to conventional or univariate filtering.</span>

<span class="sd">        Note that only the first method is available if using a Scipy version</span>
<span class="sd">        older than 0.16.</span>

<span class="sd">        If the bitmask is set directly via the `filter_method` argument, then</span>
<span class="sd">        the full method must be provided.</span>

<span class="sd">        If keyword arguments are used to set individual boolean flags, then</span>
<span class="sd">        the lowercase of the method must be used as an argument name, and the</span>
<span class="sd">        value is the desired value of the boolean flag (True or False).</span>

<span class="sd">        Note that the filter method may also be specified by directly modifying</span>
<span class="sd">        the class attributes which are defined similarly to the keyword</span>
<span class="sd">        arguments.</span>

<span class="sd">        The default filtering method is FILTER_CONVENTIONAL.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; mod = sm.tsa.statespace.SARIMAX(range(10))</span>
<span class="sd">        &gt;&gt;&gt; mod.ssm.filter_method</span>
<span class="sd">        1</span>
<span class="sd">        &gt;&gt;&gt; mod.ssm.filter_conventional</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; mod.ssm.filter_univariate = True</span>
<span class="sd">        &gt;&gt;&gt; mod.ssm.filter_method</span>
<span class="sd">        17</span>
<span class="sd">        &gt;&gt;&gt; mod.ssm.set_filter_method(filter_univariate=False,</span>
<span class="sd">        ...                           filter_collapsed=True)</span>
<span class="sd">        &gt;&gt;&gt; mod.ssm.filter_method</span>
<span class="sd">        33</span>
<span class="sd">        &gt;&gt;&gt; mod.ssm.set_filter_method(filter_method=1)</span>
<span class="sd">        &gt;&gt;&gt; mod.ssm.filter_conventional</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; mod.ssm.filter_univariate</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; mod.ssm.filter_collapsed</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; mod.ssm.filter_univariate = True</span>
<span class="sd">        &gt;&gt;&gt; mod.ssm.filter_method</span>
<span class="sd">        17</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">filter_method</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">filter_method</span> <span class="o">=</span> <span class="n">filter_method</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">KalmanFilter</span><span class="o">.</span><span class="n">filter_methods</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compatibility_mode</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_method</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Only conventional Kalman filtering&#39;</span>
                                      <span class="s1">&#39; is available. Consider updating&#39;</span>
                                      <span class="s1">&#39; dependencies for more options.&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="KalmanFilter.set_inversion_method"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.kalman_filter.KalmanFilter.set_inversion_method.html#statsmodels.tsa.statespace.kalman_filter.KalmanFilter.set_inversion_method">[docs]</a>    <span class="k">def</span> <span class="nf">set_inversion_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inversion_method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the inversion method</span>

<span class="sd">        The Kalman filter may contain one matrix inversion: that of the</span>
<span class="sd">        forecast error covariance matrix. The inversion method controls how and</span>
<span class="sd">        if that inverse is performed.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        inversion_method : integer, optional</span>
<span class="sd">            Bitmask value to set the inversion method to. See notes for</span>
<span class="sd">            details.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Keyword arguments may be used to influence the inversion method by</span>
<span class="sd">            setting individual boolean flags. See notes for details.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The inversion method is defined by a collection of boolean flags, and</span>
<span class="sd">        is internally stored as a bitmask. The methods available are:</span>

<span class="sd">        INVERT_UNIVARIATE = 0x01</span>
<span class="sd">            If the endogenous time series is univariate, then inversion can be</span>
<span class="sd">            performed by simple division. If this flag is set and the time</span>
<span class="sd">            series is univariate, then division will always be used even if</span>
<span class="sd">            other flags are also set.</span>
<span class="sd">        SOLVE_LU = 0x02</span>
<span class="sd">            Use an LU decomposition along with a linear solver (rather than</span>
<span class="sd">            ever actually inverting the matrix).</span>
<span class="sd">        INVERT_LU = 0x04</span>
<span class="sd">            Use an LU decomposition along with typical matrix inversion.</span>
<span class="sd">        SOLVE_CHOLESKY = 0x08</span>
<span class="sd">            Use a Cholesky decomposition along with a linear solver.</span>
<span class="sd">        INVERT_CHOLESKY = 0x10</span>
<span class="sd">            Use an Cholesky decomposition along with typical matrix inversion.</span>

<span class="sd">        If the bitmask is set directly via the `inversion_method` argument,</span>
<span class="sd">        then the full method must be provided.</span>

<span class="sd">        If keyword arguments are used to set individual boolean flags, then</span>
<span class="sd">        the lowercase of the method must be used as an argument name, and the</span>
<span class="sd">        value is the desired value of the boolean flag (True or False).</span>

<span class="sd">        Note that the inversion method may also be specified by directly</span>
<span class="sd">        modifying the class attributes which are defined similarly to the</span>
<span class="sd">        keyword arguments.</span>

<span class="sd">        The default inversion method is `INVERT_UNIVARIATE | SOLVE_CHOLESKY`</span>

<span class="sd">        Several things to keep in mind are:</span>

<span class="sd">        - If the filtering method is specified to be univariate, then simple</span>
<span class="sd">          division is always used regardless of the dimension of the endogenous</span>
<span class="sd">          time series.</span>
<span class="sd">        - Cholesky decomposition is about twice as fast as LU decomposition,</span>
<span class="sd">          but it requires that the matrix be positive definite. While this</span>
<span class="sd">          should generally be true, it may not be in every case.</span>
<span class="sd">        - Using a linear solver rather than true matrix inversion is generally</span>
<span class="sd">          faster and is numerically more stable.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; mod = sm.tsa.statespace.SARIMAX(range(10))</span>
<span class="sd">        &gt;&gt;&gt; mod.ssm.inversion_method</span>
<span class="sd">        1</span>
<span class="sd">        &gt;&gt;&gt; mod.ssm.solve_cholesky</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; mod.ssm.invert_univariate</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; mod.ssm.invert_lu</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; mod.ssm.invert_univariate = False</span>
<span class="sd">        &gt;&gt;&gt; mod.ssm.inversion_method</span>
<span class="sd">        8</span>
<span class="sd">        &gt;&gt;&gt; mod.ssm.set_inversion_method(solve_cholesky=False,</span>
<span class="sd">        ...                              invert_cholesky=True)</span>
<span class="sd">        &gt;&gt;&gt; mod.ssm.inversion_method</span>
<span class="sd">        16</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">inversion_method</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">inversion_method</span> <span class="o">=</span> <span class="n">inversion_method</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">KalmanFilter</span><span class="o">.</span><span class="n">inversion_methods</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">name</span><span class="p">])</span></div>

<div class="viewcode-block" id="KalmanFilter.set_stability_method"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.kalman_filter.KalmanFilter.set_stability_method.html#statsmodels.tsa.statespace.kalman_filter.KalmanFilter.set_stability_method">[docs]</a>    <span class="k">def</span> <span class="nf">set_stability_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stability_method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the numerical stability method</span>

<span class="sd">        The Kalman filter is a recursive algorithm that may in some cases</span>
<span class="sd">        suffer issues with numerical stability. The stability method controls</span>
<span class="sd">        what, if any, measures are taken to promote stability.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        stability_method : integer, optional</span>
<span class="sd">            Bitmask value to set the stability method to. See notes for</span>
<span class="sd">            details.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Keyword arguments may be used to influence the stability method by</span>
<span class="sd">            setting individual boolean flags. See notes for details.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The stability method is defined by a collection of boolean flags, and</span>
<span class="sd">        is internally stored as a bitmask. The methods available are:</span>

<span class="sd">        STABILITY_FORCE_SYMMETRY = 0x01</span>
<span class="sd">            If this flag is set, symmetry of the predicted state covariance</span>
<span class="sd">            matrix is enforced at each iteration of the filter, where each</span>
<span class="sd">            element is set to the average of the corresponding elements in the</span>
<span class="sd">            upper and lower triangle.</span>

<span class="sd">        If the bitmask is set directly via the `stability_method` argument,</span>
<span class="sd">        then the full method must be provided.</span>

<span class="sd">        If keyword arguments are used to set individual boolean flags, then</span>
<span class="sd">        the lowercase of the method must be used as an argument name, and the</span>
<span class="sd">        value is the desired value of the boolean flag (True or False).</span>

<span class="sd">        Note that the stability method may also be specified by directly</span>
<span class="sd">        modifying the class attributes which are defined similarly to the</span>
<span class="sd">        keyword arguments.</span>

<span class="sd">        The default stability method is `STABILITY_FORCE_SYMMETRY`</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; mod = sm.tsa.statespace.SARIMAX(range(10))</span>
<span class="sd">        &gt;&gt;&gt; mod.ssm.stability_method</span>
<span class="sd">        1</span>
<span class="sd">        &gt;&gt;&gt; mod.ssm.stability_force_symmetry</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; mod.ssm.stability_force_symmetry = False</span>
<span class="sd">        &gt;&gt;&gt; mod.ssm.stability_method</span>
<span class="sd">        0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">stability_method</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stability_method</span> <span class="o">=</span> <span class="n">stability_method</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">KalmanFilter</span><span class="o">.</span><span class="n">stability_methods</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">name</span><span class="p">])</span></div>

<div class="viewcode-block" id="KalmanFilter.set_conserve_memory"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.kalman_filter.KalmanFilter.set_conserve_memory.html#statsmodels.tsa.statespace.kalman_filter.KalmanFilter.set_conserve_memory">[docs]</a>    <span class="k">def</span> <span class="nf">set_conserve_memory</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">conserve_memory</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the memory conservation method</span>

<span class="sd">        By default, the Kalman filter computes a number of intermediate</span>
<span class="sd">        matrices at each iteration. The memory conservation options control</span>
<span class="sd">        which of those matrices are stored.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        conserve_memory : integer, optional</span>
<span class="sd">            Bitmask value to set the memory conservation method to. See notes</span>
<span class="sd">            for details.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Keyword arguments may be used to influence the memory conservation</span>
<span class="sd">            method by setting individual boolean flags. See notes for details.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The memory conservation method is defined by a collection of boolean</span>
<span class="sd">        flags, and is internally stored as a bitmask. The methods available</span>
<span class="sd">        are:</span>

<span class="sd">        MEMORY_STORE_ALL = 0</span>
<span class="sd">            Store all intermediate matrices. This is the default value.</span>
<span class="sd">        MEMORY_NO_FORECAST = 0x01</span>
<span class="sd">            Do not store the forecast, forecast error, or forecast error</span>
<span class="sd">            covariance matrices. If this option is used, the `predict` method</span>
<span class="sd">            from the results class is unavailable.</span>
<span class="sd">        MEMORY_NO_PREDICTED = 0x02</span>
<span class="sd">            Do not store the predicted state or predicted state covariance</span>
<span class="sd">            matrices.</span>
<span class="sd">        MEMORY_NO_FILTERED = 0x04</span>
<span class="sd">            Do not store the filtered state or filtered state covariance</span>
<span class="sd">            matrices.</span>
<span class="sd">        MEMORY_NO_LIKELIHOOD = 0x08</span>
<span class="sd">            Do not store the vector of loglikelihood values for each</span>
<span class="sd">            observation. Only the sum of the loglikelihood values is stored.</span>
<span class="sd">        MEMORY_NO_GAIN = 0x10</span>
<span class="sd">            Do not store the Kalman gain matrices.</span>
<span class="sd">        MEMORY_NO_SMOOTHING = 0x20</span>
<span class="sd">            Do not store temporary variables related to Klaman smoothing. If</span>
<span class="sd">            this option is used, smoothing is unavailable.</span>
<span class="sd">        MEMORY_NO_SMOOTHING = 0x20</span>
<span class="sd">            Do not store standardized forecast errors.</span>
<span class="sd">        MEMORY_CONSERVE</span>
<span class="sd">            Do not store any intermediate matrices.</span>

<span class="sd">        Note that if using a Scipy version less than 0.16, the options</span>
<span class="sd">        MEMORY_NO_GAIN, MEMORY_NO_SMOOTHING, and MEMORY_NO_STD_FORECAST</span>
<span class="sd">        have no effect.</span>

<span class="sd">        If the bitmask is set directly via the `conserve_memory` argument,</span>
<span class="sd">        then the full method must be provided.</span>

<span class="sd">        If keyword arguments are used to set individual boolean flags, then</span>
<span class="sd">        the lowercase of the method must be used as an argument name, and the</span>
<span class="sd">        value is the desired value of the boolean flag (True or False).</span>

<span class="sd">        Note that the memory conservation method may also be specified by</span>
<span class="sd">        directly modifying the class attributes which are defined similarly to</span>
<span class="sd">        the keyword arguments.</span>

<span class="sd">        The default memory conservation method is `MEMORY_STORE_ALL`, so that</span>
<span class="sd">        all intermediate matrices are stored.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; mod = sm.tsa.statespace.SARIMAX(range(10))</span>
<span class="sd">        &gt;&gt;&gt; mod.ssm..conserve_memory</span>
<span class="sd">        0</span>
<span class="sd">        &gt;&gt;&gt; mod.ssm.memory_no_predicted</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; mod.ssm.memory_no_predicted = True</span>
<span class="sd">        &gt;&gt;&gt; mod.ssm.conserve_memory</span>
<span class="sd">        2</span>
<span class="sd">        &gt;&gt;&gt; mod.ssm.set_conserve_memory(memory_no_filtered=True,</span>
<span class="sd">        ...                             memory_no_forecast=True)</span>
<span class="sd">        &gt;&gt;&gt; mod.ssm.conserve_memory</span>
<span class="sd">        7</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">conserve_memory</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">conserve_memory</span> <span class="o">=</span> <span class="n">conserve_memory</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">KalmanFilter</span><span class="o">.</span><span class="n">memory_options</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">name</span><span class="p">])</span></div>

<div class="viewcode-block" id="KalmanFilter.set_filter_timing"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.kalman_filter.KalmanFilter.set_filter_timing.html#statsmodels.tsa.statespace.kalman_filter.KalmanFilter.set_filter_timing">[docs]</a>    <span class="k">def</span> <span class="nf">set_filter_timing</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alternate_timing</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the filter timing convention</span>

<span class="sd">        By default, the Kalman filter follows Durbin and Koopman, 2012, in</span>
<span class="sd">        initializing the filter with predicted values. Kim and Nelson, 1999,</span>
<span class="sd">        instead initialize the filter with filtered values, which is</span>
<span class="sd">        essentially just a different timing convention.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        alternate_timing : integer, optional</span>
<span class="sd">            Whether or not to use the alternate timing convention. Default is</span>
<span class="sd">            unspecified.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Keyword arguments may be used to influence the memory conservation</span>
<span class="sd">            method by setting individual boolean flags. See notes for details.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">alternate_timing</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">filter_timing</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">alternate_timing</span><span class="p">)</span>
        <span class="k">if</span> <span class="s1">&#39;timing_init_predicted&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">filter_timing</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="ow">not</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;timing_init_predicted&#39;</span><span class="p">])</span>
        <span class="k">if</span> <span class="s1">&#39;timing_init_filtered&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">filter_timing</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;timing_init_filtered&#39;</span><span class="p">])</span>

        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_compatibility_mode</span> <span class="ow">and</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">filter_timing</span> <span class="o">==</span> <span class="n">TIMING_INIT_FILTERED</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Only &quot;predicted&quot; Kalman filter&#39;</span>
                                      <span class="s1">&#39; timing is available. Consider&#39;</span>
                                      <span class="s1">&#39; updating dependencies for more&#39;</span>
                                      <span class="s1">&#39; options.&#39;</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filter_method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">inversion_method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">stability_method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">conserve_memory</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">filter_timing</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">loglikelihood_burn</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">complex_step</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="c1"># Initialize the filter</span>
        <span class="n">prefix</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">create_filter</span><span class="p">,</span> <span class="n">create_statespace</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_filter</span><span class="p">(</span>
                <span class="n">filter_method</span><span class="p">,</span> <span class="n">inversion_method</span><span class="p">,</span> <span class="n">stability_method</span><span class="p">,</span>
                <span class="n">conserve_memory</span><span class="p">,</span> <span class="n">filter_timing</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">,</span> <span class="n">loglikelihood_burn</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="n">kfilter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kalman_filters</span><span class="p">[</span><span class="n">prefix</span><span class="p">]</span>

        <span class="c1"># Initialize the state</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_state</span><span class="p">(</span><span class="n">prefix</span><span class="o">=</span><span class="n">prefix</span><span class="p">,</span> <span class="n">complex_step</span><span class="o">=</span><span class="n">complex_step</span><span class="p">)</span>

        <span class="c1"># Run the filter</span>
        <span class="n">kfilter</span><span class="p">()</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">kfilter</span><span class="o">.</span><span class="n">loglikelihood</span><span class="p">)</span>
        <span class="n">tmp2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">kfilter</span><span class="o">.</span><span class="n">predicted_state</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">kfilter</span>

<div class="viewcode-block" id="KalmanFilter.filter"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.kalman_filter.KalmanFilter.filter.html#statsmodels.tsa.statespace.kalman_filter.KalmanFilter.filter">[docs]</a>    <span class="k">def</span> <span class="nf">filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filter_method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">inversion_method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="n">stability_method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">conserve_memory</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">filter_timing</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="n">tolerance</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">loglikelihood_burn</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">complex_step</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply the Kalman filter to the statespace model.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filter_method : int, optional</span>
<span class="sd">            Determines which Kalman filter to use. Default is conventional.</span>
<span class="sd">        inversion_method : int, optional</span>
<span class="sd">            Determines which inversion technique to use. Default is by Cholesky</span>
<span class="sd">            decomposition.</span>
<span class="sd">        stability_method : int, optional</span>
<span class="sd">            Determines which numerical stability techniques to use. Default is</span>
<span class="sd">            to enforce symmetry of the predicted state covariance matrix.</span>
<span class="sd">        conserve_memory : int, optional</span>
<span class="sd">            Determines what output from the filter to store. Default is to</span>
<span class="sd">            store everything.</span>
<span class="sd">        filter_timing : int, optional</span>
<span class="sd">            Determines the timing convention of the filter. Default is that</span>
<span class="sd">            from Durbin and Koopman (2012), in which the filter is initialized</span>
<span class="sd">            with predicted values.</span>
<span class="sd">        tolerance : float, optional</span>
<span class="sd">            The tolerance at which the Kalman filter determines convergence to</span>
<span class="sd">            steady-state. Default is 1e-19.</span>
<span class="sd">        loglikelihood_burn : int, optional</span>
<span class="sd">            The number of initial periods during which the loglikelihood is not</span>
<span class="sd">            recorded. Default is 0.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This function by default does not compute variables required for</span>
<span class="sd">        smoothing.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">conserve_memory</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">conserve_memory</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">conserve_memory</span> <span class="o">|</span> <span class="n">MEMORY_NO_SMOOTHING</span>

        <span class="c1"># Run the filter</span>
        <span class="n">kfilter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filter</span><span class="p">(</span>
            <span class="n">filter_method</span><span class="p">,</span> <span class="n">inversion_method</span><span class="p">,</span> <span class="n">stability_method</span><span class="p">,</span> <span class="n">conserve_memory</span><span class="p">,</span>
            <span class="n">filter_timing</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">,</span> <span class="n">loglikelihood_burn</span><span class="p">,</span> <span class="n">complex_step</span><span class="p">)</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">kfilter</span><span class="o">.</span><span class="n">loglikelihood</span><span class="p">)</span>
        <span class="c1"># Create the results object</span>
        <span class="n">results</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">results_class</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">results</span><span class="o">.</span><span class="n">update_representation</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">results</span><span class="o">.</span><span class="n">update_filter</span><span class="p">(</span><span class="n">kfilter</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">results</span></div>

<div class="viewcode-block" id="KalmanFilter.loglike"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.kalman_filter.KalmanFilter.loglike.html#statsmodels.tsa.statespace.kalman_filter.KalmanFilter.loglike">[docs]</a>    <span class="k">def</span> <span class="nf">loglike</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the loglikelihood associated with the statespace model.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Additional keyword arguments to pass to the Kalman filter. See</span>
<span class="sd">            `KalmanFilter.filter` for more details.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        loglike : float</span>
<span class="sd">            The joint loglikelihood.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">memory_no_likelihood</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Cannot compute loglikelihood if&#39;</span>
                               <span class="s1">&#39; MEMORY_NO_LIKELIHOOD option is selected.&#39;</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;conserve_memory&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">MEMORY_CONSERVE</span> <span class="o">^</span> <span class="n">MEMORY_NO_LIKELIHOOD</span>
        <span class="n">kfilter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filter</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">loglikelihood_burn</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;loglikelihood_burn&#39;</span><span class="p">,</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">loglikelihood_burn</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">kfilter</span><span class="o">.</span><span class="n">loglikelihood</span><span class="p">[</span><span class="n">loglikelihood_burn</span><span class="p">:])</span></div>

<div class="viewcode-block" id="KalmanFilter.loglikeobs"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.kalman_filter.KalmanFilter.loglikeobs.html#statsmodels.tsa.statespace.kalman_filter.KalmanFilter.loglikeobs">[docs]</a>    <span class="k">def</span> <span class="nf">loglikeobs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the loglikelihood for each observation associated with the</span>
<span class="sd">        statespace model.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Additional keyword arguments to pass to the Kalman filter. See</span>
<span class="sd">            `KalmanFilter.filter` for more details.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        If `loglikelihood_burn` is positive, then the entries in the returned</span>
<span class="sd">        loglikelihood vector are set to be zero for those initial time periods.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        loglike : array of float</span>
<span class="sd">            Array of loglikelihood values for each observation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">memory_no_likelihood</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Cannot compute loglikelihood if&#39;</span>
                               <span class="s1">&#39; MEMORY_NO_LIKELIHOOD option is selected.&#39;</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;conserve_memory&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">MEMORY_CONSERVE</span> <span class="o">^</span> <span class="n">MEMORY_NO_LIKELIHOOD</span>
        <span class="n">kfilter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filter</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">llf_obs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">kfilter</span><span class="o">.</span><span class="n">loglikelihood</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Set any burned observations to have zero likelihood</span>
        <span class="n">loglikelihood_burn</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;loglikelihood_burn&#39;</span><span class="p">,</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">loglikelihood_burn</span><span class="p">)</span>
        <span class="n">llf_obs</span><span class="p">[:</span><span class="n">loglikelihood_burn</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">return</span> <span class="n">llf_obs</span></div>

<div class="viewcode-block" id="KalmanFilter.simulate"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.kalman_filter.KalmanFilter.simulate.html#statsmodels.tsa.statespace.kalman_filter.KalmanFilter.simulate">[docs]</a>    <span class="k">def</span> <span class="nf">simulate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nsimulations</span><span class="p">,</span> <span class="n">measurement_shocks</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">state_shocks</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">initial_state</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Simulate a new time series following the state space model</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nsimulations : int</span>
<span class="sd">            The number of observations to simulate. If the model is</span>
<span class="sd">            time-invariant this can be any number. If the model is</span>
<span class="sd">            time-varying, then this number must be less than or equal to the</span>
<span class="sd">            number</span>
<span class="sd">        measurement_shocks : array_like, optional</span>
<span class="sd">            If specified, these are the shocks to the measurement equation,</span>
<span class="sd">            :math:`\varepsilon_t`. If unspecified, these are automatically</span>
<span class="sd">            generated using a pseudo-random number generator. If specified,</span>
<span class="sd">            must be shaped `nsimulations` x `k_endog`, where `k_endog` is the</span>
<span class="sd">            same as in the state space model.</span>
<span class="sd">        state_shocks : array_like, optional</span>
<span class="sd">            If specified, these are the shocks to the state equation,</span>
<span class="sd">            :math:`\eta_t`. If unspecified, these are automatically</span>
<span class="sd">            generated using a pseudo-random number generator. If specified,</span>
<span class="sd">            must be shaped `nsimulations` x `k_posdef` where `k_posdef` is the</span>
<span class="sd">            same as in the state space model.</span>
<span class="sd">        initial_state : array_like, optional</span>
<span class="sd">            If specified, this is the state vector at time zero, which should</span>
<span class="sd">            be shaped (`k_states` x 1), where `k_states` is the same as in the</span>
<span class="sd">            state space model. If unspecified, but the model has been</span>
<span class="sd">            initialized, then that initialization is used. If unspecified and</span>
<span class="sd">            the model has not been initialized, then a vector of zeros is used.</span>
<span class="sd">            Note that this is not included in the returned `simulated_states`</span>
<span class="sd">            array.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        simulated_obs : array</span>
<span class="sd">            An (nsimulations x k_endog) array of simulated observations.</span>
<span class="sd">        simulated_states : array</span>
<span class="sd">            An (nsimulations x k_states) array of simulated states.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">time_invariant</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_invariant</span>
        <span class="c1"># Check for valid number of simulations</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">time_invariant</span> <span class="ow">and</span> <span class="n">nsimulations</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;In a time-varying model, cannot create more&#39;</span>
                             <span class="s1">&#39; simulations than there are observations.&#39;</span><span class="p">)</span>

        <span class="c1"># Check / generate measurement shocks</span>
        <span class="k">if</span> <span class="n">measurement_shocks</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">measurement_shocks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">measurement_shocks</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">measurement_shocks</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">measurement_shocks</span> <span class="o">=</span> <span class="n">measurement_shocks</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">measurement_shocks</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">measurement_shocks</span> <span class="o">=</span> <span class="n">measurement_shocks</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">measurement_shocks</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="n">nsimulations</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid shape of provided measurement&#39;</span>
                                 <span class="s1">&#39; shocks. Required (</span><span class="si">%d</span><span class="s1">, </span><span class="si">%d</span><span class="s1">)&#39;</span>
                                 <span class="o">%</span> <span class="p">(</span><span class="n">nsimulations</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">))</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">shapes</span><span class="p">[</span><span class="s1">&#39;obs_cov&#39;</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">measurement_shocks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">multivariate_normal</span><span class="p">(</span>
                <span class="n">mean</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">),</span> <span class="n">cov</span><span class="o">=</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;obs_cov&#39;</span><span class="p">],</span>
                <span class="n">size</span><span class="o">=</span><span class="n">nsimulations</span><span class="p">)</span>

        <span class="c1"># Check / generate state shocks</span>
        <span class="k">if</span> <span class="n">state_shocks</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">state_shocks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">state_shocks</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">state_shocks</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">state_shocks</span> <span class="o">=</span> <span class="n">state_shocks</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">state_shocks</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">state_shocks</span> <span class="o">=</span> <span class="n">state_shocks</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">state_shocks</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="n">nsimulations</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_posdef</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid shape of provided state shocks.&#39;</span>
                                 <span class="s1">&#39; Required (</span><span class="si">%d</span><span class="s1">, </span><span class="si">%d</span><span class="s1">).&#39;</span>
                                 <span class="o">%</span> <span class="p">(</span><span class="n">nsimulations</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_posdef</span><span class="p">))</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">shapes</span><span class="p">[</span><span class="s1">&#39;state_cov&#39;</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">state_shocks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">multivariate_normal</span><span class="p">(</span>
                <span class="n">mean</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_posdef</span><span class="p">),</span> <span class="n">cov</span><span class="o">=</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;state_cov&#39;</span><span class="p">],</span>
                <span class="n">size</span><span class="o">=</span><span class="n">nsimulations</span><span class="p">)</span>

        <span class="c1"># Get the initial states</span>
        <span class="k">if</span> <span class="n">initial_state</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">initial_state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">initial_state</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">initial_state</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">initial_state</span> <span class="o">=</span> <span class="n">initial_state</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
            <span class="k">elif</span> <span class="p">(</span><span class="n">initial_state</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span>
                  <span class="ow">not</span> <span class="n">initial_state</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_states</span><span class="p">,</span> <span class="mi">1</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid shape of provided initial state&#39;</span>
                                 <span class="s1">&#39; vector. Required (</span><span class="si">%d</span><span class="s1">, 1)&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_states</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">initialization</span> <span class="o">==</span> <span class="s1">&#39;known&#39;</span><span class="p">:</span>
            <span class="n">initial_state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">multivariate_normal</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_initial_state</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initial_state_cov</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">initialization</span> <span class="o">==</span> <span class="s1">&#39;stationary&#39;</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="k">import</span> <span class="n">solve_discrete_lyapunov</span>
            <span class="c1"># (I - T)^{-1} c = x =&gt; (I - T) x = c</span>
            <span class="n">initial_state_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_states</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;transition&#39;</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">],</span>
                <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;state_intercept&#39;</span><span class="p">,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">])</span>
            <span class="n">R</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;selection&#39;</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">Q</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;state_cov&#39;</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">selected_state_cov</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">R</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
            <span class="n">initial_state_cov</span> <span class="o">=</span> <span class="n">solve_discrete_lyapunov</span><span class="p">(</span>
                <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;transition&#39;</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">selected_state_cov</span><span class="p">)</span>
            <span class="n">initial_state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">multivariate_normal</span><span class="p">(</span>
                <span class="n">initial_state_mean</span><span class="p">,</span> <span class="n">initial_state_cov</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">initialization</span> <span class="o">==</span> <span class="s1">&#39;approximate_diffuse&#39;</span><span class="p">:</span>
            <span class="n">initial_state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_states</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">initial_state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_states</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_simulate</span><span class="p">(</span><span class="n">nsimulations</span><span class="p">,</span> <span class="n">measurement_shocks</span><span class="p">,</span> <span class="n">state_shocks</span><span class="p">,</span>
                              <span class="n">initial_state</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_simulate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nsimulations</span><span class="p">,</span> <span class="n">measurement_shocks</span><span class="p">,</span> <span class="n">state_shocks</span><span class="p">,</span>
                  <span class="n">initial_state</span><span class="p">):</span>
        <span class="n">time_invariant</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_invariant</span>

        <span class="c1"># Holding variables for the simulations</span>
        <span class="n">simulated_obs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nsimulations</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">),</span>
                                 <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">simulated_states</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nsimulations</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_states</span><span class="p">),</span>
                                    <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">simulated_states</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">initial_state</span>

        <span class="c1"># Perform iterations to create the new time series</span>
        <span class="n">obs_intercept_t</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">design_t</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">state_intercept_t</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">transition_t</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">selection_t</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nsimulations</span><span class="p">):</span>
            <span class="c1"># Get the current shocks (this accomodates time-varying matrices)</span>
            <span class="k">if</span> <span class="n">measurement_shocks</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">measurement_shock</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">multivariate_normal</span><span class="p">(</span>
                    <span class="n">mean</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">),</span> <span class="n">cov</span><span class="o">=</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;obs_cov&#39;</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="n">t</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">measurement_shock</span> <span class="o">=</span> <span class="n">measurement_shocks</span><span class="p">[</span><span class="n">t</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">state_shocks</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">state_shock</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">multivariate_normal</span><span class="p">(</span>
                    <span class="n">mean</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_posdef</span><span class="p">),</span>
                    <span class="n">cov</span><span class="o">=</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;state_cov&#39;</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="n">t</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">state_shock</span> <span class="o">=</span> <span class="n">state_shocks</span><span class="p">[</span><span class="n">t</span><span class="p">]</span>

            <span class="c1"># Get current-iteration matrices</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">time_invariant</span><span class="p">:</span>
                <span class="n">obs_intercept_t</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">obs_intercept</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">t</span>
                <span class="n">design_t</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">design</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">t</span>
                <span class="n">state_intercept_t</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="mi">0</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">state_intercept</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">t</span><span class="p">)</span>
                <span class="n">transition_t</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">transition</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">t</span>
                <span class="n">selection_t</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">selection</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">t</span>

            <span class="n">obs_intercept</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;obs_intercept&#39;</span><span class="p">,</span> <span class="p">:,</span> <span class="n">obs_intercept_t</span><span class="p">]</span>
            <span class="n">design</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;design&#39;</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="n">design_t</span><span class="p">]</span>
            <span class="n">state_intercept</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;state_intercept&#39;</span><span class="p">,</span> <span class="p">:,</span> <span class="n">state_intercept_t</span><span class="p">]</span>
            <span class="n">transition</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;transition&#39;</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="n">transition_t</span><span class="p">]</span>
            <span class="n">selection</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;selection&#39;</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="n">selection_t</span><span class="p">]</span>

            <span class="c1"># Iterate the measurement equation</span>
            <span class="n">simulated_obs</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">obs_intercept</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">design</span><span class="p">,</span> <span class="n">simulated_states</span><span class="p">[</span><span class="n">t</span><span class="p">])</span> <span class="o">+</span>
                <span class="n">measurement_shock</span><span class="p">)</span>

            <span class="c1"># Iterate the state equation</span>
            <span class="n">simulated_states</span><span class="p">[</span><span class="n">t</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">state_intercept</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">transition</span><span class="p">,</span> <span class="n">simulated_states</span><span class="p">[</span><span class="n">t</span><span class="p">])</span> <span class="o">+</span>
                <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">selection</span><span class="p">,</span> <span class="n">state_shock</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">simulated_obs</span><span class="p">,</span> <span class="n">simulated_states</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

<div class="viewcode-block" id="KalmanFilter.impulse_responses"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.kalman_filter.KalmanFilter.impulse_responses.html#statsmodels.tsa.statespace.kalman_filter.KalmanFilter.impulse_responses">[docs]</a>    <span class="k">def</span> <span class="nf">impulse_responses</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">steps</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">impulse</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">orthogonalized</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                          <span class="n">cumulative</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Impulse response function</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        steps : int, optional</span>
<span class="sd">            The number of steps for which impulse responses are calculated.</span>
<span class="sd">            Default is 10. Note that the initial impulse is not counted as a</span>
<span class="sd">            step, so if `steps=1`, the output will have 2 entries.</span>
<span class="sd">        impulse : int or array_like</span>
<span class="sd">            If an integer, the state innovation to pulse; must be between 0</span>
<span class="sd">            and `k_posdef-1` where `k_posdef` is the same as in the state</span>
<span class="sd">            space model. Alternatively, a custom impulse vector may be</span>
<span class="sd">            provided; must be a column vector with shape `(k_posdef, 1)`.</span>
<span class="sd">        orthogonalized : boolean, optional</span>
<span class="sd">            Whether or not to perform impulse using orthogonalized innovations.</span>
<span class="sd">            Note that this will also affect custum `impulse` vectors. Default</span>
<span class="sd">            is False.</span>
<span class="sd">        cumulative : boolean, optional</span>
<span class="sd">            Whether or not to return cumulative impulse responses. Default is</span>
<span class="sd">            False.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            If the model is time-varying and `steps` is greater than the number</span>
<span class="sd">            of observations, any of the state space representation matrices</span>
<span class="sd">            that are time-varying must have updated values provided for the</span>
<span class="sd">            out-of-sample steps.</span>
<span class="sd">            For example, if `design` is a time-varying component, `nobs` is 10,</span>
<span class="sd">            and `steps` is 15, a (`k_endog` x `k_states` x 5) matrix must be</span>
<span class="sd">            provided with the new design matrix values.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        impulse_responses : array</span>
<span class="sd">            Responses for each endogenous variable due to the impulse</span>
<span class="sd">            given by the `impulse` argument. A (steps + 1 x k_endog) array.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Intercepts in the measurement and state equation are ignored when</span>
<span class="sd">        calculating impulse responses.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Since the first step is the impulse itself, we actually want steps+1</span>
        <span class="n">steps</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># Check for what kind of impulse we want</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">impulse</span><span class="p">)</span> <span class="o">==</span> <span class="nb">int</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">impulse</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_posdef</span> <span class="ow">or</span> <span class="n">impulse</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid value for `impulse`. Must be the&#39;</span>
                                 <span class="s1">&#39; index of one of the state innovations.&#39;</span><span class="p">)</span>

            <span class="c1"># Create the (non-orthogonalized) impulse vector</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">impulse</span>
            <span class="n">impulse</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_posdef</span><span class="p">)</span>
            <span class="n">impulse</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">impulse</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">impulse</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">impulse</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">impulse</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">impulse</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">impulse</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_posdef</span><span class="p">,):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid impulse vector. Must be shaped&#39;</span>
                                 <span class="s1">&#39; (</span><span class="si">%d</span><span class="s1">,)&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_posdef</span><span class="p">)</span>

        <span class="c1"># Orthogonalize the impulses, if requested, using Cholesky on the</span>
        <span class="c1"># first state covariance matrix</span>
        <span class="k">if</span> <span class="n">orthogonalized</span><span class="p">:</span>
            <span class="n">state_chol</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">cholesky</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state_cov</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">])</span>
            <span class="n">impulse</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">state_chol</span><span class="p">,</span> <span class="n">impulse</span><span class="p">)</span>

        <span class="c1"># If we have a time-invariant system, we can solve for the IRF directly</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_invariant</span><span class="p">:</span>
            <span class="c1"># Get the state space matrices</span>
            <span class="n">design</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">design</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">transition</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transition</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">selection</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">selection</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span>

            <span class="c1"># Holding arrays</span>
            <span class="n">irf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">steps</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="n">states</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">steps</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_states</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

            <span class="c1"># First iteration</span>
            <span class="n">states</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">selection</span><span class="p">,</span> <span class="n">impulse</span><span class="p">)</span>
            <span class="n">irf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">design</span><span class="p">,</span> <span class="n">states</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

            <span class="c1"># Iterations</span>
            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">steps</span><span class="p">):</span>
                <span class="n">states</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">transition</span><span class="p">,</span> <span class="n">states</span><span class="p">[</span><span class="n">t</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">irf</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">design</span><span class="p">,</span> <span class="n">states</span><span class="p">[</span><span class="n">t</span><span class="p">])</span>

        <span class="c1"># Otherwise, create a new model</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Get the basic model components</span>
            <span class="n">representation</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">shape</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">shapes</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;obs&#39;</span><span class="p">,</span> <span class="s1">&#39;obs_intercept&#39;</span><span class="p">,</span> <span class="s1">&#39;state_intercept&#39;</span><span class="p">]:</span>
                    <span class="k">continue</span>
                <span class="n">representation</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

            <span class="c1"># Allow additional specification</span>
            <span class="n">warning</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;Model has time-invariant </span><span class="si">%s</span><span class="s1"> matrix, so the </span><span class="si">%s</span><span class="s1">&#39;</span>
                       <span class="s1">&#39; argument to `irf` has been ignored.&#39;</span><span class="p">)</span>
            <span class="n">exception</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;Impulse response functions for models with&#39;</span>
                         <span class="s1">&#39; time-varying </span><span class="si">%s</span><span class="s1"> matrix requires an updated&#39;</span>
                         <span class="s1">&#39; time-varying matrix for any periods beyond those in&#39;</span>
                         <span class="s1">&#39; the original model.&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">shape</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">shapes</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;obs&#39;</span><span class="p">,</span> <span class="s1">&#39;obs_intercept&#39;</span><span class="p">,</span> <span class="s1">&#39;state_intercept&#39;</span><span class="p">]:</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="n">representation</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                        <span class="n">warn</span><span class="p">(</span><span class="n">warning</span> <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">name</span><span class="p">),</span> <span class="n">ValueWarning</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">exception</span> <span class="o">%</span> <span class="n">name</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>
                    <span class="n">validate_matrix_shape</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">mat</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                          <span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">steps</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">mat</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;</span> <span class="mi">3</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">mat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">steps</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">exception</span> <span class="o">%</span> <span class="n">name</span><span class="p">)</span>
                    <span class="n">representation</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">representation</span><span class="p">[</span><span class="n">name</span><span class="p">],</span> <span class="n">mat</span><span class="p">]</span>

            <span class="c1"># Setup the new statespace representation</span>
            <span class="n">model_kwargs</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s1">&#39;filter_method&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_method</span><span class="p">,</span>
                <span class="s1">&#39;inversion_method&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">inversion_method</span><span class="p">,</span>
                <span class="s1">&#39;stability_method&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">stability_method</span><span class="p">,</span>
                <span class="s1">&#39;conserve_memory&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">conserve_memory</span><span class="p">,</span>
                <span class="s1">&#39;tolerance&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">tolerance</span><span class="p">,</span>
                <span class="s1">&#39;loglikelihood_burn&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">loglikelihood_burn</span>
            <span class="p">}</span>
            <span class="n">model_kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">representation</span><span class="p">)</span>
            <span class="n">model</span> <span class="o">=</span> <span class="n">KalmanFilter</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endog</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_states</span><span class="p">,</span>
                                 <span class="bp">self</span><span class="o">.</span><span class="n">k_posdef</span><span class="p">,</span> <span class="o">**</span><span class="n">model_kwargs</span><span class="p">)</span>
            <span class="n">model</span><span class="o">.</span><span class="n">initialize_approximate_diffuse</span><span class="p">()</span>
            <span class="n">model</span><span class="o">.</span><span class="n">_initialize_filter</span><span class="p">()</span>
            <span class="n">model</span><span class="o">.</span><span class="n">_initialize_state</span><span class="p">()</span>

            <span class="c1"># Get the impulse response function via simulation of the state</span>
            <span class="c1"># space model, but with other shocks set to zero</span>
            <span class="c1"># Since simulate returns the zero-th period, we need to simulate</span>
            <span class="c1"># steps + 1 periods and exclude the zero-th observation.</span>
            <span class="n">steps</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">measurement_shocks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">steps</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">))</span>
            <span class="n">state_shocks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">steps</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_posdef</span><span class="p">))</span>
            <span class="n">state_shocks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">impulse</span>
            <span class="n">irf</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">simulate</span><span class="p">(</span>
                <span class="n">steps</span><span class="p">,</span> <span class="n">measurement_shocks</span><span class="o">=</span><span class="n">measurement_shocks</span><span class="p">,</span>
                <span class="n">state_shocks</span><span class="o">=</span><span class="n">state_shocks</span><span class="p">)</span>
            <span class="n">irf</span> <span class="o">=</span> <span class="n">irf</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

        <span class="c1"># Get the cumulative response if requested</span>
        <span class="k">if</span> <span class="n">cumulative</span><span class="p">:</span>
            <span class="n">irf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">irf</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">irf</span></div></div>


<div class="viewcode-block" id="FilterResults"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.kalman_filter.FilterResults.html#statsmodels.tsa.statespace.kalman_filter.FilterResults">[docs]</a><span class="k">class</span> <span class="nc">FilterResults</span><span class="p">(</span><span class="n">FrozenRepresentation</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Results from applying the Kalman filter to a state space model.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    model : Representation</span>
<span class="sd">        A Statespace representation</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    nobs : int</span>
<span class="sd">        Number of observations.</span>
<span class="sd">    k_endog : int</span>
<span class="sd">        The dimension of the observation series.</span>
<span class="sd">    k_states : int</span>
<span class="sd">        The dimension of the unobserved state process.</span>
<span class="sd">    k_posdef : int</span>
<span class="sd">        The dimension of a guaranteed positive definite</span>
<span class="sd">        covariance matrix describing the shocks in the</span>
<span class="sd">        measurement equation.</span>
<span class="sd">    dtype : dtype</span>
<span class="sd">        Datatype of representation matrices</span>
<span class="sd">    prefix : str</span>
<span class="sd">        BLAS prefix of representation matrices</span>
<span class="sd">    shapes : dictionary of name,tuple</span>
<span class="sd">        A dictionary recording the shapes of each of the</span>
<span class="sd">        representation matrices as tuples.</span>
<span class="sd">    endog : array</span>
<span class="sd">        The observation vector.</span>
<span class="sd">    design : array</span>
<span class="sd">        The design matrix, :math:`Z`.</span>
<span class="sd">    obs_intercept : array</span>
<span class="sd">        The intercept for the observation equation, :math:`d`.</span>
<span class="sd">    obs_cov : array</span>
<span class="sd">        The covariance matrix for the observation equation :math:`H`.</span>
<span class="sd">    transition : array</span>
<span class="sd">        The transition matrix, :math:`T`.</span>
<span class="sd">    state_intercept : array</span>
<span class="sd">        The intercept for the transition equation, :math:`c`.</span>
<span class="sd">    selection : array</span>
<span class="sd">        The selection matrix, :math:`R`.</span>
<span class="sd">    state_cov : array</span>
<span class="sd">        The covariance matrix for the state equation :math:`Q`.</span>
<span class="sd">    missing : array of bool</span>
<span class="sd">        An array of the same size as `endog`, filled</span>
<span class="sd">        with boolean values that are True if the</span>
<span class="sd">        corresponding entry in `endog` is NaN and False</span>
<span class="sd">        otherwise.</span>
<span class="sd">    nmissing : array of int</span>
<span class="sd">        An array of size `nobs`, where the ith entry</span>
<span class="sd">        is the number (between 0 and `k_endog`) of NaNs in</span>
<span class="sd">        the ith row of the `endog` array.</span>
<span class="sd">    time_invariant : bool</span>
<span class="sd">        Whether or not the representation matrices are time-invariant</span>
<span class="sd">    initialization : str</span>
<span class="sd">        Kalman filter initialization method.</span>
<span class="sd">    initial_state : array_like</span>
<span class="sd">        The state vector used to initialize the Kalamn filter.</span>
<span class="sd">    initial_state_cov : array_like</span>
<span class="sd">        The state covariance matrix used to initialize the Kalamn filter.</span>
<span class="sd">    filter_method : int</span>
<span class="sd">        Bitmask representing the Kalman filtering method</span>
<span class="sd">    inversion_method : int</span>
<span class="sd">        Bitmask representing the method used to</span>
<span class="sd">        invert the forecast error covariance matrix.</span>
<span class="sd">    stability_method : int</span>
<span class="sd">        Bitmask representing the methods used to promote</span>
<span class="sd">        numerical stability in the Kalman filter</span>
<span class="sd">        recursions.</span>
<span class="sd">    conserve_memory : int</span>
<span class="sd">        Bitmask representing the selected memory conservation method.</span>
<span class="sd">    filter_timing : int</span>
<span class="sd">        Whether or not to use the alternate timing convention.</span>
<span class="sd">    tolerance : float</span>
<span class="sd">        The tolerance at which the Kalman filter</span>
<span class="sd">        determines convergence to steady-state.</span>
<span class="sd">    loglikelihood_burn : int</span>
<span class="sd">        The number of initial periods during which</span>
<span class="sd">        the loglikelihood is not recorded.</span>
<span class="sd">    converged : bool</span>
<span class="sd">        Whether or not the Kalman filter converged.</span>
<span class="sd">    period_converged : int</span>
<span class="sd">        The time period in which the Kalman filter converged.</span>
<span class="sd">    filtered_state : array</span>
<span class="sd">        The filtered state vector at each time period.</span>
<span class="sd">    filtered_state_cov : array</span>
<span class="sd">        The filtered state covariance matrix at each time period.</span>
<span class="sd">    predicted_state : array</span>
<span class="sd">        The predicted state vector at each time period.</span>
<span class="sd">    predicted_state_cov : array</span>
<span class="sd">        The predicted state covariance matrix at each time period.</span>
<span class="sd">    kalman_gain : array</span>
<span class="sd">        The Kalman gain at each time period.</span>
<span class="sd">    forecasts : array</span>
<span class="sd">        The one-step-ahead forecasts of observations at each time period.</span>
<span class="sd">    forecasts_error : array</span>
<span class="sd">        The forecast errors at each time period.</span>
<span class="sd">    forecasts_error_cov : array</span>
<span class="sd">        The forecast error covariance matrices at each time period.</span>
<span class="sd">    llf_obs : array</span>
<span class="sd">        The loglikelihood values at each time period.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_filter_attributes</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s1">&#39;filter_method&#39;</span><span class="p">,</span> <span class="s1">&#39;inversion_method&#39;</span><span class="p">,</span> <span class="s1">&#39;stability_method&#39;</span><span class="p">,</span>
        <span class="s1">&#39;conserve_memory&#39;</span><span class="p">,</span> <span class="s1">&#39;filter_timing&#39;</span><span class="p">,</span> <span class="s1">&#39;tolerance&#39;</span><span class="p">,</span> <span class="s1">&#39;loglikelihood_burn&#39;</span><span class="p">,</span>
        <span class="s1">&#39;converged&#39;</span><span class="p">,</span> <span class="s1">&#39;period_converged&#39;</span><span class="p">,</span> <span class="s1">&#39;filtered_state&#39;</span><span class="p">,</span>
        <span class="s1">&#39;filtered_state_cov&#39;</span><span class="p">,</span> <span class="s1">&#39;predicted_state&#39;</span><span class="p">,</span> <span class="s1">&#39;predicted_state_cov&#39;</span><span class="p">,</span>
        <span class="s1">&#39;tmp1&#39;</span><span class="p">,</span> <span class="s1">&#39;tmp2&#39;</span><span class="p">,</span> <span class="s1">&#39;tmp3&#39;</span><span class="p">,</span> <span class="s1">&#39;tmp4&#39;</span><span class="p">,</span> <span class="s1">&#39;forecasts&#39;</span><span class="p">,</span>
        <span class="s1">&#39;forecasts_error&#39;</span><span class="p">,</span> <span class="s1">&#39;forecasts_error_cov&#39;</span><span class="p">,</span> <span class="s1">&#39;llf_obs&#39;</span><span class="p">,</span>
        <span class="s1">&#39;collapsed_forecasts&#39;</span><span class="p">,</span> <span class="s1">&#39;collapsed_forecasts_error&#39;</span><span class="p">,</span>
        <span class="s1">&#39;collapsed_forecasts_error_cov&#39;</span><span class="p">,</span>
    <span class="p">]</span>

    <span class="n">_filter_options</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">KalmanFilter</span><span class="o">.</span><span class="n">filter_methods</span> <span class="o">+</span> <span class="n">KalmanFilter</span><span class="o">.</span><span class="n">stability_methods</span> <span class="o">+</span>
        <span class="n">KalmanFilter</span><span class="o">.</span><span class="n">inversion_methods</span> <span class="o">+</span> <span class="n">KalmanFilter</span><span class="o">.</span><span class="n">memory_options</span>
    <span class="p">)</span>

    <span class="n">_attributes</span> <span class="o">=</span> <span class="n">FrozenRepresentation</span><span class="o">.</span><span class="n">_model_attributes</span> <span class="o">+</span> <span class="n">_filter_attributes</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">FilterResults</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>

        <span class="c1"># Setup caches for uninitialized objects</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_kalman_gain</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_standardized_forecasts_error</span> <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="FilterResults.update_representation"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.kalman_filter.FilterResults.update_representation.html#statsmodels.tsa.statespace.kalman_filter.FilterResults.update_representation">[docs]</a>    <span class="k">def</span> <span class="nf">update_representation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">only_options</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update the results to match a given model</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        model : Representation</span>
<span class="sd">            The model object from which to take the updated values.</span>
<span class="sd">        only_options : boolean, optional</span>
<span class="sd">            If set to true, only the filter options are updated, and the state</span>
<span class="sd">            space representation is not updated. Default is False.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method is rarely required except for internal usage.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">only_options</span><span class="p">:</span>
            <span class="nb">super</span><span class="p">(</span><span class="n">FilterResults</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">update_representation</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>

        <span class="c1"># Save the options as boolean variables</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filter_options</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span></div>

<div class="viewcode-block" id="FilterResults.update_filter"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.kalman_filter.FilterResults.update_filter.html#statsmodels.tsa.statespace.kalman_filter.FilterResults.update_filter">[docs]</a>    <span class="k">def</span> <span class="nf">update_filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kalman_filter</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update the filter results</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        kalman_filter : statespace.kalman_filter.KalmanFilter</span>
<span class="sd">            The model object from which to take the updated values.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method is rarely required except for internal usage.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># State initialization</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initial_state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="n">kalman_filter</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">initial_state</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initial_state_cov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="n">kalman_filter</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">initial_state_cov</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>

        <span class="c1"># Save Kalman filter parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filter_method</span> <span class="o">=</span> <span class="n">kalman_filter</span><span class="o">.</span><span class="n">filter_method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inversion_method</span> <span class="o">=</span> <span class="n">kalman_filter</span><span class="o">.</span><span class="n">inversion_method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stability_method</span> <span class="o">=</span> <span class="n">kalman_filter</span><span class="o">.</span><span class="n">stability_method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">conserve_memory</span> <span class="o">=</span> <span class="n">kalman_filter</span><span class="o">.</span><span class="n">conserve_memory</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filter_timing</span> <span class="o">=</span> <span class="n">kalman_filter</span><span class="o">.</span><span class="n">filter_timing</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tolerance</span> <span class="o">=</span> <span class="n">kalman_filter</span><span class="o">.</span><span class="n">tolerance</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loglikelihood_burn</span> <span class="o">=</span> <span class="n">kalman_filter</span><span class="o">.</span><span class="n">loglikelihood_burn</span>

        <span class="c1"># Save Kalman filter output</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">converged</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">kalman_filter</span><span class="o">.</span><span class="n">converged</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">period_converged</span> <span class="o">=</span> <span class="n">kalman_filter</span><span class="o">.</span><span class="n">period_converged</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">filtered_state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">kalman_filter</span><span class="o">.</span><span class="n">filtered_state</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filtered_state_cov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="n">kalman_filter</span><span class="o">.</span><span class="n">filtered_state_cov</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">predicted_state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="n">kalman_filter</span><span class="o">.</span><span class="n">predicted_state</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">predicted_state_cov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="n">kalman_filter</span><span class="o">.</span><span class="n">predicted_state_cov</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>

        <span class="c1"># Reset caches</span>
        <span class="n">has_missing</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nmissing</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compatibility_mode</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">memory_no_std_forecast</span> <span class="ow">or</span>
                                                 <span class="bp">self</span><span class="o">.</span><span class="n">invert_lu</span> <span class="ow">or</span>
                                                 <span class="bp">self</span><span class="o">.</span><span class="n">solve_lu</span> <span class="ow">or</span>
                                                 <span class="bp">self</span><span class="o">.</span><span class="n">filter_collapsed</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">has_missing</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_standardized_forecasts_error</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                    <span class="n">reorder_missing_vector</span><span class="p">(</span>
                        <span class="n">kalman_filter</span><span class="o">.</span><span class="n">standardized_forecast_error</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">missing</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">prefix</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_standardized_forecasts_error</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                    <span class="n">kalman_filter</span><span class="o">.</span><span class="n">standardized_forecast_error</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_standardized_forecasts_error</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compatibility_mode</span><span class="p">:</span>
            <span class="c1"># In the partially missing data case, all entries will</span>
            <span class="c1"># be in the upper left submatrix rather than the correct placement</span>
            <span class="c1"># Re-ordering does not make sense in the collapsed case.</span>
            <span class="k">if</span> <span class="n">has_missing</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">memory_no_gain</span> <span class="ow">and</span>
                                <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_collapsed</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_kalman_gain</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">reorder_missing_matrix</span><span class="p">(</span>
                    <span class="n">kalman_filter</span><span class="o">.</span><span class="n">kalman_gain</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">missing</span><span class="p">,</span> <span class="n">reorder_cols</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="n">prefix</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">prefix</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">tmp1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">reorder_missing_matrix</span><span class="p">(</span>
                    <span class="n">kalman_filter</span><span class="o">.</span><span class="n">tmp1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">missing</span><span class="p">,</span> <span class="n">reorder_cols</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="n">prefix</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">prefix</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">tmp2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">reorder_missing_vector</span><span class="p">(</span>
                    <span class="n">kalman_filter</span><span class="o">.</span><span class="n">tmp2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">missing</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">prefix</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">tmp3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">reorder_missing_matrix</span><span class="p">(</span>
                    <span class="n">kalman_filter</span><span class="o">.</span><span class="n">tmp3</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">missing</span><span class="p">,</span> <span class="n">reorder_rows</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="n">prefix</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">prefix</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">tmp4</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">reorder_missing_matrix</span><span class="p">(</span>
                    <span class="n">kalman_filter</span><span class="o">.</span><span class="n">tmp4</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">missing</span><span class="p">,</span> <span class="n">reorder_cols</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="n">reorder_rows</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">prefix</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_kalman_gain</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                    <span class="n">kalman_filter</span><span class="o">.</span><span class="n">kalman_gain</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">tmp1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">kalman_filter</span><span class="o">.</span><span class="n">tmp1</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">tmp2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">kalman_filter</span><span class="o">.</span><span class="n">tmp2</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">tmp3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">kalman_filter</span><span class="o">.</span><span class="n">tmp3</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">tmp4</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">kalman_filter</span><span class="o">.</span><span class="n">tmp4</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_kalman_gain</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Note: use forecasts rather than forecast, so as not to interfer</span>
        <span class="c1"># with the `forecast` methods in subclasses</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">forecasts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">kalman_filter</span><span class="o">.</span><span class="n">forecast</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">forecasts_error</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="n">kalman_filter</span><span class="o">.</span><span class="n">forecast_error</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">forecasts_error_cov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="n">kalman_filter</span><span class="o">.</span><span class="n">forecast_error_cov</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">llf_obs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">kalman_filter</span><span class="o">.</span><span class="n">loglikelihood</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># If there was missing data, save the original values from the Kalman</span>
        <span class="c1"># filter output, since below will set the values corresponding to</span>
        <span class="c1"># the missing observations to nans.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">missing_forecasts</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">missing_forecasts_error</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">missing_forecasts_error_cov</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nmissing</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Copy the provided arrays (which are as the Kalman filter dataset)</span>
            <span class="c1"># into new variables</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">missing_forecasts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">forecasts</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">missing_forecasts_error</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">forecasts_error</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">missing_forecasts_error_cov</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">forecasts_error_cov</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="c1"># Save the collapsed values</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">collapsed_forecasts</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">collapsed_forecasts_error</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">collapsed_forecasts_error_cov</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_collapsed</span><span class="p">:</span>
            <span class="c1"># Copy the provided arrays (which are from the collapsed dataset)</span>
            <span class="c1"># into new variables</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">collapsed_forecasts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">forecasts</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">k_states</span><span class="p">,</span> <span class="p">:]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">collapsed_forecasts_error</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">forecasts_error</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">k_states</span><span class="p">,</span> <span class="p">:]</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">collapsed_forecasts_error_cov</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">forecasts_error_cov</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">k_states</span><span class="p">,</span> <span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">k_states</span><span class="p">,</span> <span class="p">:]</span>
            <span class="p">)</span>
            <span class="c1"># Recreate the original arrays (which should be from the original</span>
            <span class="c1"># dataset) in the appropriate dimension</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">forecasts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">forecasts_error</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">forecasts_error_cov</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="p">))</span>
            <span class="p">)</span>

        <span class="c1"># Fill in missing values in the forecast, forecast error, and</span>
        <span class="c1"># forecast error covariance matrix (this is required due to how the</span>
        <span class="c1"># Kalman filter implements observations that are either partly or</span>
        <span class="c1"># completely missing)</span>
        <span class="c1"># Construct the predictions, forecasts</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">memory_no_forecast</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">memory_no_predicted</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="p">):</span>
                <span class="n">design_t</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">design</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">t</span>
                <span class="n">obs_cov_t</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">obs_cov</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">t</span>
                <span class="n">obs_intercept_t</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">obs_intercept</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">t</span>

                <span class="c1"># For completely missing observations, the Kalman filter will</span>
                <span class="c1"># produce forecasts, but forecast errors and the forecast</span>
                <span class="c1"># error covariance matrix will be zeros - make them nan to</span>
                <span class="c1"># improve clarity of results.</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nmissing</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">mask</span> <span class="o">=</span> <span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">missing</span><span class="p">[:,</span> <span class="n">t</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>
                    <span class="c1"># We can recover forecasts</span>
                    <span class="c1"># For partially missing observations, the Kalman filter</span>
                    <span class="c1"># will produce all elements (forecasts, forecast errors,</span>
                    <span class="c1"># forecast error covariance matrices) as usual, but their</span>
                    <span class="c1"># dimension will only be equal to the number of non-missing</span>
                    <span class="c1"># elements, and their location in memory will be in the</span>
                    <span class="c1"># first blocks (e.g. for the forecasts_error, the first</span>
                    <span class="c1"># k_endog - nmissing[t] columns will be filled in),</span>
                    <span class="c1"># regardless of which endogenous variables they refer to</span>
                    <span class="c1"># (i.e. the non- missing endogenous variables for that</span>
                    <span class="c1"># observation). Furthermore, the forecast error covariance</span>
                    <span class="c1"># matrix is only valid for those elements. What is done is</span>
                    <span class="c1"># to set all elements to nan for these observations so that</span>
                    <span class="c1"># they are flagged as missing. The variables</span>
                    <span class="c1"># missing_forecasts, etc. then provide the forecasts, etc.</span>
                    <span class="c1"># provided by the Kalman filter, from which the data can be</span>
                    <span class="c1"># retrieved if desired.</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">forecasts</span><span class="p">[:,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">design</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">design_t</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">predicted_state</span><span class="p">[:,</span> <span class="n">t</span><span class="p">]</span>
                    <span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">obs_intercept</span><span class="p">[:,</span> <span class="n">obs_intercept_t</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">forecasts_error</span><span class="p">[:,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">forecasts_error</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">endog</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">forecasts</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span> <span class="n">t</span><span class="p">])</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">forecasts_error_cov</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">design</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">design_t</span><span class="p">],</span>
                               <span class="bp">self</span><span class="o">.</span><span class="n">predicted_state_cov</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">t</span><span class="p">]),</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">design</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">design_t</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>
                    <span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">obs_cov</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">obs_cov_t</span><span class="p">]</span>
                <span class="c1"># In the collapsed case, everything just needs to be rebuilt</span>
                <span class="c1"># for the original observed data, since the Kalman filter</span>
                <span class="c1"># produced these values for the collapsed data.</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_collapsed</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">forecasts</span><span class="p">[:,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">design</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">design_t</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">predicted_state</span><span class="p">[:,</span> <span class="n">t</span><span class="p">]</span>
                    <span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">obs_intercept</span><span class="p">[:,</span> <span class="n">obs_intercept_t</span><span class="p">]</span>

                    <span class="bp">self</span><span class="o">.</span><span class="n">forecasts_error</span><span class="p">[:,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">endog</span><span class="p">[:,</span> <span class="n">t</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">forecasts</span><span class="p">[:,</span> <span class="n">t</span><span class="p">]</span>
                    <span class="p">)</span>

                    <span class="bp">self</span><span class="o">.</span><span class="n">forecasts_error_cov</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">design</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">design_t</span><span class="p">],</span>
                               <span class="bp">self</span><span class="o">.</span><span class="n">predicted_state_cov</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">t</span><span class="p">]),</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">design</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">design_t</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>
                    <span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">obs_cov</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">obs_cov_t</span><span class="p">]</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">kalman_gain</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Kalman gain matrices</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kalman_gain</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># k x n</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_kalman_gain</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_states</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="p">):</span>
                <span class="c1"># In the case of entirely missing observations, let the Kalman</span>
                <span class="c1"># gain be zeros.</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nmissing</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="n">design_t</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">design</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">t</span>
                <span class="n">transition_t</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">transition</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">t</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nmissing</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_kalman_gain</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">transition</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">transition_t</span><span class="p">],</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">predicted_state_cov</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">t</span><span class="p">]</span>
                        <span class="p">),</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
                            <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">design</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">design_t</span><span class="p">]),</span>
                            <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">forecasts_error_cov</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">t</span><span class="p">])</span>
                        <span class="p">)</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">mask</span> <span class="o">=</span> <span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">missing</span><span class="p">[:,</span> <span class="n">t</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>
                    <span class="n">F</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">forecasts_error_cov</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="p">[</span><span class="n">t</span><span class="p">])]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_kalman_gain</span><span class="p">[:,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">transition</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">transition_t</span><span class="p">],</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">predicted_state_cov</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">t</span><span class="p">]</span>
                        <span class="p">),</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
                            <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">design</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span> <span class="p">:,</span> <span class="n">design_t</span><span class="p">]),</span>
                            <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">F</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">])</span>
                        <span class="p">)</span>
                    <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kalman_gain</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">standardized_forecasts_error</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Standardized forecast errors</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The forecast errors produced by the Kalman filter are</span>

<span class="sd">        .. math::</span>

<span class="sd">            v_t \sim N(0, F_t)</span>

<span class="sd">        Hypothesis tests are usually applied to the standardized residuals</span>

<span class="sd">        .. math::</span>

<span class="sd">            v_t^s = B_t v_t \sim N(0, I)</span>

<span class="sd">        where :math:`B_t = L_t^{-1}` and :math:`F_t = L_t L_t&#39;`; then</span>
<span class="sd">        :math:`F_t^{-1} = (L_t&#39;)^{-1} L_t^{-1} = B_t&#39; B_t`; :math:`B_t`</span>
<span class="sd">        and :math:`L_t` are lower triangular. Finally,</span>
<span class="sd">        :math:`B_t v_t \sim N(0, B_t F_t B_t&#39;)` and</span>
<span class="sd">        :math:`B_t F_t B_t&#39; = L_t^{-1} L_t L_t&#39; (L_t&#39;)^{-1} = I`.</span>

<span class="sd">        Thus we can rewrite :math:`v_t^s = L_t^{-1} v_t` or</span>
<span class="sd">        :math:`L_t v_t^s = v_t`; the latter equation is the form required to</span>
<span class="sd">        use a linear solver to recover :math:`v_t^s`. Since :math:`L_t` is</span>
<span class="sd">        lower triangular, we can use a triangular solver (?TRTRS).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_standardized_forecasts_error</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_standardized_forecasts_error</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">forecasts_error</span> <span class="o">/</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">forecasts_error_cov</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:]</span><span class="o">**</span><span class="mf">0.5</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="kn">from</span> <span class="nn">scipy</span> <span class="k">import</span> <span class="n">linalg</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_standardized_forecasts_error</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">forecasts_error</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">forecasts_error_cov</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]):</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nmissing</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_standardized_forecasts_error</span><span class="p">[:,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nmissing</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">:</span>
                        <span class="n">mask</span> <span class="o">=</span> <span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">missing</span><span class="p">[:,</span> <span class="n">t</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>
                        <span class="n">F</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">forecasts_error_cov</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="p">[</span><span class="n">t</span><span class="p">])]</span>
                        <span class="n">upper</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">cho_factor</span><span class="p">(</span><span class="n">F</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">])</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_standardized_forecasts_error</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="n">linalg</span><span class="o">.</span><span class="n">solve_triangular</span><span class="p">(</span>
                                <span class="n">upper</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">forecasts_error</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span> <span class="n">t</span><span class="p">],</span> <span class="n">trans</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_standardized_forecasts_error</span>

<div class="viewcode-block" id="FilterResults.predict"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.kalman_filter.FilterResults.predict.html#statsmodels.tsa.statespace.kalman_filter.FilterResults.predict">[docs]</a>    <span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dynamic</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        In-sample and out-of-sample prediction for state space models generally</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        start : int, optional</span>
<span class="sd">            Zero-indexed observation number at which to start forecasting,</span>
<span class="sd">            i.e., the first forecast will be at start.</span>
<span class="sd">        end : int, optional</span>
<span class="sd">            Zero-indexed observation number at which to end forecasting, i.e.,</span>
<span class="sd">            the last forecast will be at end.</span>
<span class="sd">        dynamic : int, optional</span>
<span class="sd">            Offset relative to `start` at which to begin dynamic prediction.</span>
<span class="sd">            Prior to this observation, true endogenous values will be used for</span>
<span class="sd">            prediction; starting with this observation and continuing through</span>
<span class="sd">            the end of prediction, forecasted endogenous values will be used</span>
<span class="sd">            instead.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            If the prediction range is outside of the sample range, any</span>
<span class="sd">            of the state space representation matrices that are time-varying</span>
<span class="sd">            must have updated values provided for the out-of-sample range.</span>
<span class="sd">            For example, of `obs_intercept` is a time-varying component and</span>
<span class="sd">            the prediction range extends 10 periods beyond the end of the</span>
<span class="sd">            sample, a (`k_endog` x 10) matrix must be provided with the new</span>
<span class="sd">            intercept values.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        results : kalman_filter.PredictionResults</span>
<span class="sd">            A PredictionResults object.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        All prediction is performed by applying the deterministic part of the</span>
<span class="sd">        measurement equation using the predicted state variables.</span>

<span class="sd">        Out-of-sample prediction first applies the Kalman filter to missing</span>
<span class="sd">        data for the number of periods desired to obtain the predicted states.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Cannot predict if we do not have appropriate arrays</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">memory_no_forecast</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">memory_no_predicted</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Predict is not possible if memory conservation&#39;</span>
                             <span class="s1">&#39; has been used to avoid storing forecasts or&#39;</span>
                             <span class="s1">&#39; predicted values.&#39;</span><span class="p">)</span>

        <span class="c1"># Get the start and the end of the entire prediction range</span>
        <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">elif</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Cannot predict values previous to the sample.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">end</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span>

        <span class="c1"># Prediction and forecasting is performed by iterating the Kalman</span>
        <span class="c1"># Kalman filter through the entire range [0, end]</span>
        <span class="c1"># Then, everything is returned corresponding to the range [start, end].</span>
        <span class="c1"># In order to perform the calculations, the range is separately split</span>
        <span class="c1"># up into the following categories:</span>
        <span class="c1"># - static:   (in-sample) the Kalman filter is run as usual</span>
        <span class="c1"># - dynamic:  (in-sample) the Kalman filter is run, but on missing data</span>
        <span class="c1"># - forecast: (out-of-sample) the Kalman filter is run, but on missing</span>
        <span class="c1">#             data</span>

        <span class="c1"># Short-circuit if end is before start</span>
        <span class="k">if</span> <span class="n">end</span> <span class="o">&lt;=</span> <span class="n">start</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;End of prediction must be after start.&#39;</span><span class="p">)</span>

        <span class="c1"># Get the number of forecasts to make after the end of the sample</span>
        <span class="n">nforecast</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">end</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="p">)</span>

        <span class="c1"># Get the number of dynamic prediction periods</span>

        <span class="c1"># If `dynamic=True`, then assume that we want to begin dynamic</span>
        <span class="c1"># prediction at the start of the sample prediction.</span>
        <span class="k">if</span> <span class="n">dynamic</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">dynamic</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># If `dynamic=False`, then assume we want no dynamic prediction</span>
        <span class="k">if</span> <span class="n">dynamic</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">dynamic</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">ndynamic</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">dynamic</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Replace the relative dynamic offset with an absolute offset</span>
            <span class="n">dynamic</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">dynamic</span>

            <span class="c1"># Validate the `dynamic` parameter</span>
            <span class="k">if</span> <span class="n">dynamic</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Dynamic prediction cannot begin prior to the&#39;</span>
                                 <span class="s1">&#39; first observation in the sample.&#39;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">dynamic</span> <span class="o">&gt;</span> <span class="n">end</span><span class="p">:</span>
                <span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Dynamic prediction specified to begin after the end of&#39;</span>
                     <span class="s1">&#39; prediction, and so has no effect.&#39;</span><span class="p">,</span> <span class="n">ValueWarning</span><span class="p">)</span>
                <span class="n">dynamic</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">elif</span> <span class="n">dynamic</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="p">:</span>
                <span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Dynamic prediction specified to begin during&#39;</span>
                     <span class="s1">&#39; out-of-sample forecasting period, and so has no&#39;</span>
                     <span class="s1">&#39; effect.&#39;</span><span class="p">,</span> <span class="n">ValueWarning</span><span class="p">)</span>
                <span class="n">dynamic</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="c1"># Get the total size of the desired dynamic forecasting component</span>
            <span class="c1"># Note: the first `dynamic` periods of prediction are actually</span>
            <span class="c1"># *not* dynamic, because dynamic prediction begins at observation</span>
            <span class="c1"># `dynamic`.</span>
            <span class="k">if</span> <span class="n">dynamic</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">ndynamic</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">end</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="p">)</span> <span class="o">-</span> <span class="n">dynamic</span><span class="p">)</span>

        <span class="c1"># Get the number of in-sample static predictions</span>
        <span class="n">nstatic</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">end</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="p">)</span> <span class="k">if</span> <span class="n">dynamic</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">dynamic</span>

        <span class="c1"># Construct the design and observation intercept and covariance</span>
        <span class="c1"># matrices for start-npadded:end. If not time-varying in the original</span>
        <span class="c1"># model, then they will be copied over if none are provided in</span>
        <span class="c1"># `kwargs`. Otherwise additional matrices must be provided in `kwargs`.</span>
        <span class="n">representation</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">shape</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">shapes</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;obs&#39;</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">representation</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

        <span class="c1"># Update the matrices from kwargs for forecasts</span>
        <span class="n">warning</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;Model has time-invariant </span><span class="si">%s</span><span class="s1"> matrix, so the </span><span class="si">%s</span><span class="s1">&#39;</span>
                   <span class="s1">&#39; argument to `predict` has been ignored.&#39;</span><span class="p">)</span>
        <span class="n">exception</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;Forecasting for models with time-varying </span><span class="si">%s</span><span class="s1"> matrix&#39;</span>
                     <span class="s1">&#39; requires an updated time-varying matrix for the&#39;</span>
                     <span class="s1">&#39; period to be forecasted.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">nforecast</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">shape</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">shapes</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;obs&#39;</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="n">representation</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                        <span class="n">warn</span><span class="p">(</span><span class="n">warning</span> <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">name</span><span class="p">),</span> <span class="n">ValueWarning</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">exception</span> <span class="o">%</span> <span class="n">name</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                        <span class="n">validate_vector_shape</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">mat</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                                              <span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">nforecast</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">mat</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">mat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">nforecast</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">exception</span> <span class="o">%</span> <span class="n">name</span><span class="p">)</span>
                        <span class="n">representation</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">representation</span><span class="p">[</span><span class="n">name</span><span class="p">],</span> <span class="n">mat</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">validate_matrix_shape</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">mat</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                              <span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">nforecast</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">mat</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;</span> <span class="mi">3</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">mat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">nforecast</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">exception</span> <span class="o">%</span> <span class="n">name</span><span class="p">)</span>
                        <span class="n">representation</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">representation</span><span class="p">[</span><span class="n">name</span><span class="p">],</span> <span class="n">mat</span><span class="p">]</span>

        <span class="c1"># Update the matrices from kwargs for dynamic prediction in the case</span>
        <span class="c1"># that `end` is less than `nobs` and `dynamic` is less than `end`. In</span>
        <span class="c1"># this case, any time-varying matrices in the default `representation`</span>
        <span class="c1"># will be too long, causing an error to be thrown below in the</span>
        <span class="c1"># KalmanFilter(...) construction call, because the endog has length</span>
        <span class="c1"># nstatic + ndynamic + nforecast, whereas the time-varying matrices</span>
        <span class="c1"># from `representation` have length nobs.</span>
        <span class="k">if</span> <span class="n">ndynamic</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">end</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">shape</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">shapes</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;obs&#39;</span> <span class="ow">and</span> <span class="n">representation</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">representation</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">representation</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="o">...</span><span class="p">,</span> <span class="p">:</span><span class="n">end</span><span class="p">]</span>

        <span class="c1"># Construct the predicted state and covariance matrix for each time</span>
        <span class="c1"># period depending on whether that time period corresponds to</span>
        <span class="c1"># one-step-ahead prediction, dynamic prediction, or out-of-sample</span>
        <span class="c1"># forecasting.</span>

        <span class="c1"># If we only have simple prediction, then we can use the already saved</span>
        <span class="c1"># Kalman filter output</span>
        <span class="k">if</span> <span class="n">ndynamic</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">nforecast</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">results</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Construct the new endogenous array.</span>
            <span class="n">endog</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">,</span> <span class="n">ndynamic</span> <span class="o">+</span> <span class="n">nforecast</span><span class="p">))</span>
            <span class="n">endog</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
            <span class="n">endog</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asfortranarray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">endog</span><span class="p">[:,</span> <span class="p">:</span><span class="n">nstatic</span><span class="p">],</span> <span class="n">endog</span><span class="p">])</span>

            <span class="c1"># Setup the new statespace representation</span>
            <span class="n">model_kwargs</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s1">&#39;filter_method&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_method</span><span class="p">,</span>
                <span class="s1">&#39;inversion_method&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">inversion_method</span><span class="p">,</span>
                <span class="s1">&#39;stability_method&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">stability_method</span><span class="p">,</span>
                <span class="s1">&#39;conserve_memory&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">conserve_memory</span><span class="p">,</span>
                <span class="s1">&#39;filter_timing&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_timing</span><span class="p">,</span>
                <span class="s1">&#39;tolerance&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">tolerance</span><span class="p">,</span>
                <span class="s1">&#39;loglikelihood_burn&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">loglikelihood_burn</span>
            <span class="p">}</span>
            <span class="n">model_kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">representation</span><span class="p">)</span>
            <span class="n">model</span> <span class="o">=</span> <span class="n">KalmanFilter</span><span class="p">(</span>
                <span class="n">endog</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_states</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_posdef</span><span class="p">,</span> <span class="o">**</span><span class="n">model_kwargs</span>
            <span class="p">)</span>
            <span class="n">model</span><span class="o">.</span><span class="n">initialize_known</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">initial_state</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">initial_state_cov</span>
            <span class="p">)</span>
            <span class="n">model</span><span class="o">.</span><span class="n">_initialize_filter</span><span class="p">()</span>
            <span class="n">model</span><span class="o">.</span><span class="n">_initialize_state</span><span class="p">()</span>

            <span class="n">results</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_predict</span><span class="p">(</span><span class="n">nstatic</span><span class="p">,</span> <span class="n">ndynamic</span><span class="p">,</span> <span class="n">nforecast</span><span class="p">,</span> <span class="n">model</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">PredictionResults</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">nstatic</span><span class="p">,</span> <span class="n">ndynamic</span><span class="p">,</span>
                                 <span class="n">nforecast</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nstatic</span><span class="p">,</span> <span class="n">ndynamic</span><span class="p">,</span> <span class="n">nforecast</span><span class="p">,</span> <span class="n">model</span><span class="p">):</span>
        <span class="c1"># Note: this doesn&#39;t use self, and can either be a static method or</span>
        <span class="c1">#       moved outside the class altogether.</span>

        <span class="c1"># Get the underlying filter</span>
        <span class="n">kfilter</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">_kalman_filter</span>

        <span class="c1"># Save this (which shares memory with the memoryview on which the</span>
        <span class="c1"># Kalman filter will be operating) so that we can replace actual data</span>
        <span class="c1"># with predicted data during dynamic forecasting</span>
        <span class="n">endog</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">_representations</span><span class="p">[</span><span class="n">model</span><span class="o">.</span><span class="n">prefix</span><span class="p">][</span><span class="s1">&#39;obs&#39;</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">kfilter</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">nobs</span><span class="p">):</span>
            <span class="c1"># Run the Kalman filter for the first `nstatic` periods (for</span>
            <span class="c1"># which dynamic computation will not be performed)</span>
            <span class="k">if</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="n">nstatic</span><span class="p">:</span>
                <span class="nb">next</span><span class="p">(</span><span class="n">kfilter</span><span class="p">)</span>
            <span class="c1"># Perform dynamic prediction</span>
            <span class="k">elif</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="n">nstatic</span> <span class="o">+</span> <span class="n">ndynamic</span><span class="p">:</span>
                <span class="n">design_t</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">model</span><span class="o">.</span><span class="n">design</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">t</span>
                <span class="n">obs_intercept_t</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">model</span><span class="o">.</span><span class="n">obs_intercept</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">t</span>

                <span class="c1"># Unconditional value is the intercept (often zeros)</span>
                <span class="n">endog</span><span class="p">[:,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">obs_intercept</span><span class="p">[:,</span> <span class="n">obs_intercept_t</span><span class="p">]</span>
                <span class="c1"># If t &gt; 0, then we can condition the forecast on the state</span>
                <span class="k">if</span> <span class="n">t</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># Predict endog[:, t] given `predicted_state` calculated in</span>
                    <span class="c1"># previous iteration (i.e. t-1)</span>
                    <span class="n">endog</span><span class="p">[:,</span> <span class="n">t</span><span class="p">]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
                        <span class="n">model</span><span class="o">.</span><span class="n">design</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">design_t</span><span class="p">],</span>
                        <span class="n">kfilter</span><span class="o">.</span><span class="n">predicted_state</span><span class="p">[:,</span> <span class="n">t</span><span class="p">]</span>
                    <span class="p">)</span>

                <span class="c1"># Advance Kalman filter</span>
                <span class="nb">next</span><span class="p">(</span><span class="n">kfilter</span><span class="p">)</span>
            <span class="c1"># Perform any (one-step-ahead) forecasting</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">next</span><span class="p">(</span><span class="n">kfilter</span><span class="p">)</span>

        <span class="c1"># Return the predicted state and predicted state covariance matrices</span>
        <span class="n">results</span> <span class="o">=</span> <span class="n">FilterResults</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>
        <span class="n">results</span><span class="o">.</span><span class="n">update_representation</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>
        <span class="n">results</span><span class="o">.</span><span class="n">update_filter</span><span class="p">(</span><span class="n">kfilter</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">results</span></div>


<div class="viewcode-block" id="PredictionResults"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.kalman_filter.PredictionResults.html#statsmodels.tsa.statespace.kalman_filter.PredictionResults">[docs]</a><span class="k">class</span> <span class="nc">PredictionResults</span><span class="p">(</span><span class="n">FilterResults</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Results of in-sample and out-of-sample prediction for state space models</span>
<span class="sd">    generally</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    results : FilterResults</span>
<span class="sd">        Output from filtering, corresponding to the prediction desired</span>
<span class="sd">    start : int</span>
<span class="sd">        Zero-indexed observation number at which to start forecasting,</span>
<span class="sd">        i.e., the first forecast will be at start.</span>
<span class="sd">    end : int</span>
<span class="sd">        Zero-indexed observation number at which to end forecasting, i.e.,</span>
<span class="sd">        the last forecast will be at end.</span>
<span class="sd">    nstatic : int</span>
<span class="sd">        Number of in-sample static predictions (these are always the first</span>
<span class="sd">        elements of the prediction output).</span>
<span class="sd">    ndynamic : int</span>
<span class="sd">        Number of in-sample dynamic predictions (these always follow the static</span>
<span class="sd">        predictions directly, and are directly followed by the forecasts).</span>
<span class="sd">    nforecast : int</span>
<span class="sd">        Number of in-sample forecasts (these always follow the dynamic</span>
<span class="sd">        predictions directly).</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    npredictions : int</span>
<span class="sd">        Number of observations in the predicted series; this is not necessarily</span>
<span class="sd">        the same as the number of observations in the original model from which</span>
<span class="sd">        prediction was performed.</span>
<span class="sd">    start : int</span>
<span class="sd">        Zero-indexed observation number at which to start prediction,</span>
<span class="sd">        i.e., the first predict will be at `start`; this is relative to the</span>
<span class="sd">        original model from which prediction was performed.</span>
<span class="sd">    end : int</span>
<span class="sd">        Zero-indexed observation number at which to end prediction,</span>
<span class="sd">        i.e., the last predict will be at `end`; this is relative to the</span>
<span class="sd">        original model from which prediction was performed.</span>
<span class="sd">    nstatic : int</span>
<span class="sd">        Number of in-sample static predictions.</span>
<span class="sd">    ndynamic : int</span>
<span class="sd">        Number of in-sample dynamic predictions.</span>
<span class="sd">    nforecast : int</span>
<span class="sd">        Number of in-sample forecasts.</span>
<span class="sd">    endog : array</span>
<span class="sd">        The observation vector.</span>
<span class="sd">    design : array</span>
<span class="sd">        The design matrix, :math:`Z`.</span>
<span class="sd">    obs_intercept : array</span>
<span class="sd">        The intercept for the observation equation, :math:`d`.</span>
<span class="sd">    obs_cov : array</span>
<span class="sd">        The covariance matrix for the observation equation :math:`H`.</span>
<span class="sd">    transition : array</span>
<span class="sd">        The transition matrix, :math:`T`.</span>
<span class="sd">    state_intercept : array</span>
<span class="sd">        The intercept for the transition equation, :math:`c`.</span>
<span class="sd">    selection : array</span>
<span class="sd">        The selection matrix, :math:`R`.</span>
<span class="sd">    state_cov : array</span>
<span class="sd">        The covariance matrix for the state equation :math:`Q`.</span>
<span class="sd">    filtered_state : array</span>
<span class="sd">        The filtered state vector at each time period.</span>
<span class="sd">    filtered_state_cov : array</span>
<span class="sd">        The filtered state covariance matrix at each time period.</span>
<span class="sd">    predicted_state : array</span>
<span class="sd">        The predicted state vector at each time period.</span>
<span class="sd">    predicted_state_cov : array</span>
<span class="sd">        The predicted state covariance matrix at each time period.</span>
<span class="sd">    forecasts : array</span>
<span class="sd">        The one-step-ahead forecasts of observations at each time period.</span>
<span class="sd">    forecasts_error : array</span>
<span class="sd">        The forecast errors at each time period.</span>
<span class="sd">    forecasts_error_cov : array</span>
<span class="sd">        The forecast error covariance matrices at each time period.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The provided ranges must be conformable, meaning that it must be that</span>
<span class="sd">    `end - start == nstatic + ndynamic + nforecast`.</span>

<span class="sd">    This class is essentially a view to the FilterResults object, but</span>
<span class="sd">    returning the appropriate ranges for everything.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">representation_attributes</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s1">&#39;endog&#39;</span><span class="p">,</span> <span class="s1">&#39;design&#39;</span><span class="p">,</span> <span class="s1">&#39;design&#39;</span><span class="p">,</span> <span class="s1">&#39;obs_intercept&#39;</span><span class="p">,</span>
        <span class="s1">&#39;obs_cov&#39;</span><span class="p">,</span> <span class="s1">&#39;transition&#39;</span><span class="p">,</span> <span class="s1">&#39;state_intercept&#39;</span><span class="p">,</span> <span class="s1">&#39;selection&#39;</span><span class="p">,</span>
        <span class="s1">&#39;state_cov&#39;</span>
    <span class="p">]</span>
    <span class="n">filter_attributes</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s1">&#39;filtered_state&#39;</span><span class="p">,</span> <span class="s1">&#39;filtered_state_cov&#39;</span><span class="p">,</span>
        <span class="s1">&#39;predicted_state&#39;</span><span class="p">,</span> <span class="s1">&#39;predicted_state_cov&#39;</span><span class="p">,</span>
        <span class="s1">&#39;forecasts&#39;</span><span class="p">,</span> <span class="s1">&#39;forecasts_error&#39;</span><span class="p">,</span> <span class="s1">&#39;forecasts_error_cov&#39;</span>
    <span class="p">]</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">results</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">nstatic</span><span class="p">,</span> <span class="n">ndynamic</span><span class="p">,</span> <span class="n">nforecast</span><span class="p">):</span>
        <span class="c1"># Save the filter results object</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">results</span> <span class="o">=</span> <span class="n">results</span>

        <span class="c1"># Save prediction ranges</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">npredictions</span> <span class="o">=</span> <span class="n">start</span> <span class="o">-</span> <span class="n">end</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">start</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">end</span> <span class="o">=</span> <span class="n">end</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nstatic</span> <span class="o">=</span> <span class="n">nstatic</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ndynamic</span> <span class="o">=</span> <span class="n">ndynamic</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nforecast</span> <span class="o">=</span> <span class="n">nforecast</span>

    <span class="k">def</span> <span class="nf">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Provide access to the representation and filtered output in the</span>
<span class="sd">        appropriate range (`start` - `end`).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Prevent infinite recursive lookups</span>
        <span class="k">if</span> <span class="n">attr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;_&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;&#39;</span><span class="si">%s</span><span class="s2">&#39; object has no attribute &#39;</span><span class="si">%s</span><span class="s2">&#39;&quot;</span> <span class="o">%</span>
                                 <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">attr</span><span class="p">))</span>

        <span class="n">_attr</span> <span class="o">=</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">attr</span>

        <span class="c1"># Cache the attribute</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_attr</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">attr</span> <span class="o">==</span> <span class="s1">&#39;endog&#39;</span> <span class="ow">or</span> <span class="n">attr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_attributes</span><span class="p">:</span>
                <span class="c1"># Get a copy</span>
                <span class="n">value</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="c1"># Subset to the correct time frame</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">end</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">attr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">representation_attributes</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="c1"># If a time-invariant matrix, return it. Otherwise, subset to</span>
                <span class="c1"># the correct period.</span>
                <span class="k">if</span> <span class="n">value</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">end</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;&#39;</span><span class="si">%s</span><span class="s2">&#39; object has no attribute &#39;</span><span class="si">%s</span><span class="s2">&#39;&quot;</span> <span class="o">%</span>
                                     <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">attr</span><span class="p">))</span>

            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_attr</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_attr</span><span class="p">)</span></div>
</pre></div>




          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2009-2017, Josef Perktold, Skipper Seabold, Jonathan Taylor, statsmodels-developers.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.7.4.
    </div>
  </body>
</html>