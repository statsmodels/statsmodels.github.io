

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>statsmodels.tsa.regime_switching.markov_switching &#8212; statsmodels 0.9.0 documentation</title>
    <link rel="stylesheet" href="../../../../_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
    <script type="text/javascript" src="../../../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="shortcut icon" href="../../../../_static/statsmodels_hybi_favico.ico"/>
    <link rel="author" title="About these documents" href="../../../../about.html" />
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
<link rel="stylesheet" href="../../../../_static/examples.css" type="text/css" />
<link rel="stylesheet" href="../../../../_static/facebox.css" type="text/css" />
<script type="text/javascript" src="../../../../_static/scripts.js">
</script>
<script type="text/javascript" src="../../../../_static/facebox.js">
</script>
<script type="text/javascript">
$.facebox.settings.closeImage = "../../../../_static/closelabel.png"
$.facebox.settings.loadingImage = "../../../../_static/loading.gif"
</script>

  </head><body>
<div class="headerwrap">
    <div class = "header">
        
        <a href = "../../../../index.html">
<img src="../../../../_static/statsmodels_hybi_banner.png" alt="Logo"
    style="padding-left: 15px"/></a>
        
    </div>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
<li><a href ="../../../../install.html">Install</a></li> &nbsp;|&nbsp;
<li><a href="https://groups.google.com/forum/?hl=en#!forum/pystatsmodels">Support</a></li> &nbsp;|&nbsp;
<li><a href="https://github.com/statsmodels/statsmodels/issues">Bugs</a></li> &nbsp;|&nbsp;
<li><a href="../../../../dev/index.html">Develop</a></li> &nbsp;|&nbsp;
<li><a href="../../../../examples/index.html">Examples</a></li> &nbsp;|&nbsp;
<li><a href="../../../../faq.html">FAQ</a></li> &nbsp;|&nbsp;

          <li class="nav-item nav-item-1"><a href="../../../index.html" accesskey="U">Module code</a> |</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            




  <h1>Source code for statsmodels.tsa.regime_switching.markov_switching</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Markov switching models</span>

<span class="sd">Author: Chad Fulton</span>
<span class="sd">License: BSD-3</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">division</span><span class="p">,</span> <span class="n">absolute_import</span><span class="p">,</span> <span class="n">print_function</span>

<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">from</span> <span class="nn">statsmodels.compat.collections</span> <span class="k">import</span> <span class="n">OrderedDict</span>

<span class="kn">from</span> <span class="nn">scipy.misc</span> <span class="k">import</span> <span class="n">logsumexp</span>
<span class="kn">from</span> <span class="nn">statsmodels.base.data</span> <span class="k">import</span> <span class="n">PandasData</span>
<span class="kn">import</span> <span class="nn">statsmodels.tsa.base.tsa_model</span> <span class="k">as</span> <span class="nn">tsbase</span>
<span class="kn">from</span> <span class="nn">statsmodels.tools.tools</span> <span class="k">import</span> <span class="n">Bunch</span>
<span class="kn">from</span> <span class="nn">statsmodels.tools.numdiff</span> <span class="k">import</span> <span class="n">approx_fprime_cs</span><span class="p">,</span> <span class="n">approx_hess_cs</span>
<span class="kn">from</span> <span class="nn">statsmodels.tools.decorators</span> <span class="k">import</span> <span class="n">cache_readonly</span><span class="p">,</span> <span class="n">resettable_cache</span>
<span class="kn">from</span> <span class="nn">statsmodels.tools.eval_measures</span> <span class="k">import</span> <span class="n">aic</span><span class="p">,</span> <span class="n">bic</span><span class="p">,</span> <span class="n">hqic</span>
<span class="kn">from</span> <span class="nn">statsmodels.tools.tools</span> <span class="k">import</span> <span class="n">pinv_extended</span>
<span class="kn">from</span> <span class="nn">statsmodels.tools.sm_exceptions</span> <span class="k">import</span> <span class="n">EstimationWarning</span>
<span class="kn">import</span> <span class="nn">statsmodels.base.wrapper</span> <span class="k">as</span> <span class="nn">wrap</span>


<span class="kn">from</span> <span class="nn">statsmodels.tsa.statespace.tools</span> <span class="k">import</span> <span class="n">find_best_blas_type</span><span class="p">,</span> <span class="n">prepare_exog</span>

<span class="kn">from</span> <span class="nn">statsmodels.tsa.regime_switching._hamilton_filter</span> <span class="k">import</span> <span class="p">(</span>
    <span class="n">shamilton_filter</span><span class="p">,</span> <span class="n">dhamilton_filter</span><span class="p">,</span> <span class="n">chamilton_filter</span><span class="p">,</span> <span class="n">zhamilton_filter</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">statsmodels.tsa.regime_switching._kim_smoother</span> <span class="k">import</span> <span class="p">(</span>
    <span class="n">skim_smoother</span><span class="p">,</span> <span class="n">dkim_smoother</span><span class="p">,</span> <span class="n">ckim_smoother</span><span class="p">,</span> <span class="n">zkim_smoother</span><span class="p">)</span>

<span class="n">prefix_hamilton_filter_map</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;s&#39;</span><span class="p">:</span> <span class="n">shamilton_filter</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">:</span> <span class="n">dhamilton_filter</span><span class="p">,</span>
    <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="n">chamilton_filter</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">:</span> <span class="n">zhamilton_filter</span>
<span class="p">}</span>

<span class="n">prefix_kim_smoother_map</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;s&#39;</span><span class="p">:</span> <span class="n">skim_smoother</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">:</span> <span class="n">dkim_smoother</span><span class="p">,</span>
    <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="n">ckim_smoother</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">:</span> <span class="n">zkim_smoother</span>
<span class="p">}</span>


<span class="k">def</span> <span class="nf">_logistic</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Note that this is not a vectorized function</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="c1"># np.exp(x) / (1 + np.exp(x))</span>
    <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
    <span class="c1"># np.exp(x[i]) / (1 + np.sum(np.exp(x[:])))</span>
    <span class="k">elif</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
    <span class="c1"># np.exp(x[i,t]) / (1 + np.sum(np.exp(x[:,t])))</span>
    <span class="k">elif</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
    <span class="c1"># np.exp(x[i,j,t]) / (1 + np.sum(np.exp(x[:,j,t])))</span>
    <span class="k">elif</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">x</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">)),</span> <span class="n">y</span><span class="o">.</span><span class="n">T</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>
    <span class="n">evaluated</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">logsumexp</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)),</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">evaluated</span>


<span class="k">def</span> <span class="nf">_partials_logistic</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Note that this is not a vectorized function</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">tmp</span> <span class="o">=</span> <span class="n">_logistic</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="c1"># k</span>
    <span class="k">if</span> <span class="n">tmp</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">tmp</span> <span class="o">-</span> <span class="n">tmp</span><span class="o">**</span><span class="mi">2</span>
    <span class="c1"># k x k</span>
    <span class="k">elif</span> <span class="n">tmp</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">partials</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">tmp</span> <span class="o">-</span> <span class="n">tmp</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="c1"># k x k x t</span>
    <span class="k">elif</span> <span class="n">tmp</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">partials</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">tmp</span><span class="p">[:,</span> <span class="n">t</span><span class="p">]</span> <span class="o">-</span> <span class="n">tmp</span><span class="p">[:,</span> <span class="n">t</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">tmp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">tmp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">tmp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">partials</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">partials</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
    <span class="c1"># k x k x j x t</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">partials</span> <span class="o">=</span> <span class="p">[[</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">tmp</span><span class="p">[:,</span> <span class="n">j</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">-</span> <span class="n">tmp</span><span class="p">[:,</span> <span class="n">j</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
                     <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">tmp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">])]</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">tmp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">tmp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">tmp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">tmp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">partials</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">partials</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span>
            <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">tmp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
            <span class="n">partials</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">tmp</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">*</span> <span class="n">tmp</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
            <span class="n">partials</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">partials</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">partials</span>


<span class="k">def</span> <span class="nf">py_hamilton_filter</span><span class="p">(</span><span class="n">initial_probabilities</span><span class="p">,</span> <span class="n">regime_transition</span><span class="p">,</span>
                       <span class="n">conditional_likelihoods</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Hamilton filter using pure Python</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    initial_probabilities : array</span>
<span class="sd">        Array of initial probabilities, shaped (k_regimes,) giving the</span>
<span class="sd">        distribution of the regime process at time t = -order where order</span>
<span class="sd">        is a nonnegative integer.</span>
<span class="sd">    regime_transition : array</span>
<span class="sd">        Matrix of regime transition probabilities, shaped either</span>
<span class="sd">        (k_regimes, k_regimes, 1) or if there are time-varying transition</span>
<span class="sd">        probabilities (k_regimes, k_regimes, nobs + order).  Entry [i, j,</span>
<span class="sd">        t] contains the probability of moving from j at time t-1 to i at</span>
<span class="sd">        time t, so each matrix regime_transition[:, :, t] should be left</span>
<span class="sd">        stochastic.  The first order entries and initial_probabilities are</span>
<span class="sd">        used to produce the initial joint distribution of dimension order +</span>
<span class="sd">        1 at time t=0.</span>
<span class="sd">    conditional_likelihoods : array</span>
<span class="sd">        Array of likelihoods conditional on the last `order+1` regimes,</span>
<span class="sd">        shaped (k_regimes,)*(order + 1) + (nobs,).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    filtered_marginal_probabilities : array</span>
<span class="sd">        Array containing Pr[S_t=s_t | Y_t] - the probability of being in each</span>
<span class="sd">        regime conditional on time t information. Shaped (k_regimes, nobs).</span>
<span class="sd">    predicted_joint_probabilities : array</span>
<span class="sd">        Array containing Pr[S_t=s_t, ..., S_{t-order}=s_{t-order} | Y_{t-1}] -</span>
<span class="sd">        the joint probability of the current and previous `order` periods</span>
<span class="sd">        being in each combination of regimes conditional on time t-1</span>
<span class="sd">        information. Shaped (k_regimes,) * (order + 1) + (nobs,).</span>
<span class="sd">    joint_likelihoods : array</span>
<span class="sd">        Array of likelihoods condition on time t information, shaped (nobs,).</span>
<span class="sd">    filtered_joint_probabilities : array</span>
<span class="sd">        Array containing Pr[S_t=s_t, ..., S_{t-order}=s_{t-order} | Y_{t}] -</span>
<span class="sd">        the joint probability of the current and previous `order` periods</span>
<span class="sd">        being in each combination of regimes conditional on time t</span>
<span class="sd">        information. Shaped (k_regimes,) * (order + 1) + (nobs,).</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Dimensions</span>
    <span class="n">k_regimes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">initial_probabilities</span><span class="p">)</span>
    <span class="n">nobs</span> <span class="o">=</span> <span class="n">conditional_likelihoods</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">order</span> <span class="o">=</span> <span class="n">conditional_likelihoods</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">2</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="n">conditional_likelihoods</span><span class="o">.</span><span class="n">dtype</span>

    <span class="c1"># Check for compatible shapes.</span>
    <span class="n">incompatible_shapes</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">regime_transition</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nobs</span> <span class="o">+</span> <span class="n">order</span><span class="p">)</span>
        <span class="ow">or</span> <span class="n">regime_transition</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span> <span class="o">!=</span> <span class="p">(</span><span class="n">k_regimes</span><span class="p">,</span> <span class="n">k_regimes</span><span class="p">)</span>
        <span class="ow">or</span> <span class="n">conditional_likelihoods</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">k_regimes</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">incompatible_shapes</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Arguments do not have compatible shapes&#39;</span><span class="p">)</span>

    <span class="c1"># Storage</span>
    <span class="c1"># Pr[S_t = s_t | Y_t]</span>
    <span class="n">filtered_marginal_probabilities</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">k_regimes</span><span class="p">,</span> <span class="n">nobs</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">))</span>
    <span class="c1"># Pr[S_t = s_t, ... S_{t-r} = s_{t-r} | Y_{t-1}]</span>
    <span class="n">predicted_joint_probabilities</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
        <span class="p">(</span><span class="n">k_regimes</span><span class="p">,)</span> <span class="o">*</span> <span class="p">(</span><span class="n">order</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">nobs</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
    <span class="c1"># f(y_t | Y_{t-1})</span>
    <span class="n">joint_likelihoods</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nobs</span><span class="p">,),</span> <span class="n">dtype</span><span class="p">)</span>
    <span class="c1"># Pr[S_t = s_t, ... S_{t-r} = s_{t-r} | Y_t]</span>
    <span class="n">filtered_joint_probabilities</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
        <span class="p">(</span><span class="n">k_regimes</span><span class="p">,)</span> <span class="o">*</span> <span class="p">(</span><span class="n">order</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">nobs</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

    <span class="c1"># Initial probabilities</span>
    <span class="n">filtered_marginal_probabilities</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">initial_probabilities</span>
    <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">initial_probabilities</span><span class="p">)</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">k_regimes</span><span class="p">,</span> <span class="n">k_regimes</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">order</span><span class="p">):</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">regime_transition</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">i</span><span class="p">],</span> <span class="n">shape</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span> <span class="o">*</span> <span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="n">tmp</span>
    <span class="n">filtered_joint_probabilities</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span>

    <span class="c1"># Check that regime_transition is oriented correctly.</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">regime_transition</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;regime_transition does not contain &#39;</span>
                         <span class="s1">&#39;left stochastic matrices.&#39;</span><span class="p">)</span>

    <span class="c1"># Reshape regime_transition so we can use broadcasting</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">k_regimes</span><span class="p">,</span> <span class="n">k_regimes</span><span class="p">)</span>
    <span class="n">shape</span> <span class="o">+=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span> <span class="o">*</span> <span class="p">(</span><span class="n">order</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">shape</span> <span class="o">+=</span> <span class="p">(</span><span class="n">regime_transition</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],)</span>
    <span class="n">regime_transition</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">regime_transition</span><span class="p">,</span> <span class="n">shape</span><span class="p">)</span>

    <span class="c1"># Get appropriate subset of transition matrix</span>
    <span class="k">if</span> <span class="n">regime_transition</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">regime_transition</span> <span class="o">=</span> <span class="n">regime_transition</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">order</span><span class="p">:]</span>

    <span class="c1"># Hamilton filter iterations</span>
    <span class="n">transition_t</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nobs</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">regime_transition</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">transition_t</span> <span class="o">=</span> <span class="n">t</span>

        <span class="c1"># S_t, S_{t-1}, ..., S_{t-r} | t-1, stored at zero-indexed location t</span>
        <span class="k">if</span> <span class="n">order</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">predicted_joint_probabilities</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="c1"># S_t | S_{t-1}</span>
                <span class="n">regime_transition</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">transition_t</span><span class="p">]</span> <span class="o">*</span>
                <span class="c1"># S_{t-1}, S_{t-2}, ..., S_{t-r} | t-1</span>
                <span class="n">filtered_joint_probabilities</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">predicted_joint_probabilities</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">regime_transition</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">transition_t</span><span class="p">],</span>
                       <span class="n">filtered_joint_probabilities</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">t</span><span class="p">]))</span>

        <span class="c1"># f(y_t, S_t, ..., S_{t-r} | t-1)</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="p">(</span><span class="n">conditional_likelihoods</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">*</span>
               <span class="n">predicted_joint_probabilities</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">t</span><span class="p">])</span>
        <span class="c1"># f(y_t | t-1)</span>
        <span class="n">joint_likelihoods</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>

        <span class="c1"># S_t, S_{t-1}, ..., S_{t-r} | t, stored at index t+1</span>
        <span class="n">filtered_joint_probabilities</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">t</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">tmp</span> <span class="o">/</span> <span class="n">joint_likelihoods</span><span class="p">[</span><span class="n">t</span><span class="p">])</span>

    <span class="c1"># S_t | t</span>
    <span class="n">filtered_marginal_probabilities</span> <span class="o">=</span> <span class="n">filtered_joint_probabilities</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">:]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">filtered_marginal_probabilities</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">filtered_marginal_probabilities</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
            <span class="n">filtered_marginal_probabilities</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">2</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">filtered_marginal_probabilities</span><span class="p">,</span> <span class="n">predicted_joint_probabilities</span><span class="p">,</span>
            <span class="n">joint_likelihoods</span><span class="p">,</span> <span class="n">filtered_joint_probabilities</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">:])</span>


<span class="k">def</span> <span class="nf">cy_hamilton_filter</span><span class="p">(</span><span class="n">initial_probabilities</span><span class="p">,</span> <span class="n">regime_transition</span><span class="p">,</span>
                       <span class="n">conditional_likelihoods</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Hamilton filter using Cython inner loop</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    initial_probabilities : array</span>
<span class="sd">        Array of initial probabilities, shaped (k_regimes,) giving the</span>
<span class="sd">        distribution of the regime process at time t = -order where order</span>
<span class="sd">        is a nonnegative integer.</span>
<span class="sd">    regime_transition : array</span>
<span class="sd">        Matrix of regime transition probabilities, shaped either</span>
<span class="sd">        (k_regimes, k_regimes, 1) or if there are time-varying transition</span>
<span class="sd">        probabilities (k_regimes, k_regimes, nobs + order).  Entry [i, j,</span>
<span class="sd">        t] contains the probability of moving from j at time t-1 to i at</span>
<span class="sd">        time t, so each matrix regime_transition[:, :, t] should be left</span>
<span class="sd">        stochastic.  The first order entries and initial_probabilities are</span>
<span class="sd">        used to produce the initial joint distribution of dimension order +</span>
<span class="sd">        1 at time t=0.</span>
<span class="sd">    conditional_likelihoods : array</span>
<span class="sd">        Array of likelihoods conditional on the last `order+1` regimes,</span>
<span class="sd">        shaped (k_regimes,)*(order + 1) + (nobs,).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    filtered_marginal_probabilities : array</span>
<span class="sd">        Array containing Pr[S_t=s_t | Y_t] - the probability of being in each</span>
<span class="sd">        regime conditional on time t information. Shaped (k_regimes, nobs).</span>
<span class="sd">    predicted_joint_probabilities : array</span>
<span class="sd">        Array containing Pr[S_t=s_t, ..., S_{t-order}=s_{t-order} | Y_{t-1}] -</span>
<span class="sd">        the joint probability of the current and previous `order` periods</span>
<span class="sd">        being in each combination of regimes conditional on time t-1</span>
<span class="sd">        information. Shaped (k_regimes,) * (order + 1) + (nobs,).</span>
<span class="sd">    joint_likelihoods : array</span>
<span class="sd">        Array of likelihoods condition on time t information, shaped (nobs,).</span>
<span class="sd">    filtered_joint_probabilities : array</span>
<span class="sd">        Array containing Pr[S_t=s_t, ..., S_{t-order}=s_{t-order} | Y_{t}] -</span>
<span class="sd">        the joint probability of the current and previous `order` periods</span>
<span class="sd">        being in each combination of regimes conditional on time t</span>
<span class="sd">        information. Shaped (k_regimes,) * (order + 1) + (nobs,).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Dimensions</span>
    <span class="n">k_regimes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">initial_probabilities</span><span class="p">)</span>
    <span class="n">nobs</span> <span class="o">=</span> <span class="n">conditional_likelihoods</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">order</span> <span class="o">=</span> <span class="n">conditional_likelihoods</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">2</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="n">conditional_likelihoods</span><span class="o">.</span><span class="n">dtype</span>

    <span class="c1"># Check for compatible shapes.</span>
    <span class="n">incompatible_shapes</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">regime_transition</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nobs</span> <span class="o">+</span> <span class="n">order</span><span class="p">)</span>
        <span class="ow">or</span> <span class="n">regime_transition</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span> <span class="o">!=</span> <span class="p">(</span><span class="n">k_regimes</span><span class="p">,</span> <span class="n">k_regimes</span><span class="p">)</span>
        <span class="ow">or</span> <span class="n">conditional_likelihoods</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">k_regimes</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">incompatible_shapes</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Arguments do not have compatible shapes&#39;</span><span class="p">)</span>

    <span class="c1"># Storage</span>
    <span class="c1"># Pr[S_t = s_t | Y_t]</span>
    <span class="n">filtered_marginal_probabilities</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">k_regimes</span><span class="p">,</span> <span class="n">nobs</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">))</span>
    <span class="c1"># Pr[S_t = s_t, ... S_{t-r} = s_{t-r} | Y_{t-1}]</span>
    <span class="c1"># Has k_regimes^(order+1) elements</span>
    <span class="n">predicted_joint_probabilities</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
        <span class="p">(</span><span class="n">k_regimes</span><span class="p">,)</span> <span class="o">*</span> <span class="p">(</span><span class="n">order</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">nobs</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
    <span class="c1"># f(y_t | Y_{t-1})</span>
    <span class="n">joint_likelihoods</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nobs</span><span class="p">,),</span> <span class="n">dtype</span><span class="p">)</span>
    <span class="c1"># Pr[S_t = s_t, ... S_{t-r+1} = s_{t-r+1} | Y_t]</span>
    <span class="c1"># Has k_regimes^order elements</span>
    <span class="n">filtered_joint_probabilities</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
        <span class="p">(</span><span class="n">k_regimes</span><span class="p">,)</span> <span class="o">*</span> <span class="p">(</span><span class="n">order</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">nobs</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

    <span class="c1"># Initial probabilities</span>
    <span class="n">filtered_marginal_probabilities</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">initial_probabilities</span>
    <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">initial_probabilities</span><span class="p">)</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">k_regimes</span><span class="p">,</span> <span class="n">k_regimes</span><span class="p">)</span>
    <span class="n">transition_t</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">order</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">regime_transition</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">transition_t</span> <span class="o">=</span> <span class="n">i</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">regime_transition</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">transition_t</span><span class="p">],</span>
                         <span class="n">shape</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span> <span class="o">*</span> <span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="n">tmp</span>
    <span class="n">filtered_joint_probabilities</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span>

    <span class="c1"># Get appropriate subset of transition matrix</span>
    <span class="k">if</span> <span class="n">regime_transition</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">regime_transition</span> <span class="o">=</span> <span class="n">regime_transition</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">order</span><span class="p">:]</span>

    <span class="c1"># Run Cython filter iterations</span>
    <span class="n">prefix</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">find_best_blas_type</span><span class="p">((</span>
        <span class="n">regime_transition</span><span class="p">,</span> <span class="n">conditional_likelihoods</span><span class="p">,</span> <span class="n">joint_likelihoods</span><span class="p">,</span>
        <span class="n">predicted_joint_probabilities</span><span class="p">,</span> <span class="n">filtered_joint_probabilities</span><span class="p">))</span>
    <span class="n">func</span> <span class="o">=</span> <span class="n">prefix_hamilton_filter_map</span><span class="p">[</span><span class="n">prefix</span><span class="p">]</span>
    <span class="n">func</span><span class="p">(</span><span class="n">nobs</span><span class="p">,</span> <span class="n">k_regimes</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">regime_transition</span><span class="p">,</span>
         <span class="n">conditional_likelihoods</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">k_regimes</span><span class="o">**</span><span class="p">(</span><span class="n">order</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="n">nobs</span><span class="p">),</span>
         <span class="n">joint_likelihoods</span><span class="p">,</span>
         <span class="n">predicted_joint_probabilities</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">k_regimes</span><span class="o">**</span><span class="p">(</span><span class="n">order</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="n">nobs</span><span class="p">),</span>
         <span class="n">filtered_joint_probabilities</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">k_regimes</span><span class="o">**</span><span class="p">(</span><span class="n">order</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="n">nobs</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>

    <span class="c1"># S_t | t</span>
    <span class="n">filtered_marginal_probabilities</span> <span class="o">=</span> <span class="n">filtered_joint_probabilities</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">:]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">filtered_marginal_probabilities</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">filtered_marginal_probabilities</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
            <span class="n">filtered_marginal_probabilities</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">2</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">filtered_marginal_probabilities</span><span class="p">,</span> <span class="n">predicted_joint_probabilities</span><span class="p">,</span>
            <span class="n">joint_likelihoods</span><span class="p">,</span> <span class="n">filtered_joint_probabilities</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">:])</span>


<span class="k">def</span> <span class="nf">py_kim_smoother</span><span class="p">(</span><span class="n">regime_transition</span><span class="p">,</span> <span class="n">predicted_joint_probabilities</span><span class="p">,</span>
                    <span class="n">filtered_joint_probabilities</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Kim smoother using pure Python</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    regime_transition : array</span>
<span class="sd">        Matrix of regime transition probabilities, shaped either</span>
<span class="sd">        (k_regimes, k_regimes, 1) or if there are time-varying transition</span>
<span class="sd">        probabilities (k_regimes, k_regimes, nobs).</span>
<span class="sd">    predicted_joint_probabilities : array</span>
<span class="sd">        Array containing Pr[S_t=s_t, ..., S_{t-order}=s_{t-order} | Y_{t-1}] -</span>
<span class="sd">        the joint probability of the current and previous `order` periods</span>
<span class="sd">        being in each combination of regimes conditional on time t-1</span>
<span class="sd">        information. Shaped (k_regimes,) * (order + 1) + (nobs,).</span>
<span class="sd">    filtered_joint_probabilities : array</span>
<span class="sd">        Array containing Pr[S_t=s_t, ..., S_{t-order}=s_{t-order} | Y_{t}] -</span>
<span class="sd">        the joint probability of the current and previous `order` periods</span>
<span class="sd">        being in each combination of regimes conditional on time t</span>
<span class="sd">        information. Shaped (k_regimes,) * (order + 1) + (nobs,).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    smoothed_joint_probabilities : array</span>
<span class="sd">        Array containing Pr[S_t=s_t, ..., S_{t-order}=s_{t-order} | Y_T] -</span>
<span class="sd">        the joint probability of the current and previous `order` periods</span>
<span class="sd">        being in each combination of regimes conditional on all information.</span>
<span class="sd">        Shaped (k_regimes,) * (order + 1) + (nobs,).</span>
<span class="sd">    smoothed_marginal_probabilities : array</span>
<span class="sd">        Array containing Pr[S_t=s_t | Y_T] - the probability of being in each</span>
<span class="sd">        regime conditional on all information. Shaped (k_regimes, nobs).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Dimensions</span>
    <span class="n">k_regimes</span> <span class="o">=</span> <span class="n">filtered_joint_probabilities</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">nobs</span> <span class="o">=</span> <span class="n">filtered_joint_probabilities</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">order</span> <span class="o">=</span> <span class="n">filtered_joint_probabilities</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">2</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="n">filtered_joint_probabilities</span><span class="o">.</span><span class="n">dtype</span>

    <span class="c1"># Storage</span>
    <span class="n">smoothed_joint_probabilities</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
        <span class="p">(</span><span class="n">k_regimes</span><span class="p">,)</span> <span class="o">*</span> <span class="p">(</span><span class="n">order</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">nobs</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">smoothed_marginal_probabilities</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">k_regimes</span><span class="p">,</span> <span class="n">nobs</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

    <span class="c1"># S_T, S_{T-1}, ..., S_{T-r} | T</span>
    <span class="n">smoothed_joint_probabilities</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">filtered_joint_probabilities</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="c1"># Reshape transition so we can use broadcasting</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">k_regimes</span><span class="p">,</span> <span class="n">k_regimes</span><span class="p">)</span>
    <span class="n">shape</span> <span class="o">+=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span> <span class="o">*</span> <span class="p">(</span><span class="n">order</span><span class="p">)</span>
    <span class="n">shape</span> <span class="o">+=</span> <span class="p">(</span><span class="n">regime_transition</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],)</span>
    <span class="n">regime_transition</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">regime_transition</span><span class="p">,</span> <span class="n">shape</span><span class="p">)</span>

    <span class="c1"># Get appropriate subset of transition matrix</span>
    <span class="k">if</span> <span class="n">regime_transition</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">nobs</span> <span class="o">+</span> <span class="n">order</span><span class="p">:</span>
        <span class="n">regime_transition</span> <span class="o">=</span> <span class="n">regime_transition</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">order</span><span class="p">:]</span>

    <span class="c1"># Kim smoother iterations</span>
    <span class="n">transition_t</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nobs</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">regime_transition</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">transition_t</span> <span class="o">=</span> <span class="n">t</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="c1"># S_{t+1}, S_t, ..., S_{t-r+1} | t</span>
        <span class="c1"># x = predicted_joint_probabilities[..., t]</span>
        <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">filtered_joint_probabilities</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">*</span>
             <span class="n">regime_transition</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">transition_t</span><span class="p">])</span>
        <span class="c1"># S_{t+1}, S_t, ..., S_{t-r+2} | T / S_{t+1}, S_t, ..., S_{t-r+2} | t</span>
        <span class="n">y</span> <span class="o">=</span> <span class="p">(</span><span class="n">smoothed_joint_probabilities</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">t</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span>
             <span class="n">predicted_joint_probabilities</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">t</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
        <span class="c1"># S_t, S_{t-1}, ..., S_{t-r+1} | T</span>
        <span class="n">smoothed_joint_probabilities</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">y</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="kc">None</span><span class="p">])</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1"># Get smoothed marginal probabilities S_t | T by integrating out</span>
    <span class="c1"># S_{t-k+1}, S_{t-k+2}, ..., S_{t-1}</span>
    <span class="n">smoothed_marginal_probabilities</span> <span class="o">=</span> <span class="n">smoothed_joint_probabilities</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">smoothed_marginal_probabilities</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">smoothed_marginal_probabilities</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
            <span class="n">smoothed_marginal_probabilities</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">2</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">smoothed_joint_probabilities</span><span class="p">,</span> <span class="n">smoothed_marginal_probabilities</span>


<span class="k">def</span> <span class="nf">cy_kim_smoother</span><span class="p">(</span><span class="n">regime_transition</span><span class="p">,</span> <span class="n">predicted_joint_probabilities</span><span class="p">,</span>
                    <span class="n">filtered_joint_probabilities</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Kim smoother using Cython inner loop</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    regime_transition : array</span>
<span class="sd">        Matrix of regime transition probabilities, shaped either</span>
<span class="sd">        (k_regimes, k_regimes, 1) or if there are time-varying transition</span>
<span class="sd">        probabilities (k_regimes, k_regimes, nobs).</span>
<span class="sd">    predicted_joint_probabilities : array</span>
<span class="sd">        Array containing Pr[S_t=s_t, ..., S_{t-order}=s_{t-order} | Y_{t-1}] -</span>
<span class="sd">        the joint probability of the current and previous `order` periods</span>
<span class="sd">        being in each combination of regimes conditional on time t-1</span>
<span class="sd">        information. Shaped (k_regimes,) * (order + 1) + (nobs,).</span>
<span class="sd">    filtered_joint_probabilities : array</span>
<span class="sd">        Array containing Pr[S_t=s_t, ..., S_{t-order}=s_{t-order} | Y_{t}] -</span>
<span class="sd">        the joint probability of the current and previous `order` periods</span>
<span class="sd">        being in each combination of regimes conditional on time t</span>
<span class="sd">        information. Shaped (k_regimes,) * (order + 1) + (nobs,).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    smoothed_joint_probabilities : array</span>
<span class="sd">        Array containing Pr[S_t=s_t, ..., S_{t-order}=s_{t-order} | Y_T] -</span>
<span class="sd">        the joint probability of the current and previous `order` periods</span>
<span class="sd">        being in each combination of regimes conditional on all information.</span>
<span class="sd">        Shaped (k_regimes,) * (order + 1) + (nobs,).</span>
<span class="sd">    smoothed_marginal_probabilities : array</span>
<span class="sd">        Array containing Pr[S_t=s_t | Y_T] - the probability of being in each</span>
<span class="sd">        regime conditional on all information. Shaped (k_regimes, nobs).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Dimensions</span>
    <span class="n">k_regimes</span> <span class="o">=</span> <span class="n">filtered_joint_probabilities</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">nobs</span> <span class="o">=</span> <span class="n">filtered_joint_probabilities</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">order</span> <span class="o">=</span> <span class="n">filtered_joint_probabilities</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">2</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="n">filtered_joint_probabilities</span><span class="o">.</span><span class="n">dtype</span>

    <span class="c1"># Storage</span>
    <span class="n">smoothed_joint_probabilities</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
        <span class="p">(</span><span class="n">k_regimes</span><span class="p">,)</span> <span class="o">*</span> <span class="p">(</span><span class="n">order</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">nobs</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

    <span class="c1"># Get appropriate subset of transition matrix</span>
    <span class="k">if</span> <span class="n">regime_transition</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">nobs</span> <span class="o">+</span> <span class="n">order</span><span class="p">:</span>
        <span class="n">regime_transition</span> <span class="o">=</span> <span class="n">regime_transition</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">order</span><span class="p">:]</span>

    <span class="c1"># Run Cython smoother iterations</span>
    <span class="n">prefix</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">find_best_blas_type</span><span class="p">((</span>
        <span class="n">regime_transition</span><span class="p">,</span> <span class="n">predicted_joint_probabilities</span><span class="p">,</span>
        <span class="n">filtered_joint_probabilities</span><span class="p">))</span>
    <span class="n">func</span> <span class="o">=</span> <span class="n">prefix_kim_smoother_map</span><span class="p">[</span><span class="n">prefix</span><span class="p">]</span>
    <span class="n">func</span><span class="p">(</span><span class="n">nobs</span><span class="p">,</span> <span class="n">k_regimes</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">regime_transition</span><span class="p">,</span>
         <span class="n">predicted_joint_probabilities</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">k_regimes</span><span class="o">**</span><span class="p">(</span><span class="n">order</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="n">nobs</span><span class="p">),</span>
         <span class="n">filtered_joint_probabilities</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">k_regimes</span><span class="o">**</span><span class="p">(</span><span class="n">order</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="n">nobs</span><span class="p">),</span>
         <span class="n">smoothed_joint_probabilities</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">k_regimes</span><span class="o">**</span><span class="p">(</span><span class="n">order</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="n">nobs</span><span class="p">))</span>

    <span class="c1"># Get smoothed marginal probabilities S_t | T by integrating out</span>
    <span class="c1"># S_{t-k+1}, S_{t-k+2}, ..., S_{t-1}</span>
    <span class="n">smoothed_marginal_probabilities</span> <span class="o">=</span> <span class="n">smoothed_joint_probabilities</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">smoothed_marginal_probabilities</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">smoothed_marginal_probabilities</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
            <span class="n">smoothed_marginal_probabilities</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">2</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">smoothed_joint_probabilities</span><span class="p">,</span> <span class="n">smoothed_marginal_probabilities</span>


<span class="k">class</span> <span class="nc">MarkovSwitchingParams</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class to hold parameters in Markov switching models</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    k_regimes : int</span>
<span class="sd">        The number of regimes between which parameters may switch.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>

<span class="sd">    The purpose is to allow selecting parameter indexes / slices based on</span>
<span class="sd">    parameter type, regime number, or both.</span>

<span class="sd">    Parameters are lexicographically ordered in the following way:</span>

<span class="sd">    1. Named type string (e.g. &quot;autoregressive&quot;)</span>
<span class="sd">    2. Number (e.g. the first autoregressive parameter, then the second)</span>
<span class="sd">    3. Regime (if applicable)</span>

<span class="sd">    Parameter blocks are set using dictionary setter notation where the key</span>
<span class="sd">    is the named type string and the value is a list of boolean values</span>
<span class="sd">    indicating whether a given parameter is switching or not.</span>

<span class="sd">    For example, consider the following code:</span>

<span class="sd">        parameters = MarkovSwitchingParams(k_regimes=2)</span>
<span class="sd">        parameters[&#39;regime_transition&#39;] = [1,1]</span>
<span class="sd">        parameters[&#39;exog&#39;] = [0, 1]</span>

<span class="sd">    This implies the model has 7 parameters: 4 &quot;regime_transition&quot;-related</span>
<span class="sd">    parameters (2 parameters that each switch according to regimes) and 3</span>
<span class="sd">    &quot;exog&quot;-related parameters (1 parameter that does not switch, and one 1 that</span>
<span class="sd">    does).</span>

<span class="sd">    The order of parameters is then:</span>

<span class="sd">    1. The first &quot;regime_transition&quot; parameter, regime 0</span>
<span class="sd">    2. The first &quot;regime_transition&quot; parameter, regime 1</span>
<span class="sd">    3. The second &quot;regime_transition&quot; parameter, regime 1</span>
<span class="sd">    4. The second &quot;regime_transition&quot; parameter, regime 1</span>
<span class="sd">    5. The first &quot;exog&quot; parameter</span>
<span class="sd">    6. The second &quot;exog&quot; parameter, regime 0</span>
<span class="sd">    7. The second &quot;exog&quot; parameter, regime 1</span>

<span class="sd">    Retrieving indexes / slices is done through dictionary getter notation.</span>
<span class="sd">    There are three options for the dictionary key:</span>

<span class="sd">    - Regime number (zero-indexed)</span>
<span class="sd">    - Named type string (e.g. &quot;autoregressive&quot;)</span>
<span class="sd">    - Regime number and named type string</span>

<span class="sd">    In the above example, consider the following getters:</span>

<span class="sd">    &gt;&gt;&gt; parameters[0]</span>
<span class="sd">    array([0, 2, 4, 6])</span>
<span class="sd">    &gt;&gt;&gt; parameters[1]</span>
<span class="sd">    array([1, 3, 5, 6])</span>
<span class="sd">    &gt;&gt;&gt; parameters[&#39;exog&#39;]</span>
<span class="sd">    slice(4, 7, None)</span>
<span class="sd">    &gt;&gt;&gt; parameters[0, &#39;exog&#39;]</span>
<span class="sd">    [4, 6]</span>
<span class="sd">    &gt;&gt;&gt; parameters[1, &#39;exog&#39;]</span>
<span class="sd">    [4, 7]</span>

<span class="sd">    Notice that in the last two examples, both lists of indexes include 4.</span>
<span class="sd">    That&#39;s because that is the index of the the non-switching first &quot;exog&quot;</span>
<span class="sd">    parameter, which should be selected regardless of the regime.</span>

<span class="sd">    In addition to the getter, the `k_parameters` attribute is an OrderedDict</span>
<span class="sd">    with the named type strings as the keys. It can be used to get the total</span>
<span class="sd">    number of parameters of each type:</span>

<span class="sd">    &gt;&gt;&gt; parameters.k_parameters[&#39;regime_transition&#39;]</span>
<span class="sd">    4</span>
<span class="sd">    &gt;&gt;&gt; parameters.k_parameters[&#39;exog&#39;]</span>
<span class="sd">    3</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k_regimes</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k_regimes</span> <span class="o">=</span> <span class="n">k_regimes</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">k_params</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k_parameters</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">switching</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">slices_purpose</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">relative_index_regime_purpose</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">OrderedDict</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_regimes</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">index_regime_purpose</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">OrderedDict</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_regimes</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">index_regime</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_regimes</span><span class="p">)]</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="n">_type</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

        <span class="c1"># Get a slice for a block of parameters by purpose</span>
        <span class="k">if</span> <span class="n">_type</span> <span class="ow">is</span> <span class="nb">str</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">slices_purpose</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="c1"># Get a slice for a block of parameters by regime</span>
        <span class="k">elif</span> <span class="n">_type</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">index_regime</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">_type</span> <span class="ow">is</span> <span class="nb">tuple</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s1">&#39;Invalid index&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="nb">str</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="nb">int</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">index_regime_purpose</span><span class="p">[</span><span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
            <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="nb">str</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="nb">int</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">index_regime_purpose</span><span class="p">[</span><span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s1">&#39;Invalid index&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s1">&#39;Invalid index&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="n">_type</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">_type</span> <span class="ow">is</span> <span class="nb">str</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">k_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_params</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">k_parameters</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">value</span><span class="o">.</span><span class="n">size</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_regimes</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">k_params</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_parameters</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">switching</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">slices_purpose</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">s_</span><span class="p">[</span><span class="n">k_params</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">k_params</span><span class="p">]</span>

            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_regimes</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">relative_index_regime_purpose</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">index_regime_purpose</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
                <span class="n">switching</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_regimes</span><span class="p">):</span>
                    <span class="c1"># Non-switching parameters</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">switching</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">relative_index_regime_purpose</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                            <span class="n">offset</span><span class="p">)</span>
                    <span class="c1"># Switching parameters</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">relative_index_regime_purpose</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                            <span class="n">offset</span> <span class="o">+</span> <span class="n">j</span><span class="p">)</span>
                <span class="n">offset</span> <span class="o">+=</span> <span class="mi">1</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">switching</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_regimes</span>

            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_regimes</span><span class="p">):</span>
                <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">indices</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">relative_index_regime_purpose</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">v</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">+</span> <span class="n">offset</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">index_regime_purpose</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
                    <span class="n">indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                    <span class="n">offset</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_parameters</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">index_regime</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s1">&#39;Invalid index&#39;</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">MarkovSwitching</span><span class="p">(</span><span class="n">tsbase</span><span class="o">.</span><span class="n">TimeSeriesModel</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    First-order k-regime Markov switching model</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    endog : array_like</span>
<span class="sd">        The endogenous variable.</span>
<span class="sd">    k_regimes : integer</span>
<span class="sd">        The number of regimes.</span>
<span class="sd">    order : integer, optional</span>
<span class="sd">        The order of the model describes the dependence of the likelihood on</span>
<span class="sd">        previous regimes. This depends on the model in question and should be</span>
<span class="sd">        set appropriately by subclasses.</span>
<span class="sd">    exog_tvtp : array_like, optional</span>
<span class="sd">        Array of exogenous or lagged variables to use in calculating</span>
<span class="sd">        time-varying transition probabilities (TVTP). TVTP is only used if this</span>
<span class="sd">        variable is provided. If an intercept is desired, a column of ones must</span>
<span class="sd">        be explicitly included in this array.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This model is new and API stability is not guaranteed, although changes</span>
<span class="sd">    will be made in a backwards compatible way if possible.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    Kim, Chang-Jin, and Charles R. Nelson. 1999.</span>
<span class="sd">    &quot;State-Space Models with Regime Switching:</span>
<span class="sd">    Classical and Gibbs-Sampling Approaches with Applications&quot;.</span>
<span class="sd">    MIT Press Books. The MIT Press.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">endog</span><span class="p">,</span> <span class="n">k_regimes</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">exog_tvtp</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">exog</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">dates</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">missing</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">):</span>

        <span class="c1"># Properties</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k_regimes</span> <span class="o">=</span> <span class="n">k_regimes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tvtp</span> <span class="o">=</span> <span class="n">exog_tvtp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="c1"># The order of the model may be overridden in subclasses</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">order</span> <span class="o">=</span> <span class="n">order</span>

        <span class="c1"># Exogenous data</span>
        <span class="c1"># TODO add checks for exog_tvtp consistent shape and indices</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k_tvtp</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">exog_tvtp</span> <span class="o">=</span> <span class="n">prepare_exog</span><span class="p">(</span><span class="n">exog_tvtp</span><span class="p">)</span>

        <span class="c1"># Initialize the base model</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">MarkovSwitching</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">endog</span><span class="p">,</span> <span class="n">exog</span><span class="p">,</span> <span class="n">dates</span><span class="o">=</span><span class="n">dates</span><span class="p">,</span>
                                              <span class="n">freq</span><span class="o">=</span><span class="n">freq</span><span class="p">,</span> <span class="n">missing</span><span class="o">=</span><span class="n">missing</span><span class="p">)</span>

        <span class="c1"># Dimensions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">endog</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Sanity checks</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">endog</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">endog</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Must have univariate endogenous data.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_regimes</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Markov switching models must have at least two&#39;</span>
                             <span class="s1">&#39; regimes.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exog_tvtp</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">exog_tvtp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Time-varying transition probabilities exogenous&#39;</span>
                             <span class="s1">&#39; array must have the same number of observations&#39;</span>
                             <span class="s1">&#39; as the endogenous array.&#39;</span><span class="p">)</span>

        <span class="c1"># Parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span> <span class="o">=</span> <span class="n">MarkovSwitchingParams</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_regimes</span><span class="p">)</span>
        <span class="n">k_transition</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_regimes</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tvtp</span><span class="p">:</span>
            <span class="n">k_transition</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_tvtp</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;regime_transition&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">k_transition</span>

        <span class="c1"># Internal model properties: default is steady-state initialization</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initialization</span> <span class="o">=</span> <span class="s1">&#39;steady-state&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initial_probabilities</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">k_params</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        (int) Number of parameters in the model</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">k_params</span>

    <span class="k">def</span> <span class="nf">initialize_steady_state</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set initialization of regime probabilities to be steady-state values</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Only valid if there are not time-varying transition probabilities.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tvtp</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Cannot use steady-state initialization when&#39;</span>
                             <span class="s1">&#39; the regime transition matrix is time-varying.&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_initialization</span> <span class="o">=</span> <span class="s1">&#39;steady-state&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initial_probabilities</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">initialize_known</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">probabilities</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set initialization of regime probabilities to use known values</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initialization</span> <span class="o">=</span> <span class="s1">&#39;known&#39;</span>
        <span class="n">probabilities</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">probabilities</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">probabilities</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_regimes</span><span class="p">,):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Initial probabilities must be a vector of shape&#39;</span>
                             <span class="s1">&#39; (k_regimes,).&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">probabilities</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Initial probabilities vector must sum to one.&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initial_probabilities</span> <span class="o">=</span> <span class="n">probabilities</span>

    <span class="k">def</span> <span class="nf">initial_probabilities</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">regime_transition</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieve initial probabilities</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initialization</span> <span class="o">==</span> <span class="s1">&#39;steady-state&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">regime_transition</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">regime_transition</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">regime_transition_matrix</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">regime_transition</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">regime_transition</span> <span class="o">=</span> <span class="n">regime_transition</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">regime_transition</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="o">-</span> <span class="n">regime_transition</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">m</span><span class="p">)]</span><span class="o">.</span><span class="n">T</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">probabilities</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">pinv</span><span class="p">(</span><span class="n">A</span><span class="p">)[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">except</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">LinAlgError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Steady-state probabilities could not be&#39;</span>
                                   <span class="s1">&#39; constructed.&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initialization</span> <span class="o">==</span> <span class="s1">&#39;known&#39;</span><span class="p">:</span>
            <span class="n">probabilities</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initial_probabilities</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Invalid initialization method selected.&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">probabilities</span>

    <span class="k">def</span> <span class="nf">_regime_transition_matrix_tvtp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">exog_tvtp</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">exog_tvtp</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">exog_tvtp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exog_tvtp</span>
        <span class="n">nobs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">exog_tvtp</span><span class="p">)</span>

        <span class="n">regime_transition_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_regimes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_regimes</span><span class="p">,</span> <span class="n">nobs</span><span class="p">),</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">promote_types</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">params</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>

        <span class="c1"># Compute the predicted values from the regression</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_regimes</span><span class="p">):</span>
            <span class="n">coeffs</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="s1">&#39;regime_transition&#39;</span><span class="p">]]</span>
            <span class="n">regime_transition_matrix</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
                <span class="n">exog_tvtp</span><span class="p">,</span>
                <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">coeffs</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_regimes</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_tvtp</span><span class="p">))</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

        <span class="c1"># Perform the logistic transformation</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nobs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_regimes</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span>
                    <span class="n">regime_transition_matrix</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span><span class="o">.</span><span class="n">T</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>
        <span class="n">regime_transition_matrix</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span>
            <span class="n">regime_transition_matrix</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">logsumexp</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>

        <span class="c1"># Compute the last column of the transition matrix</span>
        <span class="n">regime_transition_matrix</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="mi">1</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">regime_transition_matrix</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">regime_transition_matrix</span>

    <span class="k">def</span> <span class="nf">regime_transition_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">exog_tvtp</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct the left-stochastic transition matrix</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This matrix will either be shaped (k_regimes, k_regimes, 1) or if there</span>
<span class="sd">        are time-varying transition probabilities, it will be shaped</span>
<span class="sd">        (k_regimes, k_regimes, nobs).</span>

<span class="sd">        The (i,j)th element of this matrix is the probability of transitioning</span>
<span class="sd">        from regime j to regime i; thus the previous regime is represented in a</span>
<span class="sd">        column and the next regime is represented by a row.</span>

<span class="sd">        It is left-stochastic, meaning that each column sums to one (because</span>
<span class="sd">        it is certain that from one regime (j) you will transition to *some</span>
<span class="sd">        other regime*).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">tvtp</span><span class="p">:</span>
            <span class="n">regime_transition_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_regimes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_regimes</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
                <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">promote_types</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">params</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>
            <span class="n">regime_transition_matrix</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
                <span class="n">params</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;regime_transition&#39;</span><span class="p">]],</span>
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_regimes</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_regimes</span><span class="p">))</span>
            <span class="n">regime_transition_matrix</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="mi">1</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">regime_transition_matrix</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">regime_transition_matrix</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_regime_transition_matrix_tvtp</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">exog_tvtp</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">regime_transition_matrix</span>

    <span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">probabilities</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">conditional</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        In-sample prediction and out-of-sample forecasting</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array</span>
<span class="sd">            Parameters at which to form predictions</span>
<span class="sd">        start : int, str, or datetime, optional</span>
<span class="sd">            Zero-indexed observation number at which to start forecasting,</span>
<span class="sd">            i.e., the first forecast is start. Can also be a date string to</span>
<span class="sd">            parse or a datetime type. Default is the the zeroth observation.</span>
<span class="sd">        end : int, str, or datetime, optional</span>
<span class="sd">            Zero-indexed observation number at which to end forecasting, i.e.,</span>
<span class="sd">            the last forecast is end. Can also be a date string to</span>
<span class="sd">            parse or a datetime type. However, if the dates index does not</span>
<span class="sd">            have a fixed frequency, end must be an integer index if you</span>
<span class="sd">            want out of sample prediction. Default is the last observation in</span>
<span class="sd">            the sample.</span>
<span class="sd">        probabilities : string or array_like, optional</span>
<span class="sd">            Specifies the weighting probabilities used in constructing the</span>
<span class="sd">            prediction as a weighted average. If a string, can be &#39;predicted&#39;,</span>
<span class="sd">            &#39;filtered&#39;, or &#39;smoothed&#39;. Otherwise can be an array of</span>
<span class="sd">            probabilities to use. Default is smoothed.</span>
<span class="sd">        conditional: boolean or int, optional</span>
<span class="sd">            Whether or not to return predictions conditional on current or</span>
<span class="sd">            past regimes. If False, returns a single vector of weighted</span>
<span class="sd">            predictions. If True or 1, returns predictions conditional on the</span>
<span class="sd">            current regime. For larger integers, returns predictions</span>
<span class="sd">            conditional on the current regime and some number of past regimes.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        predict : array</span>
<span class="sd">            Array of out of in-sample predictions and / or out-of-sample</span>
<span class="sd">            forecasts.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Handle start, end</span>
        <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">out_of_sample</span><span class="p">,</span> <span class="n">prediction_index</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_get_prediction_index</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">out_of_sample</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span>

        <span class="c1"># Perform in-sample prediction</span>
        <span class="n">predict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predict_conditional</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
        <span class="n">squeezed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">predict</span><span class="p">)</span>

        <span class="c1"># Check if we need to do weighted averaging</span>
        <span class="k">if</span> <span class="n">squeezed</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&gt;</span> <span class="n">conditional</span><span class="p">:</span>
            <span class="c1"># Determine in-sample weighting probabilities</span>
            <span class="k">if</span> <span class="n">probabilities</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">probabilities</span> <span class="o">==</span> <span class="s1">&#39;smoothed&#39;</span><span class="p">:</span>
                <span class="n">results</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">smooth</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">return_raw</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">probabilities</span> <span class="o">=</span> <span class="n">results</span><span class="o">.</span><span class="n">smoothed_joint_probabilities</span>
            <span class="k">elif</span> <span class="n">probabilities</span> <span class="o">==</span> <span class="s1">&#39;filtered&#39;</span><span class="p">:</span>
                <span class="n">results</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">return_raw</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">probabilities</span> <span class="o">=</span> <span class="n">results</span><span class="o">.</span><span class="n">filtered_joint_probabilities</span>
            <span class="k">elif</span> <span class="n">probabilities</span> <span class="o">==</span> <span class="s1">&#39;predicted&#39;</span><span class="p">:</span>
                <span class="n">results</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">return_raw</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">probabilities</span> <span class="o">=</span> <span class="n">results</span><span class="o">.</span><span class="n">predicted_joint_probabilities</span>

            <span class="c1"># Compute weighted average</span>
            <span class="n">predict</span> <span class="o">=</span> <span class="p">(</span><span class="n">predict</span> <span class="o">*</span> <span class="n">probabilities</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">predict</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="nb">int</span><span class="p">(</span><span class="n">conditional</span><span class="p">)):</span>
                <span class="n">predict</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">predict</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">predict</span> <span class="o">=</span> <span class="n">squeezed</span>

        <span class="k">return</span> <span class="n">predict</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span> <span class="o">+</span> <span class="n">out_of_sample</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">predict_conditional</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        In-sample prediction, conditional on the current, and possibly past,</span>
<span class="sd">        regimes</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array_like</span>
<span class="sd">            Array of parameters at which to perform prediction.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        predict : array_like</span>
<span class="sd">            Array of predictions conditional on current, and possibly past,</span>
<span class="sd">            regimes</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="k">def</span> <span class="nf">_conditional_likelihoods</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute likelihoods conditional on the current period&#39;s regime (and</span>
<span class="sd">        the last self.order periods&#39; regimes if self.order &gt; 0).</span>

<span class="sd">        Must be implemented in subclasses.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="k">def</span> <span class="nf">_filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">regime_transition</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># Get the regime transition matrix if not provided</span>
        <span class="k">if</span> <span class="n">regime_transition</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">regime_transition</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">regime_transition_matrix</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
        <span class="c1"># Get the initial probabilities</span>
        <span class="n">initial_probabilities</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">initial_probabilities</span><span class="p">(</span>
            <span class="n">params</span><span class="p">,</span> <span class="n">regime_transition</span><span class="p">)</span>

        <span class="c1"># Compute the conditional likelihoods</span>
        <span class="n">conditional_likelihoods</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conditional_likelihoods</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>

        <span class="c1"># Apply the filter</span>
        <span class="k">return</span> <span class="p">((</span><span class="n">regime_transition</span><span class="p">,</span> <span class="n">initial_probabilities</span><span class="p">,</span>
                 <span class="n">conditional_likelihoods</span><span class="p">)</span> <span class="o">+</span>
                <span class="n">cy_hamilton_filter</span><span class="p">(</span><span class="n">initial_probabilities</span><span class="p">,</span> <span class="n">regime_transition</span><span class="p">,</span>
                                   <span class="n">conditional_likelihoods</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cov_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cov_kwds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="n">return_raw</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">results_class</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="n">results_wrapper_class</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply the Hamilton filter</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array_like</span>
<span class="sd">            Array of parameters at which to perform filtering.</span>
<span class="sd">        transformed : boolean, optional</span>
<span class="sd">            Whether or not `params` is already transformed. Default is True.</span>
<span class="sd">        cov_type : str, optional</span>
<span class="sd">            See `fit` for a description of covariance matrix types</span>
<span class="sd">            for results object.</span>
<span class="sd">        cov_kwds : dict or None, optional</span>
<span class="sd">            See `fit` for a description of required keywords for alternative</span>
<span class="sd">            covariance estimators</span>
<span class="sd">        return_raw : boolean,optional</span>
<span class="sd">            Whether or not to return only the raw Hamilton filter output or a</span>
<span class="sd">            full results object. Default is to return a full results object.</span>
<span class="sd">        results_class : type, optional</span>
<span class="sd">            A results class to instantiate rather than</span>
<span class="sd">            `MarkovSwitchingResults`. Usually only used internally by</span>
<span class="sd">            subclasses.</span>
<span class="sd">        results_wrapper_class : type, optional</span>
<span class="sd">            A results wrapper class to instantiate rather than</span>
<span class="sd">            `MarkovSwitchingResults`. Usually only used internally by</span>
<span class="sd">            subclasses.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        MarkovSwitchingResults</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">transformed</span><span class="p">:</span>
            <span class="n">params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_params</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>

        <span class="c1"># Save the parameter names</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">param_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_names</span>

        <span class="c1"># Get the result</span>
        <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;regime_transition&#39;</span><span class="p">,</span> <span class="s1">&#39;initial_probabilities&#39;</span><span class="p">,</span>
                 <span class="s1">&#39;conditional_likelihoods&#39;</span><span class="p">,</span> <span class="s1">&#39;filtered_marginal_probabilities&#39;</span><span class="p">,</span>
                 <span class="s1">&#39;predicted_joint_probabilities&#39;</span><span class="p">,</span> <span class="s1">&#39;joint_likelihoods&#39;</span><span class="p">,</span>
                 <span class="s1">&#39;filtered_joint_probabilities&#39;</span><span class="p">]</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">HamiltonFilterResults</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">Bunch</span><span class="p">(</span><span class="o">**</span><span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filter</span><span class="p">(</span><span class="n">params</span><span class="p">)))))</span>

        <span class="c1"># Wrap in a results object</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_results</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">return_raw</span><span class="p">,</span> <span class="n">cov_type</span><span class="p">,</span>
                                  <span class="n">cov_kwds</span><span class="p">,</span> <span class="n">results_class</span><span class="p">,</span>
                                  <span class="n">results_wrapper_class</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_smooth</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">filtered_marginal_probabilities</span><span class="p">,</span>
                <span class="n">predicted_joint_probabilities</span><span class="p">,</span>
                <span class="n">filtered_joint_probabilities</span><span class="p">,</span> <span class="n">regime_transition</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># Get the regime transition matrix</span>
        <span class="k">if</span> <span class="n">regime_transition</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">regime_transition</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">regime_transition_matrix</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>

        <span class="c1"># Apply the smoother</span>
        <span class="k">return</span> <span class="n">cy_kim_smoother</span><span class="p">(</span><span class="n">regime_transition</span><span class="p">,</span>
                               <span class="n">predicted_joint_probabilities</span><span class="p">,</span>
                               <span class="n">filtered_joint_probabilities</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_res_classes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;fit&#39;</span><span class="p">:</span> <span class="p">(</span><span class="n">MarkovSwitchingResults</span><span class="p">,</span> <span class="n">MarkovSwitchingResultsWrapper</span><span class="p">)}</span>

    <span class="k">def</span> <span class="nf">_wrap_results</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">return_raw</span><span class="p">,</span> <span class="n">cov_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                      <span class="n">cov_kwds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">results_class</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">wrapper_class</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">return_raw</span><span class="p">:</span>
            <span class="c1"># Wrap in a results object</span>
            <span class="n">result_kwargs</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">if</span> <span class="n">cov_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">result_kwargs</span><span class="p">[</span><span class="s1">&#39;cov_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cov_type</span>
            <span class="k">if</span> <span class="n">cov_kwds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">result_kwargs</span><span class="p">[</span><span class="s1">&#39;cov_kwds&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cov_kwds</span>

            <span class="k">if</span> <span class="n">results_class</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">results_class</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_res_classes</span><span class="p">[</span><span class="s1">&#39;fit&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">wrapper_class</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">wrapper_class</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_res_classes</span><span class="p">[</span><span class="s1">&#39;fit&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>

            <span class="n">res</span> <span class="o">=</span> <span class="n">results_class</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="o">**</span><span class="n">result_kwargs</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">wrapper_class</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">smooth</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cov_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cov_kwds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="n">return_raw</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">results_class</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="n">results_wrapper_class</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply the Kim smoother and Hamilton filter</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array_like</span>
<span class="sd">            Array of parameters at which to perform filtering.</span>
<span class="sd">        transformed : boolean, optional</span>
<span class="sd">            Whether or not `params` is already transformed. Default is True.</span>
<span class="sd">        cov_type : str, optional</span>
<span class="sd">            See `fit` for a description of covariance matrix types</span>
<span class="sd">            for results object.</span>
<span class="sd">        cov_kwds : dict or None, optional</span>
<span class="sd">            See `fit` for a description of required keywords for alternative</span>
<span class="sd">            covariance estimators</span>
<span class="sd">        return_raw : boolean,optional</span>
<span class="sd">            Whether or not to return only the raw Hamilton filter output or a</span>
<span class="sd">            full results object. Default is to return a full results object.</span>
<span class="sd">        results_class : type, optional</span>
<span class="sd">            A results class to instantiate rather than</span>
<span class="sd">            `MarkovSwitchingResults`. Usually only used internally by</span>
<span class="sd">            subclasses.</span>
<span class="sd">        results_wrapper_class : type, optional</span>
<span class="sd">            A results wrapper class to instantiate rather than</span>
<span class="sd">            `MarkovSwitchingResults`. Usually only used internally by</span>
<span class="sd">            subclasses.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        MarkovSwitchingResults</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">transformed</span><span class="p">:</span>
            <span class="n">params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_params</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>

        <span class="c1"># Save the parameter names</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">param_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_names</span>

        <span class="c1"># Hamilton filter</span>
        <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;regime_transition&#39;</span><span class="p">,</span> <span class="s1">&#39;initial_probabilities&#39;</span><span class="p">,</span>
                 <span class="s1">&#39;conditional_likelihoods&#39;</span><span class="p">,</span> <span class="s1">&#39;filtered_marginal_probabilities&#39;</span><span class="p">,</span>
                 <span class="s1">&#39;predicted_joint_probabilities&#39;</span><span class="p">,</span> <span class="s1">&#39;joint_likelihoods&#39;</span><span class="p">,</span>
                 <span class="s1">&#39;filtered_joint_probabilities&#39;</span><span class="p">]</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">Bunch</span><span class="p">(</span><span class="o">**</span><span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filter</span><span class="p">(</span><span class="n">params</span><span class="p">))))</span>

        <span class="c1"># Kim smoother</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_smooth</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">result</span><span class="o">.</span><span class="n">filtered_marginal_probabilities</span><span class="p">,</span>
                           <span class="n">result</span><span class="o">.</span><span class="n">predicted_joint_probabilities</span><span class="p">,</span>
                           <span class="n">result</span><span class="o">.</span><span class="n">filtered_joint_probabilities</span><span class="p">)</span>
        <span class="n">result</span><span class="p">[</span><span class="s1">&#39;smoothed_joint_probabilities&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">result</span><span class="p">[</span><span class="s1">&#39;smoothed_marginal_probabilities&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">KimSmootherResults</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>

        <span class="c1"># Wrap in a results object</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_results</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">return_raw</span><span class="p">,</span> <span class="n">cov_type</span><span class="p">,</span>
                                  <span class="n">cov_kwds</span><span class="p">,</span> <span class="n">results_class</span><span class="p">,</span>
                                  <span class="n">results_wrapper_class</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">loglikeobs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Loglikelihood evaluation for each period</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array_like</span>
<span class="sd">            Array of parameters at which to evaluate the loglikelihood</span>
<span class="sd">            function.</span>
<span class="sd">        transformed : boolean, optional</span>
<span class="sd">            Whether or not `params` is already transformed. Default is True.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">transformed</span><span class="p">:</span>
            <span class="n">params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_params</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>

        <span class="n">results</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filter</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">loglike</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Loglikelihood evaluation</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array_like</span>
<span class="sd">            Array of parameters at which to evaluate the loglikelihood</span>
<span class="sd">            function.</span>
<span class="sd">        transformed : boolean, optional</span>
<span class="sd">            Whether or not `params` is already transformed. Default is True.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loglikeobs</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">score</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the score function at params.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array_like</span>
<span class="sd">            Array of parameters at which to evaluate the score</span>
<span class="sd">            function.</span>
<span class="sd">        transformed : boolean, optional</span>
<span class="sd">            Whether or not `params` is already transformed. Default is True.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">approx_fprime_cs</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">loglike</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">transformed</span><span class="p">,))</span>

    <span class="k">def</span> <span class="nf">score_obs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the score per observation, evaluated at params</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array_like</span>
<span class="sd">            Array of parameters at which to evaluate the score</span>
<span class="sd">            function.</span>
<span class="sd">        transformed : boolean, optional</span>
<span class="sd">            Whether or not `params` is already transformed. Default is True.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">approx_fprime_cs</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">loglikeobs</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">transformed</span><span class="p">,))</span>

    <span class="k">def</span> <span class="nf">hessian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Hessian matrix of the likelihood function, evaluated at the given</span>
<span class="sd">        parameters</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array_like</span>
<span class="sd">            Array of parameters at which to evaluate the Hessian</span>
<span class="sd">            function.</span>
<span class="sd">        transformed : boolean, optional</span>
<span class="sd">            Whether or not `params` is already transformed. Default is True.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">approx_hess_cs</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">loglike</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cov_type</span><span class="o">=</span><span class="s1">&#39;approx&#39;</span><span class="p">,</span>
            <span class="n">cov_kwds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;bfgs&#39;</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">full_output</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">disp</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="n">callback</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">return_params</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">em_iter</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">search_reps</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="n">search_iter</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">search_scale</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fits the model by maximum likelihood via Hamilton filter.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        start_params : array_like, optional</span>
<span class="sd">            Initial guess of the solution for the loglikelihood maximization.</span>
<span class="sd">            If None, the default is given by Model.start_params.</span>
<span class="sd">        transformed : boolean, optional</span>
<span class="sd">            Whether or not `start_params` is already transformed. Default is</span>
<span class="sd">            True.</span>
<span class="sd">        cov_type : str, optional</span>
<span class="sd">            The type of covariance matrix estimator to use. Can be one of</span>
<span class="sd">            &#39;approx&#39;, &#39;opg&#39;, &#39;robust&#39;, or &#39;none&#39;. Default is &#39;approx&#39;.</span>
<span class="sd">        cov_kwds : dict or None, optional</span>
<span class="sd">            Keywords for alternative covariance estimators</span>
<span class="sd">        method : str, optional</span>
<span class="sd">            The `method` determines which solver from `scipy.optimize`</span>
<span class="sd">            is used, and it can be chosen from among the following strings:</span>

<span class="sd">            - &#39;newton&#39; for Newton-Raphson, &#39;nm&#39; for Nelder-Mead</span>
<span class="sd">            - &#39;bfgs&#39; for Broyden-Fletcher-Goldfarb-Shanno (BFGS)</span>
<span class="sd">            - &#39;lbfgs&#39; for limited-memory BFGS with optional box constraints</span>
<span class="sd">            - &#39;powell&#39; for modified Powell&#39;s method</span>
<span class="sd">            - &#39;cg&#39; for conjugate gradient</span>
<span class="sd">            - &#39;ncg&#39; for Newton-conjugate gradient</span>
<span class="sd">            - &#39;basinhopping&#39; for global basin-hopping solver</span>

<span class="sd">            The explicit arguments in `fit` are passed to the solver,</span>
<span class="sd">            with the exception of the basin-hopping solver. Each</span>
<span class="sd">            solver has several optional arguments that are not the same across</span>
<span class="sd">            solvers. See the notes section below (or scipy.optimize) for the</span>
<span class="sd">            available arguments and for the list of explicit arguments that the</span>
<span class="sd">            basin-hopping solver supports.</span>
<span class="sd">        maxiter : int, optional</span>
<span class="sd">            The maximum number of iterations to perform.</span>
<span class="sd">        full_output : boolean, optional</span>
<span class="sd">            Set to True to have all available output in the Results object&#39;s</span>
<span class="sd">            mle_retvals attribute. The output is dependent on the solver.</span>
<span class="sd">            See LikelihoodModelResults notes section for more information.</span>
<span class="sd">        disp : boolean, optional</span>
<span class="sd">            Set to True to print convergence messages.</span>
<span class="sd">        callback : callable callback(xk), optional</span>
<span class="sd">            Called after each iteration, as callback(xk), where xk is the</span>
<span class="sd">            current parameter vector.</span>
<span class="sd">        return_params : boolean, optional</span>
<span class="sd">            Whether or not to return only the array of maximizing parameters.</span>
<span class="sd">            Default is False.</span>
<span class="sd">        em_iter : int, optional</span>
<span class="sd">            Number of initial EM iteration steps used to improve starting</span>
<span class="sd">            parameters.</span>
<span class="sd">        search_reps : int, optional</span>
<span class="sd">            Number of randomly drawn search parameters that are drawn around</span>
<span class="sd">            `start_params` to try and improve starting parameters. Default is</span>
<span class="sd">            0.</span>
<span class="sd">        search_iter : int, optional</span>
<span class="sd">            Number of initial EM iteration steps used to improve each of the</span>
<span class="sd">            search parameter repetitions.</span>
<span class="sd">        search_scale : float or array, optional.</span>
<span class="sd">            Scale of variates for random start parameter search.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Additional keyword arguments to pass to the optimizer.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        MarkovSwitchingResults</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">start_params</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">start_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">start_params</span>
            <span class="n">transformed</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">start_params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">start_params</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Random search for better start parameters</span>
        <span class="k">if</span> <span class="n">search_reps</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">start_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_start_params_search</span><span class="p">(</span>
                <span class="n">search_reps</span><span class="p">,</span> <span class="n">start_params</span><span class="o">=</span><span class="n">start_params</span><span class="p">,</span>
                <span class="n">transformed</span><span class="o">=</span><span class="n">transformed</span><span class="p">,</span> <span class="n">em_iter</span><span class="o">=</span><span class="n">search_iter</span><span class="p">,</span>
                <span class="n">scale</span><span class="o">=</span><span class="n">search_scale</span><span class="p">)</span>
            <span class="n">transformed</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># Get better start params through EM algorithm</span>
        <span class="k">if</span> <span class="n">em_iter</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">tvtp</span><span class="p">:</span>
            <span class="n">start_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fit_em</span><span class="p">(</span><span class="n">start_params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="n">transformed</span><span class="p">,</span>
                                        <span class="n">maxiter</span><span class="o">=</span><span class="n">em_iter</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                        <span class="n">return_params</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">transformed</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="n">transformed</span><span class="p">:</span>
            <span class="n">start_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">untransform_params</span><span class="p">(</span><span class="n">start_params</span><span class="p">)</span>

        <span class="c1"># Maximum likelihood estimation by scoring</span>
        <span class="n">fargs</span> <span class="o">=</span> <span class="p">(</span><span class="kc">False</span><span class="p">,)</span>
        <span class="n">mlefit</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">MarkovSwitching</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">start_params</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
                                                  <span class="n">fargs</span><span class="o">=</span><span class="n">fargs</span><span class="p">,</span>
                                                  <span class="n">maxiter</span><span class="o">=</span><span class="n">maxiter</span><span class="p">,</span>
                                                  <span class="n">full_output</span><span class="o">=</span><span class="n">full_output</span><span class="p">,</span>
                                                  <span class="n">disp</span><span class="o">=</span><span class="n">disp</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="n">callback</span><span class="p">,</span>
                                                  <span class="n">skip_hessian</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Just return the fitted parameters if requested</span>
        <span class="k">if</span> <span class="n">return_params</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_params</span><span class="p">(</span><span class="n">mlefit</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>
        <span class="c1"># Otherwise construct the results class if desired</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">smooth</span><span class="p">(</span><span class="n">mlefit</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                 <span class="n">cov_type</span><span class="o">=</span><span class="n">cov_type</span><span class="p">,</span> <span class="n">cov_kwds</span><span class="o">=</span><span class="n">cov_kwds</span><span class="p">)</span>

            <span class="n">result</span><span class="o">.</span><span class="n">mlefit</span> <span class="o">=</span> <span class="n">mlefit</span>
            <span class="n">result</span><span class="o">.</span><span class="n">mle_retvals</span> <span class="o">=</span> <span class="n">mlefit</span><span class="o">.</span><span class="n">mle_retvals</span>
            <span class="n">result</span><span class="o">.</span><span class="n">mle_settings</span> <span class="o">=</span> <span class="n">mlefit</span><span class="o">.</span><span class="n">mle_settings</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">_fit_em</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cov_type</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">,</span>
                <span class="n">cov_kwds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mf">1e-6</span><span class="p">,</span> <span class="n">full_output</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">return_params</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fits the model using the Expectation-Maximization (EM) algorithm</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        start_params : array_like, optional</span>
<span class="sd">            Initial guess of the solution for the loglikelihood maximization.</span>
<span class="sd">            If None, the default is given by `start_params`.</span>
<span class="sd">        transformed : boolean, optional</span>
<span class="sd">            Whether or not `start_params` is already transformed. Default is</span>
<span class="sd">            True.</span>
<span class="sd">        cov_type : str, optional</span>
<span class="sd">            The type of covariance matrix estimator to use. Can be one of</span>
<span class="sd">            &#39;approx&#39;, &#39;opg&#39;, &#39;robust&#39;, or &#39;none&#39;. Default is &#39;none&#39;.</span>
<span class="sd">        cov_kwds : dict or None, optional</span>
<span class="sd">            Keywords for alternative covariance estimators</span>
<span class="sd">        maxiter : int, optional</span>
<span class="sd">            The maximum number of iterations to perform.</span>
<span class="sd">        tolerance : float, optional</span>
<span class="sd">            The iteration stops when the difference between subsequent</span>
<span class="sd">            loglikelihood values is less than this tolerance.</span>
<span class="sd">        full_output : bool, optional</span>
<span class="sd">            Set to True to have all available output in the Results object&#39;s</span>
<span class="sd">            mle_retvals attribute. This includes all intermediate values for</span>
<span class="sd">            parameters and loglikelihood values</span>
<span class="sd">        return_params : boolean, optional</span>
<span class="sd">            Whether or not to return only the array of maximizing parameters.</span>
<span class="sd">            Default is False.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Additional keyword arguments to pass to the optimizer.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This is a private method for finding good starting parameters for MLE</span>
<span class="sd">        by scoring. It has not been tested for a thoroughly correct EM</span>
<span class="sd">        implementation in all cases. It does not support TVTP transition</span>
<span class="sd">        probabilities.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        MarkovSwitchingResults</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">start_params</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">start_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">start_params</span>
            <span class="n">transformed</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">start_params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">start_params</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">transformed</span><span class="p">:</span>
            <span class="n">start_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_params</span><span class="p">(</span><span class="n">start_params</span><span class="p">)</span>

        <span class="c1"># Perform expectation-maximization</span>
        <span class="n">llf</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">params</span> <span class="o">=</span> <span class="p">[</span><span class="n">start_params</span><span class="p">]</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">delta</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">maxiter</span> <span class="ow">and</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="ow">or</span> <span class="p">(</span><span class="n">delta</span> <span class="o">&gt;</span> <span class="n">tolerance</span><span class="p">)):</span>
            <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_em_iteration</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">llf</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">llf</span><span class="p">)</span>
            <span class="n">params</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">delta</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">llf</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">llf</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">((</span><span class="n">llf</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">llf</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]))</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># Just return the fitted parameters if requested</span>
        <span class="k">if</span> <span class="n">return_params</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># Otherwise construct the results class if desired</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                 <span class="n">cov_type</span><span class="o">=</span><span class="n">cov_type</span><span class="p">,</span> <span class="n">cov_kwds</span><span class="o">=</span><span class="n">cov_kwds</span><span class="p">)</span>

            <span class="c1"># Save the output</span>
            <span class="k">if</span> <span class="n">full_output</span><span class="p">:</span>
                <span class="n">em_retvals</span> <span class="o">=</span> <span class="n">Bunch</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="s1">&#39;params&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">params</span><span class="p">),</span>
                                      <span class="s1">&#39;llf&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">llf</span><span class="p">),</span>
                                      <span class="s1">&#39;iter&#39;</span><span class="p">:</span> <span class="n">i</span><span class="p">})</span>
                <span class="n">em_settings</span> <span class="o">=</span> <span class="n">Bunch</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="s1">&#39;tolerance&#39;</span><span class="p">:</span> <span class="n">tolerance</span><span class="p">,</span>
                                       <span class="s1">&#39;maxiter&#39;</span><span class="p">:</span> <span class="n">maxiter</span><span class="p">})</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">em_retvals</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">em_settings</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="n">result</span><span class="o">.</span><span class="n">mle_retvals</span> <span class="o">=</span> <span class="n">em_retvals</span>
            <span class="n">result</span><span class="o">.</span><span class="n">mle_settings</span> <span class="o">=</span> <span class="n">em_settings</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">_em_iteration</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        EM iteration</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The EM iteration in this base class only performs the EM step for</span>
<span class="sd">        non-TVTP transition probabilities.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">params1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">params0</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                           <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">promote_types</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">params0</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>

        <span class="c1"># Smooth at the given parameters</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">smooth</span><span class="p">(</span><span class="n">params0</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">return_raw</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># The EM with TVTP is not yet supported, just return the previous</span>
        <span class="c1"># iteration parameters</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tvtp</span><span class="p">:</span>
            <span class="n">params1</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;regime_transition&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">params0</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;regime_transition&#39;</span><span class="p">]])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">regime_transition</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_em_regime_transition</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_regimes</span><span class="p">):</span>
                <span class="n">params1</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="s1">&#39;regime_transition&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">regime_transition</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">result</span><span class="p">,</span> <span class="n">params1</span>

    <span class="k">def</span> <span class="nf">_em_regime_transition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">result</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        EM step for regime transition probabilities</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Marginalize the smoothed joint probabilites to just S_t, S_{t-1} | T</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">smoothed_joint_probabilities</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">tmp</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">3</span><span class="p">):</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">smoothed_joint_probabilities</span> <span class="o">=</span> <span class="n">tmp</span>

        <span class="c1"># Transition parameters (recall we&#39;re not yet supporting TVTP here)</span>
        <span class="n">k_transition</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;regime_transition&#39;</span><span class="p">])</span>
        <span class="n">regime_transition</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">k_regimes</span><span class="p">,</span> <span class="n">k_transition</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_regimes</span><span class="p">):</span>  <span class="c1"># S_{t_1}</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_regimes</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>  <span class="c1"># S_t</span>
                <span class="n">regime_transition</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">smoothed_joint_probabilities</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">])</span> <span class="o">/</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">smoothed_marginal_probabilities</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>

            <span class="c1"># It may be the case that due to rounding error this estimates</span>
            <span class="c1"># transition probabilities that sum to greater than one. If so,</span>
            <span class="c1"># re-scale the probabilities and warn the user that something</span>
            <span class="c1"># is not quite right</span>
            <span class="n">delta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">regime_transition</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">delta</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Invalid regime transition probabilities&#39;</span>
                              <span class="s1">&#39; estimated in EM iteration; probabilities have&#39;</span>
                              <span class="s1">&#39; been re-scaled to continue estimation.&#39;</span><span class="p">,</span>
                              <span class="n">EstimationWarning</span><span class="p">)</span>
                <span class="n">regime_transition</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">delta</span> <span class="o">+</span> <span class="mf">1e-6</span>

        <span class="k">return</span> <span class="n">regime_transition</span>

    <span class="k">def</span> <span class="nf">_start_params_search</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reps</span><span class="p">,</span> <span class="n">start_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                             <span class="n">em_iter</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mf">1.</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Search for starting parameters as random permutations of a vector</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        reps : int</span>
<span class="sd">            Number of random permutations to try.</span>
<span class="sd">        start_params : array, optional</span>
<span class="sd">            Starting parameter vector. If not given, class-level start</span>
<span class="sd">            parameters are used.</span>
<span class="sd">        transformed : boolean, optional</span>
<span class="sd">            If `start_params` was provided, whether or not those parameters</span>
<span class="sd">            are already transformed. Default is True.</span>
<span class="sd">        em_iter : int, optional</span>
<span class="sd">            Number of EM iterations to apply to each random permutation.</span>
<span class="sd">        scale : array or float, optional</span>
<span class="sd">            Scale of variates for random start parameter search. Can be given</span>
<span class="sd">            as an array of length equal to the number of parameters or as a</span>
<span class="sd">            single scalar.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This is a private method for finding good starting parameters for MLE</span>
<span class="sd">        by scoring, where the defaults have been set heuristically.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">start_params</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">start_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">start_params</span>
            <span class="n">transformed</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">start_params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">start_params</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Random search is over untransformed space</span>
        <span class="k">if</span> <span class="n">transformed</span><span class="p">:</span>
            <span class="n">start_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">untransform_params</span><span class="p">(</span><span class="n">start_params</span><span class="p">)</span>

        <span class="c1"># Construct the standard deviations</span>
        <span class="n">scale</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">scale</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">scale</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">scale</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_params</span><span class="p">)</span> <span class="o">*</span> <span class="n">scale</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">scale</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_params</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Scale of variates for random start&#39;</span>
                             <span class="s1">&#39; parameter search must be given for each&#39;</span>
                             <span class="s1">&#39; parameter or as a single scalar.&#39;</span><span class="p">)</span>

        <span class="c1"># Construct the random variates</span>
        <span class="n">variates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">reps</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_params</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_params</span><span class="p">):</span>
            <span class="n">variates</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">scale</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">reps</span><span class="p">)</span>

        <span class="n">llf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">loglike</span><span class="p">(</span><span class="n">start_params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">start_params</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">reps</span><span class="p">):</span>
            <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">():</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">)</span>

                <span class="k">try</span><span class="p">:</span>
                    <span class="n">proposed_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fit_em</span><span class="p">(</span>
                        <span class="n">start_params</span> <span class="o">+</span> <span class="n">variates</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                        <span class="n">maxiter</span><span class="o">=</span><span class="n">em_iter</span><span class="p">,</span> <span class="n">return_params</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="n">proposed_llf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">loglike</span><span class="p">(</span><span class="n">proposed_params</span><span class="p">)</span>

                    <span class="k">if</span> <span class="n">proposed_llf</span> <span class="o">&gt;</span> <span class="n">llf</span><span class="p">:</span>
                        <span class="n">llf</span> <span class="o">=</span> <span class="n">proposed_llf</span>
                        <span class="n">params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">untransform_params</span><span class="p">(</span><span class="n">proposed_params</span><span class="p">)</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="k">pass</span>

        <span class="c1"># Return transformed parameters</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_params</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">start_params</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        (array) Starting parameters for maximum likelihood estimation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_params</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

        <span class="c1"># Transition probabilities</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tvtp</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;regime_transition&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="mf">0.</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;regime_transition&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="mf">1.</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_regimes</span>

        <span class="k">return</span> <span class="n">params</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">param_names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        (list of str) List of human readable parameter names (for parameters</span>
<span class="sd">        actually included in the model).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">param_names</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_params</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>

        <span class="c1"># Transition probabilities</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tvtp</span><span class="p">:</span>
            <span class="c1"># TODO add support for exog_tvtp_names</span>
            <span class="n">param_names</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;regime_transition&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[</span>
                <span class="s1">&#39;p[</span><span class="si">%d</span><span class="s1">-&gt;</span><span class="si">%d</span><span class="s1">].tvtp</span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_regimes</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_tvtp</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_regimes</span><span class="p">)</span>
                <span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">param_names</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;regime_transition&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[</span>
                <span class="s1">&#39;p[</span><span class="si">%d</span><span class="s1">-&gt;</span><span class="si">%d</span><span class="s1">]&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_regimes</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_regimes</span><span class="p">)]</span>

        <span class="k">return</span> <span class="n">param_names</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">transform_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unconstrained</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Transform unconstrained parameters used by the optimizer to constrained</span>
<span class="sd">        parameters used in likelihood evaluation</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        unconstrained : array_like</span>
<span class="sd">            Array of unconstrained parameters used by the optimizer, to be</span>
<span class="sd">            transformed.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        constrained : array_like</span>
<span class="sd">            Array of constrained parameters which may be used in likelihood</span>
<span class="sd">            evalation.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        In the base class, this only transforms the transition-probability-</span>
<span class="sd">        related parameters.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">constrained</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">unconstrained</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">constrained</span> <span class="o">=</span> <span class="n">constrained</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">promote_types</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">constrained</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>

        <span class="c1"># Nothing to do for transition probabilities if TVTP</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tvtp</span><span class="p">:</span>
            <span class="n">constrained</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;regime_transition&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">unconstrained</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;regime_transition&#39;</span><span class="p">]])</span>
        <span class="c1"># Otherwise do logistic transformation</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Transition probabilities</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_regimes</span><span class="p">):</span>
                <span class="n">tmp1</span> <span class="o">=</span> <span class="n">unconstrained</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="s1">&#39;regime_transition&#39;</span><span class="p">]]</span>
                <span class="n">tmp2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">tmp1</span><span class="p">]</span>
                <span class="n">constrained</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="s1">&#39;regime_transition&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span>
                    <span class="n">tmp1</span> <span class="o">-</span> <span class="n">logsumexp</span><span class="p">(</span><span class="n">tmp2</span><span class="p">))</span>

        <span class="c1"># Do not do anything for the rest of the parameters</span>

        <span class="k">return</span> <span class="n">constrained</span>

    <span class="k">def</span> <span class="nf">_untransform_logistic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unconstrained</span><span class="p">,</span> <span class="n">constrained</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function to allow using a numerical root-finder to reverse the</span>
<span class="sd">        logistic transform.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">resid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">unconstrained</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">unconstrained</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">exp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">unconstrained</span><span class="p">)</span>
        <span class="n">sum_exp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">exp</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">unconstrained</span><span class="p">)):</span>
            <span class="n">resid</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">unconstrained</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">sum_exp</span> <span class="o">-</span> <span class="n">exp</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">+</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">constrained</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">resid</span>

    <span class="k">def</span> <span class="nf">untransform_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">constrained</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Transform constrained parameters used in likelihood evaluation</span>
<span class="sd">        to unconstrained parameters used by the optimizer</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        constrained : array_like</span>
<span class="sd">            Array of constrained parameters used in likelihood evalution, to be</span>
<span class="sd">            transformed.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        unconstrained : array_like</span>
<span class="sd">            Array of unconstrained parameters used by the optimizer.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        In the base class, this only untransforms the transition-probability-</span>
<span class="sd">        related parameters.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">unconstrained</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">constrained</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">unconstrained</span> <span class="o">=</span> <span class="n">unconstrained</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">promote_types</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">unconstrained</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>

        <span class="c1"># Nothing to do for transition probabilities if TVTP</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tvtp</span><span class="p">:</span>
            <span class="n">unconstrained</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;regime_transition&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">constrained</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;regime_transition&#39;</span><span class="p">]])</span>
        <span class="c1"># Otherwise reverse logistic transformation</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_regimes</span><span class="p">):</span>
                <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="s1">&#39;regime_transition&#39;</span><span class="p">]</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_regimes</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">unconstrained</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mf">1.</span> <span class="o">/</span> <span class="n">constrained</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="k">import</span> <span class="n">root</span>
                    <span class="n">out</span> <span class="o">=</span> <span class="n">root</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_untransform_logistic</span><span class="p">,</span>
                               <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">unconstrained</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                                        <span class="n">unconstrained</span><span class="o">.</span><span class="n">dtype</span><span class="p">),</span>
                               <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">constrained</span><span class="p">[</span><span class="n">s</span><span class="p">],))</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">out</span><span class="p">[</span><span class="s1">&#39;success&#39;</span><span class="p">]:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Could not untransform parameters.&#39;</span><span class="p">)</span>
                    <span class="n">unconstrained</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="n">out</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span>

        <span class="c1"># Do not do anything for the rest of the parameters</span>

        <span class="k">return</span> <span class="n">unconstrained</span>


<span class="k">class</span> <span class="nc">HamiltonFilterResults</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Results from applying the Hamilton filter to a state space model.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    model : Representation</span>
<span class="sd">        A Statespace representation</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    nobs : int</span>
<span class="sd">        Number of observations.</span>
<span class="sd">    k_endog : int</span>
<span class="sd">        The dimension of the observation series.</span>
<span class="sd">    k_regimes : int</span>
<span class="sd">        The number of unobserved regimes.</span>
<span class="sd">    regime_transition : array</span>
<span class="sd">        The regime transition matrix.</span>
<span class="sd">    initialization : str</span>
<span class="sd">        Initialization method for regime probabilities.</span>
<span class="sd">    initial_probabilities : array</span>
<span class="sd">        Initial regime probabilities</span>
<span class="sd">    conditional_likelihoods : array</span>
<span class="sd">        The likelihood values at each time period, conditional on regime.</span>
<span class="sd">    predicted_joint_probabilities : array</span>
<span class="sd">        Predicted joint probabilities at each time period.</span>
<span class="sd">    filtered_marginal_probabilities : array</span>
<span class="sd">        Filtered marginal probabilities at each time period.</span>
<span class="sd">    filtered_joint_probabilities : array</span>
<span class="sd">        Filtered joint probabilities at each time period.</span>
<span class="sd">    joint_likelihoods : array</span>
<span class="sd">        The likelihood values at each time period.</span>
<span class="sd">    llf_obs : array</span>
<span class="sd">        The loglikelihood values at each time period.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">result</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">model</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">nobs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">order</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">order</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k_regimes</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">k_regimes</span>

        <span class="n">attributes</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;regime_transition&#39;</span><span class="p">,</span> <span class="s1">&#39;initial_probabilities&#39;</span><span class="p">,</span>
                      <span class="s1">&#39;conditional_likelihoods&#39;</span><span class="p">,</span>
                      <span class="s1">&#39;predicted_joint_probabilities&#39;</span><span class="p">,</span>
                      <span class="s1">&#39;filtered_marginal_probabilities&#39;</span><span class="p">,</span>
                      <span class="s1">&#39;filtered_joint_probabilities&#39;</span><span class="p">,</span>
                      <span class="s1">&#39;joint_likelihoods&#39;</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">attributes</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">name</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">initialization</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">_initialization</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">llf_obs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">joint_likelihoods</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">llf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">llf_obs</span><span class="p">)</span>

        <span class="c1"># Subset transition if necessary (e.g. for Markov autoregression)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">regime_transition</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">order</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">regime_transition</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">regime_transition</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">order</span><span class="p">:]</span>

        <span class="c1"># Cache for predicted marginal probabilities</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_predicted_marginal_probabilities</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">predicted_marginal_probabilities</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_predicted_marginal_probabilities</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_predicted_marginal_probabilities</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">predicted_joint_probabilities</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_predicted_marginal_probabilities</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">2</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_predicted_marginal_probabilities</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_predicted_marginal_probabilities</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_predicted_marginal_probabilities</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">expected_durations</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        (array) Expected duration of a regime, possibly time-varying.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mf">1.</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">diagonal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">regime_transition</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">())</span>


<span class="k">class</span> <span class="nc">KimSmootherResults</span><span class="p">(</span><span class="n">HamiltonFilterResults</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Results from applying the Kim smoother to a Markov switching model.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    model : MarkovSwitchingModel</span>
<span class="sd">        The model object.</span>
<span class="sd">    result : dict</span>
<span class="sd">        A dictionary containing two keys: &#39;smoothd_joint_probabilities&#39; and</span>
<span class="sd">        &#39;smoothed_marginal_probabilities&#39;.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    nobs : int</span>
<span class="sd">        Number of observations.</span>
<span class="sd">    k_endog : int</span>
<span class="sd">        The dimension of the observation series.</span>
<span class="sd">    k_states : int</span>
<span class="sd">        The dimension of the unobserved state process.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">result</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">KimSmootherResults</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>

        <span class="n">attributes</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;smoothed_joint_probabilities&#39;</span><span class="p">,</span>
                      <span class="s1">&#39;smoothed_marginal_probabilities&#39;</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">attributes</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">name</span><span class="p">))</span>


<span class="k">class</span> <span class="nc">MarkovSwitchingResults</span><span class="p">(</span><span class="n">tsbase</span><span class="o">.</span><span class="n">TimeSeriesModelResults</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class to hold results from fitting a Markov switching model</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    model : MarkovSwitching instance</span>
<span class="sd">        The fitted model instance</span>
<span class="sd">    params : array</span>
<span class="sd">        Fitted parameters</span>
<span class="sd">    filter_results : HamiltonFilterResults or KimSmootherResults instance</span>
<span class="sd">        The underlying filter and, optionally, smoother output</span>
<span class="sd">    cov_type : string</span>
<span class="sd">        The type of covariance matrix estimator to use. Can be one of &#39;approx&#39;,</span>
<span class="sd">        &#39;opg&#39;, &#39;robust&#39;, or &#39;none&#39;.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    model : Model instance</span>
<span class="sd">        A reference to the model that was fit.</span>
<span class="sd">    filter_results : HamiltonFilterResults or KimSmootherResults instance</span>
<span class="sd">        The underlying filter and, optionally, smoother output</span>
<span class="sd">    nobs : float</span>
<span class="sd">        The number of observations used to fit the model.</span>
<span class="sd">    params : array</span>
<span class="sd">        The parameters of the model.</span>
<span class="sd">    scale : float</span>
<span class="sd">        This is currently set to 1.0 and not used by the model or its results.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">use_t</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">results</span><span class="p">,</span> <span class="n">cov_type</span><span class="o">=</span><span class="s1">&#39;opg&#39;</span><span class="p">,</span> <span class="n">cov_kwds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">data</span>

        <span class="n">tsbase</span><span class="o">.</span><span class="n">TimeSeriesModelResults</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span>
                                               <span class="n">normalized_cov_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                               <span class="n">scale</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span>

        <span class="c1"># Save the filter / smoother output</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filter_results</span> <span class="o">=</span> <span class="n">results</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="n">KimSmootherResults</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">smoother_results</span> <span class="o">=</span> <span class="n">results</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">smoother_results</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Dimensions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">nobs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">order</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">order</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k_regimes</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">k_regimes</span>

        <span class="c1"># Setup covariance matrix notes dictionary</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;cov_kwds&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cov_kwds</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cov_type</span> <span class="o">=</span> <span class="n">cov_type</span>

        <span class="c1"># Setup the cache</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span> <span class="o">=</span> <span class="n">resettable_cache</span><span class="p">()</span>

        <span class="c1"># Handle covariance matrix calculation</span>
        <span class="k">if</span> <span class="n">cov_kwds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">cov_kwds</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cov_approx_complex_step</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">cov_kwds</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;approx_complex_step&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cov_approx_centered</span> <span class="o">=</span> <span class="n">cov_kwds</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;approx_centered&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_rank</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_get_robustcov_results</span><span class="p">(</span><span class="n">cov_type</span><span class="o">=</span><span class="n">cov_type</span><span class="p">,</span> <span class="n">use_self</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                        <span class="o">**</span><span class="n">cov_kwds</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">LinAlgError</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_rank</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">k_params</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cov_params_default</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">k_params</span><span class="p">,</span> <span class="n">k_params</span><span class="p">))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cov_kwds</span><span class="p">[</span><span class="s1">&#39;cov_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s1">&#39;Covariance matrix could not be calculated: singular.&#39;</span>
                <span class="s1">&#39; information matrix.&#39;</span><span class="p">)</span>

        <span class="c1"># Copy over arrays</span>
        <span class="n">attributes</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;regime_transition&#39;</span><span class="p">,</span> <span class="s1">&#39;initial_probabilities&#39;</span><span class="p">,</span>
                      <span class="s1">&#39;conditional_likelihoods&#39;</span><span class="p">,</span>
                      <span class="s1">&#39;predicted_marginal_probabilities&#39;</span><span class="p">,</span>
                      <span class="s1">&#39;predicted_joint_probabilities&#39;</span><span class="p">,</span>
                      <span class="s1">&#39;filtered_marginal_probabilities&#39;</span><span class="p">,</span>
                      <span class="s1">&#39;filtered_joint_probabilities&#39;</span><span class="p">,</span>
                      <span class="s1">&#39;joint_likelihoods&#39;</span><span class="p">,</span> <span class="s1">&#39;expected_durations&#39;</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">attributes</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filter_results</span><span class="p">,</span> <span class="n">name</span><span class="p">))</span>

        <span class="n">attributes</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;smoothed_joint_probabilities&#39;</span><span class="p">,</span>
                      <span class="s1">&#39;smoothed_marginal_probabilities&#39;</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">attributes</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">smoother_results</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">smoother_results</span><span class="p">,</span> <span class="n">name</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="c1"># Reshape some arrays to long-format</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">predicted_marginal_probabilities</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">predicted_marginal_probabilities</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filtered_marginal_probabilities</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">filtered_marginal_probabilities</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">smoother_results</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">smoothed_marginal_probabilities</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">smoothed_marginal_probabilities</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

        <span class="c1"># Make into Pandas arrays if using Pandas data</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">PandasData</span><span class="p">):</span>
            <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">row_labels</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">expected_durations</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">expected_durations</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">expected_durations</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">predicted_marginal_probabilities</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">predicted_marginal_probabilities</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">filtered_marginal_probabilities</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">filtered_marginal_probabilities</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">smoother_results</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">smoothed_marginal_probabilities</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">smoothed_marginal_probabilities</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_robustcov_results</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cov_type</span><span class="o">=</span><span class="s1">&#39;opg&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">use_self</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;use_self&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">use_self</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span>
            <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">,</span>
                <span class="n">normalized_cov_params</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">normalized_cov_params</span><span class="p">,</span>
                <span class="n">scale</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">)</span>

        <span class="c1"># Set the new covariance type</span>
        <span class="n">res</span><span class="o">.</span><span class="n">cov_type</span> <span class="o">=</span> <span class="n">cov_type</span>
        <span class="n">res</span><span class="o">.</span><span class="n">cov_kwds</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="n">approx_type_str</span> <span class="o">=</span> <span class="s1">&#39;complex-step&#39;</span>

        <span class="c1"># Calculate the new covariance matrix</span>
        <span class="n">k_params</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">k_params</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">res</span><span class="o">.</span><span class="n">cov_params_default</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
            <span class="n">res</span><span class="o">.</span><span class="n">_rank</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">res</span><span class="o">.</span><span class="n">cov_kwds</span><span class="p">[</span><span class="s1">&#39;description&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;No parameters estimated.&#39;</span>
        <span class="k">elif</span> <span class="n">cov_type</span> <span class="o">==</span> <span class="s1">&#39;custom&#39;</span><span class="p">:</span>
            <span class="n">res</span><span class="o">.</span><span class="n">cov_type</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;custom_cov_type&#39;</span><span class="p">]</span>
            <span class="n">res</span><span class="o">.</span><span class="n">cov_params_default</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;custom_cov_params&#39;</span><span class="p">]</span>
            <span class="n">res</span><span class="o">.</span><span class="n">cov_kwds</span><span class="p">[</span><span class="s1">&#39;description&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;custom_description&#39;</span><span class="p">]</span>
            <span class="n">res</span><span class="o">.</span><span class="n">_rank</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">matrix_rank</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">cov_params_default</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">cov_type</span> <span class="o">==</span> <span class="s1">&#39;none&#39;</span><span class="p">:</span>
            <span class="n">res</span><span class="o">.</span><span class="n">cov_params_default</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">k_params</span><span class="p">,</span> <span class="n">k_params</span><span class="p">))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">res</span><span class="o">.</span><span class="n">_rank</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">res</span><span class="o">.</span><span class="n">cov_kwds</span><span class="p">[</span><span class="s1">&#39;description&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;Covariance matrix not calculated.&#39;</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">cov_type</span> <span class="o">==</span> <span class="s1">&#39;approx&#39;</span><span class="p">:</span>
            <span class="n">res</span><span class="o">.</span><span class="n">cov_params_default</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">cov_params_approx</span>
            <span class="n">res</span><span class="o">.</span><span class="n">cov_kwds</span><span class="p">[</span><span class="s1">&#39;description&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s1">&#39;Covariance matrix calculated using numerical (</span><span class="si">%s</span><span class="s1">)&#39;</span>
                <span class="s1">&#39; differentiation.&#39;</span> <span class="o">%</span> <span class="n">approx_type_str</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">cov_type</span> <span class="o">==</span> <span class="s1">&#39;opg&#39;</span><span class="p">:</span>
            <span class="n">res</span><span class="o">.</span><span class="n">cov_params_default</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">cov_params_opg</span>
            <span class="n">res</span><span class="o">.</span><span class="n">cov_kwds</span><span class="p">[</span><span class="s1">&#39;description&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s1">&#39;Covariance matrix calculated using the outer product of&#39;</span>
                <span class="s1">&#39; gradients (</span><span class="si">%s</span><span class="s1">).&#39;</span> <span class="o">%</span> <span class="n">approx_type_str</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">cov_type</span> <span class="o">==</span> <span class="s1">&#39;robust&#39;</span><span class="p">:</span>
            <span class="n">res</span><span class="o">.</span><span class="n">cov_params_default</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">cov_params_robust</span>
            <span class="n">res</span><span class="o">.</span><span class="n">cov_kwds</span><span class="p">[</span><span class="s1">&#39;description&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s1">&#39;Quasi-maximum likelihood covariance matrix used for&#39;</span>
                <span class="s1">&#39; robustness to some misspecifications; calculated using&#39;</span>
                <span class="s1">&#39; numerical (</span><span class="si">%s</span><span class="s1">) differentiation.&#39;</span> <span class="o">%</span> <span class="n">approx_type_str</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Invalid covariance matrix type.&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">res</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">aic</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        (float) Akaike Information Criterion</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># return -2*self.llf + 2*self.params.shape[0]</span>
        <span class="k">return</span> <span class="n">aic</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">llf</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">bic</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        (float) Bayes Information Criterion</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># return -2*self.llf + self.params.shape[0]*np.log(self.nobs)</span>
        <span class="k">return</span> <span class="n">bic</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">llf</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">cov_params_approx</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        (array) The variance / covariance matrix. Computed using the numerical</span>
<span class="sd">        Hessian approximated by complex step or finite differences methods.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">evaluated_hessian</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">hessian</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">neg_cov</span><span class="p">,</span> <span class="n">singular_values</span> <span class="o">=</span> <span class="n">pinv_extended</span><span class="p">(</span><span class="n">evaluated_hessian</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rank</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_rank</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">matrix_rank</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">singular_values</span><span class="p">))</span>

        <span class="k">return</span> <span class="o">-</span><span class="n">neg_cov</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">cov_params_opg</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        (array) The variance / covariance matrix. Computed using the outer</span>
<span class="sd">        product of gradients method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">score_obs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">score_obs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="n">cov_params</span><span class="p">,</span> <span class="n">singular_values</span> <span class="o">=</span> <span class="n">pinv_extended</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">score_obs</span><span class="p">,</span> <span class="n">score_obs</span><span class="p">))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rank</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_rank</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">matrix_rank</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">singular_values</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">cov_params</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">cov_params_robust</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        (array) The QMLE variance / covariance matrix. Computed using the</span>
<span class="sd">        numerical Hessian as the evaluated hessian.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cov_opg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cov_params_opg</span>
        <span class="n">evaluated_hessian</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">hessian</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">cov_params</span><span class="p">,</span> <span class="n">singular_values</span> <span class="o">=</span> <span class="n">pinv_extended</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">evaluated_hessian</span><span class="p">,</span> <span class="n">cov_opg</span><span class="p">),</span> <span class="n">evaluated_hessian</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rank</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_rank</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">matrix_rank</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">singular_values</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">cov_params</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">fittedvalues</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        (array) The predicted values of the model. An (nobs x k_endog) array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">hqic</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        (float) Hannan-Quinn Information Criterion</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># return -2*self.llf + 2*np.log(np.log(self.nobs))*self.params.shape[0]</span>
        <span class="k">return</span> <span class="n">hqic</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">llf</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">llf_obs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        (float) The value of the log-likelihood function evaluated at `params`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">loglikeobs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">llf</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        (float) The value of the log-likelihood function evaluated at `params`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">loglike</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">resid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        (array) The model residuals. An (nobs x k_endog) array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">endog</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">fittedvalues</span>

    <span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">probabilities</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">conditional</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        In-sample prediction and out-of-sample forecasting</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        start : int, str, or datetime, optional</span>
<span class="sd">            Zero-indexed observation number at which to start forecasting,</span>
<span class="sd">            i.e., the first forecast is start. Can also be a date string to</span>
<span class="sd">            parse or a datetime type. Default is the the zeroth observation.</span>
<span class="sd">        end : int, str, or datetime, optional</span>
<span class="sd">            Zero-indexed observation number at which to end forecasting, i.e.,</span>
<span class="sd">            the last forecast is end. Can also be a date string to</span>
<span class="sd">            parse or a datetime type. However, if the dates index does not</span>
<span class="sd">            have a fixed frequency, end must be an integer index if you</span>
<span class="sd">            want out of sample prediction. Default is the last observation in</span>
<span class="sd">            the sample.</span>
<span class="sd">        probabilities : string or array_like, optional</span>
<span class="sd">            Specifies the weighting probabilities used in constructing the</span>
<span class="sd">            prediction as a weighted average. If a string, can be &#39;predicted&#39;,</span>
<span class="sd">            &#39;filtered&#39;, or &#39;smoothed&#39;. Otherwise can be an array of</span>
<span class="sd">            probabilities to use. Default is smoothed.</span>
<span class="sd">        conditional: boolean or int, optional</span>
<span class="sd">            Whether or not to return predictions conditional on current or</span>
<span class="sd">            past regimes. If False, returns a single vector of weighted</span>
<span class="sd">            predictions. If True or 1, returns predictions conditional on the</span>
<span class="sd">            current regime. For larger integers, returns predictions</span>
<span class="sd">            conditional on the current regime and some number of past regimes.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        predict : array</span>
<span class="sd">            Array of out of in-sample predictions and / or out-of-sample</span>
<span class="sd">            forecasts. An (npredict x k_endog) array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="n">end</span><span class="p">,</span>
                                  <span class="n">probabilities</span><span class="o">=</span><span class="n">probabilities</span><span class="p">,</span>
                                  <span class="n">conditional</span><span class="o">=</span><span class="n">conditional</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">forecast</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">steps</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Out-of-sample forecasts</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        steps : int, str, or datetime, optional</span>
<span class="sd">            If an integer, the number of steps to forecast from the end of the</span>
<span class="sd">            sample. Can also be a date string to parse or a datetime type.</span>
<span class="sd">            However, if the dates index does not have a fixed frequency, steps</span>
<span class="sd">            must be an integer. Default</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Additional arguments may required for forecasting beyond the end</span>
<span class="sd">            of the sample. See `FilterResults.predict` for more details.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        forecast : array</span>
<span class="sd">            Array of out of sample forecasts. A (steps x k_endog) array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="k">def</span> <span class="nf">summary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=.</span><span class="mi">05</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">model_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">display_params</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Summarize the Model</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        alpha : float, optional</span>
<span class="sd">            Significance level for the confidence intervals. Default is 0.05.</span>
<span class="sd">        start : int, optional</span>
<span class="sd">            Integer of the start observation. Default is 0.</span>
<span class="sd">        title : str, optional</span>
<span class="sd">            The title of the summary table.</span>
<span class="sd">        model_name : string</span>
<span class="sd">            The name of the model used. Default is to use model class name.</span>
<span class="sd">        display_params : boolean, optional</span>
<span class="sd">            Whether or not to display tables of estimated parameters. Default</span>
<span class="sd">            is True. Usually only used internally.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        summary : Summary instance</span>
<span class="sd">            This holds the summary table and text, which can be printed or</span>
<span class="sd">            converted to various output formats.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        statsmodels.iolib.summary.Summary</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">statsmodels.iolib.summary</span> <span class="k">import</span> <span class="n">Summary</span>

        <span class="c1"># Model specification results</span>
        <span class="n">model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span>
        <span class="k">if</span> <span class="n">title</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">title</span> <span class="o">=</span> <span class="s1">&#39;Markov Switching Model Results&#39;</span>

        <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">dates</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">dates</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">dates</span><span class="p">[</span><span class="n">start</span><span class="p">]</span>
            <span class="n">sample</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;</span><span class="si">%02d</span><span class="s1">-</span><span class="si">%02d</span><span class="s1">-</span><span class="si">%02d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">month</span><span class="p">,</span> <span class="n">d</span><span class="o">.</span><span class="n">day</span><span class="p">,</span> <span class="n">d</span><span class="o">.</span><span class="n">year</span><span class="p">)]</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">dates</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">sample</span> <span class="o">+=</span> <span class="p">[</span><span class="s1">&#39;- &#39;</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="si">%02d</span><span class="s1">-</span><span class="si">%02d</span><span class="s1">-</span><span class="si">%02d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">month</span><span class="p">,</span> <span class="n">d</span><span class="o">.</span><span class="n">day</span><span class="p">,</span> <span class="n">d</span><span class="o">.</span><span class="n">year</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sample</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">start</span><span class="p">),</span> <span class="s1">&#39; - &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">nobs</span><span class="p">)]</span>

        <span class="c1"># Standardize the model name as a list of str</span>
        <span class="k">if</span> <span class="n">model_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">model_name</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>

        <span class="c1"># Create the tables</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">model_name</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">model_name</span> <span class="o">=</span> <span class="p">[</span><span class="n">model_name</span><span class="p">]</span>

        <span class="n">top_left</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;Dep. Variable:&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)]</span>
        <span class="n">top_left</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s1">&#39;Model:&#39;</span><span class="p">,</span> <span class="p">[</span><span class="n">model_name</span><span class="p">[</span><span class="mi">0</span><span class="p">]]))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">model_name</span><span class="p">)):</span>
            <span class="n">top_left</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;+ &#39;</span> <span class="o">+</span> <span class="n">model_name</span><span class="p">[</span><span class="n">i</span><span class="p">]]))</span>
        <span class="n">top_left</span> <span class="o">+=</span> <span class="p">[</span>
            <span class="p">(</span><span class="s1">&#39;Date:&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
            <span class="p">(</span><span class="s1">&#39;Time:&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
            <span class="p">(</span><span class="s1">&#39;Sample:&#39;</span><span class="p">,</span> <span class="p">[</span><span class="n">sample</span><span class="p">[</span><span class="mi">0</span><span class="p">]]),</span>
            <span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="p">[</span><span class="n">sample</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
        <span class="p">]</span>

        <span class="n">top_right</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="s1">&#39;No. Observations:&#39;</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">nobs</span><span class="p">]),</span>
            <span class="p">(</span><span class="s1">&#39;Log Likelihood&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;</span><span class="si">%#5.3f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">llf</span><span class="p">]),</span>
            <span class="p">(</span><span class="s1">&#39;AIC&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;</span><span class="si">%#5.3f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">aic</span><span class="p">]),</span>
            <span class="p">(</span><span class="s1">&#39;BIC&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;</span><span class="si">%#5.3f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">bic</span><span class="p">]),</span>
            <span class="p">(</span><span class="s1">&#39;HQIC&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;</span><span class="si">%#5.3f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">hqic</span><span class="p">])</span>
        <span class="p">]</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;cov_type&#39;</span><span class="p">):</span>
            <span class="n">top_left</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s1">&#39;Covariance Type:&#39;</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">cov_type</span><span class="p">]))</span>

        <span class="n">summary</span> <span class="o">=</span> <span class="n">Summary</span><span class="p">()</span>
        <span class="n">summary</span><span class="o">.</span><span class="n">add_table_2cols</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gleft</span><span class="o">=</span><span class="n">top_left</span><span class="p">,</span> <span class="n">gright</span><span class="o">=</span><span class="n">top_right</span><span class="p">,</span>
                                <span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">)</span>

        <span class="c1"># Make parameters tables for each regime</span>
        <span class="kn">from</span> <span class="nn">statsmodels.iolib.summary</span> <span class="k">import</span> <span class="n">summary_params</span>
        <span class="kn">import</span> <span class="nn">re</span>

        <span class="k">def</span> <span class="nf">make_table</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">title</span><span class="p">,</span> <span class="n">strip_end</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="n">res</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="n">mask</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">bse</span><span class="p">[</span><span class="n">mask</span><span class="p">],</span>
                   <span class="bp">self</span><span class="o">.</span><span class="n">tvalues</span><span class="p">[</span><span class="n">mask</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">pvalues</span><span class="p">[</span><span class="n">mask</span><span class="p">],</span>
                   <span class="bp">self</span><span class="o">.</span><span class="n">conf_int</span><span class="p">(</span><span class="n">alpha</span><span class="p">)[</span><span class="n">mask</span><span class="p">])</span>

            <span class="n">param_names</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s1">&#39;\[\d+\]$&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span>
                <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">param_names</span><span class="p">)[</span><span class="n">mask</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="p">]</span>

            <span class="k">return</span> <span class="n">summary_params</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">yname</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">xname</span><span class="o">=</span><span class="n">param_names</span><span class="p">,</span>
                                  <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">use_t</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">)</span>

        <span class="n">params</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">parameters</span>
        <span class="n">regime_masks</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">k_regimes</span><span class="p">)]</span>
        <span class="n">other_masks</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">switching</span> <span class="ow">in</span> <span class="n">params</span><span class="o">.</span><span class="n">switching</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">k_params</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">switching</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="s1">&#39;regime_transition&#39;</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">other_masks</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k_params</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">switching</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_regimes</span><span class="p">):</span>
                        <span class="n">regime_masks</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">key</span><span class="p">][</span><span class="n">i</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">other_masks</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">key</span><span class="p">][</span><span class="n">i</span><span class="p">])</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_regimes</span><span class="p">):</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">regime_masks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">table</span> <span class="o">=</span> <span class="n">make_table</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="s1">&#39;Regime </span><span class="si">%d</span><span class="s1"> parameters&#39;</span> <span class="o">%</span> <span class="n">i</span><span class="p">)</span>
                <span class="n">summary</span><span class="o">.</span><span class="n">tables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">table</span><span class="p">)</span>

        <span class="n">mask</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">_mask</span> <span class="ow">in</span> <span class="n">other_masks</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">mask</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">_mask</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">table</span> <span class="o">=</span> <span class="n">make_table</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="s1">&#39;Non-switching parameters&#39;</span><span class="p">)</span>
            <span class="n">summary</span><span class="o">.</span><span class="n">tables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">table</span><span class="p">)</span>

        <span class="c1"># Transition parameters</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;regime_transition&#39;</span><span class="p">]</span>
        <span class="n">table</span> <span class="o">=</span> <span class="n">make_table</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="s1">&#39;Regime transition parameters&#39;</span><span class="p">)</span>
        <span class="n">summary</span><span class="o">.</span><span class="n">tables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">table</span><span class="p">)</span>

        <span class="c1"># Add warnings/notes, added to text format only</span>
        <span class="n">etext</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;cov_type&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="s1">&#39;description&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cov_kwds</span><span class="p">:</span>
            <span class="n">etext</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cov_kwds</span><span class="p">[</span><span class="s1">&#39;description&#39;</span><span class="p">])</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rank</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">):</span>
            <span class="n">etext</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;Covariance matrix is singular or near-singular,&quot;</span>
                         <span class="s2">&quot; with condition number </span><span class="si">%6.3g</span><span class="s2">. Standard errors may be&quot;</span>
                         <span class="s2">&quot; unstable.&quot;</span> <span class="o">%</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">cond</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cov_params</span><span class="p">()))</span>

        <span class="k">if</span> <span class="n">etext</span><span class="p">:</span>
            <span class="n">etext</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;[</span><span class="si">{0}</span><span class="s2">] </span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>
                     <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">text</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">etext</span><span class="p">)]</span>
            <span class="n">etext</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;Warnings:&quot;</span><span class="p">)</span>
            <span class="n">summary</span><span class="o">.</span><span class="n">add_extra_txt</span><span class="p">(</span><span class="n">etext</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">summary</span>


<span class="k">class</span> <span class="nc">MarkovSwitchingResultsWrapper</span><span class="p">(</span><span class="n">wrap</span><span class="o">.</span><span class="n">ResultsWrapper</span><span class="p">):</span>
    <span class="n">_attrs</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;cov_params_approx&#39;</span><span class="p">:</span> <span class="s1">&#39;cov&#39;</span><span class="p">,</span>
        <span class="s1">&#39;cov_params_default&#39;</span><span class="p">:</span> <span class="s1">&#39;cov&#39;</span><span class="p">,</span>
        <span class="s1">&#39;cov_params_opg&#39;</span><span class="p">:</span> <span class="s1">&#39;cov&#39;</span><span class="p">,</span>
        <span class="s1">&#39;cov_params_robust&#39;</span><span class="p">:</span> <span class="s1">&#39;cov&#39;</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="n">_wrap_attrs</span> <span class="o">=</span> <span class="n">wrap</span><span class="o">.</span><span class="n">union_dicts</span><span class="p">(</span><span class="n">tsbase</span><span class="o">.</span><span class="n">TimeSeriesResultsWrapper</span><span class="o">.</span><span class="n">_wrap_attrs</span><span class="p">,</span>
                                   <span class="n">_attrs</span><span class="p">)</span>
    <span class="n">_methods</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;forecast&#39;</span><span class="p">:</span> <span class="s1">&#39;dates&#39;</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="n">_wrap_methods</span> <span class="o">=</span> <span class="n">wrap</span><span class="o">.</span><span class="n">union_dicts</span><span class="p">(</span>
        <span class="n">tsbase</span><span class="o">.</span><span class="n">TimeSeriesResultsWrapper</span><span class="o">.</span><span class="n">_wrap_methods</span><span class="p">,</span> <span class="n">_methods</span><span class="p">)</span>
<span class="n">wrap</span><span class="o">.</span><span class="n">populate_wrapper</span><span class="p">(</span><span class="n">MarkovSwitchingResultsWrapper</span><span class="p">,</span>  <span class="c1"># noqa:E305</span>
                      <span class="n">MarkovSwitchingResults</span><span class="p">)</span>
</pre></div>




          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2009-2017, Josef Perktold, Skipper Seabold, Jonathan Taylor, statsmodels-developers.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.7.4.
    </div>
  </body>
</html>