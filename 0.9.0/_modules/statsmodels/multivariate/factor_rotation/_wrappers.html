

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>statsmodels.multivariate.factor_rotation._wrappers &#8212; statsmodels 0.9.0 documentation</title>
    <link rel="stylesheet" href="../../../../_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
    <script type="text/javascript" src="../../../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="shortcut icon" href="../../../../_static/statsmodels_hybi_favico.ico"/>
    <link rel="author" title="About these documents" href="../../../../about.html" />
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
<link rel="stylesheet" href="../../../../_static/examples.css" type="text/css" />
<link rel="stylesheet" href="../../../../_static/facebox.css" type="text/css" />
<script type="text/javascript" src="../../../../_static/scripts.js">
</script>
<script type="text/javascript" src="../../../../_static/facebox.js">
</script>
<script type="text/javascript">
$.facebox.settings.closeImage = "../../../../_static/closelabel.png"
$.facebox.settings.loadingImage = "../../../../_static/loading.gif"
</script>

  </head><body>
<div class="headerwrap">
    <div class = "header">
        
        <a href = "../../../../index.html">
<img src="../../../../_static/statsmodels_hybi_banner.png" alt="Logo"
    style="padding-left: 15px"/></a>
        
    </div>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
<li><a href ="../../../../install.html">Install</a></li> &nbsp;|&nbsp;
<li><a href="https://groups.google.com/forum/?hl=en#!forum/pystatsmodels">Support</a></li> &nbsp;|&nbsp;
<li><a href="https://github.com/statsmodels/statsmodels/issues">Bugs</a></li> &nbsp;|&nbsp;
<li><a href="../../../../dev/index.html">Develop</a></li> &nbsp;|&nbsp;
<li><a href="../../../../examples/index.html">Examples</a></li> &nbsp;|&nbsp;
<li><a href="../../../../faq.html">FAQ</a></li> &nbsp;|&nbsp;

          <li class="nav-item nav-item-1"><a href="../../../index.html" accesskey="U">Module code</a> |</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            




  <h1>Source code for statsmodels.multivariate.factor_rotation._wrappers</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">division</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">print_function</span>
<span class="kn">from</span> <span class="nn">._analytic_rotation</span> <span class="k">import</span> <span class="n">target_rotation</span>
<span class="kn">from</span> <span class="nn">._gpa_rotation</span> <span class="k">import</span> <span class="n">oblimin_objective</span><span class="p">,</span> <span class="n">orthomax_objective</span><span class="p">,</span> <span class="n">CF_objective</span>
<span class="kn">from</span> <span class="nn">._gpa_rotation</span> <span class="k">import</span> <span class="n">ff_partial_target</span><span class="p">,</span> <span class="n">ff_target</span>
<span class="kn">from</span> <span class="nn">._gpa_rotation</span> <span class="k">import</span> <span class="n">vgQ_partial_target</span><span class="p">,</span> <span class="n">vgQ_target</span>
<span class="kn">from</span> <span class="nn">._gpa_rotation</span> <span class="k">import</span> <span class="n">rotateA</span><span class="p">,</span> <span class="n">GPA</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[]</span>


<div class="viewcode-block" id="rotate_factors"><a class="viewcode-back" href="../../../../generated/statsmodels.multivariate.factor_rotation.rotate_factors.html#statsmodels.multivariate.factor_rotation.rotate_factors">[docs]</a><span class="k">def</span> <span class="nf">rotate_factors</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="o">*</span><span class="n">method_args</span><span class="p">,</span> <span class="o">**</span><span class="n">algorithm_kwargs</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Subroutine for orthogonal and oblique rotation of the matrix :math:`A`.</span>
<span class="sd">    For orthogonal rotations :math:`A` is rotated to :math:`L` according to</span>

<span class="sd">    .. math::</span>

<span class="sd">        L =  AT,</span>

<span class="sd">    where :math:`T` is an orthogonal matrix. And, for oblique rotations</span>
<span class="sd">    :math:`A` is rotated to :math:`L` according to</span>

<span class="sd">    .. math::</span>

<span class="sd">        L =  A(T^*)^{-1},</span>

<span class="sd">    where :math:`T` is a normal matrix.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    A : numpy matrix (default None)</span>
<span class="sd">        non rotated factors</span>
<span class="sd">    method : string</span>
<span class="sd">        should be one of the methods listed below</span>
<span class="sd">    method_args : list</span>
<span class="sd">        additional arguments that should be provided with each method</span>
<span class="sd">    algorithm_kwargs : dictionary</span>
<span class="sd">        algorithm : string (default gpa)</span>
<span class="sd">            should be one of:</span>

<span class="sd">            * &#39;gpa&#39;: a numerical method</span>
<span class="sd">            * &#39;gpa_der_free&#39;: a derivative free numerical method</span>
<span class="sd">            * &#39;analytic&#39; : an analytic method</span>

<span class="sd">        Depending on the algorithm, there are algorithm specific keyword</span>
<span class="sd">        arguments. For the gpa and gpa_der_free, the following</span>
<span class="sd">        keyword arguments are available:</span>

<span class="sd">        max_tries : integer (default 501)</span>
<span class="sd">            maximum number of iterations</span>

<span class="sd">        tol : float</span>
<span class="sd">            stop criterion, algorithm stops if Frobenius norm of gradient is</span>
<span class="sd">            smaller then tol</span>

<span class="sd">        For analytic, the supporeted arguments depend on the method, see above.</span>

<span class="sd">        See the lower level functions for more details.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    The tuple :math:`(L,T)`</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    What follows is a list of available methods. Depending on the method</span>
<span class="sd">    additional argument are required and different algorithms</span>
<span class="sd">    are available. The algorithm_kwargs are additional keyword arguments</span>
<span class="sd">    passed to the selected algorithm (see the parameters section).</span>
<span class="sd">    Unless stated otherwise, only the gpa and</span>
<span class="sd">    gpa_der_free algorithm are available.</span>

<span class="sd">    Below,</span>

<span class="sd">        * :math:`L` is a :math:`p\times k` matrix;</span>
<span class="sd">        * :math:`N` is :math:`k\times k` matrix with zeros on the diagonal and ones</span>
<span class="sd">          elsewhere;</span>
<span class="sd">        * :math:`M` is :math:`p\times p` matrix with zeros on the diagonal and ones</span>
<span class="sd">          elsewhere;</span>
<span class="sd">        * :math:`C` is a :math:`p\times p` matrix with elements equal to</span>
<span class="sd">          :math:`1/p`;</span>
<span class="sd">        * :math:`(X,Y)=\operatorname{Tr}(X^*Y)` is the Frobenius norm;</span>
<span class="sd">        * :math:`\circ` is the element-wise product or Hadamard product.</span>

<span class="sd">    oblimin : orthogonal or oblique rotation that minimizes</span>
<span class="sd">        .. math::</span>
<span class="sd">            \phi(L) = \frac{1}{4}(L\circ L,(I-\gamma C)(L\circ L)N).</span>

<span class="sd">        For orthogonal rotations:</span>

<span class="sd">        * :math:`\gamma=0` corresponds to quartimax,</span>
<span class="sd">        * :math:`\gamma=\frac{1}{2}` corresponds to biquartimax,</span>
<span class="sd">        * :math:`\gamma=1` corresponds to varimax,</span>
<span class="sd">        * :math:`\gamma=\frac{1}{p}` corresponds to equamax.</span>

<span class="sd">        For oblique rotations rotations:</span>

<span class="sd">        * :math:`\gamma=0` corresponds to quartimin,</span>
<span class="sd">        * :math:`\gamma=\frac{1}{2}` corresponds to biquartimin.</span>

<span class="sd">        method_args:</span>

<span class="sd">        gamma : float</span>
<span class="sd">            oblimin family parameter</span>
<span class="sd">        rotation_method : string</span>
<span class="sd">            should be one of {orthogonal, oblique}</span>

<span class="sd">    orthomax : orthogonal rotation that minimizes</span>

<span class="sd">        .. math::</span>
<span class="sd">            \phi(L) = -\frac{1}{4}(L\circ L,(I-\gamma C)(L\circ L)),</span>

<span class="sd">        where :math:`0\leq\gamma\leq1`. The orthomax family is equivalent to</span>
<span class="sd">        the oblimin family (when restricted to orthogonal rotations).</span>
<span class="sd">        Furthermore,</span>

<span class="sd">        * :math:`\gamma=0` corresponds to quartimax,</span>
<span class="sd">        * :math:`\gamma=\frac{1}{2}` corresponds to biquartimax,</span>
<span class="sd">        * :math:`\gamma=1` corresponds to varimax,</span>
<span class="sd">        * :math:`\gamma=\frac{1}{p}` corresponds to equamax.</span>

<span class="sd">        method_args:</span>

<span class="sd">        gamma : float (between 0 and 1)</span>
<span class="sd">            orthomax family parameter</span>

<span class="sd">    CF : Crawford-Ferguson family for orthogonal and oblique rotation which</span>
<span class="sd">    minimizes:</span>

<span class="sd">        .. math::</span>

<span class="sd">            \phi(L) =\frac{1-\kappa}{4} (L\circ L,(L\circ L)N)</span>
<span class="sd">                     -\frac{1}{4}(L\circ L,M(L\circ L)),</span>

<span class="sd">        where :math:`0\leq\kappa\leq1`. For orthogonal rotations the oblimin</span>
<span class="sd">        (and orthomax) family of rotations is equivalent to the</span>
<span class="sd">        Crawford-Ferguson family.</span>
<span class="sd">        To be more precise:</span>

<span class="sd">        * :math:`\kappa=0` corresponds to quartimax,</span>
<span class="sd">        * :math:`\kappa=\frac{1}{p}` corresponds to varimax,</span>
<span class="sd">        * :math:`\kappa=\frac{k-1}{p+k-2}` corresponds to parsimax,</span>
<span class="sd">        * :math:`\kappa=1` corresponds to factor parsimony.</span>

<span class="sd">        method_args:</span>

<span class="sd">        kappa : float (between 0 and 1)</span>
<span class="sd">            Crawford-Ferguson family parameter</span>
<span class="sd">        rotation_method : string</span>
<span class="sd">            should be one of {orthogonal, oblique}</span>

<span class="sd">    quartimax : orthogonal rotation method</span>
<span class="sd">        minimizes the orthomax objective with :math:`\gamma=0`</span>

<span class="sd">    biquartimax : orthogonal rotation method</span>
<span class="sd">        minimizes the orthomax objective with :math:`\gamma=\frac{1}{2}`</span>

<span class="sd">    varimax : orthogonal rotation method</span>
<span class="sd">        minimizes the orthomax objective with :math:`\gamma=1`</span>

<span class="sd">    equamax : orthogonal rotation method</span>
<span class="sd">        minimizes the orthomax objective with :math:`\gamma=\frac{1}{p}`</span>

<span class="sd">    parsimax : orthogonal rotation method</span>
<span class="sd">        minimizes the Crawford-Ferguson family objective with</span>
<span class="sd">        :math:`\kappa=\frac{k-1}{p+k-2}`</span>

<span class="sd">    parsimony : orthogonal rotation method</span>
<span class="sd">        minimizes the Crawford-Ferguson family objective with :math:`\kappa=1`</span>

<span class="sd">    quartimin : oblique rotation method that minimizes</span>
<span class="sd">        minimizes the oblimin objective with :math:`\gamma=0`</span>

<span class="sd">    quartimin : oblique rotation method that minimizes</span>
<span class="sd">        minimizes the oblimin objective with :math:`\gamma=\frac{1}{2}`</span>

<span class="sd">    target : orthogonal or oblique rotation that rotates towards a target</span>

<span class="sd">    matrix : math:`H` by minimizing the objective</span>

<span class="sd">        .. math::</span>

<span class="sd">            \phi(L) =\frac{1}{2}\|L-H\|^2.</span>

<span class="sd">        method_args:</span>

<span class="sd">        H : numpy matrix</span>
<span class="sd">            target matrix</span>
<span class="sd">        rotation_method : string</span>
<span class="sd">            should be one of {orthogonal, oblique}</span>

<span class="sd">        For orthogonal rotations the algorithm can be set to analytic in which</span>
<span class="sd">        case the following keyword arguments are available:</span>

<span class="sd">        full_rank : boolean (default False)</span>
<span class="sd">            if set to true full rank is assumed</span>

<span class="sd">    partial_target : orthogonal (default) or oblique rotation that partially</span>
<span class="sd">    rotates towards a target matrix :math:`H` by minimizing the objective:</span>

<span class="sd">        .. math::</span>

<span class="sd">            \phi(L) =\frac{1}{2}\|W\circ(L-H)\|^2.</span>

<span class="sd">        method_args:</span>

<span class="sd">        H : numpy matrix</span>
<span class="sd">            target matrix</span>
<span class="sd">        W : numpy matrix (default matrix with equal weight one for all entries)</span>
<span class="sd">            matrix with weights, entries can either be one or zero</span>

<span class="sd">    Examples</span>
<span class="sd">    -------</span>
<span class="sd">    &gt;&gt;&gt; A = np.random.randn(8,2)</span>
<span class="sd">    &gt;&gt;&gt; L, T = rotate_factors(A,&#39;varimax&#39;)</span>
<span class="sd">    &gt;&gt;&gt; np.allclose(L,A.dot(T))</span>
<span class="sd">    &gt;&gt;&gt; L, T = rotate_factors(A,&#39;orthomax&#39;,0.5)</span>
<span class="sd">    &gt;&gt;&gt; np.allclose(L,A.dot(T))</span>
<span class="sd">    &gt;&gt;&gt; L, T = rotate_factors(A,&#39;quartimin&#39;,0.5)</span>
<span class="sd">    &gt;&gt;&gt; np.allclose(L,A.dot(np.linalg.inv(T.T)))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="s1">&#39;algorithm&#39;</span> <span class="ow">in</span> <span class="n">algorithm_kwargs</span><span class="p">:</span>
        <span class="n">algorithm</span> <span class="o">=</span> <span class="n">algorithm_kwargs</span><span class="p">[</span><span class="s1">&#39;algorithm&#39;</span><span class="p">]</span>
        <span class="n">algorithm_kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;algorithm&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">algorithm</span> <span class="o">=</span> <span class="s1">&#39;gpa&#39;</span>
    <span class="k">assert</span> <span class="ow">not</span> <span class="p">(</span><span class="s1">&#39;rotation_method&#39;</span> <span class="ow">in</span> <span class="n">algorithm_kwargs</span><span class="p">),</span> <span class="p">(</span>
        <span class="s1">&#39;rotation_method cannot be provided as keyword argument&#39;</span><span class="p">)</span>
    <span class="n">L</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">T</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">ff</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">vgQ</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">p</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span>
    <span class="c1"># set ff or vgQ to appropriate objective function, compute solution using</span>
    <span class="c1"># recursion or analytically compute solution</span>
    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;orthomax&#39;</span><span class="p">:</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">method_args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;Only </span><span class="si">%s</span><span class="s1"> family parameter should be &#39;</span>
                                       <span class="s1">&#39;provided&#39;</span> <span class="o">%</span> <span class="n">method</span><span class="p">)</span>
        <span class="n">rotation_method</span> <span class="o">=</span> <span class="s1">&#39;orthogonal&#39;</span>
        <span class="n">gamma</span> <span class="o">=</span> <span class="n">method_args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">algorithm</span> <span class="o">==</span> <span class="s1">&#39;gpa&#39;</span><span class="p">:</span>
            <span class="n">vgQ</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">L</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">A</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="kc">None</span><span class="p">:</span> <span class="n">orthomax_objective</span><span class="p">(</span>
                <span class="n">L</span><span class="o">=</span><span class="n">L</span><span class="p">,</span> <span class="n">A</span><span class="o">=</span><span class="n">A</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="n">T</span><span class="p">,</span> <span class="n">gamma</span><span class="o">=</span><span class="n">gamma</span><span class="p">,</span> <span class="n">return_gradient</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">algorithm</span> <span class="o">==</span> <span class="s1">&#39;gpa_der_free&#39;</span><span class="p">:</span>
            <span class="n">ff</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">L</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">A</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="kc">None</span><span class="p">:</span> <span class="n">orthomax_objective</span><span class="p">(</span>
                <span class="n">L</span><span class="o">=</span><span class="n">L</span><span class="p">,</span> <span class="n">A</span><span class="o">=</span><span class="n">A</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="n">T</span><span class="p">,</span> <span class="n">gamma</span><span class="o">=</span><span class="n">gamma</span><span class="p">,</span> <span class="n">return_gradient</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Algorithm </span><span class="si">%s</span><span class="s1"> is not possible for </span><span class="si">%s</span><span class="s1"> &#39;</span>
                             <span class="s1">&#39;rotation&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">algorithm</span><span class="p">,</span> <span class="n">method</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;oblimin&#39;</span><span class="p">:</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">method_args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;Both </span><span class="si">%s</span><span class="s1"> family parameter and &#39;</span>
                                       <span class="s1">&#39;rotation_method should be &#39;</span>
                                       <span class="s1">&#39;provided&#39;</span> <span class="o">%</span> <span class="n">method</span><span class="p">)</span>
        <span class="n">rotation_method</span> <span class="o">=</span> <span class="n">method_args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">assert</span> <span class="n">rotation_method</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;orthogonal&#39;</span><span class="p">,</span> <span class="s1">&#39;oblique&#39;</span><span class="p">],</span> <span class="p">(</span>
            <span class="s1">&#39;rotation_method should be one of {orthogonal, oblique}&#39;</span><span class="p">)</span>
        <span class="n">gamma</span> <span class="o">=</span> <span class="n">method_args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">algorithm</span> <span class="o">==</span> <span class="s1">&#39;gpa&#39;</span><span class="p">:</span>
            <span class="n">vgQ</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">L</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">A</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="kc">None</span><span class="p">:</span> <span class="n">oblimin_objective</span><span class="p">(</span>
                <span class="n">L</span><span class="o">=</span><span class="n">L</span><span class="p">,</span> <span class="n">A</span><span class="o">=</span><span class="n">A</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="n">T</span><span class="p">,</span> <span class="n">gamma</span><span class="o">=</span><span class="n">gamma</span><span class="p">,</span> <span class="n">return_gradient</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">algorithm</span> <span class="o">==</span> <span class="s1">&#39;gpa_der_free&#39;</span><span class="p">:</span>
            <span class="n">ff</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">L</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">A</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="kc">None</span><span class="p">:</span> <span class="n">oblimin_objective</span><span class="p">(</span>
                <span class="n">L</span><span class="o">=</span><span class="n">L</span><span class="p">,</span> <span class="n">A</span><span class="o">=</span><span class="n">A</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="n">T</span><span class="p">,</span> <span class="n">gamma</span><span class="o">=</span><span class="n">gamma</span><span class="p">,</span> <span class="n">rotation_method</span><span class="o">=</span><span class="n">rotation_method</span><span class="p">,</span>
                <span class="n">return_gradient</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Algorithm </span><span class="si">%s</span><span class="s1"> is not possible for </span><span class="si">%s</span><span class="s1"> &#39;</span>
                             <span class="s1">&#39;rotation&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">algorithm</span><span class="p">,</span> <span class="n">method</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;CF&#39;</span><span class="p">:</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">method_args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;Both </span><span class="si">%s</span><span class="s1"> family parameter and &#39;</span>
                                       <span class="s1">&#39;rotation_method should be provided&#39;</span>
                                       <span class="o">%</span> <span class="n">method</span><span class="p">)</span>
        <span class="n">rotation_method</span> <span class="o">=</span> <span class="n">method_args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">assert</span> <span class="n">rotation_method</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;orthogonal&#39;</span><span class="p">,</span> <span class="s1">&#39;oblique&#39;</span><span class="p">],</span> <span class="p">(</span>
            <span class="s1">&#39;rotation_method should be one of {orthogonal, oblique}&#39;</span><span class="p">)</span>
        <span class="n">kappa</span> <span class="o">=</span> <span class="n">method_args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">algorithm</span> <span class="o">==</span> <span class="s1">&#39;gpa&#39;</span><span class="p">:</span>
            <span class="n">vgQ</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">L</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">A</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="kc">None</span><span class="p">:</span> <span class="n">CF_objective</span><span class="p">(</span>
                <span class="n">L</span><span class="o">=</span><span class="n">L</span><span class="p">,</span> <span class="n">A</span><span class="o">=</span><span class="n">A</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="n">T</span><span class="p">,</span> <span class="n">kappa</span><span class="o">=</span><span class="n">kappa</span><span class="p">,</span> <span class="n">rotation_method</span><span class="o">=</span><span class="n">rotation_method</span><span class="p">,</span>
                <span class="n">return_gradient</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">algorithm</span> <span class="o">==</span> <span class="s1">&#39;gpa_der_free&#39;</span><span class="p">:</span>
            <span class="n">ff</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">L</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">A</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="kc">None</span><span class="p">:</span> <span class="n">CF_objective</span><span class="p">(</span>
                <span class="n">L</span><span class="o">=</span><span class="n">L</span><span class="p">,</span> <span class="n">A</span><span class="o">=</span><span class="n">A</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="n">T</span><span class="p">,</span> <span class="n">kappa</span><span class="o">=</span><span class="n">kappa</span><span class="p">,</span> <span class="n">rotation_method</span><span class="o">=</span><span class="n">rotation_method</span><span class="p">,</span>
                <span class="n">return_gradient</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Algorithm </span><span class="si">%s</span><span class="s1"> is not possible for </span><span class="si">%s</span><span class="s1"> &#39;</span>
                             <span class="s1">&#39;rotation&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">algorithm</span><span class="p">,</span> <span class="n">method</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;quartimax&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">rotate_factors</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="s1">&#39;orthomax&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">**</span><span class="n">algorithm_kwargs</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;biquartimax&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">rotate_factors</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="s1">&#39;orthomax&#39;</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="o">**</span><span class="n">algorithm_kwargs</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;varimax&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">rotate_factors</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="s1">&#39;orthomax&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">algorithm_kwargs</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;equamax&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">rotate_factors</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="s1">&#39;orthomax&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="n">p</span><span class="p">,</span> <span class="o">**</span><span class="n">algorithm_kwargs</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;parsimax&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">rotate_factors</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="s1">&#39;CF&#39;</span><span class="p">,</span> <span class="p">(</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">p</span><span class="o">+</span><span class="n">k</span><span class="o">-</span><span class="mi">2</span><span class="p">),</span>
                              <span class="s1">&#39;orthogonal&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">algorithm_kwargs</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;parsimony&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">rotate_factors</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="s1">&#39;CF&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;orthogonal&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">algorithm_kwargs</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;quartimin&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">rotate_factors</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="s1">&#39;oblimin&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;oblique&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">algorithm_kwargs</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;biquartimin&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">rotate_factors</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="s1">&#39;oblimin&#39;</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="s1">&#39;oblique&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">algorithm_kwargs</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;target&#39;</span><span class="p">:</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">method_args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">,</span> <span class="p">(</span>
            <span class="s1">&#39;only the rotation target and orthogonal/oblique should be provide&#39;</span>
            <span class="s1">&#39; for </span><span class="si">%s</span><span class="s1"> rotation&#39;</span> <span class="o">%</span> <span class="n">method</span><span class="p">)</span>
        <span class="n">H</span> <span class="o">=</span> <span class="n">method_args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">rotation_method</span> <span class="o">=</span> <span class="n">method_args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">assert</span> <span class="n">rotation_method</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;orthogonal&#39;</span><span class="p">,</span> <span class="s1">&#39;oblique&#39;</span><span class="p">],</span> <span class="p">(</span>
            <span class="s1">&#39;rotation_method should be one of {orthogonal, oblique}&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">algorithm</span> <span class="o">==</span> <span class="s1">&#39;gpa&#39;</span><span class="p">:</span>
            <span class="n">vgQ</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">L</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">A</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="kc">None</span><span class="p">:</span> <span class="n">vgQ_target</span><span class="p">(</span>
                <span class="n">H</span><span class="p">,</span> <span class="n">L</span><span class="o">=</span><span class="n">L</span><span class="p">,</span> <span class="n">A</span><span class="o">=</span><span class="n">A</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="n">T</span><span class="p">,</span> <span class="n">rotation_method</span><span class="o">=</span><span class="n">rotation_method</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">algorithm</span> <span class="o">==</span> <span class="s1">&#39;gpa_der_free&#39;</span><span class="p">:</span>
            <span class="n">ff</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">L</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">A</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="kc">None</span><span class="p">:</span> <span class="n">ff_target</span><span class="p">(</span>
                <span class="n">H</span><span class="p">,</span> <span class="n">L</span><span class="o">=</span><span class="n">L</span><span class="p">,</span> <span class="n">A</span><span class="o">=</span><span class="n">A</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="n">T</span><span class="p">,</span> <span class="n">rotation_method</span><span class="o">=</span><span class="n">rotation_method</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">algorithm</span> <span class="o">==</span> <span class="s1">&#39;analytic&#39;</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">rotation_method</span> <span class="o">==</span> <span class="s1">&#39;orthogonal&#39;</span><span class="p">,</span> <span class="p">(</span>
                <span class="s1">&#39;For analytic </span><span class="si">%s</span><span class="s1"> rotation only orthogonal rotation is &#39;</span>
                <span class="s1">&#39;supported&#39;</span><span class="p">)</span>
            <span class="n">T</span> <span class="o">=</span> <span class="n">target_rotation</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="o">**</span><span class="n">algorithm_kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Algorithm </span><span class="si">%s</span><span class="s1"> is not possible for </span><span class="si">%s</span><span class="s1"> rotation&#39;</span>
                             <span class="o">%</span> <span class="p">(</span><span class="n">algorithm</span><span class="p">,</span> <span class="n">method</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;partial_target&#39;</span><span class="p">:</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">method_args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;2 additional arguments are expected &#39;</span>
                                       <span class="s1">&#39;for </span><span class="si">%s</span><span class="s1"> rotation&#39;</span> <span class="o">%</span> <span class="n">method</span><span class="p">)</span>
        <span class="n">H</span> <span class="o">=</span> <span class="n">method_args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">W</span> <span class="o">=</span> <span class="n">method_args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">rotation_method</span> <span class="o">=</span> <span class="s1">&#39;orthogonal&#39;</span>
        <span class="k">if</span> <span class="n">algorithm</span> <span class="o">==</span> <span class="s1">&#39;gpa&#39;</span><span class="p">:</span>
            <span class="n">vgQ</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">L</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">A</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="kc">None</span><span class="p">:</span> <span class="n">vgQ_partial_target</span><span class="p">(</span>
                <span class="n">H</span><span class="p">,</span> <span class="n">W</span><span class="o">=</span><span class="n">W</span><span class="p">,</span> <span class="n">L</span><span class="o">=</span><span class="n">L</span><span class="p">,</span> <span class="n">A</span><span class="o">=</span><span class="n">A</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="n">T</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">algorithm</span> <span class="o">==</span> <span class="s1">&#39;gpa_der_free&#39;</span><span class="p">:</span>
            <span class="n">ff</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">L</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">A</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="kc">None</span><span class="p">:</span> <span class="n">ff_partial_target</span><span class="p">(</span>
                <span class="n">H</span><span class="p">,</span> <span class="n">W</span><span class="o">=</span><span class="n">W</span><span class="p">,</span> <span class="n">L</span><span class="o">=</span><span class="n">L</span><span class="p">,</span> <span class="n">A</span><span class="o">=</span><span class="n">A</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="n">T</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Algorithm </span><span class="si">%s</span><span class="s1"> is not possible for </span><span class="si">%s</span><span class="s1"> &#39;</span>
                             <span class="s1">&#39;rotation&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">algorithm</span><span class="p">,</span> <span class="n">method</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid method&#39;</span><span class="p">)</span>
    <span class="c1"># compute L and T if not already done</span>
    <span class="k">if</span> <span class="n">T</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">L</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">table</span> <span class="o">=</span> <span class="n">GPA</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">vgQ</span><span class="o">=</span><span class="n">vgQ</span><span class="p">,</span> <span class="n">ff</span><span class="o">=</span><span class="n">ff</span><span class="p">,</span>
                               <span class="n">rotation_method</span><span class="o">=</span><span class="n">rotation_method</span><span class="p">,</span>
                               <span class="o">**</span><span class="n">algorithm_kwargs</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">L</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">T</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;Cannot compute L without T&#39;</span>
        <span class="n">L</span> <span class="o">=</span> <span class="n">rotateA</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">rotation_method</span><span class="o">=</span><span class="n">rotation_method</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">L</span><span class="p">,</span> <span class="n">T</span></div>
</pre></div>




          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2009-2017, Josef Perktold, Skipper Seabold, Jonathan Taylor, statsmodels-developers.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.7.4.
    </div>
  </body>
</html>