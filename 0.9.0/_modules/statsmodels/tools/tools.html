

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>statsmodels.tools.tools &#8212; statsmodels 0.9.0 documentation</title>
    <link rel="stylesheet" href="../../../_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <script type="text/javascript" src="../../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="shortcut icon" href="../../../_static/statsmodels_hybi_favico.ico"/>
    <link rel="author" title="About these documents" href="../../../about.html" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
<link rel="stylesheet" href="../../../_static/examples.css" type="text/css" />
<link rel="stylesheet" href="../../../_static/facebox.css" type="text/css" />
<script type="text/javascript" src="../../../_static/scripts.js">
</script>
<script type="text/javascript" src="../../../_static/facebox.js">
</script>
<script type="text/javascript">
$.facebox.settings.closeImage = "../../../_static/closelabel.png"
$.facebox.settings.loadingImage = "../../../_static/loading.gif"
</script>

  </head><body>
<div class="headerwrap">
    <div class = "header">
        
        <a href = "../../../index.html">
<img src="../../../_static/statsmodels_hybi_banner.png" alt="Logo"
    style="padding-left: 15px"/></a>
        
    </div>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
<li><a href ="../../../install.html">Install</a></li> &nbsp;|&nbsp;
<li><a href="https://groups.google.com/forum/?hl=en#!forum/pystatsmodels">Support</a></li> &nbsp;|&nbsp;
<li><a href="https://github.com/statsmodels/statsmodels/issues">Bugs</a></li> &nbsp;|&nbsp;
<li><a href="../../../dev/index.html">Develop</a></li> &nbsp;|&nbsp;
<li><a href="../../../examples/index.html">Examples</a></li> &nbsp;|&nbsp;
<li><a href="../../../faq.html">FAQ</a></li> &nbsp;|&nbsp;

          <li class="nav-item nav-item-1"><a href="../../index.html" accesskey="U">Module code</a> |</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            




  <h1>Source code for statsmodels.tools.tools</h1><div class="highlight"><pre>
<span></span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">Utility functions models code</span>
<span class="sd">&#39;&#39;&#39;</span>
<span class="kn">from</span> <span class="nn">statsmodels.compat.python</span> <span class="k">import</span> <span class="n">reduce</span><span class="p">,</span> <span class="n">lzip</span><span class="p">,</span> <span class="n">lmap</span><span class="p">,</span> <span class="n">asstr2</span><span class="p">,</span> <span class="nb">range</span><span class="p">,</span> <span class="n">long</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">numpy.lib.recfunctions</span> <span class="k">as</span> <span class="nn">nprf</span>
<span class="kn">import</span> <span class="nn">numpy.linalg</span> <span class="k">as</span> <span class="nn">L</span>
<span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="k">import</span> <span class="n">svdvals</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>

<span class="kn">from</span> <span class="nn">statsmodels.datasets</span> <span class="k">import</span> <span class="n">webuse</span>
<span class="kn">from</span> <span class="nn">statsmodels.tools.data</span> <span class="k">import</span> <span class="n">_is_using_pandas</span><span class="p">,</span> <span class="n">_is_recarray</span>
<span class="kn">from</span> <span class="nn">statsmodels.compat.numpy</span> <span class="k">import</span> <span class="n">np_matrix_rank</span>


<span class="k">def</span> <span class="nf">_make_dictnames</span><span class="p">(</span><span class="n">tmp_arr</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Helper function to create a dictionary mapping a column number</span>
<span class="sd">    to the name in tmp_arr.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">col_map</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">col_name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">tmp_arr</span><span class="p">):</span>
        <span class="n">col_map</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">i</span><span class="o">+</span><span class="n">offset</span> <span class="p">:</span> <span class="n">col_name</span><span class="p">})</span>
    <span class="k">return</span> <span class="n">col_map</span>


<span class="k">def</span> <span class="nf">drop_missing</span><span class="p">(</span><span class="n">Y</span><span class="p">,</span> <span class="n">X</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns views on the arrays Y and X where missing observations are dropped.</span>

<span class="sd">    Y : array-like</span>
<span class="sd">    X : array-like, optional</span>
<span class="sd">    axis : int</span>
<span class="sd">        Axis along which to look for missing observations.  Default is 1, ie.,</span>
<span class="sd">        observations in rows.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Y : array</span>
<span class="sd">        All Y where the</span>
<span class="sd">    X : array</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    If either Y or X is 1d, it is reshaped to be 2d.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">Y</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">Y</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">Y</span> <span class="o">=</span> <span class="n">Y</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">X</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">X</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">X</span> <span class="o">=</span> <span class="n">X</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span>
        <span class="n">keepidx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">Y</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">axis</span><span class="p">),</span>
                                 <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">X</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">axis</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">Y</span><span class="p">[</span><span class="n">keepidx</span><span class="p">],</span> <span class="n">X</span><span class="p">[</span><span class="n">keepidx</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">keepidx</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">Y</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Y</span><span class="p">[</span><span class="n">keepidx</span><span class="p">]</span>


<span class="c1"># TODO: needs to better preserve dtype and be more flexible</span>
<span class="c1"># ie., if you still have a string variable in your array you don&#39;t</span>
<span class="c1"># want to cast it to float</span>
<span class="c1"># TODO: add name validator (ie., bad names for datasets.grunfeld)</span>
<div class="viewcode-block" id="categorical"><a class="viewcode-back" href="../../../generated/statsmodels.tools.tools.categorical.html#statsmodels.tools.tools.categorical">[docs]</a><span class="k">def</span> <span class="nf">categorical</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">col</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dictnames</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">drop</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Returns a dummy matrix given an array of categorical variables.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : array</span>
<span class="sd">        A structured array, recarray, or array.  This can be either</span>
<span class="sd">        a 1d vector of the categorical variable or a 2d array with</span>
<span class="sd">        the column specifying the categorical variable specified by the col</span>
<span class="sd">        argument.</span>
<span class="sd">    col : &#39;string&#39;, int, or None</span>
<span class="sd">        If data is a structured array or a recarray, `col` can be a string</span>
<span class="sd">        that is the name of the column that contains the variable.  For all</span>
<span class="sd">        arrays `col` can be an int that is the (zero-based) column index</span>
<span class="sd">        number.  `col` can only be None for a 1d array.  The default is None.</span>
<span class="sd">    dictnames : bool, optional</span>
<span class="sd">        If True, a dictionary mapping the column number to the categorical</span>
<span class="sd">        name is returned.  Used to have information about plain arrays.</span>
<span class="sd">    drop : bool</span>
<span class="sd">        Whether or not keep the categorical variable in the returned matrix.</span>

<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">    dummy_matrix, [dictnames, optional]</span>
<span class="sd">        A matrix of dummy (indicator/binary) float variables for the</span>
<span class="sd">        categorical data.  If dictnames is True, then the dictionary</span>
<span class="sd">        is returned as well.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This returns a dummy variable for EVERY distinct variable.  If a</span>
<span class="sd">    a structured or recarray is provided, the names for the new variable is the</span>
<span class="sd">    old variable name - underscore - category name.  So if the a variable</span>
<span class="sd">    &#39;vote&#39; had answers as &#39;yes&#39; or &#39;no&#39; then the returned array would have to</span>
<span class="sd">    new variables-- &#39;vote_yes&#39; and &#39;vote_no&#39;.  There is currently</span>
<span class="sd">    no name checking.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; import statsmodels.api as sm</span>

<span class="sd">    Univariate examples</span>

<span class="sd">    &gt;&gt;&gt; import string</span>
<span class="sd">    &gt;&gt;&gt; string_var = [string.ascii_lowercase[0:5], \</span>
<span class="sd">                      string.ascii_lowercase[5:10], \</span>
<span class="sd">                      string.ascii_lowercase[10:15], \</span>
<span class="sd">                      string.ascii_lowercase[15:20],   \</span>
<span class="sd">                      string.ascii_lowercase[20:25]]</span>
<span class="sd">    &gt;&gt;&gt; string_var *= 5</span>
<span class="sd">    &gt;&gt;&gt; string_var = np.asarray(sorted(string_var))</span>
<span class="sd">    &gt;&gt;&gt; design = sm.tools.categorical(string_var, drop=True)</span>

<span class="sd">    Or for a numerical categorical variable</span>

<span class="sd">    &gt;&gt;&gt; instr = np.floor(np.arange(10,60, step=2)/10)</span>
<span class="sd">    &gt;&gt;&gt; design = sm.tools.categorical(instr, drop=True)</span>

<span class="sd">    With a structured array</span>

<span class="sd">    &gt;&gt;&gt; num = np.random.randn(25,2)</span>
<span class="sd">    &gt;&gt;&gt; struct_ar = np.zeros((25,1), dtype=[(&#39;var1&#39;, &#39;f4&#39;),(&#39;var2&#39;, &#39;f4&#39;),  \</span>
<span class="sd">                    (&#39;instrument&#39;,&#39;f4&#39;),(&#39;str_instr&#39;,&#39;a5&#39;)])</span>
<span class="sd">    &gt;&gt;&gt; struct_ar[&#39;var1&#39;] = num[:,0][:,None]</span>
<span class="sd">    &gt;&gt;&gt; struct_ar[&#39;var2&#39;] = num[:,1][:,None]</span>
<span class="sd">    &gt;&gt;&gt; struct_ar[&#39;instrument&#39;] = instr[:,None]</span>
<span class="sd">    &gt;&gt;&gt; struct_ar[&#39;str_instr&#39;] = string_var[:,None]</span>
<span class="sd">    &gt;&gt;&gt; design = sm.tools.categorical(struct_ar, col=&#39;instrument&#39;, drop=True)</span>

<span class="sd">    Or</span>

<span class="sd">    &gt;&gt;&gt; design2 = sm.tools.categorical(struct_ar, col=&#39;str_instr&#39;, drop=True)</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">col</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
            <span class="n">col</span> <span class="o">=</span> <span class="n">col</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Can only convert one column at a time&quot;</span><span class="p">)</span>

    <span class="c1"># TODO: add a NameValidator function</span>
    <span class="c1"># catch recarrays and structured arrays</span>
    <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span> <span class="ow">or</span> <span class="n">data</span><span class="o">.</span><span class="vm">__class__</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">recarray</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">col</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;col is None and the input array is not 1d&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">long</span><span class="p">)):</span>
            <span class="n">col</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">[</span><span class="n">col</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">col</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">col</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">tmp_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">col</span><span class="p">])</span>

        <span class="c1"># if the cols are shape (#,) vs (#,1) need to add an axis and flip</span>
        <span class="n">_swap</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">data</span><span class="p">[</span><span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">tmp_arr</span> <span class="o">=</span> <span class="n">tmp_arr</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span>
            <span class="n">_swap</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">tmp_dummy</span> <span class="o">=</span> <span class="p">(</span><span class="n">tmp_arr</span> <span class="o">==</span> <span class="n">data</span><span class="p">[</span><span class="n">col</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">_swap</span><span class="p">:</span>
            <span class="n">tmp_dummy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">tmp_dummy</span><span class="p">)</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">tmp_arr</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>  <span class="c1"># how do we get to this code path?</span>
            <span class="n">tmp_arr</span> <span class="o">=</span> <span class="p">[</span><span class="n">asstr2</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">tmp_arr</span><span class="p">)]</span>
        <span class="k">elif</span> <span class="n">tmp_arr</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
            <span class="n">tmp_arr</span> <span class="o">=</span> <span class="p">[</span><span class="n">asstr2</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">tmp_arr</span><span class="o">.</span><span class="n">tolist</span><span class="p">())]</span>

        <span class="c1"># prepend the varname and underscore, if col is numeric attribute</span>
        <span class="c1"># lookup is lost for recarrays...</span>
        <span class="k">if</span> <span class="n">col</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">col</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="n">col</span> <span class="o">=</span> <span class="s1">&#39;var&#39;</span>
        <span class="c1"># TODO: the above needs to be made robust because there could be many</span>
        <span class="c1"># var_yes, var_no varaibles for instance.</span>
        <span class="n">tmp_arr</span> <span class="o">=</span> <span class="p">[</span><span class="n">col</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">item</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">tmp_arr</span><span class="p">]</span>
        <span class="c1"># TODO: test this for rec and structured arrays!!!</span>

        <span class="k">if</span> <span class="n">drop</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">tmp_dummy</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">tmp_dummy</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="n">tmp_dummy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">tmp_dummy</span><span class="p">)</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">dt</span> <span class="o">=</span> <span class="n">lzip</span><span class="p">(</span><span class="n">tmp_arr</span><span class="p">,</span> <span class="p">[</span><span class="n">tmp_dummy</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">str</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">tmp_arr</span><span class="p">))</span>
                <span class="c1"># preserve array type</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lmap</span><span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="n">tmp_dummy</span><span class="o">.</span><span class="n">tolist</span><span class="p">()),</span>
                                <span class="n">dtype</span><span class="o">=</span><span class="n">dt</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>

            <span class="n">data</span> <span class="o">=</span> <span class="n">nprf</span><span class="o">.</span><span class="n">drop_fields</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">usemask</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                    <span class="n">asrecarray</span><span class="o">=</span><span class="nb">type</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">recarray</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">nprf</span><span class="o">.</span><span class="n">append_fields</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">tmp_arr</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">tmp_dummy</span><span class="p">,</span>
                                  <span class="n">usemask</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                  <span class="n">asrecarray</span><span class="o">=</span><span class="nb">type</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">recarray</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">data</span>

    <span class="c1"># handle ndarrays and catch array-like for an error</span>
    <span class="k">elif</span> <span class="n">data</span><span class="o">.</span><span class="vm">__class__</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Array-like objects are not supported&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">long</span><span class="p">)):</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>          <span class="c1"># need error catching here?</span>
            <span class="n">tmp_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">data</span><span class="p">[:,</span> <span class="n">col</span><span class="p">])</span>
            <span class="n">tmp_dummy</span> <span class="o">=</span> <span class="p">(</span><span class="n">tmp_arr</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">==</span> <span class="n">data</span><span class="p">[:,</span> <span class="n">col</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
            <span class="n">tmp_dummy</span> <span class="o">=</span> <span class="n">tmp_dummy</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">drop</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">offset</span> <span class="o">-=</span> <span class="mi">1</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">data</span><span class="p">,</span> <span class="n">tmp_dummy</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">dictnames</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">col_map</span> <span class="o">=</span> <span class="n">_make_dictnames</span><span class="p">(</span><span class="n">tmp_arr</span><span class="p">,</span> <span class="n">offset</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">data</span><span class="p">,</span> <span class="n">col_map</span>
            <span class="k">return</span> <span class="n">data</span>
        <span class="k">elif</span> <span class="n">col</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">tmp_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="n">tmp_dummy</span> <span class="o">=</span> <span class="p">(</span><span class="n">tmp_arr</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">==</span> <span class="n">data</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
            <span class="n">tmp_dummy</span> <span class="o">=</span> <span class="n">tmp_dummy</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">drop</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">dictnames</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="n">col_map</span> <span class="o">=</span> <span class="n">_make_dictnames</span><span class="p">(</span><span class="n">tmp_arr</span><span class="p">)</span>
                    <span class="k">return</span> <span class="n">tmp_dummy</span><span class="p">,</span> <span class="n">col_map</span>
                <span class="k">return</span> <span class="n">tmp_dummy</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">data</span><span class="p">,</span> <span class="n">tmp_dummy</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">dictnames</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="n">col_map</span> <span class="o">=</span> <span class="n">_make_dictnames</span><span class="p">(</span><span class="n">tmp_arr</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                    <span class="k">return</span> <span class="n">data</span><span class="p">,</span> <span class="n">col_map</span>
                <span class="k">return</span> <span class="n">data</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;The index </span><span class="si">%s</span><span class="s2"> is not understood&quot;</span> <span class="o">%</span> <span class="n">col</span><span class="p">)</span></div>


<span class="c1"># TODO: add an axis argument to this for sysreg</span>
<div class="viewcode-block" id="add_constant"><a class="viewcode-back" href="../../../generated/statsmodels.tools.tools.add_constant.html#statsmodels.tools.tools.add_constant">[docs]</a><span class="k">def</span> <span class="nf">add_constant</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">prepend</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">has_constant</span><span class="o">=</span><span class="s1">&#39;skip&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Adds a column of ones to an array</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : array-like</span>
<span class="sd">        ``data`` is the column-ordered design matrix</span>
<span class="sd">    prepend : bool</span>
<span class="sd">        If true, the constant is in the first column.  Else the constant is</span>
<span class="sd">        appended (last column).</span>
<span class="sd">    has_constant : str {&#39;raise&#39;, &#39;add&#39;, &#39;skip&#39;}</span>
<span class="sd">        Behavior if ``data`` already has a constant. The default will return</span>
<span class="sd">        data without adding another constant. If &#39;raise&#39;, will raise an</span>
<span class="sd">        error if a constant is present. Using &#39;add&#39; will duplicate the</span>
<span class="sd">        constant, if one is present.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    data : array, recarray or DataFrame</span>
<span class="sd">        The original values with a constant (column of ones) as the first or</span>
<span class="sd">        last column. Returned value depends on input type.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    When the input is recarray or a pandas Series or DataFrame, the added</span>
<span class="sd">    column&#39;s name is &#39;const&#39;.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">_is_using_pandas</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="n">_is_recarray</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">statsmodels.tsa.tsatools</span> <span class="k">import</span> <span class="n">add_trend</span>
        <span class="k">return</span> <span class="n">add_trend</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">trend</span><span class="o">=</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="n">prepend</span><span class="o">=</span><span class="n">prepend</span><span class="p">,</span> <span class="n">has_constant</span><span class="o">=</span><span class="n">has_constant</span><span class="p">)</span>

    <span class="c1"># Special case for NumPy</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">[:,</span><span class="kc">None</span><span class="p">]</span>
    <span class="k">elif</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Only implementd 2-dimensional arrays&#39;</span><span class="p">)</span>

    <span class="n">is_nonzero_const</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ptp</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
    <span class="n">is_nonzero_const</span> <span class="o">&amp;=</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">x</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">is_nonzero_const</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">has_constant</span> <span class="o">==</span> <span class="s1">&#39;skip&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">x</span>
        <span class="k">elif</span> <span class="n">has_constant</span> <span class="o">==</span> <span class="s1">&#39;raise&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;data already contains a constant&quot;</span><span class="p">)</span>

    <span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">x</span><span class="p">]</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="k">if</span> <span class="n">prepend</span> <span class="k">else</span> <span class="n">x</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></div>


<div class="viewcode-block" id="isestimable"><a class="viewcode-back" href="../../../generated/statsmodels.tools.tools.isestimable.html#statsmodels.tools.tools.isestimable">[docs]</a><span class="k">def</span> <span class="nf">isestimable</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">D</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; True if (Q, P) contrast `C` is estimable for (N, P) design `D`</span>

<span class="sd">    From an Q x P contrast matrix `C` and an N x P design matrix `D`, checks if</span>
<span class="sd">    the contrast `C` is estimable by looking at the rank of ``vstack([C,D])``</span>
<span class="sd">    and verifying it is the same as the rank of `D`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    C : (Q, P) array-like</span>
<span class="sd">        contrast matrix. If `C` has is 1 dimensional assume shape (1, P)</span>
<span class="sd">    D: (N, P) array-like</span>
<span class="sd">        design matrix</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tf : bool</span>
<span class="sd">        True if the contrast `C` is estimable on design `D`</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; D = np.array([[1, 1, 1, 0, 0, 0],</span>
<span class="sd">    ...               [0, 0, 0, 1, 1, 1],</span>
<span class="sd">    ...               [1, 1, 1, 1, 1, 1]]).T</span>
<span class="sd">    &gt;&gt;&gt; isestimable([1, 0, 0], D)</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; isestimable([1, -1, 0], D)</span>
<span class="sd">    True</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
    <span class="n">D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">D</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">C</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">C</span> <span class="o">=</span> <span class="n">C</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>
    <span class="k">if</span> <span class="n">C</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">D</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Contrast should have </span><span class="si">%d</span><span class="s1"> columns&#39;</span> <span class="o">%</span> <span class="n">D</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">new</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">C</span><span class="p">,</span> <span class="n">D</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">np_matrix_rank</span><span class="p">(</span><span class="n">new</span><span class="p">)</span> <span class="o">!=</span> <span class="n">np_matrix_rank</span><span class="p">(</span><span class="n">D</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="kc">True</span></div>


<span class="k">def</span> <span class="nf">pinv_extended</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">rcond</span><span class="o">=</span><span class="mf">1e-15</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the pinv of an array X as well as the singular values</span>
<span class="sd">    used in computation.</span>

<span class="sd">    Code adapted from numpy.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span>
    <span class="n">u</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">vt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">s_orig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">vt</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">cutoff</span> <span class="o">=</span> <span class="n">rcond</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">cutoff</span><span class="p">:</span>
            <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">/</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">vt</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">s</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span>
                                               <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">u</span><span class="p">)))</span>
    <span class="k">return</span> <span class="n">res</span><span class="p">,</span> <span class="n">s_orig</span>


<div class="viewcode-block" id="recipr"><a class="viewcode-back" href="../../../generated/statsmodels.tools.tools.recipr.html#statsmodels.tools.tools.recipr">[docs]</a><span class="k">def</span> <span class="nf">recipr</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the reciprocal of an array, setting all entries less than or</span>
<span class="sd">    equal to 0 to 0. Therefore, it presumes that X should be positive in</span>
<span class="sd">    general.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="n">nans</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">flat</span><span class="p">)</span>
    <span class="n">pos</span> <span class="o">=</span> <span class="o">~</span><span class="n">nans</span>
    <span class="n">pos</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">pos</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">flat</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">out</span><span class="o">.</span><span class="n">flat</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">x</span><span class="o">.</span><span class="n">flat</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span>
    <span class="n">out</span><span class="o">.</span><span class="n">flat</span><span class="p">[</span><span class="n">nans</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="k">return</span> <span class="n">out</span></div>


<div class="viewcode-block" id="recipr0"><a class="viewcode-back" href="../../../generated/statsmodels.tools.tools.recipr0.html#statsmodels.tools.tools.recipr0">[docs]</a><span class="k">def</span> <span class="nf">recipr0</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the reciprocal of an array, setting all entries equal to 0</span>
<span class="sd">    as 0. It does not assume that X should be positive in</span>
<span class="sd">    general.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="n">nans</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">flat</span><span class="p">)</span>
    <span class="n">non_zero</span> <span class="o">=</span> <span class="o">~</span><span class="n">nans</span>
    <span class="n">non_zero</span><span class="p">[</span><span class="n">non_zero</span><span class="p">]</span> <span class="o">=</span> <span class="n">non_zero</span><span class="p">[</span><span class="n">non_zero</span><span class="p">]</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">flat</span><span class="p">[</span><span class="n">non_zero</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">out</span><span class="o">.</span><span class="n">flat</span><span class="p">[</span><span class="n">non_zero</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">x</span><span class="o">.</span><span class="n">flat</span><span class="p">[</span><span class="n">non_zero</span><span class="p">]</span>
    <span class="n">out</span><span class="o">.</span><span class="n">flat</span><span class="p">[</span><span class="n">nans</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="k">return</span> <span class="n">out</span></div>


<div class="viewcode-block" id="clean0"><a class="viewcode-back" href="../../../generated/statsmodels.tools.tools.clean0.html#statsmodels.tools.tools.clean0">[docs]</a><span class="k">def</span> <span class="nf">clean0</span><span class="p">(</span><span class="n">matrix</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Erase columns of zeros: can save some time in pseudoinverse.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">colsum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">matrix</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">val</span> <span class="o">=</span> <span class="p">[</span><span class="n">matrix</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">(</span><span class="n">colsum</span><span class="p">)]</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">val</span><span class="p">))</span></div>


<div class="viewcode-block" id="fullrank"><a class="viewcode-back" href="../../../generated/statsmodels.tools.tools.fullrank.html#statsmodels.tools.tools.fullrank">[docs]</a><span class="k">def</span> <span class="nf">fullrank</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">r</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a matrix whose column span is the same as X.</span>

<span class="sd">    If the rank of X is known it can be specified as r -- no check</span>
<span class="sd">    is made to ensure that this really is the rank of X.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">r</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">np_matrix_rank</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>

    <span class="n">V</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">U</span> <span class="o">=</span> <span class="n">L</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">full_matrices</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">order</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">D</span><span class="p">)</span>
    <span class="n">order</span> <span class="o">=</span> <span class="n">order</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">value</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">r</span><span class="p">):</span>
        <span class="n">value</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">V</span><span class="p">[:,</span> <span class="n">order</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">value</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span></div>


<div class="viewcode-block" id="unsqueeze"><a class="viewcode-back" href="../../../generated/statsmodels.tools.tools.unsqueeze.html#statsmodels.tools.tools.unsqueeze">[docs]</a><span class="k">def</span> <span class="nf">unsqueeze</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">oldshape</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Unsqueeze a collapsed array</span>

<span class="sd">    &gt;&gt;&gt; from numpy import mean</span>
<span class="sd">    &gt;&gt;&gt; from numpy.random import standard_normal</span>
<span class="sd">    &gt;&gt;&gt; x = standard_normal((3,4,5))</span>
<span class="sd">    &gt;&gt;&gt; m = mean(x, axis=1)</span>
<span class="sd">    &gt;&gt;&gt; m.shape</span>
<span class="sd">    (3, 5)</span>
<span class="sd">    &gt;&gt;&gt; m = unsqueeze(m, 1, x.shape)</span>
<span class="sd">    &gt;&gt;&gt; m.shape</span>
<span class="sd">    (3, 1, 5)</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">newshape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">oldshape</span><span class="p">)</span>
    <span class="n">newshape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">data</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">newshape</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">chain_dot</span><span class="p">(</span><span class="o">*</span><span class="n">arrs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the dot product of the given matrices.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arrs: argument list of ndarray</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Dot product of all arguments.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; from statsmodels.tools import chain_dot</span>
<span class="sd">    &gt;&gt;&gt; A = np.arange(1,13).reshape(3,4)</span>
<span class="sd">    &gt;&gt;&gt; B = np.arange(3,15).reshape(4,3)</span>
<span class="sd">    &gt;&gt;&gt; C = np.arange(5,8).reshape(3,1)</span>
<span class="sd">    &gt;&gt;&gt; chain_dot(A,B,C)</span>
<span class="sd">    array([[1820],</span>
<span class="sd">       [4300],</span>
<span class="sd">       [6780]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span> <span class="n">arrs</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>


<span class="k">def</span> <span class="nf">nan_dot</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns np.dot(left_matrix, right_matrix) with the convention that</span>
<span class="sd">    nan * 0 = 0 and nan * x = nan if x != 0.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    A, B : np.ndarrays</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Find out who should be nan due to nan * nonzero</span>
    <span class="n">should_be_nan_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">A</span><span class="p">),</span> <span class="p">(</span><span class="n">B</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span>
    <span class="n">should_be_nan_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">((</span><span class="n">A</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">B</span><span class="p">))</span>
    <span class="n">should_be_nan</span> <span class="o">=</span> <span class="n">should_be_nan_1</span> <span class="o">+</span> <span class="n">should_be_nan_2</span>

    <span class="c1"># Multiply after setting all nan to 0</span>
    <span class="c1"># This is what happens if there were no nan * nonzero conflicts</span>
    <span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">A</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">B</span><span class="p">))</span>

    <span class="n">C</span><span class="p">[</span><span class="n">should_be_nan</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

    <span class="k">return</span> <span class="n">C</span>


<span class="k">def</span> <span class="nf">maybe_unwrap_results</span><span class="p">(</span><span class="n">results</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Gets raw results back from wrapped results.</span>

<span class="sd">    Can be used in plotting functions or other post-estimation type</span>
<span class="sd">    routines.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="s1">&#39;_results&#39;</span><span class="p">,</span> <span class="n">results</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Bunch</span><span class="p">(</span><span class="nb">dict</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a dict-like object with keys accessible via attribute lookup.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Bunch</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span> <span class="o">=</span> <span class="bp">self</span>


<span class="k">def</span> <span class="nf">_ensure_2d</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">ndarray</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : array, Series, DataFrame or None</span>
<span class="sd">        Input to verify dimensions, and to transform as necesary</span>
<span class="sd">    ndarray : bool</span>
<span class="sd">        Flag indicating whether to always return a NumPy array. Setting False</span>
<span class="sd">        will return an pandas DataFrame when the input is a Series or a</span>
<span class="sd">        DataFrame.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : array, DataFrame or None</span>
<span class="sd">        array or DataFrame with 2 dimensiona.  One dimensional arrays are</span>
<span class="sd">        returned as nobs by 1. None is returned if x is None.</span>
<span class="sd">    names : list of str or None</span>
<span class="sd">        list containing variables names when the input is a pandas datatype.</span>
<span class="sd">        Returns None if the input is an ndarray.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Accepts None for simplicity</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">x</span>
    <span class="n">is_pandas</span> <span class="o">=</span> <span class="n">_is_using_pandas</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">is_pandas</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">columns</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="kc">None</span>
    <span class="k">elif</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;x mst be 1 or 2-dimensional.&#39;</span><span class="p">)</span>

    <span class="n">name</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">name</span> <span class="k">if</span> <span class="n">is_pandas</span> <span class="k">else</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">ndarray</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)[:,</span> <span class="kc">None</span><span class="p">],</span> <span class="n">name</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">name</span>
</pre></div>




          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2009-2017, Josef Perktold, Skipper Seabold, Jonathan Taylor, statsmodels-developers.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.7.4.
    </div>
  </body>
</html>