

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>statsmodels.nonparametric._kernel_base &#8212; statsmodels 0.9.0 documentation</title>
    <link rel="stylesheet" href="../../../_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <script type="text/javascript" src="../../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="shortcut icon" href="../../../_static/statsmodels_hybi_favico.ico"/>
    <link rel="author" title="About these documents" href="../../../about.html" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
<link rel="stylesheet" href="../../../_static/examples.css" type="text/css" />
<link rel="stylesheet" href="../../../_static/facebox.css" type="text/css" />
<script type="text/javascript" src="../../../_static/scripts.js">
</script>
<script type="text/javascript" src="../../../_static/facebox.js">
</script>
<script type="text/javascript">
$.facebox.settings.closeImage = "../../../_static/closelabel.png"
$.facebox.settings.loadingImage = "../../../_static/loading.gif"
</script>

  </head><body>
<div class="headerwrap">
    <div class = "header">
        
        <a href = "../../../index.html">
<img src="../../../_static/statsmodels_hybi_banner.png" alt="Logo"
    style="padding-left: 15px"/></a>
        
    </div>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
<li><a href ="../../../install.html">Install</a></li> &nbsp;|&nbsp;
<li><a href="https://groups.google.com/forum/?hl=en#!forum/pystatsmodels">Support</a></li> &nbsp;|&nbsp;
<li><a href="https://github.com/statsmodels/statsmodels/issues">Bugs</a></li> &nbsp;|&nbsp;
<li><a href="../../../dev/index.html">Develop</a></li> &nbsp;|&nbsp;
<li><a href="../../../examples/index.html">Examples</a></li> &nbsp;|&nbsp;
<li><a href="../../../faq.html">FAQ</a></li> &nbsp;|&nbsp;

          <li class="nav-item nav-item-1"><a href="../../index.html" accesskey="U">Module code</a> |</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            




  <h1>Source code for statsmodels.nonparametric._kernel_base</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Module containing the base object for multivariate kernel density and</span>
<span class="sd">regression, plus some utilities.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">statsmodels.compat.python</span> <span class="k">import</span> <span class="nb">range</span><span class="p">,</span> <span class="n">string_types</span>
<span class="kn">import</span> <span class="nn">copy</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="k">import</span> <span class="n">optimize</span>
<span class="kn">from</span> <span class="nn">scipy.stats.mstats</span> <span class="k">import</span> <span class="n">mquantiles</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">joblib</span>
    <span class="n">has_joblib</span> <span class="o">=</span> <span class="kc">True</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="n">has_joblib</span> <span class="o">=</span> <span class="kc">False</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">kernels</span>


<span class="n">kernel_func</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">wangryzin</span><span class="o">=</span><span class="n">kernels</span><span class="o">.</span><span class="n">wang_ryzin</span><span class="p">,</span>
                   <span class="n">aitchisonaitken</span><span class="o">=</span><span class="n">kernels</span><span class="o">.</span><span class="n">aitchison_aitken</span><span class="p">,</span>
                   <span class="n">gaussian</span><span class="o">=</span><span class="n">kernels</span><span class="o">.</span><span class="n">gaussian</span><span class="p">,</span>
                   <span class="n">aitchison_aitken_reg</span> <span class="o">=</span> <span class="n">kernels</span><span class="o">.</span><span class="n">aitchison_aitken_reg</span><span class="p">,</span>
                   <span class="n">wangryzin_reg</span> <span class="o">=</span> <span class="n">kernels</span><span class="o">.</span><span class="n">wang_ryzin_reg</span><span class="p">,</span>
                   <span class="n">gauss_convolution</span><span class="o">=</span><span class="n">kernels</span><span class="o">.</span><span class="n">gaussian_convolution</span><span class="p">,</span>
                   <span class="n">wangryzin_convolution</span><span class="o">=</span><span class="n">kernels</span><span class="o">.</span><span class="n">wang_ryzin_convolution</span><span class="p">,</span>
                   <span class="n">aitchisonaitken_convolution</span><span class="o">=</span><span class="n">kernels</span><span class="o">.</span><span class="n">aitchison_aitken_convolution</span><span class="p">,</span>
                   <span class="n">gaussian_cdf</span><span class="o">=</span><span class="n">kernels</span><span class="o">.</span><span class="n">gaussian_cdf</span><span class="p">,</span>
                   <span class="n">aitchisonaitken_cdf</span><span class="o">=</span><span class="n">kernels</span><span class="o">.</span><span class="n">aitchison_aitken_cdf</span><span class="p">,</span>
                   <span class="n">wangryzin_cdf</span><span class="o">=</span><span class="n">kernels</span><span class="o">.</span><span class="n">wang_ryzin_cdf</span><span class="p">,</span>
                   <span class="n">d_gaussian</span><span class="o">=</span><span class="n">kernels</span><span class="o">.</span><span class="n">d_gaussian</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_compute_min_std_IQR</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute minimum of std and IQR for each variable.&quot;&quot;&quot;</span>
    <span class="n">s1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">q75</span> <span class="o">=</span> <span class="n">mquantiles</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">q25</span> <span class="o">=</span> <span class="n">mquantiles</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">s2</span> <span class="o">=</span> <span class="p">(</span><span class="n">q75</span> <span class="o">-</span> <span class="n">q25</span><span class="p">)</span> <span class="o">/</span> <span class="mf">1.349</span>  <span class="c1"># IQR</span>
    <span class="n">dispersion</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">dispersion</span>


<span class="k">def</span> <span class="nf">_compute_subset</span><span class="p">(</span><span class="n">class_type</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">bw</span><span class="p">,</span> <span class="n">co</span><span class="p">,</span> <span class="n">do</span><span class="p">,</span> <span class="n">n_cvars</span><span class="p">,</span> <span class="n">ix_ord</span><span class="p">,</span>
                    <span class="n">ix_unord</span><span class="p">,</span> <span class="n">n_sub</span><span class="p">,</span> <span class="n">class_vars</span><span class="p">,</span> <span class="n">randomize</span><span class="p">,</span> <span class="n">bound</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;&quot;Compute bw on subset of data.</span>

<span class="sd">    Called from ``GenericKDE._compute_efficient_*``.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Needs to be outside the class in order for joblib to be able to pickle it.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">randomize</span><span class="p">:</span>
        <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">sub_data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:</span><span class="n">n_sub</span><span class="p">,</span> <span class="p">:]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">sub_data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">bound</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">bound</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">:]</span>

    <span class="k">if</span> <span class="n">class_type</span> <span class="o">==</span> <span class="s1">&#39;KDEMultivariate&#39;</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">.kernel_density</span> <span class="k">import</span> <span class="n">KDEMultivariate</span>
        <span class="n">var_type</span> <span class="o">=</span> <span class="n">class_vars</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">sub_model</span> <span class="o">=</span> <span class="n">KDEMultivariate</span><span class="p">(</span><span class="n">sub_data</span><span class="p">,</span> <span class="n">var_type</span><span class="p">,</span> <span class="n">bw</span><span class="o">=</span><span class="n">bw</span><span class="p">,</span>
                        <span class="n">defaults</span><span class="o">=</span><span class="n">EstimatorSettings</span><span class="p">(</span><span class="n">efficient</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">class_type</span> <span class="o">==</span> <span class="s1">&#39;KDEMultivariateConditional&#39;</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">.kernel_density</span> <span class="k">import</span> <span class="n">KDEMultivariateConditional</span>
        <span class="n">k_dep</span><span class="p">,</span> <span class="n">dep_type</span><span class="p">,</span> <span class="n">indep_type</span> <span class="o">=</span> <span class="n">class_vars</span>
        <span class="n">endog</span> <span class="o">=</span> <span class="n">sub_data</span><span class="p">[:,</span> <span class="p">:</span><span class="n">k_dep</span><span class="p">]</span>
        <span class="n">exog</span> <span class="o">=</span> <span class="n">sub_data</span><span class="p">[:,</span> <span class="n">k_dep</span><span class="p">:]</span>
        <span class="n">sub_model</span> <span class="o">=</span> <span class="n">KDEMultivariateConditional</span><span class="p">(</span><span class="n">endog</span><span class="p">,</span> <span class="n">exog</span><span class="p">,</span> <span class="n">dep_type</span><span class="p">,</span>
            <span class="n">indep_type</span><span class="p">,</span> <span class="n">bw</span><span class="o">=</span><span class="n">bw</span><span class="p">,</span> <span class="n">defaults</span><span class="o">=</span><span class="n">EstimatorSettings</span><span class="p">(</span><span class="n">efficient</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">class_type</span> <span class="o">==</span> <span class="s1">&#39;KernelReg&#39;</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">.kernel_regression</span> <span class="k">import</span> <span class="n">KernelReg</span>
        <span class="n">var_type</span><span class="p">,</span> <span class="n">k_vars</span><span class="p">,</span> <span class="n">reg_type</span> <span class="o">=</span> <span class="n">class_vars</span>
        <span class="n">endog</span> <span class="o">=</span> <span class="n">_adjust_shape</span><span class="p">(</span><span class="n">sub_data</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">exog</span> <span class="o">=</span> <span class="n">_adjust_shape</span><span class="p">(</span><span class="n">sub_data</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:],</span> <span class="n">k_vars</span><span class="p">)</span>
        <span class="n">sub_model</span> <span class="o">=</span> <span class="n">KernelReg</span><span class="p">(</span><span class="n">endog</span><span class="o">=</span><span class="n">endog</span><span class="p">,</span> <span class="n">exog</span><span class="o">=</span><span class="n">exog</span><span class="p">,</span> <span class="n">reg_type</span><span class="o">=</span><span class="n">reg_type</span><span class="p">,</span>
                              <span class="n">var_type</span><span class="o">=</span><span class="n">var_type</span><span class="p">,</span> <span class="n">bw</span><span class="o">=</span><span class="n">bw</span><span class="p">,</span>
                              <span class="n">defaults</span><span class="o">=</span><span class="n">EstimatorSettings</span><span class="p">(</span><span class="n">efficient</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;class_type not recognized, should be one of &quot;</span> \
                 <span class="s2">&quot;{KDEMultivariate, KDEMultivariateConditional, KernelReg}&quot;</span><span class="p">)</span>

    <span class="c1"># Compute dispersion in next 4 lines</span>
    <span class="k">if</span> <span class="n">class_type</span> <span class="o">==</span> <span class="s1">&#39;KernelReg&#39;</span><span class="p">:</span>
        <span class="n">sub_data</span> <span class="o">=</span> <span class="n">sub_data</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:]</span>

    <span class="n">dispersion</span> <span class="o">=</span> <span class="n">_compute_min_std_IQR</span><span class="p">(</span><span class="n">sub_data</span><span class="p">)</span>

    <span class="n">fct</span> <span class="o">=</span> <span class="n">dispersion</span> <span class="o">*</span> <span class="n">n_sub</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mf">1.</span> <span class="o">/</span> <span class="p">(</span><span class="n">n_cvars</span> <span class="o">+</span> <span class="n">co</span><span class="p">))</span>
    <span class="n">fct</span><span class="p">[</span><span class="n">ix_unord</span><span class="p">]</span> <span class="o">=</span> <span class="n">n_sub</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mf">2.</span> <span class="o">/</span> <span class="p">(</span><span class="n">n_cvars</span> <span class="o">+</span> <span class="n">do</span><span class="p">))</span>
    <span class="n">fct</span><span class="p">[</span><span class="n">ix_ord</span><span class="p">]</span> <span class="o">=</span> <span class="n">n_sub</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mf">2.</span> <span class="o">/</span> <span class="p">(</span><span class="n">n_cvars</span> <span class="o">+</span> <span class="n">do</span><span class="p">))</span>
    <span class="n">sample_scale_sub</span> <span class="o">=</span> <span class="n">sub_model</span><span class="o">.</span><span class="n">bw</span> <span class="o">/</span> <span class="n">fct</span>  <span class="c1">#TODO: check if correct</span>
    <span class="n">bw_sub</span> <span class="o">=</span> <span class="n">sub_model</span><span class="o">.</span><span class="n">bw</span>
    <span class="k">return</span> <span class="n">sample_scale_sub</span><span class="p">,</span> <span class="n">bw_sub</span>


<span class="k">class</span> <span class="nc">GenericKDE</span> <span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Base class for density estimation and regression KDE classes.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">_compute_bw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bw</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the bandwidth of the data.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        bw: array_like or str</span>
<span class="sd">            If array_like: user-specified bandwidth.</span>
<span class="sd">            If a string, should be one of:</span>

<span class="sd">                - cv_ml: cross validation maximum likelihood</span>
<span class="sd">                - normal_reference: normal reference rule of thumb</span>
<span class="sd">                - cv_ls: cross validation least squares</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The default values for bw is &#39;normal_reference&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">bw_func</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">normal_reference</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_normal_reference</span><span class="p">,</span>
                            <span class="n">cv_ml</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_cv_ml</span><span class="p">,</span> <span class="n">cv_ls</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_cv_ls</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">bw</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">bw</span> <span class="o">=</span> <span class="s1">&#39;normal_reference&#39;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bw</span><span class="p">,</span> <span class="n">string_types</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_bw_method</span> <span class="o">=</span> <span class="s2">&quot;user-specified&quot;</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">bw</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># The user specified a bandwidth selection method</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_bw_method</span> <span class="o">=</span> <span class="n">bw</span>
            <span class="n">bwfunc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bw_func</span><span class="p">[</span><span class="n">bw</span><span class="p">]</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">bwfunc</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">res</span>

    <span class="k">def</span> <span class="nf">_compute_dispersion</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the measure of dispersion.</span>

<span class="sd">        The minimum of the standard deviation and interquartile range / 1.349</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Reimplemented in `KernelReg`, because the first column of `data` has to</span>
<span class="sd">        be removed.</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        See the user guide for the np package in R.</span>
<span class="sd">        In the notes on bwscaling option in npreg, npudens, npcdens there is</span>
<span class="sd">        a discussion on the measure of dispersion</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_compute_min_std_IQR</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_class_vars_type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Helper method to be able to pass needed vars to _compute_subset.</span>

<span class="sd">        Needs to be implemented by subclasses.&quot;&quot;&quot;</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">_compute_efficient</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bw</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the bandwidth by estimating the scaling factor (c)</span>
<span class="sd">        in n_res resamples of size ``n_sub`` (in `randomize` case), or by</span>
<span class="sd">        dividing ``nobs`` into as many ``n_sub`` blocks as needed (if</span>
<span class="sd">        `randomize` is False).</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        See p.9 in socserv.mcmaster.ca/racine/np_faq.pdf</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">bw</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_bw_method</span> <span class="o">=</span> <span class="s1">&#39;normal_reference&#39;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bw</span><span class="p">,</span> <span class="n">string_types</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_bw_method</span> <span class="o">=</span> <span class="n">bw</span>
        <span class="k">else</span><span class="p">:</span> 
            <span class="bp">self</span><span class="o">.</span><span class="n">_bw_method</span> <span class="o">=</span> <span class="s2">&quot;user-specified&quot;</span>
            <span class="k">return</span> <span class="n">bw</span>

        <span class="n">nobs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span>
        <span class="n">n_sub</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_sub</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
        <span class="n">n_cvars</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_type</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s1">&#39;c&#39;</span><span class="p">)</span>
        <span class="n">co</span> <span class="o">=</span> <span class="mi">4</span>  <span class="c1"># 2*order of continuous kernel</span>
        <span class="n">do</span> <span class="o">=</span> <span class="mi">4</span>  <span class="c1"># 2*order of discrete kernel</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">ix_ord</span><span class="p">,</span> <span class="n">ix_unord</span> <span class="o">=</span> <span class="n">_get_type_pos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_type</span><span class="p">)</span>

        <span class="c1"># Define bounds for slicing the data</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">randomize</span><span class="p">:</span>
            <span class="c1"># randomize chooses blocks of size n_sub, independent of nobs</span>
            <span class="n">bounds</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_res</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">bounds</span> <span class="o">=</span> <span class="p">[(</span><span class="n">i</span> <span class="o">*</span> <span class="n">n_sub</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">n_sub</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nobs</span> <span class="o">//</span> <span class="n">n_sub</span><span class="p">)]</span>
            <span class="k">if</span> <span class="n">nobs</span> <span class="o">%</span> <span class="n">n_sub</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">bounds</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">nobs</span> <span class="o">-</span> <span class="n">nobs</span> <span class="o">%</span> <span class="n">n_sub</span><span class="p">,</span> <span class="n">nobs</span><span class="p">))</span>

        <span class="n">n_blocks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_res</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">randomize</span> <span class="k">else</span> <span class="nb">len</span><span class="p">(</span><span class="n">bounds</span><span class="p">)</span>
        <span class="n">sample_scale</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">n_blocks</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_vars</span><span class="p">))</span>
        <span class="n">only_bw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">n_blocks</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_vars</span><span class="p">))</span>

        <span class="n">class_type</span><span class="p">,</span> <span class="n">class_vars</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_class_vars_type</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">has_joblib</span><span class="p">:</span>
            <span class="c1"># `res` is a list of tuples (sample_scale_sub, bw_sub)</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">joblib</span><span class="o">.</span><span class="n">Parallel</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">)</span> \
                <span class="p">(</span><span class="n">joblib</span><span class="o">.</span><span class="n">delayed</span><span class="p">(</span><span class="n">_compute_subset</span><span class="p">)</span> \
                <span class="p">(</span><span class="n">class_type</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">bw</span><span class="p">,</span> <span class="n">co</span><span class="p">,</span> <span class="n">do</span><span class="p">,</span> <span class="n">n_cvars</span><span class="p">,</span> <span class="n">ix_ord</span><span class="p">,</span> <span class="n">ix_unord</span><span class="p">,</span> \
                <span class="n">n_sub</span><span class="p">,</span> <span class="n">class_vars</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">randomize</span><span class="p">,</span> <span class="n">bounds</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> \
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_blocks</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_blocks</span><span class="p">):</span>
                <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_compute_subset</span><span class="p">(</span><span class="n">class_type</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">bw</span><span class="p">,</span> <span class="n">co</span><span class="p">,</span> <span class="n">do</span><span class="p">,</span>
                                           <span class="n">n_cvars</span><span class="p">,</span> <span class="n">ix_ord</span><span class="p">,</span> <span class="n">ix_unord</span><span class="p">,</span> <span class="n">n_sub</span><span class="p">,</span>
                                           <span class="n">class_vars</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">randomize</span><span class="p">,</span>
                                           <span class="n">bounds</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_blocks</span><span class="p">):</span>
            <span class="n">sample_scale</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">res</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">only_bw</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">res</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_dispersion</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">order_func</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">return_median</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span>
        <span class="n">m_scale</span> <span class="o">=</span> <span class="n">order_func</span><span class="p">(</span><span class="n">sample_scale</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="c1"># TODO: Check if 1/5 is correct in line below!</span>
        <span class="n">bw</span> <span class="o">=</span> <span class="n">m_scale</span> <span class="o">*</span> <span class="n">s</span> <span class="o">*</span> <span class="n">nobs</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mf">1.</span> <span class="o">/</span> <span class="p">(</span><span class="n">n_cvars</span> <span class="o">+</span> <span class="n">co</span><span class="p">))</span>
        <span class="n">bw</span><span class="p">[</span><span class="n">ix_ord</span><span class="p">]</span> <span class="o">=</span> <span class="n">m_scale</span><span class="p">[</span><span class="n">ix_ord</span><span class="p">]</span> <span class="o">*</span> <span class="n">nobs</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mf">2.</span><span class="o">/</span> <span class="p">(</span><span class="n">n_cvars</span> <span class="o">+</span> <span class="n">do</span><span class="p">))</span>
        <span class="n">bw</span><span class="p">[</span><span class="n">ix_unord</span><span class="p">]</span> <span class="o">=</span> <span class="n">m_scale</span><span class="p">[</span><span class="n">ix_unord</span><span class="p">]</span> <span class="o">*</span> <span class="n">nobs</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mf">2.</span><span class="o">/</span> <span class="p">(</span><span class="n">n_cvars</span> <span class="o">+</span> <span class="n">do</span><span class="p">))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">return_only_bw</span><span class="p">:</span>
            <span class="n">bw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">only_bw</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">bw</span>

    <span class="k">def</span> <span class="nf">_set_defaults</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">defaults</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sets the default values for the efficient estimation&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_res</span> <span class="o">=</span> <span class="n">defaults</span><span class="o">.</span><span class="n">n_res</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_sub</span> <span class="o">=</span> <span class="n">defaults</span><span class="o">.</span><span class="n">n_sub</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">randomize</span> <span class="o">=</span> <span class="n">defaults</span><span class="o">.</span><span class="n">randomize</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">return_median</span> <span class="o">=</span> <span class="n">defaults</span><span class="o">.</span><span class="n">return_median</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">efficient</span> <span class="o">=</span> <span class="n">defaults</span><span class="o">.</span><span class="n">efficient</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">return_only_bw</span> <span class="o">=</span> <span class="n">defaults</span><span class="o">.</span><span class="n">return_only_bw</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span> <span class="o">=</span> <span class="n">defaults</span><span class="o">.</span><span class="n">n_jobs</span>

    <span class="k">def</span> <span class="nf">_normal_reference</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns Scott&#39;s normal reference rule of thumb bandwidth parameter.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        See p.13 in [2] for an example and discussion.  The formula for the</span>
<span class="sd">        bandwidth is</span>

<span class="sd">        .. math:: h = 1.06n^{-1/(4+q)}</span>

<span class="sd">        where ``n`` is the number of observations and ``q`` is the number of</span>
<span class="sd">        variables.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="mf">1.06</span> <span class="o">*</span> <span class="n">X</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span> <span class="mf">1.</span> <span class="o">/</span> <span class="p">(</span><span class="mi">4</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

    <span class="k">def</span> <span class="nf">_set_bw_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bw</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets bandwidth lower bound to effectively zero )1e-10), and for</span>
<span class="sd">        discrete values upper bound to 1.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">bw</span><span class="p">[</span><span class="n">bw</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1e-10</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">ix_ord</span><span class="p">,</span> <span class="n">ix_unord</span> <span class="o">=</span> <span class="n">_get_type_pos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_type</span><span class="p">)</span>
        <span class="n">bw</span><span class="p">[</span><span class="n">ix_ord</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">bw</span><span class="p">[</span><span class="n">ix_ord</span><span class="p">],</span> <span class="mf">1.</span><span class="p">)</span>
        <span class="n">bw</span><span class="p">[</span><span class="n">ix_unord</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">bw</span><span class="p">[</span><span class="n">ix_unord</span><span class="p">],</span> <span class="mf">1.</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">bw</span>

    <span class="k">def</span> <span class="nf">_cv_ml</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the cross validation maximum likelihood bandwidth parameter.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        For more details see p.16, 18, 27 in Ref. [1] (see module docstring).</span>

<span class="sd">        Returns the bandwidth estimate that maximizes the leave-out-out</span>
<span class="sd">        likelihood.  The leave-one-out log likelihood function is:</span>

<span class="sd">        .. math:: \ln L=\sum_{i=1}^{n}\ln f_{-i}(X_{i})</span>

<span class="sd">        The leave-one-out kernel estimator of :math:`f_{-i}` is:</span>

<span class="sd">        .. math:: f_{-i}(X_{i})=\frac{1}{(n-1)h}</span>
<span class="sd">                        \sum_{j=1,j\neq i}K_{h}(X_{i},X_{j})</span>

<span class="sd">        where :math:`K_{h}` represents the Generalized product kernel</span>
<span class="sd">        estimator:</span>

<span class="sd">        .. math:: K_{h}(X_{i},X_{j})=\prod_{s=1}^</span>
<span class="sd">                        {q}h_{s}^{-1}k\left(\frac{X_{is}-X_{js}}{h_{s}}\right)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># the initial value for the optimization is the normal_reference</span>
        <span class="n">h0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_normal_reference</span><span class="p">()</span>
        <span class="n">bw</span> <span class="o">=</span> <span class="n">optimize</span><span class="o">.</span><span class="n">fmin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loo_likelihood</span><span class="p">,</span> <span class="n">x0</span><span class="o">=</span><span class="n">h0</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">,</span> <span class="p">),</span>
                           <span class="n">maxiter</span><span class="o">=</span><span class="mf">1e3</span><span class="p">,</span> <span class="n">maxfun</span><span class="o">=</span><span class="mf">1e3</span><span class="p">,</span> <span class="n">disp</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">xtol</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">)</span>
        <span class="n">bw</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set_bw_bounds</span><span class="p">(</span><span class="n">bw</span><span class="p">)</span>  <span class="c1"># bound bw if necessary</span>
        <span class="k">return</span> <span class="n">bw</span>

    <span class="k">def</span> <span class="nf">_cv_ls</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the cross-validation least squares bandwidth parameter(s).</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        For more details see pp. 16, 27 in Ref. [1] (see module docstring).</span>

<span class="sd">        Returns the value of the bandwidth that maximizes the integrated mean</span>
<span class="sd">        square error between the estimated and actual distribution.  The</span>
<span class="sd">        integrated mean square error (IMSE) is given by:</span>

<span class="sd">        .. math:: \int\left[\hat{f}(x)-f(x)\right]^{2}dx</span>

<span class="sd">        This is the general formula for the IMSE.  The IMSE differs for</span>
<span class="sd">        conditional (``KDEMultivariateConditional``) and unconditional</span>
<span class="sd">        (``KDEMultivariate``) kernel density estimation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">h0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_normal_reference</span><span class="p">()</span>
        <span class="n">bw</span> <span class="o">=</span> <span class="n">optimize</span><span class="o">.</span><span class="n">fmin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">imse</span><span class="p">,</span> <span class="n">x0</span><span class="o">=</span><span class="n">h0</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="mf">1e3</span><span class="p">,</span> <span class="n">maxfun</span><span class="o">=</span><span class="mf">1e3</span><span class="p">,</span> <span class="n">disp</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                           <span class="n">xtol</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">)</span>
        <span class="n">bw</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set_bw_bounds</span><span class="p">(</span><span class="n">bw</span><span class="p">)</span>  <span class="c1"># bound bw if necessary</span>
        <span class="k">return</span> <span class="n">bw</span>

    <span class="k">def</span> <span class="nf">loo_likelihood</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>


<div class="viewcode-block" id="EstimatorSettings"><a class="viewcode-back" href="../../../generated/statsmodels.nonparametric.kernel_density.EstimatorSettings.html#statsmodels.nonparametric.kernel_density.EstimatorSettings">[docs]</a><span class="k">class</span> <span class="nc">EstimatorSettings</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Object to specify settings for density estimation or regression.</span>

<span class="sd">    `EstimatorSettings` has several proporties related to how bandwidth</span>
<span class="sd">    estimation for the `KDEMultivariate`, `KDEMultivariateConditional`,</span>
<span class="sd">    `KernelReg` and `CensoredKernelReg` classes behaves.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    efficient: bool, optional</span>
<span class="sd">        If True, the bandwidth estimation is to be performed</span>
<span class="sd">        efficiently -- by taking smaller sub-samples and estimating</span>
<span class="sd">        the scaling factor of each subsample.  This is useful for large</span>
<span class="sd">        samples (nobs &gt;&gt; 300) and/or multiple variables (k_vars &gt; 3).</span>
<span class="sd">        If False (default), all data is used at the same time.</span>
<span class="sd">    randomize: bool, optional</span>
<span class="sd">        If True, the bandwidth estimation is to be performed by</span>
<span class="sd">        taking `n_res` random resamples (with replacement) of size `n_sub` from</span>
<span class="sd">        the full sample.  If set to False (default), the estimation is</span>
<span class="sd">        performed by slicing the full sample in sub-samples of size `n_sub` so</span>
<span class="sd">        that all samples are used once.</span>
<span class="sd">    n_sub: int, optional</span>
<span class="sd">        Size of the sub-samples.  Default is 50.</span>
<span class="sd">    n_res: int, optional</span>
<span class="sd">        The number of random re-samples used to estimate the bandwidth.</span>
<span class="sd">        Only has an effect if ``randomize == True``.  Default value is 25.</span>
<span class="sd">    return_median: bool, optional</span>
<span class="sd">        If True (default), the estimator uses the median of all scaling factors</span>
<span class="sd">        for each sub-sample to estimate the bandwidth of the full sample.</span>
<span class="sd">        If False, the estimator uses the mean.</span>
<span class="sd">    return_only_bw: bool, optional</span>
<span class="sd">        If True, the estimator is to use the bandwidth and not the</span>
<span class="sd">        scaling factor.  This is *not* theoretically justified.</span>
<span class="sd">        Should be used only for experimenting.</span>
<span class="sd">    n_jobs : int, optional</span>
<span class="sd">        The number of jobs to use for parallel estimation with</span>
<span class="sd">        ``joblib.Parallel``.  Default is -1, meaning ``n_cores - 1``, with</span>
<span class="sd">        ``n_cores`` the number of available CPU cores.</span>
<span class="sd">        See the `joblib documentation</span>
<span class="sd">        &lt;https://pythonhosted.org/joblib/parallel.html&gt;`_ for more details.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; settings = EstimatorSettings(randomize=True, n_jobs=3)</span>
<span class="sd">    &gt;&gt;&gt; k_dens = KDEMultivariate(data, var_type, defaults=settings)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">efficient</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">randomize</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">n_res</span><span class="o">=</span><span class="mi">25</span><span class="p">,</span> <span class="n">n_sub</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span>
                 <span class="n">return_median</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">return_only_bw</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">efficient</span> <span class="o">=</span> <span class="n">efficient</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">randomize</span> <span class="o">=</span> <span class="n">randomize</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_res</span> <span class="o">=</span> <span class="n">n_res</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_sub</span> <span class="o">=</span> <span class="n">n_sub</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">return_median</span> <span class="o">=</span> <span class="n">return_median</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">return_only_bw</span> <span class="o">=</span> <span class="n">return_only_bw</span>  <span class="c1"># TODO: remove this?</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span> <span class="o">=</span> <span class="n">n_jobs</span></div>


<span class="k">class</span> <span class="nc">LeaveOneOut</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generator to give leave-one-out views on X.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    X : array-like</span>
<span class="sd">        2-D array.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; X = np.random.normal(0, 1, [10,2])</span>
<span class="sd">    &gt;&gt;&gt; loo = LeaveOneOut(X)</span>
<span class="sd">    &gt;&gt;&gt; for x in loo:</span>
<span class="sd">    ...    print x</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    A little lighter weight than sklearn LOO. We don&#39;t need test index.</span>
<span class="sd">    Also passes views on X, not the index.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">X</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">X</span>
        <span class="n">nobs</span><span class="p">,</span> <span class="n">k_vars</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nobs</span><span class="p">):</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">nobs</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span>
            <span class="n">index</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">yield</span> <span class="n">X</span><span class="p">[</span><span class="n">index</span><span class="p">,</span> <span class="p">:]</span>


<span class="k">def</span> <span class="nf">_get_type_pos</span><span class="p">(</span><span class="n">var_type</span><span class="p">):</span>
    <span class="n">ix_cont</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">c</span> <span class="o">==</span> <span class="s1">&#39;c&#39;</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">var_type</span><span class="p">])</span>
    <span class="n">ix_ord</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">c</span> <span class="o">==</span> <span class="s1">&#39;o&#39;</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">var_type</span><span class="p">])</span>
    <span class="n">ix_unord</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">c</span> <span class="o">==</span> <span class="s1">&#39;u&#39;</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">var_type</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">ix_cont</span><span class="p">,</span> <span class="n">ix_ord</span><span class="p">,</span> <span class="n">ix_unord</span>


<span class="k">def</span> <span class="nf">_adjust_shape</span><span class="p">(</span><span class="n">dat</span><span class="p">,</span> <span class="n">k_vars</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Returns an array of shape (nobs, k_vars) for use with `gpke`.&quot;&quot;&quot;</span>
    <span class="n">dat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">dat</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">dat</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">dat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">dat</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">dat</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">k_vars</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># one obs many vars</span>
        <span class="n">nobs</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">elif</span> <span class="n">dat</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">k_vars</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># one obs one var</span>
        <span class="n">nobs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dat</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">dat</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">k_vars</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">dat</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">k_vars</span><span class="p">:</span>
            <span class="n">dat</span> <span class="o">=</span> <span class="n">dat</span><span class="o">.</span><span class="n">T</span>

        <span class="n">nobs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">dat</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># ndim &gt;1 so many obs many vars</span>

    <span class="n">dat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">dat</span><span class="p">,</span> <span class="p">(</span><span class="n">nobs</span><span class="p">,</span> <span class="n">k_vars</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">dat</span>


<span class="k">def</span> <span class="nf">gpke</span><span class="p">(</span><span class="n">bw</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">data_predict</span><span class="p">,</span> <span class="n">var_type</span><span class="p">,</span> <span class="n">ckertype</span><span class="o">=</span><span class="s1">&#39;gaussian&#39;</span><span class="p">,</span>
         <span class="n">okertype</span><span class="o">=</span><span class="s1">&#39;wangryzin&#39;</span><span class="p">,</span> <span class="n">ukertype</span><span class="o">=</span><span class="s1">&#39;aitchisonaitken&#39;</span><span class="p">,</span> <span class="n">tosum</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the non-normalized Generalized Product Kernel Estimator</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    bw: 1-D ndarray</span>
<span class="sd">        The user-specified bandwidth parameters.</span>
<span class="sd">    data: 1D or 2-D ndarray</span>
<span class="sd">        The training data.</span>
<span class="sd">    data_predict: 1-D ndarray</span>
<span class="sd">        The evaluation points at which the kernel estimation is performed.</span>
<span class="sd">    var_type: str, optional</span>
<span class="sd">        The variable type (continuous, ordered, unordered).</span>
<span class="sd">    ckertype: str, optional</span>
<span class="sd">        The kernel used for the continuous variables.</span>
<span class="sd">    okertype: str, optional</span>
<span class="sd">        The kernel used for the ordered discrete variables.</span>
<span class="sd">    ukertype: str, optional</span>
<span class="sd">        The kernel used for the unordered discrete variables.</span>
<span class="sd">    tosum : bool, optional</span>
<span class="sd">        Whether or not to sum the calculated array of densities.  Default is</span>
<span class="sd">        True.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dens: array-like</span>
<span class="sd">        The generalized product kernel density estimator.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The formula for the multivariate kernel estimator for the pdf is:</span>

<span class="sd">    .. math:: f(x)=\frac{1}{nh_{1}...h_{q}}\sum_{i=1}^</span>
<span class="sd">                        {n}K\left(\frac{X_{i}-x}{h}\right)</span>

<span class="sd">    where</span>

<span class="sd">    .. math:: K\left(\frac{X_{i}-x}{h}\right) =</span>
<span class="sd">                k\left( \frac{X_{i1}-x_{1}}{h_{1}}\right)\times</span>
<span class="sd">                k\left( \frac{X_{i2}-x_{2}}{h_{2}}\right)\times...\times</span>
<span class="sd">                k\left(\frac{X_{iq}-x_{q}}{h_{q}}\right)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">kertypes</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">c</span><span class="o">=</span><span class="n">ckertype</span><span class="p">,</span> <span class="n">o</span><span class="o">=</span><span class="n">okertype</span><span class="p">,</span> <span class="n">u</span><span class="o">=</span><span class="n">ukertype</span><span class="p">)</span>
    <span class="c1">#Kval = []</span>
    <span class="c1">#for ii, vtype in enumerate(var_type):</span>
    <span class="c1">#    func = kernel_func[kertypes[vtype]]</span>
    <span class="c1">#    Kval.append(func(bw[ii], data[:, ii], data_predict[ii]))</span>

    <span class="c1">#Kval = np.column_stack(Kval)</span>

    <span class="n">Kval</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">vtype</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">var_type</span><span class="p">):</span>
        <span class="n">func</span> <span class="o">=</span> <span class="n">kernel_func</span><span class="p">[</span><span class="n">kertypes</span><span class="p">[</span><span class="n">vtype</span><span class="p">]]</span>
        <span class="n">Kval</span><span class="p">[:,</span> <span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">bw</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span> <span class="n">data</span><span class="p">[:,</span> <span class="n">ii</span><span class="p">],</span> <span class="n">data_predict</span><span class="p">[</span><span class="n">ii</span><span class="p">])</span>

    <span class="n">iscontinuous</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">c</span> <span class="o">==</span> <span class="s1">&#39;c&#39;</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">var_type</span><span class="p">])</span>
    <span class="n">dens</span> <span class="o">=</span> <span class="n">Kval</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">bw</span><span class="p">[</span><span class="n">iscontinuous</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">tosum</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">dens</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">dens</span>
</pre></div>




          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2009-2017, Josef Perktold, Skipper Seabold, Jonathan Taylor, statsmodels-developers.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.7.4.
    </div>
  </body>
</html>