

<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <meta name="lang:clipboard.copy" content="Copy to clipboard">
  <meta name="lang:clipboard.copied" content="Copied to clipboard">
  <meta name="lang:search.language" content="en">
  <meta name="lang:search.pipeline.stopwords" content="True">
  <meta name="lang:search.pipeline.trimmer" content="True">
  <meta name="lang:search.result.none" content="No matching documents">
  <meta name="lang:search.result.one" content="1 matching document">
  <meta name="lang:search.result.other" content="# matching documents">
  <meta name="lang:search.tokenizer" content="[\s\-]+">

  
    <link href="https://fonts.gstatic.com/" rel="preconnect" crossorigin>
    <link href="https://fonts.googleapis.com/css?family=Roboto+Mono:400,500,700|Roboto:300,400,400i,700&display=fallback" rel="stylesheet">

    <style>
      body,
      input {
        font-family: "Roboto", "Helvetica Neue", Helvetica, Arial, sans-serif
      }

      code,
      kbd,
      pre {
        font-family: "Roboto Mono", "Courier New", Courier, monospace
      }
    </style>
  

  <link rel="stylesheet" href="../../../_static/stylesheets/application.css"/>
  <link rel="stylesheet" href="../../../_static/stylesheets/application-palette.css"/>
  <link rel="stylesheet" href="../../../_static/stylesheets/application-fixes.css"/>
  
  <link rel="stylesheet" href="../../../_static/fonts/material-icons.css"/>
  
  <meta name="theme-color" content="#3f51b5">
  <script src="../../../_static/javascripts/modernizr.js"></script>
  
  
  
    <title>statsmodels.duration.hazard_regression &#8212; statsmodels</title>
  <link rel="icon" type="image/png" sizes="32x32" href="../../../_static/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="../../../_static/icons/favicon-16x16.png">
  <link rel="manifest" href="../../../_static/icons/site.webmanifest">
  <link rel="mask-icon" href="../../../_static/icons/safari-pinned-tab.svg" color="#919191">
  <meta name="msapplication-TileColor" content="#2b5797">
  <meta name="msapplication-config" content="../../../_static/icons/browserconfig.xml">
  <link rel="stylesheet" href="../../../_static/stylesheets/examples.css">
    <link rel="stylesheet" href="../../../_static/material.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css" />
    <script id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/language_data.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
    <link rel="shortcut icon" href="../../../_static/favicon.ico"/>
    <link rel="author" title="About these documents" href="../../../about.html" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
  
   
  
  <script src="../../../_static/javascripts/version_dropdown.js"></script>
  <script>
    var json_loc = "../../../_static/versions.json",
        target_loc = "../../../../",
        text = "Versions";
    $( document ).ready( add_version_dropdown(json_loc, target_loc, text));
  </script>


  </head>
  <body dir=ltr
        data-md-color-primary=indigo data-md-color-accent=blue>
  
  <svg class="md-svg">
    <defs data-children-count="0">
      
      <svg xmlns="http://www.w3.org/2000/svg" width="416" height="448" viewBox="0 0 416 448" id="__github"><path fill="currentColor" d="M160 304q0 10-3.125 20.5t-10.75 19T128 352t-18.125-8.5-10.75-19T96 304t3.125-20.5 10.75-19T128 256t18.125 8.5 10.75 19T160 304zm160 0q0 10-3.125 20.5t-10.75 19T288 352t-18.125-8.5-10.75-19T256 304t3.125-20.5 10.75-19T288 256t18.125 8.5 10.75 19T320 304zm40 0q0-30-17.25-51T296 232q-10.25 0-48.75 5.25Q229.5 240 208 240t-39.25-2.75Q130.75 232 120 232q-29.5 0-46.75 21T56 304q0 22 8 38.375t20.25 25.75 30.5 15 35 7.375 37.25 1.75h42q20.5 0 37.25-1.75t35-7.375 30.5-15 20.25-25.75T360 304zm56-44q0 51.75-15.25 82.75-9.5 19.25-26.375 33.25t-35.25 21.5-42.5 11.875-42.875 5.5T212 416q-19.5 0-35.5-.75t-36.875-3.125-38.125-7.5-34.25-12.875T37 371.5t-21.5-28.75Q0 312 0 260q0-59.25 34-99-6.75-20.5-6.75-42.5 0-29 12.75-54.5 27 0 47.5 9.875t47.25 30.875Q171.5 96 212 96q37 0 70 8 26.25-20.5 46.75-30.25T376 64q12.75 25.5 12.75 54.5 0 21.75-6.75 42 34 40 34 99.5z"/></svg>
      
    </defs>
  </svg>
  
  <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer">
  <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search">
  <label class="md-overlay" data-md-component="overlay" for="__drawer"></label>
  <a href="#_modules/statsmodels/duration/hazard_regression" tabindex="1" class="md-skip"> Skip to content </a>
  <header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid">
    <div class="md-flex navheader">
      <div class="md-flex__cell md-flex__cell--shrink">
        <a href="../../../index.html" title="statsmodels"
           class="md-header-nav__button md-logo">
          
              <img src="../../../_static/statsmodels-logo-v2-bw.svg" height="26"
                   alt="statsmodels logo">
          
        </a>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        <label class="md-icon md-icon--menu md-header-nav__button" for="__drawer"></label>
      </div>
      <div class="md-flex__cell md-flex__cell--stretch">
        <div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
          <span class="md-header-nav__topic">statsmodels v0.11.1</span>
          <span class="md-header-nav__topic"> statsmodels.duration.hazard_regression </span>
        </div>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        <label class="md-icon md-icon--search md-header-nav__button" for="__search"></label>
        
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" action="../../../search.html" method="GET" name="search">
      <input type="text" class="md-search__input" name="q" placeholder="Search"
             autocapitalize="off" autocomplete="off" spellcheck="false"
             data-md-component="query" data-md-state="active">
      <label class="md-icon md-search__icon" for="__search"></label>
      <button type="reset" class="md-icon md-search__icon" data-md-component="reset" tabindex="-1">
        &#xE5CD;
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="result">
          <div class="md-search-result__meta">
            Type to start searching
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>

      </div>
      
        <div class="md-flex__cell md-flex__cell--shrink">
          <div class="md-header-nav__source">
            <a href="https://github.com/statsmodels/statsmodels" title="Go to repository" class="md-source" data-md-source="github">

    <div class="md-source__icon">
      <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24" width="28" height="28">
        <use xlink:href="#__github" width="24" height="24"></use>
      </svg>
    </div>
  
  <div class="md-source__repository">
    statsmodels
  </div>
</a>
          </div>
        </div>
      
    </div>
  </nav>
</header>

  
  <div class="md-container">
    
    
    
  <nav class="md-tabs" data-md-component="tabs">
    <div class="md-tabs__inner md-grid">
      <ul class="md-tabs__list">
          <li class="md-tabs__item"><a href="../../index.html" class="md-tabs__link">Module code</a></li>
      </ul>
    </div>
  </nav>
    <main class="md-main">
      <div class="md-main__inner md-grid" data-md-component="container">
        
          <div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
            <div class="md-sidebar__scrollwrap">
              <div class="md-sidebar__inner">
                <nav class="md-nav md-nav--primary" data-md-level="0">
  <label class="md-nav__title md-nav__title--site" for="__drawer">
    <a href="../../../index.html" title="statsmodels" class="md-nav__button md-logo">
      
        <img src="../../../_static/statsmodels-logo-v2-bw.svg" alt=" logo" width="48" height="48">
      
    </a>
    <a href="../../../index.html"
       title="statsmodels">statsmodels v0.11.1</a>
  </label>
    <div class="md-nav__source">
      <a href="https://github.com/statsmodels/statsmodels" title="Go to repository" class="md-source" data-md-source="github">

    <div class="md-source__icon">
      <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24" width="28" height="28">
        <use xlink:href="#__github" width="24" height="24"></use>
      </svg>
    </div>
  
  <div class="md-source__repository">
    statsmodels
  </div>
</a>
    </div>
  
  

  
  
  <ul class="md-nav__list">
    <li class="md-nav__item">
    
      <a href="../../../install.html" class="md-nav__link">Installing statsmodels</a>
      
    </li>
    <li class="md-nav__item">
    
      <a href="../../../gettingstarted.html" class="md-nav__link">Getting started</a>
      
    </li>
    <li class="md-nav__item">
    
      <a href="../../../user-guide.html" class="md-nav__link">User Guide</a>
      
    </li>
    <li class="md-nav__item">
    
      <a href="../../../examples/index.html" class="md-nav__link">Examples</a>
      
    </li>
    <li class="md-nav__item">
    
      <a href="../../../api.html" class="md-nav__link">API Reference</a>
      
    </li>
    <li class="md-nav__item">
    
      <a href="../../../about.html" class="md-nav__link">About statsmodels</a>
      
    </li>
    <li class="md-nav__item">
    
      <a href="../../../dev/index.html" class="md-nav__link">Developer Page</a>
      
    </li>
    <li class="md-nav__item">
    
      <a href="../../../release/index.html" class="md-nav__link">Release Notes</a>
      
    </li>
  </ul>
  

</nav>
              </div>
            </div>
          </div>
          <div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
            <div class="md-sidebar__scrollwrap">
              <div class="md-sidebar__inner">
                
<nav class="md-nav md-nav--secondary">
  <ul class="md-nav__list" data-md-scrollfix="">
    

<li id="searchbox" class="md-nav__item"></li>

  </ul>
</nav>
              </div>
            </div>
          </div>
        
        <div class="md-content">
          <article class="md-content__inner md-typeset" role="main">
            
  <h1 id="modules-statsmodels-duration-hazard-regression--page-root">Source code for statsmodels.duration.hazard_regression</h1><div class="highlight"><pre>
<span></span><span class="sd">"""</span>
<span class="sd">Implementation of proportional hazards regression models for duration</span>
<span class="sd">data that may be censored ("Cox models").</span>

<span class="sd">References</span>
<span class="sd">----------</span>
<span class="sd">T Therneau (1996).  Extending the Cox model.  Technical report.</span>
<span class="sd">http://www.mayo.edu/research/documents/biostat-58pdf/DOC-10027288</span>

<span class="sd">G Rodriguez (2005).  Non-parametric estimation in survival models.</span>
<span class="sd">http://data.princeton.edu/pop509/NonParametricSurvival.pdf</span>

<span class="sd">B Gillespie (2006).  Checking the assumptions in the Cox proportional</span>
<span class="sd">hazards model.</span>
<span class="sd">http://www.mwsug.org/proceedings/2006/stats/MWSUG-2006-SD08.pdf</span>
<span class="sd">"""</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">statsmodels.base</span> <span class="kn">import</span> <span class="n">model</span>
<span class="kn">import</span> <span class="nn">statsmodels.base.model</span> <span class="k">as</span> <span class="nn">base</span>
<span class="kn">from</span> <span class="nn">statsmodels.tools.decorators</span> <span class="kn">import</span> <span class="n">cache_readonly</span>
<span class="kn">from</span> <span class="nn">statsmodels.compat.pandas</span> <span class="kn">import</span> <span class="n">Appender</span>


<span class="n">_predict_docstring</span> <span class="o">=</span> <span class="s2">"""</span>
<span class="s2">    Returns predicted values from the proportional hazards</span>
<span class="s2">    regression model.</span>

<span class="s2">    Parameters</span>
<span class="s2">    ----------</span><span class="si">%(params_doc)s</span><span class="s2"></span>
<span class="s2">    exog : array_like</span>
<span class="s2">        Data to use as `exog` in forming predictions.  If not</span>
<span class="s2">        provided, the `exog` values from the model used to fit the</span>
<span class="s2">        data are used.</span><span class="si">%(cov_params_doc)s</span><span class="s2"></span>
<span class="s2">    endog : array_like</span>
<span class="s2">        Duration (time) values at which the predictions are made.</span>
<span class="s2">        Only used if pred_type is either 'cumhaz' or 'surv'.  If</span>
<span class="s2">        using model `exog`, defaults to model `endog` (time), but</span>
<span class="s2">        may be provided explicitly to make predictions at</span>
<span class="s2">        alternative times.</span>
<span class="s2">    strata : array_like</span>
<span class="s2">        A vector of stratum values used to form the predictions.</span>
<span class="s2">        Not used (may be 'None') if pred_type is 'lhr' or 'hr'.</span>
<span class="s2">        If `exog` is None, the model stratum values are used.  If</span>
<span class="s2">        `exog` is not None and pred_type is 'surv' or 'cumhaz',</span>
<span class="s2">        stratum values must be provided (unless there is only one</span>
<span class="s2">        stratum).</span>
<span class="s2">    offset : array_like</span>
<span class="s2">        Offset values used to create the predicted values.</span>
<span class="s2">    pred_type : str</span>
<span class="s2">        If 'lhr', returns log hazard ratios, if 'hr' returns</span>
<span class="s2">        hazard ratios, if 'surv' returns the survival function, if</span>
<span class="s2">        'cumhaz' returns the cumulative hazard function.</span>

<span class="s2">    Returns</span>
<span class="s2">    -------</span>
<span class="s2">    A bunch containing two fields: `predicted_values` and</span>
<span class="s2">    `standard_errors`.</span>

<span class="s2">    Notes</span>
<span class="s2">    -----</span>
<span class="s2">    Standard errors are only returned when predicting the log</span>
<span class="s2">    hazard ratio (pred_type is 'lhr').</span>

<span class="s2">    Types `surv` and `cumhaz` require estimation of the cumulative</span>
<span class="s2">    hazard function.</span>
<span class="s2">"""</span>

<span class="n">_predict_params_doc</span> <span class="o">=</span> <span class="s2">"""</span>
<span class="s2">    params : array_like</span>
<span class="s2">        The proportional hazards model parameters."""</span>

<span class="n">_predict_cov_params_docstring</span> <span class="o">=</span> <span class="s2">"""</span>
<span class="s2">    cov_params : array_like</span>
<span class="s2">        The covariance matrix of the estimated `params` vector,</span>
<span class="s2">        used to obtain prediction errors if pred_type='lhr',</span>
<span class="s2">        otherwise optional."""</span>



<span class="k">class</span> <span class="nc">PHSurvivalTime</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="n">exog</span><span class="p">,</span> <span class="n">strata</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">entry</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">offset</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Represent a collection of survival times with possible</span>
<span class="sd">        stratification and left truncation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        time : array_like</span>
<span class="sd">            The times at which either the event (failure) occurs or</span>
<span class="sd">            the observation is censored.</span>
<span class="sd">        status : array_like</span>
<span class="sd">            Indicates whether the event (failure) occurs at `time`</span>
<span class="sd">            (`status` is 1), or if `time` is a censoring time (`status`</span>
<span class="sd">            is 0).</span>
<span class="sd">        exog : array_like</span>
<span class="sd">            The exogeneous (covariate) data matrix, cases are rows and</span>
<span class="sd">            variables are columns.</span>
<span class="sd">        strata : array_like</span>
<span class="sd">            Grouping variable defining the strata.  If None, all</span>
<span class="sd">            observations are in a single stratum.</span>
<span class="sd">        entry : array_like</span>
<span class="sd">            Entry (left truncation) times.  The observation is not</span>
<span class="sd">            part of the risk set for times before the entry time.  If</span>
<span class="sd">            None, the entry time is treated as being zero, which</span>
<span class="sd">            gives no left truncation.  The entry time must be less</span>
<span class="sd">            than or equal to `time`.</span>
<span class="sd">        offset : array_like</span>
<span class="sd">            An optional array of offsets</span>
<span class="sd">        """</span>

        <span class="c1"># Default strata</span>
        <span class="k">if</span> <span class="n">strata</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">strata</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">time</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>

        <span class="c1"># Default entry times</span>
        <span class="k">if</span> <span class="n">entry</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">entry</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">time</span><span class="p">))</span>

        <span class="c1"># Parameter validity checks.</span>
        <span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">,</span> <span class="n">n3</span><span class="p">,</span> <span class="n">n4</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">time</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">status</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">strata</span><span class="p">),</span>\
            <span class="nb">len</span><span class="p">(</span><span class="n">entry</span><span class="p">)</span>
        <span class="n">nv</span> <span class="o">=</span> <span class="p">[</span><span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">,</span> <span class="n">n3</span><span class="p">,</span> <span class="n">n4</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">max</span><span class="p">(</span><span class="n">nv</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">min</span><span class="p">(</span><span class="n">nv</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"endog, status, strata, and "</span> <span class="o">+</span>
                             <span class="s2">"entry must all have the same length"</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">min</span><span class="p">(</span><span class="n">time</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"endog must be non-negative"</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">min</span><span class="p">(</span><span class="n">entry</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"entry time must be non-negative"</span><span class="p">)</span>

        <span class="c1"># In Stata, this is entry &gt;= time, in R it is &gt;.</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">entry</span> <span class="o">&gt;</span> <span class="n">time</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"entry times may not occur "</span> <span class="o">+</span>
                             <span class="s2">"after event or censoring times"</span><span class="p">)</span>

        <span class="c1"># Get the row indices for the cases in each stratum</span>
        <span class="n">stu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">strata</span><span class="p">)</span>
        <span class="c1">#sth = {x: [] for x in stu} # needs &gt;=2.7</span>
        <span class="n">sth</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">x</span><span class="p">,</span> <span class="p">[])</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">stu</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">k</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">strata</span><span class="p">):</span>
            <span class="n">sth</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="n">stratum_rows</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">sth</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">stu</span><span class="p">]</span>
        <span class="n">stratum_names</span> <span class="o">=</span> <span class="n">stu</span>

        <span class="c1"># Remove strata with no events</span>
        <span class="n">ix</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">ix</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">stratum_rows</span><span class="p">)</span> <span class="k">if</span> <span class="n">status</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nstrat_orig</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">stratum_rows</span><span class="p">)</span>
        <span class="n">stratum_rows</span> <span class="o">=</span> <span class="p">[</span><span class="n">stratum_rows</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ix</span><span class="p">]</span>
        <span class="n">stratum_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">stratum_names</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ix</span><span class="p">]</span>

        <span class="c1"># The number of strata</span>
        <span class="n">nstrat</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">stratum_rows</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nstrat</span> <span class="o">=</span> <span class="n">nstrat</span>

        <span class="c1"># Remove subjects whose entry time occurs after the last event</span>
        <span class="c1"># in their stratum.</span>
        <span class="k">for</span> <span class="n">stx</span><span class="p">,</span><span class="n">ix</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">stratum_rows</span><span class="p">):</span>
            <span class="n">last_failure</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">time</span><span class="p">[</span><span class="n">ix</span><span class="p">][</span><span class="n">status</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">])</span>

            <span class="c1"># Stata uses &lt; here, R uses &lt;=</span>
            <span class="n">ii</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">t</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">entry</span><span class="p">[</span><span class="n">ix</span><span class="p">])</span> <span class="k">if</span>
                  <span class="n">t</span> <span class="o">&lt;=</span> <span class="n">last_failure</span><span class="p">]</span>
            <span class="n">stratum_rows</span><span class="p">[</span><span class="n">stx</span><span class="p">]</span> <span class="o">=</span> <span class="n">stratum_rows</span><span class="p">[</span><span class="n">stx</span><span class="p">][</span><span class="n">ii</span><span class="p">]</span>

        <span class="c1"># Remove subjects who are censored before the first event in</span>
        <span class="c1"># their stratum.</span>
        <span class="k">for</span> <span class="n">stx</span><span class="p">,</span><span class="n">ix</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">stratum_rows</span><span class="p">):</span>
            <span class="n">first_failure</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">time</span><span class="p">[</span><span class="n">ix</span><span class="p">][</span><span class="n">status</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">])</span>

            <span class="n">ii</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">t</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">time</span><span class="p">[</span><span class="n">ix</span><span class="p">])</span> <span class="k">if</span>
                  <span class="n">t</span> <span class="o">&gt;=</span> <span class="n">first_failure</span><span class="p">]</span>
            <span class="n">stratum_rows</span><span class="p">[</span><span class="n">stx</span><span class="p">]</span> <span class="o">=</span> <span class="n">stratum_rows</span><span class="p">[</span><span class="n">stx</span><span class="p">][</span><span class="n">ii</span><span class="p">]</span>

        <span class="c1"># Order by time within each stratum</span>
        <span class="k">for</span> <span class="n">stx</span><span class="p">,</span><span class="n">ix</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">stratum_rows</span><span class="p">):</span>
            <span class="n">ii</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">time</span><span class="p">[</span><span class="n">ix</span><span class="p">])</span>
            <span class="n">stratum_rows</span><span class="p">[</span><span class="n">stx</span><span class="p">]</span> <span class="o">=</span> <span class="n">stratum_rows</span><span class="p">[</span><span class="n">stx</span><span class="p">][</span><span class="n">ii</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">offset</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">offset_s</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">stx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nstrat</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">offset_s</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">offset</span><span class="p">[</span><span class="n">stratum_rows</span><span class="p">[</span><span class="n">stx</span><span class="p">]])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">offset_s</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Number of informative subjects</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_obs</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">ix</span><span class="p">)</span> <span class="k">for</span> <span class="n">ix</span> <span class="ow">in</span> <span class="n">stratum_rows</span><span class="p">])</span>

        <span class="c1"># Split everything by stratum</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time_s</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">exog_s</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">status_s</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">entry_s</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ix</span> <span class="ow">in</span> <span class="n">stratum_rows</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">time_s</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">time</span><span class="p">[</span><span class="n">ix</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">exog_s</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">exog</span><span class="p">[</span><span class="n">ix</span><span class="p">,:])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">status_s</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">status</span><span class="p">[</span><span class="n">ix</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">entry_s</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">entry</span><span class="p">[</span><span class="n">ix</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">stratum_rows</span> <span class="o">=</span> <span class="n">stratum_rows</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stratum_names</span> <span class="o">=</span> <span class="n">stratum_names</span>

        <span class="c1"># Precalculate some indices needed to fit Cox models.</span>
        <span class="c1"># Distinct failure times within a stratum are always taken to</span>
        <span class="c1"># be sorted in ascending order.</span>
        <span class="c1">#</span>
        <span class="c1"># ufailt_ix[stx][k] is a list of indices for subjects who fail</span>
        <span class="c1"># at the k^th sorted unique failure time in stratum stx</span>
        <span class="c1">#</span>
        <span class="c1"># risk_enter[stx][k] is a list of indices for subjects who</span>
        <span class="c1"># enter the risk set at the k^th sorted unique failure time in</span>
        <span class="c1"># stratum stx</span>
        <span class="c1">#</span>
        <span class="c1"># risk_exit[stx][k] is a list of indices for subjects who exit</span>
        <span class="c1"># the risk set at the k^th sorted unique failure time in</span>
        <span class="c1"># stratum stx</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ufailt_ix</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">risk_enter</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">risk_exit</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ufailt</span> <span class="o">=</span>\
            <span class="p">[],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">stx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nstrat</span><span class="p">):</span>

            <span class="c1"># All failure times</span>
            <span class="n">ift</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">status_s</span><span class="p">[</span><span class="n">stx</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">ft</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_s</span><span class="p">[</span><span class="n">stx</span><span class="p">][</span><span class="n">ift</span><span class="p">]</span>

            <span class="c1"># Unique failure times</span>
            <span class="n">uft</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">ft</span><span class="p">)</span>
            <span class="n">nuft</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">uft</span><span class="p">)</span>

            <span class="c1"># Indices of cases that fail at each unique failure time</span>
            <span class="c1">#uft_map = {x:i for i,x in enumerate(uft)} # requires &gt;=2.7</span>
            <span class="n">uft_map</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">x</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">uft</span><span class="p">)])</span> <span class="c1"># 2.6</span>
            <span class="n">uft_ix</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nuft</span><span class="p">)]</span>
            <span class="k">for</span> <span class="n">ix</span><span class="p">,</span><span class="n">ti</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">ift</span><span class="p">,</span><span class="n">ft</span><span class="p">):</span>
                <span class="n">uft_ix</span><span class="p">[</span><span class="n">uft_map</span><span class="p">[</span><span class="n">ti</span><span class="p">]]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ix</span><span class="p">)</span>

            <span class="c1"># Indices of cases (failed or censored) that enter the</span>
            <span class="c1"># risk set at each unique failure time.</span>
            <span class="n">risk_enter1</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nuft</span><span class="p">)]</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">t</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time_s</span><span class="p">[</span><span class="n">stx</span><span class="p">]):</span>
                <span class="n">ix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">uft</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="s2">"right"</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">ix</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">risk_enter1</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

            <span class="c1"># Indices of cases (failed or censored) that exit the</span>
            <span class="c1"># risk set at each unique failure time.</span>
            <span class="n">risk_exit1</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nuft</span><span class="p">)]</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">t</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">entry_s</span><span class="p">[</span><span class="n">stx</span><span class="p">]):</span>
                <span class="n">ix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">uft</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
                <span class="n">risk_exit1</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">ufailt</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">uft</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ufailt_ix</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
                                   <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">uft_ix</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">risk_enter</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
                                    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">risk_enter1</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">risk_exit</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
                                   <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">risk_exit1</span><span class="p">])</span>


<span class="k">class</span> <span class="nc">PHReg</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">LikelihoodModel</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    Cox Proportional Hazards Regression Model</span>

<span class="sd">    The Cox PH Model is for right censored data.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    endog : array_like</span>
<span class="sd">        The observed times (event or censoring)</span>
<span class="sd">    exog : 2D array_like</span>
<span class="sd">        The covariates or exogeneous variables</span>
<span class="sd">    status : array_like</span>
<span class="sd">        The censoring status values; status=1 indicates that an</span>
<span class="sd">        event occurred (e.g. failure or death), status=0 indicates</span>
<span class="sd">        that the observation was right censored. If None, defaults</span>
<span class="sd">        to status=1 for all cases.</span>
<span class="sd">    entry : array_like</span>
<span class="sd">        The entry times, if left truncation occurs</span>
<span class="sd">    strata : array_like</span>
<span class="sd">        Stratum labels.  If None, all observations are taken to be</span>
<span class="sd">        in a single stratum.</span>
<span class="sd">    ties : str</span>
<span class="sd">        The method used to handle tied times, must be either 'breslow'</span>
<span class="sd">        or 'efron'.</span>
<span class="sd">    offset : array_like</span>
<span class="sd">        Array of offset values</span>
<span class="sd">    missing : str</span>
<span class="sd">        The method used to handle missing data</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Proportional hazards regression models should not include an</span>
<span class="sd">    explicit or implicit intercept.  The effect of an intercept is</span>
<span class="sd">    not identified using the partial likelihood approach.</span>

<span class="sd">    `endog`, `event`, `strata`, `entry`, and the first dimension</span>
<span class="sd">    of `exog` all must have the same length</span>
<span class="sd">    """</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">endog</span><span class="p">,</span> <span class="n">exog</span><span class="p">,</span> <span class="n">status</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">entry</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">strata</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ties</span><span class="o">=</span><span class="s1">'breslow'</span><span class="p">,</span>
                 <span class="n">missing</span><span class="o">=</span><span class="s1">'drop'</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

        <span class="c1"># Default is no censoring</span>
        <span class="k">if</span> <span class="n">status</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">status</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">endog</span><span class="p">))</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">PHReg</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">endog</span><span class="p">,</span> <span class="n">exog</span><span class="p">,</span> <span class="n">status</span><span class="o">=</span><span class="n">status</span><span class="p">,</span>
                                    <span class="n">entry</span><span class="o">=</span><span class="n">entry</span><span class="p">,</span> <span class="n">strata</span><span class="o">=</span><span class="n">strata</span><span class="p">,</span>
                                    <span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">,</span> <span class="n">missing</span><span class="o">=</span><span class="n">missing</span><span class="p">,</span>
                                    <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># endog and exog are automatically converted, but these are</span>
        <span class="c1"># not</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">status</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">status</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">status</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">entry</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">entry</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">entry</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">strata</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">strata</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">strata</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">offset</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">offset</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">offset</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">surv</span> <span class="o">=</span> <span class="n">PHSurvivalTime</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endog</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">status</span><span class="p">,</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">exog</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">strata</span><span class="p">,</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">entry</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">offset</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endog</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">groups</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># TODO: not used?</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">missing</span> <span class="o">=</span> <span class="n">missing</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">df_resid</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exog</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span>
                                  <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">matrix_rank</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exog</span><span class="p">)))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">df_model</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">matrix_rank</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exog</span><span class="p">))</span>

        <span class="n">ties</span> <span class="o">=</span> <span class="n">ties</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">ties</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">"efron"</span><span class="p">,</span> <span class="s2">"breslow"</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"`ties` must be either `efron` or "</span> <span class="o">+</span>
                             <span class="s2">"`breslow`"</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">ties</span> <span class="o">=</span> <span class="n">ties</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_formula</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">formula</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">status</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">entry</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">strata</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">subset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">ties</span><span class="o">=</span><span class="s1">'breslow'</span><span class="p">,</span> <span class="n">missing</span><span class="o">=</span><span class="s1">'drop'</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Create a proportional hazards regression model from a formula</span>
<span class="sd">        and dataframe.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        formula : str or generic Formula object</span>
<span class="sd">            The formula specifying the model</span>
<span class="sd">        data : array_like</span>
<span class="sd">            The data for the model. See Notes.</span>
<span class="sd">        status : array_like</span>
<span class="sd">            The censoring status values; status=1 indicates that an</span>
<span class="sd">            event occurred (e.g. failure or death), status=0 indicates</span>
<span class="sd">            that the observation was right censored. If None, defaults</span>
<span class="sd">            to status=1 for all cases.</span>
<span class="sd">        entry : array_like</span>
<span class="sd">            The entry times, if left truncation occurs</span>
<span class="sd">        strata : array_like</span>
<span class="sd">            Stratum labels.  If None, all observations are taken to be</span>
<span class="sd">            in a single stratum.</span>
<span class="sd">        offset : array_like</span>
<span class="sd">            Array of offset values</span>
<span class="sd">        subset : array_like</span>
<span class="sd">            An array-like object of booleans, integers, or index</span>
<span class="sd">            values that indicate the subset of df to use in the</span>
<span class="sd">            model. Assumes df is a `pandas.DataFrame`</span>
<span class="sd">        ties : str</span>
<span class="sd">            The method used to handle tied times, must be either 'breslow'</span>
<span class="sd">            or 'efron'.</span>
<span class="sd">        missing : str</span>
<span class="sd">            The method used to handle missing data</span>
<span class="sd">        args : extra arguments</span>
<span class="sd">            These are passed to the model</span>
<span class="sd">        kwargs : extra keyword arguments</span>
<span class="sd">            These are passed to the model with one exception. The</span>
<span class="sd">            ``eval_env`` keyword is passed to patsy. It can be either a</span>
<span class="sd">            :class:`patsy:patsy.EvalEnvironment` object or an integer</span>
<span class="sd">            indicating the depth of the namespace to use. For example, the</span>
<span class="sd">            default ``eval_env=0`` uses the calling namespace. If you wish</span>
<span class="sd">            to use a "clean" environment set ``eval_env=-1``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        model : PHReg model instance</span>
<span class="sd">        """</span>

        <span class="c1"># Allow array arguments to be passed by column name.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">status</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">status</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">entry</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">entry</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">strata</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">strata</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">strata</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">offset</span><span class="p">]</span>

        <span class="kn">import</span> <span class="nn">re</span>
        <span class="n">terms</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">r</span><span class="s2">"[+\-~]"</span><span class="p">,</span> <span class="n">formula</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="n">terms</span><span class="p">:</span>
            <span class="n">term</span> <span class="o">=</span> <span class="n">term</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">term</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">"0"</span><span class="p">,</span> <span class="s2">"1"</span><span class="p">):</span>
                <span class="kn">import</span> <span class="nn">warnings</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">"PHReg formulas should not include any '0' or '1' terms"</span><span class="p">)</span>

        <span class="n">mod</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">PHReg</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span><span class="o">.</span><span class="n">from_formula</span><span class="p">(</span><span class="n">formula</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span>
                    <span class="n">status</span><span class="o">=</span><span class="n">status</span><span class="p">,</span> <span class="n">entry</span><span class="o">=</span><span class="n">entry</span><span class="p">,</span> <span class="n">strata</span><span class="o">=</span><span class="n">strata</span><span class="p">,</span>
                    <span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">,</span> <span class="n">subset</span><span class="o">=</span><span class="n">subset</span><span class="p">,</span> <span class="n">ties</span><span class="o">=</span><span class="n">ties</span><span class="p">,</span>
                    <span class="n">missing</span><span class="o">=</span><span class="n">missing</span><span class="p">,</span> <span class="n">drop_cols</span><span class="o">=</span><span class="p">[</span><span class="s2">"Intercept"</span><span class="p">],</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span>
                    <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">mod</span>

    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">groups</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Fit a proportional hazards regression model.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        groups : array_like</span>
<span class="sd">            Labels indicating groups of observations that may be</span>
<span class="sd">            dependent.  If present, the standard errors account for</span>
<span class="sd">            this dependence. Does not affect fitted values.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        PHRegResults</span>
<span class="sd">            Returns a results instance.</span>
<span class="sd">        """</span>

        <span class="c1"># TODO process for missing values</span>
        <span class="k">if</span> <span class="n">groups</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">groups</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endog</span><span class="p">):</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">"len(groups) = </span><span class="si">%d</span><span class="s2"> and len(endog) = </span><span class="si">%d</span><span class="s2"> differ"</span> <span class="o">%</span>
                       <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">groups</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endog</span><span class="p">)))</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">groups</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">groups</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">groups</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="s1">'disp'</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
            <span class="n">args</span><span class="p">[</span><span class="s1">'disp'</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">fit_rslts</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">PHReg</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="o">**</span><span class="n">args</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">groups</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cov_params</span> <span class="o">=</span> <span class="n">fit_rslts</span><span class="o">.</span><span class="n">cov_params</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cov_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">robust_covariance</span><span class="p">(</span><span class="n">fit_rslts</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>

        <span class="n">results</span> <span class="o">=</span> <span class="n">PHRegResults</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fit_rslts</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="n">cov_params</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">results</span>

    <span class="k">def</span> <span class="nf">fit_regularized</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">"elastic_net"</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span>
                        <span class="n">start_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">refit</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">"""</span>
<span class="sd">        Return a regularized fit to a linear regression model.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        method : {'elastic_net'}</span>
<span class="sd">            Only the `elastic_net` approach is currently implemented.</span>
<span class="sd">        alpha : scalar or array_like</span>
<span class="sd">            The penalty weight.  If a scalar, the same penalty weight</span>
<span class="sd">            applies to all variables in the model.  If a vector, it</span>
<span class="sd">            must have the same length as `params`, and contains a</span>
<span class="sd">            penalty weight for each coefficient.</span>
<span class="sd">        start_params : array_like</span>
<span class="sd">            Starting values for `params`.</span>
<span class="sd">        refit : bool</span>
<span class="sd">            If True, the model is refit using only the variables that</span>
<span class="sd">            have non-zero coefficients in the regularized fit.  The</span>
<span class="sd">            refitted model is not regularized.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Additional keyword arguments used to fit the model.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        PHRegResults</span>
<span class="sd">            Returns a results instance.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The penalty is the ``elastic net`` penalty, which is a</span>
<span class="sd">        combination of L1 and L2 penalties.</span>

<span class="sd">        The function that is minimized is:</span>

<span class="sd">        .. math::</span>

<span class="sd">            -loglike/n + alpha*((1-L1\_wt)*|params|_2^2/2 + L1\_wt*|params|_1)</span>

<span class="sd">        where :math:`|*|_1` and :math:`|*|_2` are the L1 and L2 norms.</span>

<span class="sd">        Post-estimation results are based on the same data used to</span>
<span class="sd">        select variables, hence may be subject to overfitting biases.</span>

<span class="sd">        The elastic_net method uses the following keyword arguments:</span>

<span class="sd">        maxiter : int</span>
<span class="sd">            Maximum number of iterations</span>
<span class="sd">        L1_wt  : float</span>
<span class="sd">            Must be in [0, 1].  The L1 penalty has weight L1_wt and the</span>
<span class="sd">            L2 penalty has weight 1 - L1_wt.</span>
<span class="sd">        cnvrg_tol : float</span>
<span class="sd">            Convergence threshold for line searches</span>
<span class="sd">        zero_tol : float</span>
<span class="sd">            Coefficients below this threshold are treated as zero.</span>
<span class="sd">        """</span>

        <span class="kn">from</span> <span class="nn">statsmodels.base.elastic_net</span> <span class="kn">import</span> <span class="n">fit_elasticnet</span>

        <span class="k">if</span> <span class="n">method</span> <span class="o">!=</span> <span class="s2">"elastic_net"</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"method for fit_regularied must be elastic_net"</span><span class="p">)</span>

        <span class="n">defaults</span> <span class="o">=</span> <span class="p">{</span><span class="s2">"maxiter"</span> <span class="p">:</span> <span class="mi">50</span><span class="p">,</span> <span class="s2">"L1_wt"</span> <span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">"cnvrg_tol"</span> <span class="p">:</span> <span class="mf">1e-10</span><span class="p">,</span>
                    <span class="s2">"zero_tol"</span> <span class="p">:</span> <span class="mf">1e-10</span><span class="p">}</span>
        <span class="n">defaults</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">fit_elasticnet</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
                              <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span>
                              <span class="n">start_params</span><span class="o">=</span><span class="n">start_params</span><span class="p">,</span>
                              <span class="n">refit</span><span class="o">=</span><span class="n">refit</span><span class="p">,</span>
                              <span class="o">**</span><span class="n">defaults</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">loglike</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Returns the log partial likelihood function evaluated at</span>
<span class="sd">        `params`.</span>
<span class="sd">        """</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ties</span> <span class="o">==</span> <span class="s2">"breslow"</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">breslow_loglike</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">ties</span> <span class="o">==</span> <span class="s2">"efron"</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">efron_loglike</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">score</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Returns the score function evaluated at `params`.</span>
<span class="sd">        """</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ties</span> <span class="o">==</span> <span class="s2">"breslow"</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">breslow_gradient</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">ties</span> <span class="o">==</span> <span class="s2">"efron"</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">efron_gradient</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">hessian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Returns the Hessian matrix of the log partial likelihood</span>
<span class="sd">        function evaluated at `params`.</span>
<span class="sd">        """</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ties</span> <span class="o">==</span> <span class="s2">"breslow"</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">breslow_hessian</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">efron_hessian</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">breslow_loglike</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Returns the value of the log partial likelihood function</span>
<span class="sd">        evaluated at `params`, using the Breslow method to handle tied</span>
<span class="sd">        times.</span>
<span class="sd">        """</span>

        <span class="n">surv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">surv</span>

        <span class="n">like</span> <span class="o">=</span> <span class="mf">0.</span>

        <span class="c1"># Loop over strata</span>
        <span class="k">for</span> <span class="n">stx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">surv</span><span class="o">.</span><span class="n">nstrat</span><span class="p">):</span>

            <span class="n">uft_ix</span> <span class="o">=</span> <span class="n">surv</span><span class="o">.</span><span class="n">ufailt_ix</span><span class="p">[</span><span class="n">stx</span><span class="p">]</span>
            <span class="n">exog_s</span> <span class="o">=</span> <span class="n">surv</span><span class="o">.</span><span class="n">exog_s</span><span class="p">[</span><span class="n">stx</span><span class="p">]</span>
            <span class="n">nuft</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">uft_ix</span><span class="p">)</span>

            <span class="n">linpred</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">exog_s</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">surv</span><span class="o">.</span><span class="n">offset_s</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">linpred</span> <span class="o">+=</span> <span class="n">surv</span><span class="o">.</span><span class="n">offset_s</span><span class="p">[</span><span class="n">stx</span><span class="p">]</span>
            <span class="n">linpred</span> <span class="o">-=</span> <span class="n">linpred</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
            <span class="n">e_linpred</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">linpred</span><span class="p">)</span>

            <span class="n">xp0</span> <span class="o">=</span> <span class="mf">0.</span>

            <span class="c1"># Iterate backward through the unique failure times.</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nuft</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>

                <span class="c1"># Update for new cases entering the risk set.</span>
                <span class="n">ix</span> <span class="o">=</span> <span class="n">surv</span><span class="o">.</span><span class="n">risk_enter</span><span class="p">[</span><span class="n">stx</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
                <span class="n">xp0</span> <span class="o">+=</span> <span class="n">e_linpred</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

                <span class="c1"># Account for all cases that fail at this point.</span>
                <span class="n">ix</span> <span class="o">=</span> <span class="n">uft_ix</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">like</span> <span class="o">+=</span> <span class="p">(</span><span class="n">linpred</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">xp0</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

                <span class="c1"># Update for cases leaving the risk set.</span>
                <span class="n">ix</span> <span class="o">=</span> <span class="n">surv</span><span class="o">.</span><span class="n">risk_exit</span><span class="p">[</span><span class="n">stx</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
                <span class="n">xp0</span> <span class="o">-=</span> <span class="n">e_linpred</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">like</span>

    <span class="k">def</span> <span class="nf">efron_loglike</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Returns the value of the log partial likelihood function</span>
<span class="sd">        evaluated at `params`, using the Efron method to handle tied</span>
<span class="sd">        times.</span>
<span class="sd">        """</span>

        <span class="n">surv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">surv</span>

        <span class="n">like</span> <span class="o">=</span> <span class="mf">0.</span>

        <span class="c1"># Loop over strata</span>
        <span class="k">for</span> <span class="n">stx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">surv</span><span class="o">.</span><span class="n">nstrat</span><span class="p">):</span>

            <span class="c1"># exog and linear predictor for this stratum</span>
            <span class="n">exog_s</span> <span class="o">=</span> <span class="n">surv</span><span class="o">.</span><span class="n">exog_s</span><span class="p">[</span><span class="n">stx</span><span class="p">]</span>
            <span class="n">linpred</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">exog_s</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">surv</span><span class="o">.</span><span class="n">offset_s</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">linpred</span> <span class="o">+=</span> <span class="n">surv</span><span class="o">.</span><span class="n">offset_s</span><span class="p">[</span><span class="n">stx</span><span class="p">]</span>
            <span class="n">linpred</span> <span class="o">-=</span> <span class="n">linpred</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
            <span class="n">e_linpred</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">linpred</span><span class="p">)</span>

            <span class="n">xp0</span> <span class="o">=</span> <span class="mf">0.</span>

            <span class="c1"># Iterate backward through the unique failure times.</span>
            <span class="n">uft_ix</span> <span class="o">=</span> <span class="n">surv</span><span class="o">.</span><span class="n">ufailt_ix</span><span class="p">[</span><span class="n">stx</span><span class="p">]</span>
            <span class="n">nuft</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">uft_ix</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nuft</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>

                <span class="c1"># Update for new cases entering the risk set.</span>
                <span class="n">ix</span> <span class="o">=</span> <span class="n">surv</span><span class="o">.</span><span class="n">risk_enter</span><span class="p">[</span><span class="n">stx</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
                <span class="n">xp0</span> <span class="o">+=</span> <span class="n">e_linpred</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
                <span class="n">xp0f</span> <span class="o">=</span> <span class="n">e_linpred</span><span class="p">[</span><span class="n">uft_ix</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

                <span class="c1"># Account for all cases that fail at this point.</span>
                <span class="n">ix</span> <span class="o">=</span> <span class="n">uft_ix</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">like</span> <span class="o">+=</span> <span class="n">linpred</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

                <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ix</span><span class="p">)</span>
                <span class="n">J</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span> <span class="o">/</span> <span class="n">m</span>
                <span class="n">like</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">xp0</span> <span class="o">-</span> <span class="n">J</span><span class="o">*</span><span class="n">xp0f</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

                <span class="c1"># Update for cases leaving the risk set.</span>
                <span class="n">ix</span> <span class="o">=</span> <span class="n">surv</span><span class="o">.</span><span class="n">risk_exit</span><span class="p">[</span><span class="n">stx</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
                <span class="n">xp0</span> <span class="o">-=</span> <span class="n">e_linpred</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">like</span>

    <span class="k">def</span> <span class="nf">breslow_gradient</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Returns the gradient of the log partial likelihood, using the</span>
<span class="sd">        Breslow method to handle tied times.</span>
<span class="sd">        """</span>

        <span class="n">surv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">surv</span>

        <span class="n">grad</span> <span class="o">=</span> <span class="mf">0.</span>

        <span class="c1"># Loop over strata</span>
        <span class="k">for</span> <span class="n">stx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">surv</span><span class="o">.</span><span class="n">nstrat</span><span class="p">):</span>

            <span class="c1"># Indices of subjects in the stratum</span>
            <span class="n">strat_ix</span> <span class="o">=</span> <span class="n">surv</span><span class="o">.</span><span class="n">stratum_rows</span><span class="p">[</span><span class="n">stx</span><span class="p">]</span>

            <span class="c1"># Unique failure times in the stratum</span>
            <span class="n">uft_ix</span> <span class="o">=</span> <span class="n">surv</span><span class="o">.</span><span class="n">ufailt_ix</span><span class="p">[</span><span class="n">stx</span><span class="p">]</span>
            <span class="n">nuft</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">uft_ix</span><span class="p">)</span>

            <span class="c1"># exog and linear predictor for the stratum</span>
            <span class="n">exog_s</span> <span class="o">=</span> <span class="n">surv</span><span class="o">.</span><span class="n">exog_s</span><span class="p">[</span><span class="n">stx</span><span class="p">]</span>
            <span class="n">linpred</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">exog_s</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">surv</span><span class="o">.</span><span class="n">offset_s</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">linpred</span> <span class="o">+=</span> <span class="n">surv</span><span class="o">.</span><span class="n">offset_s</span><span class="p">[</span><span class="n">stx</span><span class="p">]</span>
            <span class="n">linpred</span> <span class="o">-=</span> <span class="n">linpred</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
            <span class="n">e_linpred</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">linpred</span><span class="p">)</span>

            <span class="n">xp0</span><span class="p">,</span> <span class="n">xp1</span> <span class="o">=</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span>

            <span class="c1"># Iterate backward through the unique failure times.</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nuft</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>

                <span class="c1"># Update for new cases entering the risk set.</span>
                <span class="n">ix</span> <span class="o">=</span> <span class="n">surv</span><span class="o">.</span><span class="n">risk_enter</span><span class="p">[</span><span class="n">stx</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ix</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">v</span> <span class="o">=</span> <span class="n">exog_s</span><span class="p">[</span><span class="n">ix</span><span class="p">,:]</span>
                    <span class="n">xp0</span> <span class="o">+=</span> <span class="n">e_linpred</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
                    <span class="n">xp1</span> <span class="o">+=</span> <span class="p">(</span><span class="n">e_linpred</span><span class="p">[</span><span class="n">ix</span><span class="p">][:,</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

                <span class="c1"># Account for all cases that fail at this point.</span>
                <span class="n">ix</span> <span class="o">=</span> <span class="n">uft_ix</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">grad</span> <span class="o">+=</span> <span class="p">(</span><span class="n">exog_s</span><span class="p">[</span><span class="n">ix</span><span class="p">,:]</span> <span class="o">-</span> <span class="n">xp1</span> <span class="o">/</span> <span class="n">xp0</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

                <span class="c1"># Update for cases leaving the risk set.</span>
                <span class="n">ix</span> <span class="o">=</span> <span class="n">surv</span><span class="o">.</span><span class="n">risk_exit</span><span class="p">[</span><span class="n">stx</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ix</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">v</span> <span class="o">=</span> <span class="n">exog_s</span><span class="p">[</span><span class="n">ix</span><span class="p">,:]</span>
                    <span class="n">xp0</span> <span class="o">-=</span> <span class="n">e_linpred</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
                    <span class="n">xp1</span> <span class="o">-=</span> <span class="p">(</span><span class="n">e_linpred</span><span class="p">[</span><span class="n">ix</span><span class="p">][:,</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">grad</span>

    <span class="k">def</span> <span class="nf">efron_gradient</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Returns the gradient of the log partial likelihood evaluated</span>
<span class="sd">        at `params`, using the Efron method to handle tied times.</span>
<span class="sd">        """</span>

        <span class="n">surv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">surv</span>

        <span class="n">grad</span> <span class="o">=</span> <span class="mf">0.</span>

        <span class="c1"># Loop over strata</span>
        <span class="k">for</span> <span class="n">stx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">surv</span><span class="o">.</span><span class="n">nstrat</span><span class="p">):</span>

            <span class="c1"># Indices of cases in the stratum</span>
            <span class="n">strat_ix</span> <span class="o">=</span> <span class="n">surv</span><span class="o">.</span><span class="n">stratum_rows</span><span class="p">[</span><span class="n">stx</span><span class="p">]</span>

            <span class="c1"># exog and linear predictor of the stratum</span>
            <span class="n">exog_s</span> <span class="o">=</span> <span class="n">surv</span><span class="o">.</span><span class="n">exog_s</span><span class="p">[</span><span class="n">stx</span><span class="p">]</span>
            <span class="n">linpred</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">exog_s</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">surv</span><span class="o">.</span><span class="n">offset_s</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">linpred</span> <span class="o">+=</span> <span class="n">surv</span><span class="o">.</span><span class="n">offset_s</span><span class="p">[</span><span class="n">stx</span><span class="p">]</span>
            <span class="n">linpred</span> <span class="o">-=</span> <span class="n">linpred</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
            <span class="n">e_linpred</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">linpred</span><span class="p">)</span>

            <span class="n">xp0</span><span class="p">,</span> <span class="n">xp1</span> <span class="o">=</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span>

            <span class="c1"># Iterate backward through the unique failure times.</span>
            <span class="n">uft_ix</span> <span class="o">=</span> <span class="n">surv</span><span class="o">.</span><span class="n">ufailt_ix</span><span class="p">[</span><span class="n">stx</span><span class="p">]</span>
            <span class="n">nuft</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">uft_ix</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nuft</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>

                <span class="c1"># Update for new cases entering the risk set.</span>
                <span class="n">ix</span> <span class="o">=</span> <span class="n">surv</span><span class="o">.</span><span class="n">risk_enter</span><span class="p">[</span><span class="n">stx</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ix</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">v</span> <span class="o">=</span> <span class="n">exog_s</span><span class="p">[</span><span class="n">ix</span><span class="p">,:]</span>
                    <span class="n">xp0</span> <span class="o">+=</span> <span class="n">e_linpred</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
                    <span class="n">xp1</span> <span class="o">+=</span> <span class="p">(</span><span class="n">e_linpred</span><span class="p">[</span><span class="n">ix</span><span class="p">][:,</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">ixf</span> <span class="o">=</span> <span class="n">uft_ix</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ixf</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">v</span> <span class="o">=</span> <span class="n">exog_s</span><span class="p">[</span><span class="n">ixf</span><span class="p">,:]</span>
                    <span class="n">xp0f</span> <span class="o">=</span> <span class="n">e_linpred</span><span class="p">[</span><span class="n">ixf</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
                    <span class="n">xp1f</span> <span class="o">=</span> <span class="p">(</span><span class="n">e_linpred</span><span class="p">[</span><span class="n">ixf</span><span class="p">][:,</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

                    <span class="c1"># Consider all cases that fail at this point.</span>
                    <span class="n">grad</span> <span class="o">+=</span> <span class="n">v</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

                    <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ixf</span><span class="p">)</span>
                    <span class="n">J</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span> <span class="o">/</span> <span class="n">m</span>
                    <span class="n">numer</span> <span class="o">=</span> <span class="n">xp1</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="n">xp1f</span><span class="p">)</span>
                    <span class="n">denom</span> <span class="o">=</span> <span class="n">xp0</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="n">xp0f</span><span class="p">)</span>
                    <span class="n">ratio</span> <span class="o">=</span> <span class="n">numer</span> <span class="o">/</span> <span class="n">denom</span>
                    <span class="n">rsum</span> <span class="o">=</span> <span class="n">ratio</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                    <span class="n">grad</span> <span class="o">-=</span> <span class="n">rsum</span>

                <span class="c1"># Update for cases leaving the risk set.</span>
                <span class="n">ix</span> <span class="o">=</span> <span class="n">surv</span><span class="o">.</span><span class="n">risk_exit</span><span class="p">[</span><span class="n">stx</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ix</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">v</span> <span class="o">=</span> <span class="n">exog_s</span><span class="p">[</span><span class="n">ix</span><span class="p">,:]</span>
                    <span class="n">xp0</span> <span class="o">-=</span> <span class="n">e_linpred</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
                    <span class="n">xp1</span> <span class="o">-=</span> <span class="p">(</span><span class="n">e_linpred</span><span class="p">[</span><span class="n">ix</span><span class="p">][:,</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">grad</span>

    <span class="k">def</span> <span class="nf">breslow_hessian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Returns the Hessian of the log partial likelihood evaluated at</span>
<span class="sd">        `params`, using the Breslow method to handle tied times.</span>
<span class="sd">        """</span>

        <span class="n">surv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">surv</span>

        <span class="n">hess</span> <span class="o">=</span> <span class="mf">0.</span>

        <span class="c1"># Loop over strata</span>
        <span class="k">for</span> <span class="n">stx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">surv</span><span class="o">.</span><span class="n">nstrat</span><span class="p">):</span>

            <span class="n">uft_ix</span> <span class="o">=</span> <span class="n">surv</span><span class="o">.</span><span class="n">ufailt_ix</span><span class="p">[</span><span class="n">stx</span><span class="p">]</span>
            <span class="n">nuft</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">uft_ix</span><span class="p">)</span>

            <span class="n">exog_s</span> <span class="o">=</span> <span class="n">surv</span><span class="o">.</span><span class="n">exog_s</span><span class="p">[</span><span class="n">stx</span><span class="p">]</span>

            <span class="n">linpred</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">exog_s</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">surv</span><span class="o">.</span><span class="n">offset_s</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">linpred</span> <span class="o">+=</span> <span class="n">surv</span><span class="o">.</span><span class="n">offset_s</span><span class="p">[</span><span class="n">stx</span><span class="p">]</span>
            <span class="n">linpred</span> <span class="o">-=</span> <span class="n">linpred</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
            <span class="n">e_linpred</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">linpred</span><span class="p">)</span>

            <span class="n">xp0</span><span class="p">,</span> <span class="n">xp1</span><span class="p">,</span> <span class="n">xp2</span> <span class="o">=</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span>

            <span class="c1"># Iterate backward through the unique failure times.</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nuft</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>

                <span class="c1"># Update for new cases entering the risk set.</span>
                <span class="n">ix</span> <span class="o">=</span> <span class="n">surv</span><span class="o">.</span><span class="n">risk_enter</span><span class="p">[</span><span class="n">stx</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ix</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">xp0</span> <span class="o">+=</span> <span class="n">e_linpred</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
                    <span class="n">v</span> <span class="o">=</span> <span class="n">exog_s</span><span class="p">[</span><span class="n">ix</span><span class="p">,:]</span>
                    <span class="n">xp1</span> <span class="o">+=</span> <span class="p">(</span><span class="n">e_linpred</span><span class="p">[</span><span class="n">ix</span><span class="p">][:,</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                    <span class="n">elx</span> <span class="o">=</span> <span class="n">e_linpred</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span>
                    <span class="n">xp2</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">"ij,ik,i-&gt;jk"</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">elx</span><span class="p">)</span>

                <span class="c1"># Account for all cases that fail at this point.</span>
                <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">uft_ix</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">hess</span> <span class="o">+=</span> <span class="n">m</span><span class="o">*</span><span class="p">(</span><span class="n">xp2</span> <span class="o">/</span> <span class="n">xp0</span>  <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">xp1</span><span class="p">,</span> <span class="n">xp1</span><span class="p">)</span> <span class="o">/</span> <span class="n">xp0</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

                <span class="c1"># Update for new cases entering the risk set.</span>
                <span class="n">ix</span> <span class="o">=</span> <span class="n">surv</span><span class="o">.</span><span class="n">risk_exit</span><span class="p">[</span><span class="n">stx</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ix</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">xp0</span> <span class="o">-=</span> <span class="n">e_linpred</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
                    <span class="n">v</span> <span class="o">=</span> <span class="n">exog_s</span><span class="p">[</span><span class="n">ix</span><span class="p">,:]</span>
                    <span class="n">xp1</span> <span class="o">-=</span> <span class="p">(</span><span class="n">e_linpred</span><span class="p">[</span><span class="n">ix</span><span class="p">][:,</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                    <span class="n">elx</span> <span class="o">=</span> <span class="n">e_linpred</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span>
                    <span class="n">xp2</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">"ij,ik,i-&gt;jk"</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">elx</span><span class="p">)</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">hess</span>

    <span class="k">def</span> <span class="nf">efron_hessian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Returns the Hessian matrix of the partial log-likelihood</span>
<span class="sd">        evaluated at `params`, using the Efron method to handle tied</span>
<span class="sd">        times.</span>
<span class="sd">        """</span>

        <span class="n">surv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">surv</span>

        <span class="n">hess</span> <span class="o">=</span> <span class="mf">0.</span>

        <span class="c1"># Loop over strata</span>
        <span class="k">for</span> <span class="n">stx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">surv</span><span class="o">.</span><span class="n">nstrat</span><span class="p">):</span>

            <span class="n">exog_s</span> <span class="o">=</span> <span class="n">surv</span><span class="o">.</span><span class="n">exog_s</span><span class="p">[</span><span class="n">stx</span><span class="p">]</span>

            <span class="n">linpred</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">exog_s</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">surv</span><span class="o">.</span><span class="n">offset_s</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">linpred</span> <span class="o">+=</span> <span class="n">surv</span><span class="o">.</span><span class="n">offset_s</span><span class="p">[</span><span class="n">stx</span><span class="p">]</span>
            <span class="n">linpred</span> <span class="o">-=</span> <span class="n">linpred</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
            <span class="n">e_linpred</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">linpred</span><span class="p">)</span>

            <span class="n">xp0</span><span class="p">,</span> <span class="n">xp1</span><span class="p">,</span> <span class="n">xp2</span> <span class="o">=</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span>

            <span class="c1"># Iterate backward through the unique failure times.</span>
            <span class="n">uft_ix</span> <span class="o">=</span> <span class="n">surv</span><span class="o">.</span><span class="n">ufailt_ix</span><span class="p">[</span><span class="n">stx</span><span class="p">]</span>
            <span class="n">nuft</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">uft_ix</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nuft</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>

                <span class="c1"># Update for new cases entering the risk set.</span>
                <span class="n">ix</span> <span class="o">=</span> <span class="n">surv</span><span class="o">.</span><span class="n">risk_enter</span><span class="p">[</span><span class="n">stx</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ix</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">xp0</span> <span class="o">+=</span> <span class="n">e_linpred</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
                    <span class="n">v</span> <span class="o">=</span> <span class="n">exog_s</span><span class="p">[</span><span class="n">ix</span><span class="p">,:]</span>
                    <span class="n">xp1</span> <span class="o">+=</span> <span class="p">(</span><span class="n">e_linpred</span><span class="p">[</span><span class="n">ix</span><span class="p">][:,</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                    <span class="n">elx</span> <span class="o">=</span> <span class="n">e_linpred</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span>
                    <span class="n">xp2</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">"ij,ik,i-&gt;jk"</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">elx</span><span class="p">)</span>

                <span class="n">ixf</span> <span class="o">=</span> <span class="n">uft_ix</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ixf</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">v</span> <span class="o">=</span> <span class="n">exog_s</span><span class="p">[</span><span class="n">ixf</span><span class="p">,:]</span>
                    <span class="n">xp0f</span> <span class="o">=</span> <span class="n">e_linpred</span><span class="p">[</span><span class="n">ixf</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
                    <span class="n">xp1f</span> <span class="o">=</span> <span class="p">(</span><span class="n">e_linpred</span><span class="p">[</span><span class="n">ixf</span><span class="p">][:,</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                    <span class="n">elx</span> <span class="o">=</span> <span class="n">e_linpred</span><span class="p">[</span><span class="n">ixf</span><span class="p">]</span>
                    <span class="n">xp2f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">"ij,ik,i-&gt;jk"</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">elx</span><span class="p">)</span>

                <span class="c1"># Account for all cases that fail at this point.</span>
                <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">uft_ix</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">J</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span> <span class="o">/</span> <span class="n">m</span>
                <span class="n">c0</span> <span class="o">=</span> <span class="n">xp0</span> <span class="o">-</span> <span class="n">J</span><span class="o">*</span><span class="n">xp0f</span>
                <span class="n">hess</span> <span class="o">+=</span> <span class="n">xp2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">c0</span><span class="p">)</span>
                <span class="n">hess</span> <span class="o">-=</span> <span class="n">xp2f</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">J</span> <span class="o">/</span> <span class="n">c0</span><span class="p">)</span>
                <span class="n">mat</span> <span class="o">=</span> <span class="p">(</span><span class="n">xp1</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="n">xp1f</span><span class="p">))</span> <span class="o">/</span> <span class="n">c0</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span>
                <span class="n">hess</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">"ij,ik-&gt;jk"</span><span class="p">,</span> <span class="n">mat</span><span class="p">,</span> <span class="n">mat</span><span class="p">)</span>

                <span class="c1"># Update for new cases entering the risk set.</span>
                <span class="n">ix</span> <span class="o">=</span> <span class="n">surv</span><span class="o">.</span><span class="n">risk_exit</span><span class="p">[</span><span class="n">stx</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ix</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">xp0</span> <span class="o">-=</span> <span class="n">e_linpred</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
                    <span class="n">v</span> <span class="o">=</span> <span class="n">exog_s</span><span class="p">[</span><span class="n">ix</span><span class="p">,:]</span>
                    <span class="n">xp1</span> <span class="o">-=</span> <span class="p">(</span><span class="n">e_linpred</span><span class="p">[</span><span class="n">ix</span><span class="p">][:,</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                    <span class="n">elx</span> <span class="o">=</span> <span class="n">e_linpred</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span>
                    <span class="n">xp2</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">"ij,ik,i-&gt;jk"</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">elx</span><span class="p">)</span>

        <span class="k">return</span> <span class="o">-</span><span class="n">hess</span>

    <span class="k">def</span> <span class="nf">robust_covariance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Returns a covariance matrix for the proportional hazards model</span>
<span class="sd">        regresion coefficient estimates that is robust to certain</span>
<span class="sd">        forms of model misspecification.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : ndarray</span>
<span class="sd">            The parameter vector at which the covariance matrix is</span>
<span class="sd">            calculated.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        The robust covariance matrix as a square ndarray.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This function uses the `groups` argument to determine groups</span>
<span class="sd">        within which observations may be dependent.  The covariance</span>
<span class="sd">        matrix is calculated using the Huber-White "sandwich" approach.</span>
<span class="sd">        """</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">groups</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"`groups` must be specified to calculate the robust covariance matrix"</span><span class="p">)</span>

        <span class="n">hess</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hessian</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>

        <span class="n">score_obs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">score_residuals</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>

        <span class="c1"># Collapse</span>
        <span class="n">grads</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">g</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">groups</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">g</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">grads</span><span class="p">:</span>
                <span class="n">grads</span><span class="p">[</span><span class="n">g</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.</span>
            <span class="n">grads</span><span class="p">[</span><span class="n">g</span><span class="p">]</span> <span class="o">+=</span> <span class="n">score_obs</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">grads</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">grads</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>

        <span class="n">mat</span> <span class="o">=</span> <span class="n">grads</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>
        <span class="n">mat</span> <span class="o">=</span> <span class="n">mat</span><span class="o">.</span><span class="n">T</span> <span class="o">*</span> <span class="n">mat</span>
        <span class="n">mat</span> <span class="o">=</span> <span class="n">mat</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">hess_inv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">hess</span><span class="p">)</span>
        <span class="n">cmat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">hess_inv</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">mat</span><span class="p">,</span> <span class="n">hess_inv</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">cmat</span>

    <span class="k">def</span> <span class="nf">score_residuals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Returns the score residuals calculated at a given vector of</span>
<span class="sd">        parameters.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : ndarray</span>
<span class="sd">            The parameter vector at which the score residuals are</span>
<span class="sd">            calculated.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        The score residuals, returned as a ndarray having the same</span>
<span class="sd">        shape as `exog`.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Observations in a stratum with no observed events have undefined</span>
<span class="sd">        score residuals, and contain NaN in the returned matrix.</span>
<span class="sd">        """</span>

        <span class="n">surv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">surv</span>

        <span class="n">score_resid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exog</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

        <span class="c1"># Use to set undefined values to NaN.</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exog</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>

        <span class="n">w_avg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weighted_covariate_averages</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>

        <span class="c1"># Loop over strata</span>
        <span class="k">for</span> <span class="n">stx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">surv</span><span class="o">.</span><span class="n">nstrat</span><span class="p">):</span>

            <span class="n">uft_ix</span> <span class="o">=</span> <span class="n">surv</span><span class="o">.</span><span class="n">ufailt_ix</span><span class="p">[</span><span class="n">stx</span><span class="p">]</span>
            <span class="n">exog_s</span> <span class="o">=</span> <span class="n">surv</span><span class="o">.</span><span class="n">exog_s</span><span class="p">[</span><span class="n">stx</span><span class="p">]</span>
            <span class="n">nuft</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">uft_ix</span><span class="p">)</span>
            <span class="n">strat_ix</span> <span class="o">=</span> <span class="n">surv</span><span class="o">.</span><span class="n">stratum_rows</span><span class="p">[</span><span class="n">stx</span><span class="p">]</span>

            <span class="n">xp0</span> <span class="o">=</span> <span class="mf">0.</span>

            <span class="n">linpred</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">exog_s</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">surv</span><span class="o">.</span><span class="n">offset_s</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">linpred</span> <span class="o">+=</span> <span class="n">surv</span><span class="o">.</span><span class="n">offset_s</span><span class="p">[</span><span class="n">stx</span><span class="p">]</span>
            <span class="n">linpred</span> <span class="o">-=</span> <span class="n">linpred</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
            <span class="n">e_linpred</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">linpred</span><span class="p">)</span>

            <span class="n">at_risk_ix</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([])</span>

            <span class="c1"># Iterate backward through the unique failure times.</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nuft</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>

                <span class="c1"># Update for new cases entering the risk set.</span>
                <span class="n">ix</span> <span class="o">=</span> <span class="n">surv</span><span class="o">.</span><span class="n">risk_enter</span><span class="p">[</span><span class="n">stx</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
                <span class="n">at_risk_ix</span> <span class="o">|=</span> <span class="nb">set</span><span class="p">(</span><span class="n">ix</span><span class="p">)</span>
                <span class="n">xp0</span> <span class="o">+=</span> <span class="n">e_linpred</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

                <span class="n">atr_ix</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">at_risk_ix</span><span class="p">)</span>
                <span class="n">leverage</span> <span class="o">=</span> <span class="n">exog_s</span><span class="p">[</span><span class="n">atr_ix</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">w_avg</span><span class="p">[</span><span class="n">stx</span><span class="p">][</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span>

                <span class="c1"># Event indicators</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">exog_s</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">d</span><span class="p">[</span><span class="n">uft_ix</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span>

                <span class="c1"># The increment in the cumulative hazard</span>
                <span class="n">dchaz</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">uft_ix</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">/</span> <span class="n">xp0</span>

                <span class="c1"># Piece of the martingale residual</span>
                <span class="n">mrp</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="n">atr_ix</span><span class="p">]</span> <span class="o">-</span> <span class="n">e_linpred</span><span class="p">[</span><span class="n">atr_ix</span><span class="p">]</span> <span class="o">*</span> <span class="n">dchaz</span>

                <span class="c1"># Update the score residuals</span>
                <span class="n">ii</span> <span class="o">=</span> <span class="n">strat_ix</span><span class="p">[</span><span class="n">atr_ix</span><span class="p">]</span>
                <span class="n">score_resid</span><span class="p">[</span><span class="n">ii</span><span class="p">,:]</span> <span class="o">+=</span> <span class="n">leverage</span> <span class="o">*</span> <span class="n">mrp</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span>
                <span class="n">mask</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

                <span class="c1"># Update for cases leaving the risk set.</span>
                <span class="n">ix</span> <span class="o">=</span> <span class="n">surv</span><span class="o">.</span><span class="n">risk_exit</span><span class="p">[</span><span class="n">stx</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
                <span class="n">at_risk_ix</span> <span class="o">-=</span> <span class="nb">set</span><span class="p">(</span><span class="n">ix</span><span class="p">)</span>
                <span class="n">xp0</span> <span class="o">-=</span> <span class="n">e_linpred</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

        <span class="n">jj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">(</span><span class="n">mask</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">jj</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">score_resid</span><span class="p">[</span><span class="n">jj</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

        <span class="k">return</span> <span class="n">score_resid</span>

    <span class="k">def</span> <span class="nf">weighted_covariate_averages</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Returns the hazard-weighted average of covariate values for</span>
<span class="sd">        subjects who are at-risk at a particular time.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : ndarray</span>
<span class="sd">            Parameter vector</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        averages : list of ndarrays</span>
<span class="sd">            averages[stx][i,:] is a row vector containing the weighted</span>
<span class="sd">            average values (for all the covariates) of at-risk</span>
<span class="sd">            subjects a the i^th largest observed failure time in</span>
<span class="sd">            stratum `stx`, using the hazard multipliers as weights.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Used to calculate leverages and score residuals.</span>
<span class="sd">        """</span>

        <span class="n">surv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">surv</span>

        <span class="n">averages</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">xp0</span><span class="p">,</span> <span class="n">xp1</span> <span class="o">=</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span>

        <span class="c1"># Loop over strata</span>
        <span class="k">for</span> <span class="n">stx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">surv</span><span class="o">.</span><span class="n">nstrat</span><span class="p">):</span>

            <span class="n">uft_ix</span> <span class="o">=</span> <span class="n">surv</span><span class="o">.</span><span class="n">ufailt_ix</span><span class="p">[</span><span class="n">stx</span><span class="p">]</span>
            <span class="n">exog_s</span> <span class="o">=</span> <span class="n">surv</span><span class="o">.</span><span class="n">exog_s</span><span class="p">[</span><span class="n">stx</span><span class="p">]</span>
            <span class="n">nuft</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">uft_ix</span><span class="p">)</span>

            <span class="n">average_s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">uft_ix</span><span class="p">),</span> <span class="n">exog_s</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
                                  <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

            <span class="n">linpred</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">exog_s</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">surv</span><span class="o">.</span><span class="n">offset_s</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">linpred</span> <span class="o">+=</span> <span class="n">surv</span><span class="o">.</span><span class="n">offset_s</span><span class="p">[</span><span class="n">stx</span><span class="p">]</span>
            <span class="n">linpred</span> <span class="o">-=</span> <span class="n">linpred</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
            <span class="n">e_linpred</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">linpred</span><span class="p">)</span>

            <span class="c1"># Iterate backward through the unique failure times.</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nuft</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>

                <span class="c1"># Update for new cases entering the risk set.</span>
                <span class="n">ix</span> <span class="o">=</span> <span class="n">surv</span><span class="o">.</span><span class="n">risk_enter</span><span class="p">[</span><span class="n">stx</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
                <span class="n">xp0</span> <span class="o">+=</span> <span class="n">e_linpred</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
                <span class="n">xp1</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">e_linpred</span><span class="p">[</span><span class="n">ix</span><span class="p">],</span> <span class="n">exog_s</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="p">:])</span>

                <span class="n">average_s</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">xp1</span> <span class="o">/</span> <span class="n">xp0</span>

                <span class="c1"># Update for cases leaving the risk set.</span>
                <span class="n">ix</span> <span class="o">=</span> <span class="n">surv</span><span class="o">.</span><span class="n">risk_exit</span><span class="p">[</span><span class="n">stx</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
                <span class="n">xp0</span> <span class="o">-=</span> <span class="n">e_linpred</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
                <span class="n">xp1</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">e_linpred</span><span class="p">[</span><span class="n">ix</span><span class="p">],</span> <span class="n">exog_s</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="p">:])</span>

            <span class="n">averages</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">average_s</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">averages</span>

    <span class="k">def</span> <span class="nf">baseline_cumulative_hazard</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Estimate the baseline cumulative hazard and survival</span>
<span class="sd">        functions.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : ndarray</span>
<span class="sd">            The model parameters.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        A list of triples (time, hazard, survival) containing the time</span>
<span class="sd">        values and corresponding cumulative hazard and survival</span>
<span class="sd">        function values for each stratum.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Uses the Nelson-Aalen estimator.</span>
<span class="sd">        """</span>

        <span class="c1"># TODO: some disagreements with R, not the same algorithm but</span>
        <span class="c1"># hard to deduce what R is doing.  Our results are reasonable.</span>

        <span class="n">surv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">surv</span>
        <span class="n">rslt</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Loop over strata</span>
        <span class="k">for</span> <span class="n">stx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">surv</span><span class="o">.</span><span class="n">nstrat</span><span class="p">):</span>

            <span class="n">uft</span> <span class="o">=</span> <span class="n">surv</span><span class="o">.</span><span class="n">ufailt</span><span class="p">[</span><span class="n">stx</span><span class="p">]</span>
            <span class="n">uft_ix</span> <span class="o">=</span> <span class="n">surv</span><span class="o">.</span><span class="n">ufailt_ix</span><span class="p">[</span><span class="n">stx</span><span class="p">]</span>
            <span class="n">exog_s</span> <span class="o">=</span> <span class="n">surv</span><span class="o">.</span><span class="n">exog_s</span><span class="p">[</span><span class="n">stx</span><span class="p">]</span>
            <span class="n">nuft</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">uft_ix</span><span class="p">)</span>

            <span class="n">linpred</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">exog_s</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">surv</span><span class="o">.</span><span class="n">offset_s</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">linpred</span> <span class="o">+=</span> <span class="n">surv</span><span class="o">.</span><span class="n">offset_s</span><span class="p">[</span><span class="n">stx</span><span class="p">]</span>
            <span class="n">e_linpred</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">linpred</span><span class="p">)</span>

            <span class="n">xp0</span> <span class="o">=</span> <span class="mf">0.</span>
            <span class="n">h0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nuft</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

            <span class="c1"># Iterate backward through the unique failure times.</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nuft</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>

                <span class="c1"># Update for new cases entering the risk set.</span>
                <span class="n">ix</span> <span class="o">=</span> <span class="n">surv</span><span class="o">.</span><span class="n">risk_enter</span><span class="p">[</span><span class="n">stx</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
                <span class="n">xp0</span> <span class="o">+=</span> <span class="n">e_linpred</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

                <span class="c1"># Account for all cases that fail at this point.</span>
                <span class="n">ix</span> <span class="o">=</span> <span class="n">uft_ix</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">h0</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ix</span><span class="p">)</span> <span class="o">/</span> <span class="n">xp0</span>

                <span class="c1"># Update for cases leaving the risk set.</span>
                <span class="n">ix</span> <span class="o">=</span> <span class="n">surv</span><span class="o">.</span><span class="n">risk_exit</span><span class="p">[</span><span class="n">stx</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
                <span class="n">xp0</span> <span class="o">-=</span> <span class="n">e_linpred</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

            <span class="n">cumhaz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">h0</span><span class="p">)</span> <span class="o">-</span> <span class="n">h0</span>
            <span class="n">current_strata_surv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">cumhaz</span><span class="p">)</span>
            <span class="n">rslt</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">uft</span><span class="p">,</span> <span class="n">cumhaz</span><span class="p">,</span> <span class="n">current_strata_surv</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">rslt</span>

    <span class="k">def</span> <span class="nf">baseline_cumulative_hazard_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Returns a function that calculates the baseline cumulative</span>
<span class="sd">        hazard function for each stratum.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : ndarray</span>
<span class="sd">            The model parameters.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        A dict mapping stratum names to the estimated baseline</span>
<span class="sd">        cumulative hazard function.</span>
<span class="sd">        """</span>

        <span class="kn">from</span> <span class="nn">scipy.interpolate</span> <span class="kn">import</span> <span class="n">interp1d</span>
        <span class="n">surv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">surv</span>
        <span class="n">base</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">baseline_cumulative_hazard</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>

        <span class="n">cumhaz_f</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">stx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">surv</span><span class="o">.</span><span class="n">nstrat</span><span class="p">):</span>
            <span class="n">time_h</span> <span class="o">=</span> <span class="n">base</span><span class="p">[</span><span class="n">stx</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">cumhaz</span> <span class="o">=</span> <span class="n">base</span><span class="p">[</span><span class="n">stx</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">time_h</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">time_h</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">]</span>
            <span class="n">cumhaz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">cumhaz</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">cumhaz</span><span class="p">,</span> <span class="n">cumhaz</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
            <span class="n">func</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span><span class="n">time_h</span><span class="p">,</span> <span class="n">cumhaz</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">'zero'</span><span class="p">)</span>
            <span class="n">cumhaz_f</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">surv</span><span class="o">.</span><span class="n">stratum_names</span><span class="p">[</span><span class="n">stx</span><span class="p">]]</span> <span class="o">=</span> <span class="n">func</span>

        <span class="k">return</span> <span class="n">cumhaz_f</span>

    <span class="nd">@Appender</span><span class="p">(</span><span class="n">_predict_docstring</span> <span class="o">%</span> <span class="p">{</span>
        <span class="s1">'params_doc'</span><span class="p">:</span> <span class="n">_predict_params_doc</span><span class="p">,</span>
        <span class="s1">'cov_params_doc'</span><span class="p">:</span> <span class="n">_predict_cov_params_docstring</span><span class="p">})</span>
    <span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">exog</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cov_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">endog</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">strata</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pred_type</span><span class="o">=</span><span class="s2">"lhr"</span><span class="p">):</span>

        <span class="n">pred_type</span> <span class="o">=</span> <span class="n">pred_type</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">pred_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">"lhr"</span><span class="p">,</span> <span class="s2">"hr"</span><span class="p">,</span> <span class="s2">"surv"</span><span class="p">,</span> <span class="s2">"cumhaz"</span><span class="p">]:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">"Type </span><span class="si">%s</span><span class="s2"> not allowed for prediction"</span> <span class="o">%</span> <span class="n">pred_type</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="k">class</span> <span class="nc">bunch</span><span class="p">:</span>
            <span class="n">predicted_values</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">standard_errors</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">ret_val</span> <span class="o">=</span> <span class="n">bunch</span><span class="p">()</span>

        <span class="c1"># Do not do anything with offset here because we want to allow</span>
        <span class="c1"># different offsets to be specified even if exog is the model</span>
        <span class="c1"># exog.</span>
        <span class="n">exog_provided</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">exog</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">exog</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exog</span>
            <span class="n">exog_provided</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="n">lhr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">exog</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">offset</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">lhr</span> <span class="o">+=</span> <span class="n">offset</span>
        <span class="c1"># Never use self.offset unless we are also using self.exog</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">offset</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">exog_provided</span><span class="p">:</span>
            <span class="n">lhr</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">offset</span>

        <span class="c1"># Handle lhr and hr prediction first, since they do not make</span>
        <span class="c1"># use of the hazard function.</span>

        <span class="k">if</span> <span class="n">pred_type</span> <span class="o">==</span> <span class="s2">"lhr"</span><span class="p">:</span>
            <span class="n">ret_val</span><span class="o">.</span><span class="n">predicted_values</span> <span class="o">=</span> <span class="n">lhr</span>
            <span class="k">if</span> <span class="n">cov_params</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">exog</span><span class="p">,</span> <span class="n">cov_params</span><span class="p">)</span>
                <span class="n">va</span> <span class="o">=</span> <span class="p">(</span><span class="n">mat</span> <span class="o">*</span> <span class="n">exog</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">ret_val</span><span class="o">.</span><span class="n">standard_errors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">va</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">ret_val</span>

        <span class="n">hr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">lhr</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">pred_type</span> <span class="o">==</span> <span class="s2">"hr"</span><span class="p">:</span>
            <span class="n">ret_val</span><span class="o">.</span><span class="n">predicted_values</span> <span class="o">=</span> <span class="n">hr</span>
            <span class="k">return</span> <span class="n">ret_val</span>

        <span class="c1"># Makes sure endog is defined</span>
        <span class="k">if</span> <span class="n">endog</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">exog_provided</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">"If `exog` is provided `endog` must be provided."</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="c1"># Use model endog if using model exog</span>
        <span class="k">elif</span> <span class="n">endog</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">exog_provided</span><span class="p">:</span>
            <span class="n">endog</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">endog</span>

        <span class="c1"># Make sure strata is defined</span>
        <span class="k">if</span> <span class="n">strata</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">exog_provided</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">surv</span><span class="o">.</span><span class="n">nstrat</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"`strata` must be provided"</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">strata</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">strata</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">surv</span><span class="o">.</span><span class="n">stratum_names</span><span class="p">[</span><span class="mi">0</span><span class="p">],]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">endog</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">strata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">strata</span>

        <span class="n">cumhaz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">endog</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">stv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">strata</span><span class="p">)</span>
        <span class="n">bhaz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">baseline_cumulative_hazard_function</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">stx</span> <span class="ow">in</span> <span class="n">stv</span><span class="p">:</span>
            <span class="n">ix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">(</span><span class="n">strata</span> <span class="o">==</span> <span class="n">stx</span><span class="p">)</span>
            <span class="n">func</span> <span class="o">=</span> <span class="n">bhaz</span><span class="p">[</span><span class="n">stx</span><span class="p">]</span>
            <span class="n">cumhaz</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">endog</span><span class="p">[</span><span class="n">ix</span><span class="p">])</span> <span class="o">*</span> <span class="n">hr</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">pred_type</span> <span class="o">==</span> <span class="s2">"cumhaz"</span><span class="p">:</span>
            <span class="n">ret_val</span><span class="o">.</span><span class="n">predicted_values</span> <span class="o">=</span> <span class="n">cumhaz</span>

        <span class="k">elif</span> <span class="n">pred_type</span> <span class="o">==</span> <span class="s2">"surv"</span><span class="p">:</span>
            <span class="n">ret_val</span><span class="o">.</span><span class="n">predicted_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">cumhaz</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">ret_val</span>

    <span class="k">def</span> <span class="nf">get_distribution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Returns a scipy distribution object corresponding to the</span>
<span class="sd">        distribution of uncensored endog (duration) values for each</span>
<span class="sd">        case.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array_like</span>
<span class="sd">            The proportional hazards model parameters.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        A list of objects of type scipy.stats.distributions.rv_discrete</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The distributions are obtained from a simple discrete estimate</span>
<span class="sd">        of the survivor function that puts all mass on the observed</span>
<span class="sd">        failure times within a stratum.</span>
<span class="sd">        """</span>

        <span class="c1"># TODO: this returns a Python list of rv_discrete objects, so</span>
        <span class="c1"># nothing can be vectorized.  It appears that rv_discrete does</span>
        <span class="c1"># not allow vectorization.</span>

        <span class="n">surv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">surv</span>
        <span class="n">bhaz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">baseline_cumulative_hazard</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>

        <span class="c1"># The arguments to rv_discrete_float, first obtained by</span>
        <span class="c1"># stratum</span>
        <span class="n">pk</span><span class="p">,</span> <span class="n">xk</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">stx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surv</span><span class="o">.</span><span class="n">nstrat</span><span class="p">):</span>

            <span class="n">exog_s</span> <span class="o">=</span> <span class="n">surv</span><span class="o">.</span><span class="n">exog_s</span><span class="p">[</span><span class="n">stx</span><span class="p">]</span>

            <span class="n">linpred</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">exog_s</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">surv</span><span class="o">.</span><span class="n">offset_s</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">linpred</span> <span class="o">+=</span> <span class="n">surv</span><span class="o">.</span><span class="n">offset_s</span><span class="p">[</span><span class="n">stx</span><span class="p">]</span>
            <span class="n">e_linpred</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">linpred</span><span class="p">)</span>

            <span class="c1"># The unique failure times for this stratum (the support</span>
            <span class="c1"># of the distribution).</span>
            <span class="n">pts</span> <span class="o">=</span> <span class="n">bhaz</span><span class="p">[</span><span class="n">stx</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

            <span class="c1"># The individual cumulative hazards for everyone in this</span>
            <span class="c1"># stratum.</span>
            <span class="n">ichaz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">e_linpred</span><span class="p">,</span> <span class="n">bhaz</span><span class="p">[</span><span class="n">stx</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>

            <span class="c1"># The individual survival functions.</span>
            <span class="n">usurv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">ichaz</span><span class="p">)</span>
            <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">usurv</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">))</span>
            <span class="n">usurv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">usurv</span><span class="p">,</span> <span class="n">z</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

            <span class="c1"># The individual survival probability masses.</span>
            <span class="n">probs</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">usurv</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

            <span class="n">pk</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">probs</span><span class="p">)</span>
            <span class="n">xk</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">probs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">pts</span><span class="p">))</span>

        <span class="c1"># Pad to make all strata have the same shape</span>
        <span class="n">mxc</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">xk</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surv</span><span class="o">.</span><span class="n">nstrat</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">xk</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">mxc</span><span class="p">:</span>
                <span class="n">xk1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">xk</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">mxc</span><span class="p">))</span>
                <span class="n">pk1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">pk</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">mxc</span><span class="p">))</span>
                <span class="n">xk1</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="n">xk</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">xk</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                <span class="n">pk1</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="n">pk</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">pk</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                <span class="n">xk</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">pk</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">xk1</span><span class="p">,</span> <span class="n">pk1</span>

        <span class="c1"># Put the support points and probabilities into single matrices</span>
        <span class="n">xka</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endog</span><span class="p">),</span> <span class="n">mxc</span><span class="p">))</span>
        <span class="n">pka</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endog</span><span class="p">),</span> <span class="n">mxc</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span> <span class="o">/</span> <span class="n">mxc</span>
        <span class="k">for</span> <span class="n">stx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surv</span><span class="o">.</span><span class="n">nstrat</span><span class="p">):</span>
            <span class="n">ix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">surv</span><span class="o">.</span><span class="n">stratum_rows</span><span class="p">[</span><span class="n">stx</span><span class="p">]</span>
            <span class="n">xka</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">xk</span><span class="p">[</span><span class="n">stx</span><span class="p">]</span>
            <span class="n">pka</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">pk</span><span class="p">[</span><span class="n">stx</span><span class="p">]</span>

        <span class="n">dist</span> <span class="o">=</span> <span class="n">rv_discrete_float</span><span class="p">(</span><span class="n">xka</span><span class="p">,</span> <span class="n">pka</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">dist</span>


<span class="k">class</span> <span class="nc">PHRegResults</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="n">LikelihoodModelResults</span><span class="p">):</span>
    <span class="sd">'''</span>
<span class="sd">    Class to contain results of fitting a Cox proportional hazards</span>
<span class="sd">    survival model.</span>

<span class="sd">    PHregResults inherits from statsmodels.LikelihoodModelResults</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    See statsmodels.LikelihoodModelResults</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    model : class instance</span>
<span class="sd">        PHreg model instance that called fit.</span>
<span class="sd">    normalized_cov_params : ndarray</span>
<span class="sd">        The sampling covariance matrix of the estimates</span>
<span class="sd">    params : ndarray</span>
<span class="sd">        The coefficients of the fitted model.  Each coefficient is the</span>
<span class="sd">        log hazard ratio corresponding to a 1 unit difference in a</span>
<span class="sd">        single covariate while holding the other covariates fixed.</span>
<span class="sd">    bse : ndarray</span>
<span class="sd">        The standard errors of the fitted parameters.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    statsmodels.LikelihoodModelResults</span>
<span class="sd">    '''</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">cov_params</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span> <span class="n">covariance_type</span><span class="o">=</span><span class="s2">"naive"</span><span class="p">):</span>

        <span class="c1"># There is no scale parameter, but we need it for</span>
        <span class="c1"># meta-procedures that work with results.</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">covariance_type</span> <span class="o">=</span> <span class="n">covariance_type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">df_resid</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">df_resid</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">df_model</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">df_model</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">PHRegResults</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span>
           <span class="n">normalized_cov_params</span><span class="o">=</span><span class="n">cov_params</span><span class="p">)</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">standard_errors</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Returns the standard errors of the parameter estimates.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cov_params</span><span class="p">()))</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">bse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Returns the standard errors of the parameter estimates.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">standard_errors</span>

    <span class="k">def</span> <span class="nf">get_distribution</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Returns a scipy distribution object corresponding to the</span>
<span class="sd">        distribution of uncensored endog (duration) values for each</span>
<span class="sd">        case.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        A list of objects of type scipy.stats.distributions.rv_discrete</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The distributions are obtained from a simple discrete estimate</span>
<span class="sd">        of the survivor function that puts all mass on the observed</span>
<span class="sd">        failure times within a stratum.</span>
<span class="sd">        """</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">get_distribution</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>

    <span class="nd">@Appender</span><span class="p">(</span><span class="n">_predict_docstring</span> <span class="o">%</span> <span class="p">{</span><span class="s1">'params_doc'</span><span class="p">:</span> <span class="s1">''</span><span class="p">,</span> <span class="s1">'cov_params_doc'</span><span class="p">:</span> <span class="s1">''</span><span class="p">})</span>
    <span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">endog</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">exog</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">strata</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">offset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">transform</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">pred_type</span><span class="o">=</span><span class="s2">"lhr"</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">PHRegResults</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">exog</span><span class="o">=</span><span class="n">exog</span><span class="p">,</span>
                                                 <span class="n">transform</span><span class="o">=</span><span class="n">transform</span><span class="p">,</span>
                                                 <span class="n">cov_params</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cov_params</span><span class="p">(),</span>
                                                 <span class="n">endog</span><span class="o">=</span><span class="n">endog</span><span class="p">,</span>
                                                 <span class="n">strata</span><span class="o">=</span><span class="n">strata</span><span class="p">,</span>
                                                 <span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">,</span>
                                                 <span class="n">pred_type</span><span class="o">=</span><span class="n">pred_type</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_group_stats</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">groups</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Descriptive statistics of the groups.</span>
<span class="sd">        """</span>
        <span class="n">gsizes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">groups</span><span class="p">,</span> <span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">gsizes</span> <span class="o">=</span> <span class="n">gsizes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">gsizes</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">gsizes</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="n">gsizes</span><span class="o">.</span><span class="n">mean</span><span class="p">(),</span> <span class="nb">len</span><span class="p">(</span><span class="n">gsizes</span><span class="p">)</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">weighted_covariate_averages</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        The average covariate values within the at-risk set at each</span>
<span class="sd">        event time point, weighted by hazard.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">weighted_covariate_averages</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">score_residuals</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        A matrix containing the score residuals.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">score_residuals</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">baseline_cumulative_hazard</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        A list (corresponding to the strata) containing the baseline</span>
<span class="sd">        cumulative hazard function evaluated at the event points.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">baseline_cumulative_hazard</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">baseline_cumulative_hazard_function</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        A list (corresponding to the strata) containing function</span>
<span class="sd">        objects that calculate the cumulative hazard function.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">baseline_cumulative_hazard_function</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">schoenfeld_residuals</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        A matrix containing the Schoenfeld residuals.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Schoenfeld residuals for censored observations are set to zero.</span>
<span class="sd">        """</span>

        <span class="n">surv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">surv</span>
        <span class="n">w_avg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weighted_covariate_averages</span>

        <span class="c1"># Initialize at NaN since rows that belong to strata with no</span>
        <span class="c1"># events have undefined residuals.</span>
        <span class="n">sch_resid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">exog</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

        <span class="c1"># Loop over strata</span>
        <span class="k">for</span> <span class="n">stx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">surv</span><span class="o">.</span><span class="n">nstrat</span><span class="p">):</span>

            <span class="n">uft</span> <span class="o">=</span> <span class="n">surv</span><span class="o">.</span><span class="n">ufailt</span><span class="p">[</span><span class="n">stx</span><span class="p">]</span>
            <span class="n">exog_s</span> <span class="o">=</span> <span class="n">surv</span><span class="o">.</span><span class="n">exog_s</span><span class="p">[</span><span class="n">stx</span><span class="p">]</span>
            <span class="n">time_s</span> <span class="o">=</span> <span class="n">surv</span><span class="o">.</span><span class="n">time_s</span><span class="p">[</span><span class="n">stx</span><span class="p">]</span>
            <span class="n">strat_ix</span> <span class="o">=</span> <span class="n">surv</span><span class="o">.</span><span class="n">stratum_rows</span><span class="p">[</span><span class="n">stx</span><span class="p">]</span>

            <span class="n">ii</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">uft</span><span class="p">,</span> <span class="n">time_s</span><span class="p">)</span>

            <span class="c1"># These subjects are censored after the last event in</span>
            <span class="c1"># their stratum, so have empty risk sets and undefined</span>
            <span class="c1"># residuals.</span>
            <span class="n">jj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">(</span><span class="n">ii</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">uft</span><span class="p">))</span>

            <span class="n">sch_resid</span><span class="p">[</span><span class="n">strat_ix</span><span class="p">[</span><span class="n">jj</span><span class="p">],</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">exog_s</span><span class="p">[</span><span class="n">jj</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">w_avg</span><span class="p">[</span><span class="n">stx</span><span class="p">][</span><span class="n">ii</span><span class="p">[</span><span class="n">jj</span><span class="p">],</span> <span class="p">:]</span>

        <span class="n">jj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">status</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">sch_resid</span><span class="p">[</span><span class="n">jj</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

        <span class="k">return</span> <span class="n">sch_resid</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">martingale_residuals</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        The martingale residuals.</span>
<span class="sd">        """</span>

        <span class="n">surv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">surv</span>

        <span class="c1"># Initialize at NaN since rows that belong to strata with no</span>
        <span class="c1"># events have undefined residuals.</span>
        <span class="n">mart_resid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">endog</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

        <span class="n">cumhaz_f_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">baseline_cumulative_hazard_function</span>

        <span class="c1"># Loop over strata</span>
        <span class="k">for</span> <span class="n">stx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">surv</span><span class="o">.</span><span class="n">nstrat</span><span class="p">):</span>

            <span class="n">cumhaz_f</span> <span class="o">=</span> <span class="n">cumhaz_f_list</span><span class="p">[</span><span class="n">stx</span><span class="p">]</span>

            <span class="n">exog_s</span> <span class="o">=</span> <span class="n">surv</span><span class="o">.</span><span class="n">exog_s</span><span class="p">[</span><span class="n">stx</span><span class="p">]</span>
            <span class="n">time_s</span> <span class="o">=</span> <span class="n">surv</span><span class="o">.</span><span class="n">time_s</span><span class="p">[</span><span class="n">stx</span><span class="p">]</span>

            <span class="n">linpred</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">exog_s</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">surv</span><span class="o">.</span><span class="n">offset_s</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">linpred</span> <span class="o">+=</span> <span class="n">surv</span><span class="o">.</span><span class="n">offset_s</span><span class="p">[</span><span class="n">stx</span><span class="p">]</span>
            <span class="n">e_linpred</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">linpred</span><span class="p">)</span>

            <span class="n">ii</span> <span class="o">=</span> <span class="n">surv</span><span class="o">.</span><span class="n">stratum_rows</span><span class="p">[</span><span class="n">stx</span><span class="p">]</span>
            <span class="n">chaz</span> <span class="o">=</span> <span class="n">cumhaz_f</span><span class="p">(</span><span class="n">time_s</span><span class="p">)</span>
            <span class="n">mart_resid</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">status</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">-</span> <span class="n">e_linpred</span> <span class="o">*</span> <span class="n">chaz</span>

        <span class="k">return</span> <span class="n">mart_resid</span>

    <span class="k">def</span> <span class="nf">summary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">yname</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">xname</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=.</span><span class="mi">05</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Summarize the proportional hazards regression results.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        yname : str, optional</span>
<span class="sd">            Default is `y`</span>
<span class="sd">        xname : list[str], optional</span>
<span class="sd">            Names for the exogenous variables, default is `x#` for ## in p the</span>
<span class="sd">            number of regressors. Must match the number of parameters in</span>
<span class="sd">            the model</span>
<span class="sd">        title : str, optional</span>
<span class="sd">            Title for the top table. If not None, then this replaces</span>
<span class="sd">            the default title</span>
<span class="sd">        alpha : float</span>
<span class="sd">            significance level for the confidence intervals</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        smry : Summary instance</span>
<span class="sd">            this holds the summary tables and text, which can be</span>
<span class="sd">            printed or converted to various output formats.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        statsmodels.iolib.summary2.Summary : class to hold summary results</span>
<span class="sd">        """</span>

        <span class="kn">from</span> <span class="nn">statsmodels.iolib</span> <span class="kn">import</span> <span class="n">summary2</span>
        <span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">OrderedDict</span>
        <span class="n">smry</span> <span class="o">=</span> <span class="n">summary2</span><span class="o">.</span><span class="n">Summary</span><span class="p">()</span>
        <span class="n">float_format</span> <span class="o">=</span> <span class="s2">"</span><span class="si">%8.3f</span><span class="s2">"</span>

        <span class="n">info</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="n">info</span><span class="p">[</span><span class="s2">"Model:"</span><span class="p">]</span> <span class="o">=</span> <span class="s2">"PH Reg"</span>
        <span class="k">if</span> <span class="n">yname</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">yname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">endog_names</span>
        <span class="n">info</span><span class="p">[</span><span class="s2">"Dependent variable:"</span><span class="p">]</span> <span class="o">=</span> <span class="n">yname</span>
        <span class="n">info</span><span class="p">[</span><span class="s2">"Ties:"</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">ties</span><span class="o">.</span><span class="n">capitalize</span><span class="p">()</span>
        <span class="n">info</span><span class="p">[</span><span class="s2">"Sample size:"</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">surv</span><span class="o">.</span><span class="n">n_obs</span><span class="p">)</span>
        <span class="n">info</span><span class="p">[</span><span class="s2">"Num. events:"</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">status</span><span class="p">)))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">groups</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">mn</span><span class="p">,</span> <span class="n">mx</span><span class="p">,</span> <span class="n">avg</span><span class="p">,</span> <span class="n">num</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_group_stats</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">groups</span><span class="p">)</span>
            <span class="n">info</span><span class="p">[</span><span class="s2">"Num groups:"</span><span class="p">]</span> <span class="o">=</span> <span class="s2">"</span><span class="si">%.0f</span><span class="s2">"</span> <span class="o">%</span> <span class="n">num</span>
            <span class="n">info</span><span class="p">[</span><span class="s2">"Min group size:"</span><span class="p">]</span> <span class="o">=</span> <span class="s2">"</span><span class="si">%.0f</span><span class="s2">"</span> <span class="o">%</span> <span class="n">mn</span>
            <span class="n">info</span><span class="p">[</span><span class="s2">"Max group size:"</span><span class="p">]</span> <span class="o">=</span> <span class="s2">"</span><span class="si">%.0f</span><span class="s2">"</span> <span class="o">%</span> <span class="n">mx</span>
            <span class="n">info</span><span class="p">[</span><span class="s2">"Avg group size:"</span><span class="p">]</span> <span class="o">=</span> <span class="s2">"</span><span class="si">%.1f</span><span class="s2">"</span> <span class="o">%</span> <span class="n">avg</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">strata</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">mn</span><span class="p">,</span> <span class="n">mx</span><span class="p">,</span> <span class="n">avg</span><span class="p">,</span> <span class="n">num</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_group_stats</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">strata</span><span class="p">)</span>
            <span class="n">info</span><span class="p">[</span><span class="s2">"Num strata:"</span><span class="p">]</span> <span class="o">=</span> <span class="s2">"</span><span class="si">%.0f</span><span class="s2">"</span> <span class="o">%</span> <span class="n">num</span>
            <span class="n">info</span><span class="p">[</span><span class="s2">"Min stratum size:"</span><span class="p">]</span> <span class="o">=</span> <span class="s2">"</span><span class="si">%.0f</span><span class="s2">"</span> <span class="o">%</span> <span class="n">mn</span>
            <span class="n">info</span><span class="p">[</span><span class="s2">"Max stratum size:"</span><span class="p">]</span> <span class="o">=</span> <span class="s2">"</span><span class="si">%.0f</span><span class="s2">"</span> <span class="o">%</span> <span class="n">mx</span>
            <span class="n">info</span><span class="p">[</span><span class="s2">"Avg stratum size:"</span><span class="p">]</span> <span class="o">=</span> <span class="s2">"</span><span class="si">%.1f</span><span class="s2">"</span> <span class="o">%</span> <span class="n">avg</span>

        <span class="n">smry</span><span class="o">.</span><span class="n">add_dict</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">align</span><span class="o">=</span><span class="s1">'l'</span><span class="p">,</span> <span class="n">float_format</span><span class="o">=</span><span class="n">float_format</span><span class="p">)</span>

        <span class="n">param</span> <span class="o">=</span> <span class="n">summary2</span><span class="o">.</span><span class="n">summary_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">)</span>
        <span class="n">param</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s2">"Coef."</span><span class="p">:</span> <span class="s2">"log HR"</span><span class="p">,</span>
                                      <span class="s2">"Std.Err."</span><span class="p">:</span> <span class="s2">"log HR SE"</span><span class="p">})</span>
        <span class="n">param</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s2">"HR"</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">param</span><span class="p">[</span><span class="s2">"log HR"</span><span class="p">]))</span>
        <span class="n">a</span> <span class="o">=</span> <span class="s2">"[</span><span class="si">%.3f</span><span class="s2">"</span> <span class="o">%</span> <span class="p">(</span><span class="n">alpha</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">param</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">a</span><span class="p">])</span>
        <span class="n">a</span> <span class="o">=</span> <span class="s2">"</span><span class="si">%.3f</span><span class="s2">]"</span> <span class="o">%</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">alpha</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">param</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">a</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">xname</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">param</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">xname</span>
        <span class="n">smry</span><span class="o">.</span><span class="n">add_df</span><span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="n">float_format</span><span class="o">=</span><span class="n">float_format</span><span class="p">)</span>
        <span class="n">smry</span><span class="o">.</span><span class="n">add_title</span><span class="p">(</span><span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">,</span> <span class="n">results</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">smry</span><span class="o">.</span><span class="n">add_text</span><span class="p">(</span><span class="s2">"Confidence intervals are for the hazard ratios"</span><span class="p">)</span>

        <span class="n">dstrat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">surv</span><span class="o">.</span><span class="n">nstrat_orig</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">surv</span><span class="o">.</span><span class="n">nstrat</span>
        <span class="k">if</span> <span class="n">dstrat</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">dstrat</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">smry</span><span class="o">.</span><span class="n">add_text</span><span class="p">(</span><span class="s2">"1 stratum dropped for having no events"</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">smry</span><span class="o">.</span><span class="n">add_text</span><span class="p">(</span><span class="s2">"</span><span class="si">%d</span><span class="s2"> strata dropped for having no events"</span> <span class="o">%</span> <span class="n">dstrat</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">entry</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">n_entry</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">entry</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">n_entry</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">smry</span><span class="o">.</span><span class="n">add_text</span><span class="p">(</span><span class="s2">"1 observation has a positive entry time"</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">smry</span><span class="o">.</span><span class="n">add_text</span><span class="p">(</span><span class="s2">"</span><span class="si">%d</span><span class="s2"> observations have positive entry times"</span> <span class="o">%</span> <span class="n">n_entry</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">groups</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">smry</span><span class="o">.</span><span class="n">add_text</span><span class="p">(</span><span class="s2">"Standard errors account for dependence within groups"</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">"regularized"</span><span class="p">):</span>
            <span class="n">smry</span><span class="o">.</span><span class="n">add_text</span><span class="p">(</span><span class="s2">"Standard errors do not account for the regularization"</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">smry</span>


<span class="k">class</span> <span class="nc">rv_discrete_float</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    A class representing a collection of discrete distributions.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    xk : 2d array_like</span>
<span class="sd">        The support points, should be non-decreasing within each</span>
<span class="sd">        row.</span>
<span class="sd">    pk : 2d array_like</span>
<span class="sd">        The probabilities, should sum to one within each row.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Each row of `xk`, and the corresponding row of `pk` describe a</span>
<span class="sd">    discrete distribution.</span>

<span class="sd">    `xk` and `pk` should both be two-dimensional ndarrays.  Each row</span>
<span class="sd">    of `pk` should sum to 1.</span>

<span class="sd">    This class is used as a substitute for scipy.distributions.</span>
<span class="sd">    rv_discrete, since that class does not allow non-integer support</span>
<span class="sd">    points, or vectorized operations.</span>

<span class="sd">    Only a limited number of methods are implemented here compared to</span>
<span class="sd">    the other scipy distribution classes.</span>
<span class="sd">    """</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xk</span><span class="p">,</span> <span class="n">pk</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">xk</span> <span class="o">=</span> <span class="n">xk</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pk</span> <span class="o">=</span> <span class="n">pk</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cpk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pk</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">rvs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Returns a random sample from the discrete distribution.</span>

<span class="sd">        A vector is returned containing a single draw from each row of</span>
<span class="sd">        `xk`, using the probabilities of the corresponding row of `pk`</span>
<span class="sd">        """</span>

        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xk</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">n</span><span class="p">)</span>

        <span class="n">ix</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cpk</span> <span class="o">&lt;</span> <span class="n">u</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">])</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">ii</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">xk</span><span class="p">[(</span><span class="n">ii</span><span class="p">,</span><span class="n">ix</span><span class="p">)]</span>

    <span class="k">def</span> <span class="nf">mean</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Returns a vector containing the mean values of the discrete</span>
<span class="sd">        distributions.</span>

<span class="sd">        A vector is returned containing the mean value of each row of</span>
<span class="sd">        `xk`, using the probabilities in the corresponding row of</span>
<span class="sd">        `pk`.</span>
<span class="sd">        """</span>

        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xk</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">pk</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">var</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Returns a vector containing the variances of the discrete</span>
<span class="sd">        distributions.</span>

<span class="sd">        A vector is returned containing the variance for each row of</span>
<span class="sd">        `xk`, using the probabilities in the corresponding row of</span>
<span class="sd">        `pk`.</span>
<span class="sd">        """</span>

        <span class="n">mn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        <span class="n">xkc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xk</span> <span class="o">-</span> <span class="n">mn</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span>

        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pk</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xk</span> <span class="o">-</span> <span class="n">xkc</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">std</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Returns a vector containing the standard deviations of the</span>
<span class="sd">        discrete distributions.</span>

<span class="sd">        A vector is returned containing the standard deviation for</span>
<span class="sd">        each row of `xk`, using the probabilities in the corresponding</span>
<span class="sd">        row of `pk`.</span>
<span class="sd">        """</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">var</span><span class="p">())</span>
</pre></div>

          </article>
        </div>
      </div>
    </main>
  </div>
  <footer class="md-footer">
    <div class="md-footer-nav">
      <nav class="md-footer-nav__inner md-grid">
          
          
        </a>
        
      </nav>
    </div>
    <div class="md-footer-meta md-typeset">
      <div class="md-footer-meta__inner md-grid">
        <div class="md-footer-copyright">
          <div class="md-footer-copyright__highlight">
              &#169; Copyright 2009-2019, Josef Perktold, Skipper Seabold, Jonathan Taylor, statsmodels-developers.
              
          </div>
            Last updated on
              Feb 21, 2020.
            <br/>
            Created using
            <a href="http://www.sphinx-doc.org/">Sphinx</a> 2.4.2.
             and
            <a href="https://github.com/bashtage/sphinx-material/">Material for
              Sphinx</a>
        </div>
      </div>
    </div>
  </footer>
  <script src="../../../_static/javascripts/application.js"></script>
  <script>app.initialize({version: "1.0.4", url: {base: ".."}})</script>
  </body>
</html>