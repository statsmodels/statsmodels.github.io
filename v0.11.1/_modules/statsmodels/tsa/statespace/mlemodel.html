

<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <meta name="lang:clipboard.copy" content="Copy to clipboard">
  <meta name="lang:clipboard.copied" content="Copied to clipboard">
  <meta name="lang:search.language" content="en">
  <meta name="lang:search.pipeline.stopwords" content="True">
  <meta name="lang:search.pipeline.trimmer" content="True">
  <meta name="lang:search.result.none" content="No matching documents">
  <meta name="lang:search.result.one" content="1 matching document">
  <meta name="lang:search.result.other" content="# matching documents">
  <meta name="lang:search.tokenizer" content="[\s\-]+">

  
    <link href="https://fonts.gstatic.com/" rel="preconnect" crossorigin>
    <link href="https://fonts.googleapis.com/css?family=Roboto+Mono:400,500,700|Roboto:300,400,400i,700&display=fallback" rel="stylesheet">

    <style>
      body,
      input {
        font-family: "Roboto", "Helvetica Neue", Helvetica, Arial, sans-serif
      }

      code,
      kbd,
      pre {
        font-family: "Roboto Mono", "Courier New", Courier, monospace
      }
    </style>
  

  <link rel="stylesheet" href="../../../../_static/stylesheets/application.css"/>
  <link rel="stylesheet" href="../../../../_static/stylesheets/application-palette.css"/>
  <link rel="stylesheet" href="../../../../_static/stylesheets/application-fixes.css"/>
  
  <link rel="stylesheet" href="../../../../_static/fonts/material-icons.css"/>
  
  <meta name="theme-color" content="#3f51b5">
  <script src="../../../../_static/javascripts/modernizr.js"></script>
  
  
  
    <title>statsmodels.tsa.statespace.mlemodel &#8212; statsmodels</title>
  <link rel="icon" type="image/png" sizes="32x32" href="../../../../_static/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="../../../../_static/icons/favicon-16x16.png">
  <link rel="manifest" href="../../../../_static/icons/site.webmanifest">
  <link rel="mask-icon" href="../../../../_static/icons/safari-pinned-tab.svg" color="#919191">
  <meta name="msapplication-TileColor" content="#2b5797">
  <meta name="msapplication-config" content="../../../../_static/icons/browserconfig.xml">
  <link rel="stylesheet" href="../../../../_static/stylesheets/examples.css">
    <link rel="stylesheet" href="../../../../_static/material.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/graphviz.css" />
    <script id="documentation_options" data-url_root="../../../../" src="../../../../_static/documentation_options.js"></script>
    <script src="../../../../_static/jquery.js"></script>
    <script src="../../../../_static/underscore.js"></script>
    <script src="../../../../_static/doctools.js"></script>
    <script src="../../../../_static/language_data.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
    <link rel="shortcut icon" href="../../../../_static/favicon.ico"/>
    <link rel="author" title="About these documents" href="../../../../about.html" />
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
  
   
  
  <script src="../../../../_static/javascripts/version_dropdown.js"></script>
  <script>
    var json_loc = "../../../../_static/versions.json",
        target_loc = "../../../../../",
        text = "Versions";
    $( document ).ready( add_version_dropdown(json_loc, target_loc, text));
  </script>


  </head>
  <body dir=ltr
        data-md-color-primary=indigo data-md-color-accent=blue>
  
  <svg class="md-svg">
    <defs data-children-count="0">
      
      <svg xmlns="http://www.w3.org/2000/svg" width="416" height="448" viewBox="0 0 416 448" id="__github"><path fill="currentColor" d="M160 304q0 10-3.125 20.5t-10.75 19T128 352t-18.125-8.5-10.75-19T96 304t3.125-20.5 10.75-19T128 256t18.125 8.5 10.75 19T160 304zm160 0q0 10-3.125 20.5t-10.75 19T288 352t-18.125-8.5-10.75-19T256 304t3.125-20.5 10.75-19T288 256t18.125 8.5 10.75 19T320 304zm40 0q0-30-17.25-51T296 232q-10.25 0-48.75 5.25Q229.5 240 208 240t-39.25-2.75Q130.75 232 120 232q-29.5 0-46.75 21T56 304q0 22 8 38.375t20.25 25.75 30.5 15 35 7.375 37.25 1.75h42q20.5 0 37.25-1.75t35-7.375 30.5-15 20.25-25.75T360 304zm56-44q0 51.75-15.25 82.75-9.5 19.25-26.375 33.25t-35.25 21.5-42.5 11.875-42.875 5.5T212 416q-19.5 0-35.5-.75t-36.875-3.125-38.125-7.5-34.25-12.875T37 371.5t-21.5-28.75Q0 312 0 260q0-59.25 34-99-6.75-20.5-6.75-42.5 0-29 12.75-54.5 27 0 47.5 9.875t47.25 30.875Q171.5 96 212 96q37 0 70 8 26.25-20.5 46.75-30.25T376 64q12.75 25.5 12.75 54.5 0 21.75-6.75 42 34 40 34 99.5z"/></svg>
      
    </defs>
  </svg>
  
  <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer">
  <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search">
  <label class="md-overlay" data-md-component="overlay" for="__drawer"></label>
  <a href="#_modules/statsmodels/tsa/statespace/mlemodel" tabindex="1" class="md-skip"> Skip to content </a>
  <header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid">
    <div class="md-flex navheader">
      <div class="md-flex__cell md-flex__cell--shrink">
        <a href="../../../../index.html" title="statsmodels"
           class="md-header-nav__button md-logo">
          
              <img src="../../../../_static/statsmodels-logo-v2-bw.svg" height="26"
                   alt="statsmodels logo">
          
        </a>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        <label class="md-icon md-icon--menu md-header-nav__button" for="__drawer"></label>
      </div>
      <div class="md-flex__cell md-flex__cell--stretch">
        <div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
          <span class="md-header-nav__topic">statsmodels v0.11.1</span>
          <span class="md-header-nav__topic"> statsmodels.tsa.statespace.mlemodel </span>
        </div>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        <label class="md-icon md-icon--search md-header-nav__button" for="__search"></label>
        
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" action="../../../../search.html" method="GET" name="search">
      <input type="text" class="md-search__input" name="q" placeholder="Search"
             autocapitalize="off" autocomplete="off" spellcheck="false"
             data-md-component="query" data-md-state="active">
      <label class="md-icon md-search__icon" for="__search"></label>
      <button type="reset" class="md-icon md-search__icon" data-md-component="reset" tabindex="-1">
        &#xE5CD;
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="result">
          <div class="md-search-result__meta">
            Type to start searching
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>

      </div>
      
        <div class="md-flex__cell md-flex__cell--shrink">
          <div class="md-header-nav__source">
            <a href="https://github.com/statsmodels/statsmodels" title="Go to repository" class="md-source" data-md-source="github">

    <div class="md-source__icon">
      <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24" width="28" height="28">
        <use xlink:href="#__github" width="24" height="24"></use>
      </svg>
    </div>
  
  <div class="md-source__repository">
    statsmodels
  </div>
</a>
          </div>
        </div>
      
    </div>
  </nav>
</header>

  
  <div class="md-container">
    
    
    
  <nav class="md-tabs" data-md-component="tabs">
    <div class="md-tabs__inner md-grid">
      <ul class="md-tabs__list">
          <li class="md-tabs__item"><a href="../../../index.html" class="md-tabs__link">Module code</a></li>
      </ul>
    </div>
  </nav>
    <main class="md-main">
      <div class="md-main__inner md-grid" data-md-component="container">
        
          <div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
            <div class="md-sidebar__scrollwrap">
              <div class="md-sidebar__inner">
                <nav class="md-nav md-nav--primary" data-md-level="0">
  <label class="md-nav__title md-nav__title--site" for="__drawer">
    <a href="../../../../index.html" title="statsmodels" class="md-nav__button md-logo">
      
        <img src="../../../../_static/statsmodels-logo-v2-bw.svg" alt=" logo" width="48" height="48">
      
    </a>
    <a href="../../../../index.html"
       title="statsmodels">statsmodels v0.11.1</a>
  </label>
    <div class="md-nav__source">
      <a href="https://github.com/statsmodels/statsmodels" title="Go to repository" class="md-source" data-md-source="github">

    <div class="md-source__icon">
      <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24" width="28" height="28">
        <use xlink:href="#__github" width="24" height="24"></use>
      </svg>
    </div>
  
  <div class="md-source__repository">
    statsmodels
  </div>
</a>
    </div>
  
  

  
  
  <ul class="md-nav__list">
    <li class="md-nav__item">
    
      <a href="../../../../install.html" class="md-nav__link">Installing statsmodels</a>
      
    </li>
    <li class="md-nav__item">
    
      <a href="../../../../gettingstarted.html" class="md-nav__link">Getting started</a>
      
    </li>
    <li class="md-nav__item">
    
      <a href="../../../../user-guide.html" class="md-nav__link">User Guide</a>
      
    </li>
    <li class="md-nav__item">
    
      <a href="../../../../examples/index.html" class="md-nav__link">Examples</a>
      
    </li>
    <li class="md-nav__item">
    
      <a href="../../../../api.html" class="md-nav__link">API Reference</a>
      
    </li>
    <li class="md-nav__item">
    
      <a href="../../../../about.html" class="md-nav__link">About statsmodels</a>
      
    </li>
    <li class="md-nav__item">
    
      <a href="../../../../dev/index.html" class="md-nav__link">Developer Page</a>
      
    </li>
    <li class="md-nav__item">
    
      <a href="../../../../release/index.html" class="md-nav__link">Release Notes</a>
      
    </li>
  </ul>
  

</nav>
              </div>
            </div>
          </div>
          <div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
            <div class="md-sidebar__scrollwrap">
              <div class="md-sidebar__inner">
                
<nav class="md-nav md-nav--secondary">
  <ul class="md-nav__list" data-md-scrollfix="">
    

<li id="searchbox" class="md-nav__item"></li>

  </ul>
</nav>
              </div>
            </div>
          </div>
        
        <div class="md-content">
          <article class="md-content__inner md-typeset" role="main">
            
  <h1 id="modules-statsmodels-tsa-statespace-mlemodel--page-root">Source code for statsmodels.tsa.statespace.mlemodel</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">"""</span>
<span class="sd">State Space Model</span>

<span class="sd">Author: Chad Fulton</span>
<span class="sd">License: Simplified-BSD</span>
<span class="sd">"""</span>
<span class="kn">import</span> <span class="nn">contextlib</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">OrderedDict</span>
<span class="kn">from</span> <span class="nn">types</span> <span class="kn">import</span> <span class="n">SimpleNamespace</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">norm</span>

<span class="kn">from</span> <span class="nn">statsmodels.tools.tools</span> <span class="kn">import</span> <span class="n">pinv_extended</span><span class="p">,</span> <span class="n">Bunch</span>
<span class="kn">from</span> <span class="nn">statsmodels.tools.sm_exceptions</span> <span class="kn">import</span> <span class="n">PrecisionWarning</span><span class="p">,</span> <span class="n">ValueWarning</span>
<span class="kn">from</span> <span class="nn">statsmodels.tools.numdiff</span> <span class="kn">import</span> <span class="p">(</span><span class="n">_get_epsilon</span><span class="p">,</span> <span class="n">approx_hess_cs</span><span class="p">,</span>
                                       <span class="n">approx_fprime_cs</span><span class="p">,</span> <span class="n">approx_fprime</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">statsmodels.tools.decorators</span> <span class="kn">import</span> <span class="n">cache_readonly</span>
<span class="kn">from</span> <span class="nn">statsmodels.tools.eval_measures</span> <span class="kn">import</span> <span class="n">aic</span><span class="p">,</span> <span class="n">aicc</span><span class="p">,</span> <span class="n">bic</span><span class="p">,</span> <span class="n">hqic</span>

<span class="kn">import</span> <span class="nn">statsmodels.base.wrapper</span> <span class="k">as</span> <span class="nn">wrap</span>

<span class="kn">import</span> <span class="nn">statsmodels.genmod._prediction</span> <span class="k">as</span> <span class="nn">pred</span>
<span class="kn">from</span> <span class="nn">statsmodels.genmod.families.links</span> <span class="kn">import</span> <span class="n">identity</span>

<span class="kn">from</span> <span class="nn">statsmodels.base.data</span> <span class="kn">import</span> <span class="n">PandasData</span>
<span class="kn">import</span> <span class="nn">statsmodels.tsa.base.tsa_model</span> <span class="k">as</span> <span class="nn">tsbase</span>

<span class="kn">from</span> <span class="nn">.simulation_smoother</span> <span class="kn">import</span> <span class="n">SimulationSmoother</span>
<span class="kn">from</span> <span class="nn">.kalman_smoother</span> <span class="kn">import</span> <span class="n">SmootherResults</span>
<span class="kn">from</span> <span class="nn">.kalman_filter</span> <span class="kn">import</span> <span class="n">INVERT_UNIVARIATE</span><span class="p">,</span> <span class="n">SOLVE_LU</span><span class="p">,</span> <span class="n">MEMORY_CONSERVE</span>
<span class="kn">from</span> <span class="nn">.initialization</span> <span class="kn">import</span> <span class="n">Initialization</span>
<span class="kn">from</span> <span class="nn">.tools</span> <span class="kn">import</span> <span class="n">prepare_exog</span><span class="p">,</span> <span class="n">concat</span>


<span class="k">def</span> <span class="nf">_handle_args</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">defaults</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">output_args</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># We need to handle positional arguments in two ways, in case this was</span>
    <span class="c1"># called by a Scipy optimization routine</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># the fit() method will pass a dictionary</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">flags</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># otherwise, a user may have just used positional arguments...</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">flags</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">args</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">names</span><span class="p">)):</span>
            <span class="n">output_args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">flags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">names</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">defaults</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>

        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">flags</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">"loglike() got multiple values for keyword"</span>
                                <span class="s2">" argument '</span><span class="si">%s</span><span class="s2">'"</span> <span class="o">%</span> <span class="n">name</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">names</span><span class="p">)):</span>
            <span class="n">output_args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">names</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">defaults</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>

    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">output_args</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">kwargs</span><span class="p">,)</span>


<span class="k">def</span> <span class="nf">_check_index</span><span class="p">(</span><span class="n">desired_index</span><span class="p">,</span> <span class="n">dta</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s1">'data'</span><span class="p">):</span>
    <span class="n">given_index</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dta</span><span class="p">,</span> <span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">)):</span>
        <span class="n">given_index</span> <span class="o">=</span> <span class="n">dta</span><span class="o">.</span><span class="n">index</span>
    <span class="k">if</span> <span class="n">given_index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">desired_index</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">given_index</span><span class="p">):</span>
        <span class="n">desired_freq</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">desired_index</span><span class="p">,</span> <span class="s1">'freq'</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">given_freq</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">given_index</span><span class="p">,</span> <span class="s1">'freq'</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">desired_freq</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">given_freq</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span>
                <span class="n">desired_freq</span> <span class="o">!=</span> <span class="n">given_freq</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'Given </span><span class="si">%s</span><span class="s1"> does not have an index'</span>
                             <span class="s1">' that extends the index of the'</span>
                             <span class="s1">' model. Expected index frequency is'</span>
                             <span class="s1">' "</span><span class="si">%s</span><span class="s1">", but got "</span><span class="si">%s</span><span class="s1">".'</span>
                             <span class="o">%</span> <span class="p">(</span><span class="n">title</span><span class="p">,</span> <span class="n">desired_freq</span><span class="p">,</span> <span class="n">given_freq</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'Given </span><span class="si">%s</span><span class="s1"> does not have an index'</span>
                             <span class="s1">' that extends the index of the'</span>
                             <span class="s1">' model.'</span> <span class="o">%</span> <span class="n">title</span><span class="p">)</span>


<div class="viewcode-block" id="MLEModel"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEModel.html#statsmodels.tsa.statespace.structural.MLEModel">[docs]</a><span class="k">class</span> <span class="nc">MLEModel</span><span class="p">(</span><span class="n">tsbase</span><span class="o">.</span><span class="n">TimeSeriesModel</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">"""</span>
<span class="sd">    State space model for maximum likelihood estimation</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    endog : array_like</span>
<span class="sd">        The observed time-series process :math:`y`</span>
<span class="sd">    k_states : int</span>
<span class="sd">        The dimension of the unobserved state process.</span>
<span class="sd">    exog : array_like, optional</span>
<span class="sd">        Array of exogenous regressors, shaped nobs x k. Default is no</span>
<span class="sd">        exogenous regressors.</span>
<span class="sd">    dates : array_like of datetime, optional</span>
<span class="sd">        An array-like object of datetime objects. If a Pandas object is given</span>
<span class="sd">        for endog, it is assumed to have a DateIndex.</span>
<span class="sd">    freq : str, optional</span>
<span class="sd">        The frequency of the time-series. A Pandas offset or 'B', 'D', 'W',</span>
<span class="sd">        'M', 'A', or 'Q'. This is optional if dates are given.</span>
<span class="sd">    **kwargs</span>
<span class="sd">        Keyword arguments may be used to provide default values for state space</span>
<span class="sd">        matrices or for Kalman filtering options. See `Representation`, and</span>
<span class="sd">        `KalmanFilter` for more details.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    ssm : statsmodels.tsa.statespace.kalman_filter.KalmanFilter</span>
<span class="sd">        Underlying state space representation.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This class wraps the state space model with Kalman filtering to add in</span>
<span class="sd">    functionality for maximum likelihood estimation. In particular, it adds</span>
<span class="sd">    the concept of updating the state space representation based on a defined</span>
<span class="sd">    set of parameters, through the `update` method or `updater` attribute (see</span>
<span class="sd">    below for more details on which to use when), and it adds a `fit` method</span>
<span class="sd">    which uses a numerical optimizer to select the parameters that maximize</span>
<span class="sd">    the likelihood of the model.</span>

<span class="sd">    The `start_params` `update` method must be overridden in the</span>
<span class="sd">    child class (and the `transform` and `untransform` methods, if needed).</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    statsmodels.tsa.statespace.mlemodel.MLEResults</span>
<span class="sd">    statsmodels.tsa.statespace.kalman_filter.KalmanFilter</span>
<span class="sd">    statsmodels.tsa.statespace.representation.Representation</span>
<span class="sd">    """</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">endog</span><span class="p">,</span> <span class="n">k_states</span><span class="p">,</span> <span class="n">exog</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dates</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># Initialize the model base</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">MLEModel</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">endog</span><span class="o">=</span><span class="n">endog</span><span class="p">,</span> <span class="n">exog</span><span class="o">=</span><span class="n">exog</span><span class="p">,</span>
                                       <span class="n">dates</span><span class="o">=</span><span class="n">dates</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="n">freq</span><span class="p">,</span>
                                       <span class="n">missing</span><span class="o">=</span><span class="s1">'none'</span><span class="p">)</span>

        <span class="c1"># Store kwargs to recreate model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_init_kwargs</span> <span class="o">=</span> <span class="n">kwargs</span>

        <span class="c1"># Prepared the endog array: C-ordered, shape=(nobs x k_endog)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">endog</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">exog</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prepare_data</span><span class="p">()</span>

        <span class="c1"># Dimensions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">endog</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k_states</span> <span class="o">=</span> <span class="n">k_states</span>

        <span class="c1"># Initialize the state-space representation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initialize_statespace</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Setup holder for fixed parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_has_fixed_params</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fixed_params</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_params_index</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fixed_params_index</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_free_params_index</span> <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="MLEModel.prepare_data"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEModel.prepare_data.html#statsmodels.tsa.statespace.structural.MLEModel.prepare_data">[docs]</a>    <span class="k">def</span> <span class="nf">prepare_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Prepare data for use in the state space representation</span>
<span class="sd">        """</span>
        <span class="n">endog</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">orig_endog</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">'C'</span><span class="p">)</span>
        <span class="n">exog</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">orig_exog</span>
        <span class="k">if</span> <span class="n">exog</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">exog</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">exog</span><span class="p">)</span>

        <span class="c1"># Base class may allow 1-dim data, whereas we need 2-dim</span>
        <span class="k">if</span> <span class="n">endog</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">endog</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">endog</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># this will be C-contiguous</span>

        <span class="k">return</span> <span class="n">endog</span><span class="p">,</span> <span class="n">exog</span></div>

<div class="viewcode-block" id="MLEModel.initialize_statespace"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEModel.initialize_statespace.html#statsmodels.tsa.statespace.structural.MLEModel.initialize_statespace">[docs]</a>    <span class="k">def</span> <span class="nf">initialize_statespace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Initialize the state space representation</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Additional keyword arguments to pass to the state space class</span>
<span class="sd">            constructor.</span>
<span class="sd">        """</span>
        <span class="c1"># (Now self.endog is C-ordered and in long format (nobs x k_endog). To</span>
        <span class="c1"># get F-ordered and in wide format just need to transpose)</span>
        <span class="n">endog</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">endog</span><span class="o">.</span><span class="n">T</span>

        <span class="c1"># Instantiate the state space object</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span> <span class="o">=</span> <span class="n">SimulationSmoother</span><span class="p">(</span><span class="n">endog</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_states</span><span class="p">,</span>
                                      <span class="n">nobs</span><span class="o">=</span><span class="n">endog</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c1"># Bind the data to the model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">endog</span><span class="p">)</span>

        <span class="c1"># Other dimensions, now that `ssm` is available</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">k_endog</span></div>

    <span class="k">def</span> <span class="nf">_get_index_with_initial_state</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># The index we inherit from `TimeSeriesModel` will only cover the</span>
        <span class="c1"># data sample itself, but we will also need an index value for the</span>
        <span class="c1"># initial state which is the previous time step to the first datapoint.</span>
        <span class="c1"># This method figures out an appropriate value for the three types of</span>
        <span class="c1"># supported indexes: date-based, Int64Index, or RangeIndex</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index_dates</span><span class="p">:</span>
            <span class="c1"># value = self._index.shift(-1)[0]</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DatetimeIndex</span><span class="p">):</span>
                <span class="n">index</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">date_range</span><span class="p">(</span>
                    <span class="n">end</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">periods</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                    <span class="n">freq</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="o">.</span><span class="n">freq</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">PeriodIndex</span><span class="p">):</span>
                <span class="n">index</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">period_range</span><span class="p">(</span>
                    <span class="n">end</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">periods</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                    <span class="n">freq</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="o">.</span><span class="n">freq</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Int64Index</span><span class="p">):</span>
            <span class="c1"># The only valid Int64Index is a full, incrementing index, so this</span>
            <span class="c1"># is general</span>
            <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Int64Index</span><span class="p">([</span><span class="n">value</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">RangeIndex</span><span class="p">):</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">RangeIndex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="o">.</span><span class="n">start</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="o">.</span><span class="n">step</span><span class="p">,</span>
                                  <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="o">.</span><span class="n">end</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="o">.</span><span class="n">step</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span>
        <span class="k">return</span> <span class="n">index</span>

    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="fm">__setitem__</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_init_kwds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Get keywords based on model attributes</span>
        <span class="n">kwds</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">MLEModel</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_get_init_kwds</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">kwds</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
                <span class="n">kwds</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">kwds</span>

<div class="viewcode-block" id="MLEModel.clone"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEModel.clone.html#statsmodels.tsa.statespace.structural.MLEModel.clone">[docs]</a>    <span class="k">def</span> <span class="nf">clone</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">endog</span><span class="p">,</span> <span class="n">exog</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>

    <span class="k">def</span> <span class="nf">_clone_from_init_kwds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">endog</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># Cannot make this the default, because there is extra work required</span>
        <span class="c1"># for subclasses to make _get_init_kwds useful.</span>
        <span class="n">use_kwargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_init_kwds</span><span class="p">()</span>
        <span class="n">use_kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Check for `exog`</span>
        <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">'k_exog'</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">'exog'</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'Cloning a model with an exogenous component'</span>
                             <span class="s1">' requires specifying a new exogenous array using'</span>
                             <span class="s1">' the `exog` argument.'</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">endog</span><span class="p">,</span> <span class="o">**</span><span class="n">use_kwargs</span><span class="p">)</span>

<div class="viewcode-block" id="MLEModel.set_filter_method"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEModel.set_filter_method.html#statsmodels.tsa.statespace.structural.MLEModel.set_filter_method">[docs]</a>    <span class="k">def</span> <span class="nf">set_filter_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filter_method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Set the filtering method</span>

<span class="sd">        The filtering method controls aspects of which Kalman filtering</span>
<span class="sd">        approach will be used.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filter_method : int, optional</span>
<span class="sd">            Bitmask value to set the filter method to. See notes for details.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Keyword arguments may be used to influence the filter method by</span>
<span class="sd">            setting individual boolean flags. See notes for details.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method is rarely used. See the corresponding function in the</span>
<span class="sd">        `KalmanFilter` class for details.</span>
<span class="sd">        """</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">set_filter_method</span><span class="p">(</span><span class="n">filter_method</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="MLEModel.set_inversion_method"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEModel.set_inversion_method.html#statsmodels.tsa.statespace.structural.MLEModel.set_inversion_method">[docs]</a>    <span class="k">def</span> <span class="nf">set_inversion_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inversion_method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Set the inversion method</span>

<span class="sd">        The Kalman filter may contain one matrix inversion: that of the</span>
<span class="sd">        forecast error covariance matrix. The inversion method controls how and</span>
<span class="sd">        if that inverse is performed.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        inversion_method : int, optional</span>
<span class="sd">            Bitmask value to set the inversion method to. See notes for</span>
<span class="sd">            details.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Keyword arguments may be used to influence the inversion method by</span>
<span class="sd">            setting individual boolean flags. See notes for details.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method is rarely used. See the corresponding function in the</span>
<span class="sd">        `KalmanFilter` class for details.</span>
<span class="sd">        """</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">set_inversion_method</span><span class="p">(</span><span class="n">inversion_method</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="MLEModel.set_stability_method"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEModel.set_stability_method.html#statsmodels.tsa.statespace.structural.MLEModel.set_stability_method">[docs]</a>    <span class="k">def</span> <span class="nf">set_stability_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stability_method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Set the numerical stability method</span>

<span class="sd">        The Kalman filter is a recursive algorithm that may in some cases</span>
<span class="sd">        suffer issues with numerical stability. The stability method controls</span>
<span class="sd">        what, if any, measures are taken to promote stability.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        stability_method : int, optional</span>
<span class="sd">            Bitmask value to set the stability method to. See notes for</span>
<span class="sd">            details.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Keyword arguments may be used to influence the stability method by</span>
<span class="sd">            setting individual boolean flags. See notes for details.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method is rarely used. See the corresponding function in the</span>
<span class="sd">        `KalmanFilter` class for details.</span>
<span class="sd">        """</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">set_stability_method</span><span class="p">(</span><span class="n">stability_method</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="MLEModel.set_conserve_memory"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEModel.set_conserve_memory.html#statsmodels.tsa.statespace.structural.MLEModel.set_conserve_memory">[docs]</a>    <span class="k">def</span> <span class="nf">set_conserve_memory</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">conserve_memory</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Set the memory conservation method</span>

<span class="sd">        By default, the Kalman filter computes a number of intermediate</span>
<span class="sd">        matrices at each iteration. The memory conservation options control</span>
<span class="sd">        which of those matrices are stored.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        conserve_memory : int, optional</span>
<span class="sd">            Bitmask value to set the memory conservation method to. See notes</span>
<span class="sd">            for details.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Keyword arguments may be used to influence the memory conservation</span>
<span class="sd">            method by setting individual boolean flags.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method is rarely used. See the corresponding function in the</span>
<span class="sd">        `KalmanFilter` class for details.</span>
<span class="sd">        """</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">set_conserve_memory</span><span class="p">(</span><span class="n">conserve_memory</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="MLEModel.set_smoother_output"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEModel.set_smoother_output.html#statsmodels.tsa.statespace.structural.MLEModel.set_smoother_output">[docs]</a>    <span class="k">def</span> <span class="nf">set_smoother_output</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">smoother_output</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Set the smoother output</span>

<span class="sd">        The smoother can produce several types of results. The smoother output</span>
<span class="sd">        variable controls which are calculated and returned.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        smoother_output : int, optional</span>
<span class="sd">            Bitmask value to set the smoother output to. See notes for details.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Keyword arguments may be used to influence the smoother output by</span>
<span class="sd">            setting individual boolean flags.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method is rarely used. See the corresponding function in the</span>
<span class="sd">        `KalmanSmoother` class for details.</span>
<span class="sd">        """</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">set_smoother_output</span><span class="p">(</span><span class="n">smoother_output</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="MLEModel.initialize_known"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEModel.initialize_known.html#statsmodels.tsa.statespace.structural.MLEModel.initialize_known">[docs]</a>    <span class="k">def</span> <span class="nf">initialize_known</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">initial_state</span><span class="p">,</span> <span class="n">initial_state_cov</span><span class="p">):</span>
        <span class="sd">"""Initialize known"""</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">initialize_known</span><span class="p">(</span><span class="n">initial_state</span><span class="p">,</span> <span class="n">initial_state_cov</span><span class="p">)</span></div>

<div class="viewcode-block" id="MLEModel.initialize_approximate_diffuse"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEModel.initialize_approximate_diffuse.html#statsmodels.tsa.statespace.structural.MLEModel.initialize_approximate_diffuse">[docs]</a>    <span class="k">def</span> <span class="nf">initialize_approximate_diffuse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variance</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">"""Initialize approximate diffuse"""</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">initialize_approximate_diffuse</span><span class="p">(</span><span class="n">variance</span><span class="p">)</span></div>

<div class="viewcode-block" id="MLEModel.initialize_stationary"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEModel.initialize_stationary.html#statsmodels.tsa.statespace.structural.MLEModel.initialize_stationary">[docs]</a>    <span class="k">def</span> <span class="nf">initialize_stationary</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""Initialize stationary"""</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">initialize_stationary</span><span class="p">()</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">initialization</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">initialization</span>

    <span class="nd">@initialization</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">initialization</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">initialization</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">initial_variance</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">initial_variance</span>

    <span class="nd">@initial_variance</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">initial_variance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">initial_variance</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">loglikelihood_burn</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">loglikelihood_burn</span>

    <span class="nd">@loglikelihood_burn</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">loglikelihood_burn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">loglikelihood_burn</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">tolerance</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">tolerance</span>

    <span class="nd">@tolerance</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">tolerance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">tolerance</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">_validate_can_fix_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">param_names</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">param_name</span> <span class="ow">in</span> <span class="n">param_names</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">param_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'Invalid parameter name passed: "</span><span class="si">%s</span><span class="s1">".'</span>
                                 <span class="o">%</span> <span class="n">param_name</span><span class="p">)</span>

<div class="viewcode-block" id="MLEModel.fix_params"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEModel.fix_params.html#statsmodels.tsa.statespace.structural.MLEModel.fix_params">[docs]</a>    <span class="nd">@contextlib</span><span class="o">.</span><span class="n">contextmanager</span>
    <span class="k">def</span> <span class="nf">fix_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Fix parameters to specific values (context manager)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : dict</span>
<span class="sd">            Dictionary describing the fixed parameter values, of the form</span>
<span class="sd">            `param_name: fixed_value`. See the `param_names` property for valid</span>
<span class="sd">            parameter names.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; mod = sm.tsa.SARIMAX(endog, order=(1, 0, 1))</span>
<span class="sd">        &gt;&gt;&gt; with mod.fix_params({'ar.L1': 0.5}):</span>
<span class="sd">                res = mod.fit()</span>
<span class="sd">        """</span>
        <span class="n">k_params</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">)</span>
        <span class="c1"># Initialization (this is done here rather than in the constructor</span>
        <span class="c1"># because param_names may not be available at that point)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fixed_params</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_fixed_params</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_params_index</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">(</span>
                <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">k_params</span><span class="p">)))</span>

        <span class="c1"># Cache the current fixed parameters</span>
        <span class="n">cache_fixed_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fixed_params</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">cache_has_fixed_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_fixed_params</span>
        <span class="n">cache_fixed_params_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fixed_params_index</span>
        <span class="n">cache_free_params_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_free_params_index</span>

        <span class="c1"># Validate parameter names and values</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_validate_can_fix_params</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">params</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>

        <span class="c1"># Set the new fixed parameters, keeping the order as given by</span>
        <span class="c1"># param_names</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fixed_params</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fixed_params</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">([</span>
            <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fixed_params</span><span class="p">[</span><span class="n">name</span><span class="p">])</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_names</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fixed_params</span><span class="p">])</span>

        <span class="c1"># Update associated values</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_has_fixed_params</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fixed_params_index</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_params_index</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
                                    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fixed_params</span><span class="o">.</span><span class="n">keys</span><span class="p">()]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_free_params_index</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
            <span class="nb">set</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">k_params</span><span class="p">))</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_fixed_params_index</span><span class="p">))</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">yield</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="c1"># Reset the fixed parameters</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_has_fixed_params</span> <span class="o">=</span> <span class="n">cache_has_fixed_params</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_fixed_params</span> <span class="o">=</span> <span class="n">cache_fixed_params</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_fixed_params_index</span> <span class="o">=</span> <span class="n">cache_fixed_params_index</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_free_params_index</span> <span class="o">=</span> <span class="n">cache_free_params_index</span></div>

<div class="viewcode-block" id="MLEModel.fit"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEModel.fit.html#statsmodels.tsa.statespace.structural.MLEModel.fit">[docs]</a>    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">includes_fixed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">cov_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cov_kwds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">'lbfgs'</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span>
            <span class="n">full_output</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">disp</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">return_params</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">optim_score</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">optim_complex_step</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">optim_hessian</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">flags</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">low_memory</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Fits the model by maximum likelihood via Kalman filter.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        start_params : array_like, optional</span>
<span class="sd">            Initial guess of the solution for the loglikelihood maximization.</span>
<span class="sd">            If None, the default is given by Model.start_params.</span>
<span class="sd">        transformed : bool, optional</span>
<span class="sd">            Whether or not `start_params` is already transformed. Default is</span>
<span class="sd">            True.</span>
<span class="sd">        includes_fixed : bool, optional</span>
<span class="sd">            If parameters were previously fixed with the `fix_params` method,</span>
<span class="sd">            this argument describes whether or not `start_params` also includes</span>
<span class="sd">            the fixed parameters, in addition to the free parameters. Default</span>
<span class="sd">            is False.</span>
<span class="sd">        cov_type : str, optional</span>
<span class="sd">            The `cov_type` keyword governs the method for calculating the</span>
<span class="sd">            covariance matrix of parameter estimates. Can be one of:</span>

<span class="sd">            - 'opg' for the outer product of gradient estimator</span>
<span class="sd">            - 'oim' for the observed information matrix estimator, calculated</span>
<span class="sd">              using the method of Harvey (1989)</span>
<span class="sd">            - 'approx' for the observed information matrix estimator,</span>
<span class="sd">              calculated using a numerical approximation of the Hessian matrix.</span>
<span class="sd">            - 'robust' for an approximate (quasi-maximum likelihood) covariance</span>
<span class="sd">              matrix that may be valid even in the presence of some</span>
<span class="sd">              misspecifications. Intermediate calculations use the 'oim'</span>
<span class="sd">              method.</span>
<span class="sd">            - 'robust_approx' is the same as 'robust' except that the</span>
<span class="sd">              intermediate calculations use the 'approx' method.</span>
<span class="sd">            - 'none' for no covariance matrix calculation.</span>

<span class="sd">            Default is 'opg' unless memory conservation is used to avoid</span>
<span class="sd">            computing the loglikelihood values for each observation, in which</span>
<span class="sd">            case the default is 'approx'.</span>
<span class="sd">        cov_kwds : dict or None, optional</span>
<span class="sd">            A dictionary of arguments affecting covariance matrix computation.</span>

<span class="sd">            **opg, oim, approx, robust, robust_approx**</span>

<span class="sd">            - 'approx_complex_step' : bool, optional - If True, numerical</span>
<span class="sd">              approximations are computed using complex-step methods. If False,</span>
<span class="sd">              numerical approximations are computed using finite difference</span>
<span class="sd">              methods. Default is True.</span>
<span class="sd">            - 'approx_centered' : bool, optional - If True, numerical</span>
<span class="sd">              approximations computed using finite difference methods use a</span>
<span class="sd">              centered approximation. Default is False.</span>
<span class="sd">        method : str, optional</span>
<span class="sd">            The `method` determines which solver from `scipy.optimize`</span>
<span class="sd">            is used, and it can be chosen from among the following strings:</span>

<span class="sd">            - 'newton' for Newton-Raphson, 'nm' for Nelder-Mead</span>
<span class="sd">            - 'bfgs' for Broyden-Fletcher-Goldfarb-Shanno (BFGS)</span>
<span class="sd">            - 'lbfgs' for limited-memory BFGS with optional box constraints</span>
<span class="sd">            - 'powell' for modified Powell's method</span>
<span class="sd">            - 'cg' for conjugate gradient</span>
<span class="sd">            - 'ncg' for Newton-conjugate gradient</span>
<span class="sd">            - 'basinhopping' for global basin-hopping solver</span>

<span class="sd">            The explicit arguments in `fit` are passed to the solver,</span>
<span class="sd">            with the exception of the basin-hopping solver. Each</span>
<span class="sd">            solver has several optional arguments that are not the same across</span>
<span class="sd">            solvers. See the notes section below (or scipy.optimize) for the</span>
<span class="sd">            available arguments and for the list of explicit arguments that the</span>
<span class="sd">            basin-hopping solver supports.</span>
<span class="sd">        maxiter : int, optional</span>
<span class="sd">            The maximum number of iterations to perform.</span>
<span class="sd">        full_output : bool, optional</span>
<span class="sd">            Set to True to have all available output in the Results object's</span>
<span class="sd">            mle_retvals attribute. The output is dependent on the solver.</span>
<span class="sd">            See LikelihoodModelResults notes section for more information.</span>
<span class="sd">        disp : bool, optional</span>
<span class="sd">            Set to True to print convergence messages.</span>
<span class="sd">        callback : callable callback(xk), optional</span>
<span class="sd">            Called after each iteration, as callback(xk), where xk is the</span>
<span class="sd">            current parameter vector.</span>
<span class="sd">        return_params : bool, optional</span>
<span class="sd">            Whether or not to return only the array of maximizing parameters.</span>
<span class="sd">            Default is False.</span>
<span class="sd">        optim_score : {'harvey', 'approx'} or None, optional</span>
<span class="sd">            The method by which the score vector is calculated. 'harvey' uses</span>
<span class="sd">            the method from Harvey (1989), 'approx' uses either finite</span>
<span class="sd">            difference or complex step differentiation depending upon the</span>
<span class="sd">            value of `optim_complex_step`, and None uses the built-in gradient</span>
<span class="sd">            approximation of the optimizer. Default is None. This keyword is</span>
<span class="sd">            only relevant if the optimization method uses the score.</span>
<span class="sd">        optim_complex_step : bool, optional</span>
<span class="sd">            Whether or not to use complex step differentiation when</span>
<span class="sd">            approximating the score; if False, finite difference approximation</span>
<span class="sd">            is used. Default is True. This keyword is only relevant if</span>
<span class="sd">            `optim_score` is set to 'harvey' or 'approx'.</span>
<span class="sd">        optim_hessian : {'opg','oim','approx'}, optional</span>
<span class="sd">            The method by which the Hessian is numerically approximated. 'opg'</span>
<span class="sd">            uses outer product of gradients, 'oim' uses the information</span>
<span class="sd">            matrix formula from Harvey (1989), and 'approx' uses numerical</span>
<span class="sd">            approximation. This keyword is only relevant if the</span>
<span class="sd">            optimization method uses the Hessian matrix.</span>
<span class="sd">        low_memory : bool, optional</span>
<span class="sd">            If set to True, techniques are applied to substantially reduce</span>
<span class="sd">            memory usage. If used, some features of the results object will</span>
<span class="sd">            not be available (including smoothed results and in-sample</span>
<span class="sd">            prediction), although out-of-sample forecasting is possible.</span>
<span class="sd">            Default is False.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Additional keyword arguments to pass to the optimizer.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        MLEResults</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        statsmodels.base.model.LikelihoodModel.fit</span>
<span class="sd">        statsmodels.tsa.statespace.mlemodel.MLEResults</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="n">start_params</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">start_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">start_params</span>
            <span class="n">transformed</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">includes_fixed</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># Update the score method</span>
        <span class="k">if</span> <span class="n">optim_score</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">'lbfgs'</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">'approx_grad'</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
            <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">'epsilon'</span><span class="p">,</span> <span class="mf">1e-5</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">optim_score</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">optim_score</span> <span class="o">=</span> <span class="s1">'approx'</span>

        <span class="c1"># Check for complex step differentiation</span>
        <span class="k">if</span> <span class="n">optim_complex_step</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">optim_complex_step</span> <span class="o">=</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">_complex_endog</span>
        <span class="k">elif</span> <span class="n">optim_complex_step</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">_complex_endog</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'Cannot use complex step derivatives when data'</span>
                             <span class="s1">' or parameters are complex.'</span><span class="p">)</span>

        <span class="c1"># Standardize starting parameters</span>
        <span class="n">start_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">handle_params</span><span class="p">(</span><span class="n">start_params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                          <span class="n">includes_fixed</span><span class="o">=</span><span class="n">includes_fixed</span><span class="p">)</span>

        <span class="c1"># Unconstrain the starting parameters</span>
        <span class="k">if</span> <span class="n">transformed</span><span class="p">:</span>
            <span class="n">start_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">untransform_params</span><span class="p">(</span><span class="n">start_params</span><span class="p">)</span>

        <span class="c1"># Remove any fixed parameters</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_fixed_params</span><span class="p">:</span>
            <span class="n">start_params</span> <span class="o">=</span> <span class="n">start_params</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_free_params_index</span><span class="p">]</span>

        <span class="c1"># If all parameters are fixed, we are done</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_fixed_params</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">start_params</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">mlefit</span> <span class="o">=</span> <span class="n">Bunch</span><span class="p">(</span><span class="n">params</span><span class="o">=</span><span class="p">[],</span> <span class="n">mle_retvals</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                           <span class="n">mle_settings</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Maximum likelihood estimation</span>
            <span class="k">if</span> <span class="n">flags</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">flags</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">flags</span><span class="o">.</span><span class="n">update</span><span class="p">({</span>
                <span class="s1">'transformed'</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
                <span class="s1">'includes_fixed'</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
                <span class="s1">'score_method'</span><span class="p">:</span> <span class="n">optim_score</span><span class="p">,</span>
                <span class="s1">'approx_complex_step'</span><span class="p">:</span> <span class="n">optim_complex_step</span>
            <span class="p">})</span>
            <span class="k">if</span> <span class="n">optim_hessian</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">flags</span><span class="p">[</span><span class="s1">'hessian_method'</span><span class="p">]</span> <span class="o">=</span> <span class="n">optim_hessian</span>
            <span class="n">fargs</span> <span class="o">=</span> <span class="p">(</span><span class="n">flags</span><span class="p">,)</span>
            <span class="n">mlefit</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">MLEModel</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">start_params</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
                                               <span class="n">fargs</span><span class="o">=</span><span class="n">fargs</span><span class="p">,</span>
                                               <span class="n">maxiter</span><span class="o">=</span><span class="n">maxiter</span><span class="p">,</span>
                                               <span class="n">full_output</span><span class="o">=</span><span class="n">full_output</span><span class="p">,</span>
                                               <span class="n">disp</span><span class="o">=</span><span class="n">disp</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="n">callback</span><span class="p">,</span>
                                               <span class="n">skip_hessian</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Just return the fitted parameters if requested</span>
        <span class="k">if</span> <span class="n">return_params</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">handle_params</span><span class="p">(</span><span class="n">mlefit</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                      <span class="n">includes_fixed</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="c1"># Otherwise construct the results class if desired</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Handle memory conservation option</span>
            <span class="k">if</span> <span class="n">low_memory</span><span class="p">:</span>
                <span class="n">conserve_memory</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">conserve_memory</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">set_conserve_memory</span><span class="p">(</span><span class="n">MEMORY_CONSERVE</span><span class="p">)</span>

            <span class="c1"># Perform filtering / smoothing</span>
            <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">memory_no_predicted</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">memory_no_gain</span>
                    <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">memory_no_smoothing</span><span class="p">):</span>
                <span class="n">func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">smooth</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">mlefit</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">includes_fixed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                       <span class="n">cov_type</span><span class="o">=</span><span class="n">cov_type</span><span class="p">,</span> <span class="n">cov_kwds</span><span class="o">=</span><span class="n">cov_kwds</span><span class="p">)</span>

            <span class="n">res</span><span class="o">.</span><span class="n">mlefit</span> <span class="o">=</span> <span class="n">mlefit</span>
            <span class="n">res</span><span class="o">.</span><span class="n">mle_retvals</span> <span class="o">=</span> <span class="n">mlefit</span><span class="o">.</span><span class="n">mle_retvals</span>
            <span class="n">res</span><span class="o">.</span><span class="n">mle_settings</span> <span class="o">=</span> <span class="n">mlefit</span><span class="o">.</span><span class="n">mle_settings</span>

            <span class="c1"># Reset memory conservation</span>
            <span class="k">if</span> <span class="n">low_memory</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">set_conserve_memory</span><span class="p">(</span><span class="n">conserve_memory</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">res</span></div>

<div class="viewcode-block" id="MLEModel.fit_constrained"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEModel.fit_constrained.html#statsmodels.tsa.statespace.structural.MLEModel.fit_constrained">[docs]</a>    <span class="k">def</span> <span class="nf">fit_constrained</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">constraints</span><span class="p">,</span> <span class="n">start_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">fit_kwds</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Fit the model with some parameters subject to equality constraints.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        constraints : dict</span>
<span class="sd">            Dictionary of constraints, of the form `param_name: fixed_value`.</span>
<span class="sd">            See the `param_names` property for valid parameter names.</span>
<span class="sd">        start_params : array_like, optional</span>
<span class="sd">            Initial guess of the solution for the loglikelihood maximization.</span>
<span class="sd">            If None, the default is given by Model.start_params.</span>
<span class="sd">        **fit_kwds : keyword arguments</span>
<span class="sd">            fit_kwds are used in the optimization of the remaining parameters.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        results : Results instance</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; mod = sm.tsa.SARIMAX(endog, order=(1, 0, 1))</span>
<span class="sd">        &gt;&gt;&gt; res = mod.fit_constrained({'ar.L1': 0.5})</span>
<span class="sd">        """</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">fix_params</span><span class="p">(</span><span class="n">constraints</span><span class="p">):</span>
            <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">start_params</span><span class="p">,</span> <span class="o">**</span><span class="n">fit_kwds</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_res_classes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">'fit'</span><span class="p">:</span> <span class="p">(</span><span class="n">MLEResults</span><span class="p">,</span> <span class="n">MLEResultsWrapper</span><span class="p">)}</span>

    <span class="k">def</span> <span class="nf">_wrap_results</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">return_raw</span><span class="p">,</span> <span class="n">cov_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                      <span class="n">cov_kwds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">results_class</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">wrapper_class</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">return_raw</span><span class="p">:</span>
            <span class="c1"># Wrap in a results object</span>
            <span class="n">result_kwargs</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">if</span> <span class="n">cov_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">result_kwargs</span><span class="p">[</span><span class="s1">'cov_type'</span><span class="p">]</span> <span class="o">=</span> <span class="n">cov_type</span>
            <span class="k">if</span> <span class="n">cov_kwds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">result_kwargs</span><span class="p">[</span><span class="s1">'cov_kwds'</span><span class="p">]</span> <span class="o">=</span> <span class="n">cov_kwds</span>

            <span class="k">if</span> <span class="n">results_class</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">results_class</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_res_classes</span><span class="p">[</span><span class="s1">'fit'</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">wrapper_class</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">wrapper_class</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_res_classes</span><span class="p">[</span><span class="s1">'fit'</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>

            <span class="n">res</span> <span class="o">=</span> <span class="n">results_class</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="o">**</span><span class="n">result_kwargs</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">wrapper_class</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

<div class="viewcode-block" id="MLEModel.filter"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEModel.filter.html#statsmodels.tsa.statespace.structural.MLEModel.filter">[docs]</a>    <span class="k">def</span> <span class="nf">filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">includes_fixed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
               <span class="n">complex_step</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">cov_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cov_kwds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="n">return_ssm</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">results_class</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="n">results_wrapper_class</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">low_memory</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Kalman filtering</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array_like</span>
<span class="sd">            Array of parameters at which to evaluate the loglikelihood</span>
<span class="sd">            function.</span>
<span class="sd">        transformed : bool, optional</span>
<span class="sd">            Whether or not `params` is already transformed. Default is True.</span>
<span class="sd">        return_ssm : bool,optional</span>
<span class="sd">            Whether or not to return only the state space output or a full</span>
<span class="sd">            results object. Default is to return a full results object.</span>
<span class="sd">        cov_type : str, optional</span>
<span class="sd">            See `MLEResults.fit` for a description of covariance matrix types</span>
<span class="sd">            for results object.</span>
<span class="sd">        cov_kwds : dict or None, optional</span>
<span class="sd">            See `MLEResults.get_robustcov_results` for a description required</span>
<span class="sd">            keywords for alternative covariance estimators</span>
<span class="sd">        low_memory : bool, optional</span>
<span class="sd">            If set to True, techniques are applied to substantially reduce</span>
<span class="sd">            memory usage. If used, some features of the results object will</span>
<span class="sd">            not be available (including in-sample prediction), although</span>
<span class="sd">            out-of-sample forecasting is possible. Default is False.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Additional keyword arguments to pass to the Kalman filter. See</span>
<span class="sd">            `KalmanFilter.filter` for more details.</span>
<span class="sd">        """</span>
        <span class="n">params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">handle_params</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="n">transformed</span><span class="p">,</span>
                                    <span class="n">includes_fixed</span><span class="o">=</span><span class="n">includes_fixed</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">includes_fixed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="n">complex_step</span><span class="o">=</span><span class="n">complex_step</span><span class="p">)</span>

        <span class="c1"># Save the parameter names</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">param_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_names</span>

        <span class="k">if</span> <span class="n">complex_step</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">'inversion_method'</span><span class="p">]</span> <span class="o">=</span> <span class="n">INVERT_UNIVARIATE</span> <span class="o">|</span> <span class="n">SOLVE_LU</span>

        <span class="c1"># Handle memory conservation</span>
        <span class="k">if</span> <span class="n">low_memory</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">'conserve_memory'</span><span class="p">]</span> <span class="o">=</span> <span class="n">MEMORY_CONSERVE</span>

        <span class="c1"># Get the state space output</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">complex_step</span><span class="o">=</span><span class="n">complex_step</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Wrap in a results object</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_results</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">return_ssm</span><span class="p">,</span> <span class="n">cov_type</span><span class="p">,</span>
                                  <span class="n">cov_kwds</span><span class="p">,</span> <span class="n">results_class</span><span class="p">,</span>
                                  <span class="n">results_wrapper_class</span><span class="p">)</span></div>

<div class="viewcode-block" id="MLEModel.smooth"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEModel.smooth.html#statsmodels.tsa.statespace.structural.MLEModel.smooth">[docs]</a>    <span class="k">def</span> <span class="nf">smooth</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">includes_fixed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
               <span class="n">complex_step</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">cov_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cov_kwds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="n">return_ssm</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">results_class</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="n">results_wrapper_class</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Kalman smoothing</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array_like</span>
<span class="sd">            Array of parameters at which to evaluate the loglikelihood</span>
<span class="sd">            function.</span>
<span class="sd">        transformed : bool, optional</span>
<span class="sd">            Whether or not `params` is already transformed. Default is True.</span>
<span class="sd">        return_ssm : bool,optional</span>
<span class="sd">            Whether or not to return only the state space output or a full</span>
<span class="sd">            results object. Default is to return a full results object.</span>
<span class="sd">        cov_type : str, optional</span>
<span class="sd">            See `MLEResults.fit` for a description of covariance matrix types</span>
<span class="sd">            for results object.</span>
<span class="sd">        cov_kwds : dict or None, optional</span>
<span class="sd">            See `MLEResults.get_robustcov_results` for a description required</span>
<span class="sd">            keywords for alternative covariance estimators</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Additional keyword arguments to pass to the Kalman filter. See</span>
<span class="sd">            `KalmanFilter.filter` for more details.</span>
<span class="sd">        """</span>
        <span class="n">params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">handle_params</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="n">transformed</span><span class="p">,</span>
                                    <span class="n">includes_fixed</span><span class="o">=</span><span class="n">includes_fixed</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">includes_fixed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="n">complex_step</span><span class="o">=</span><span class="n">complex_step</span><span class="p">)</span>

        <span class="c1"># Save the parameter names</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">param_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_names</span>

        <span class="k">if</span> <span class="n">complex_step</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">'inversion_method'</span><span class="p">]</span> <span class="o">=</span> <span class="n">INVERT_UNIVARIATE</span> <span class="o">|</span> <span class="n">SOLVE_LU</span>

        <span class="c1"># Get the state space output</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">smooth</span><span class="p">(</span><span class="n">complex_step</span><span class="o">=</span><span class="n">complex_step</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Wrap in a results object</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_results</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">return_ssm</span><span class="p">,</span> <span class="n">cov_type</span><span class="p">,</span>
                                  <span class="n">cov_kwds</span><span class="p">,</span> <span class="n">results_class</span><span class="p">,</span>
                                  <span class="n">results_wrapper_class</span><span class="p">)</span></div>

    <span class="n">_loglike_param_names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">'transformed'</span><span class="p">,</span> <span class="s1">'includes_fixed'</span><span class="p">,</span> <span class="s1">'complex_step'</span><span class="p">]</span>
    <span class="n">_loglike_param_defaults</span> <span class="o">=</span> <span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">]</span>

<div class="viewcode-block" id="MLEModel.loglike"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEModel.loglike.html#statsmodels.tsa.statespace.structural.MLEModel.loglike">[docs]</a>    <span class="k">def</span> <span class="nf">loglike</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Loglikelihood evaluation</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array_like</span>
<span class="sd">            Array of parameters at which to evaluate the loglikelihood</span>
<span class="sd">            function.</span>
<span class="sd">        transformed : bool, optional</span>
<span class="sd">            Whether or not `params` is already transformed. Default is True.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Additional keyword arguments to pass to the Kalman filter. See</span>
<span class="sd">            `KalmanFilter.filter` for more details.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        [1]_ recommend maximizing the average likelihood to avoid scale issues;</span>
<span class="sd">        this is done automatically by the base Model fit method.</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        .. [1] Koopman, Siem Jan, Neil Shephard, and Jurgen A. Doornik. 1999.</span>
<span class="sd">           Statistical Algorithms for Models in State Space Using SsfPack 2.2.</span>
<span class="sd">           Econometrics Journal 2 (1): 107-60. doi:10.1111/1368-423X.00023.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        update : modifies the internal state of the state space model to</span>
<span class="sd">                 reflect new params</span>
<span class="sd">        """</span>
        <span class="n">transformed</span><span class="p">,</span> <span class="n">includes_fixed</span><span class="p">,</span> <span class="n">complex_step</span><span class="p">,</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="n">_handle_args</span><span class="p">(</span>
            <span class="n">MLEModel</span><span class="o">.</span><span class="n">_loglike_param_names</span><span class="p">,</span> <span class="n">MLEModel</span><span class="o">.</span><span class="n">_loglike_param_defaults</span><span class="p">,</span>
            <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="n">params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">handle_params</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="n">transformed</span><span class="p">,</span>
                                    <span class="n">includes_fixed</span><span class="o">=</span><span class="n">includes_fixed</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">includes_fixed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="n">complex_step</span><span class="o">=</span><span class="n">complex_step</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">complex_step</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">'inversion_method'</span><span class="p">]</span> <span class="o">=</span> <span class="n">INVERT_UNIVARIATE</span> <span class="o">|</span> <span class="n">SOLVE_LU</span>

        <span class="n">loglike</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">loglike</span><span class="p">(</span><span class="n">complex_step</span><span class="o">=</span><span class="n">complex_step</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Koopman, Shephard, and Doornik recommend maximizing the average</span>
        <span class="c1"># likelihood to avoid scale issues, but the averaging is done</span>
        <span class="c1"># automatically in the base model `fit` method</span>
        <span class="k">return</span> <span class="n">loglike</span></div>

<div class="viewcode-block" id="MLEModel.loglikeobs"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEModel.loglikeobs.html#statsmodels.tsa.statespace.structural.MLEModel.loglikeobs">[docs]</a>    <span class="k">def</span> <span class="nf">loglikeobs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">includes_fixed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                   <span class="n">complex_step</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Loglikelihood evaluation</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array_like</span>
<span class="sd">            Array of parameters at which to evaluate the loglikelihood</span>
<span class="sd">            function.</span>
<span class="sd">        transformed : bool, optional</span>
<span class="sd">            Whether or not `params` is already transformed. Default is True.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Additional keyword arguments to pass to the Kalman filter. See</span>
<span class="sd">            `KalmanFilter.filter` for more details.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        [1]_ recommend maximizing the average likelihood to avoid scale issues;</span>
<span class="sd">        this is done automatically by the base Model fit method.</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        .. [1] Koopman, Siem Jan, Neil Shephard, and Jurgen A. Doornik. 1999.</span>
<span class="sd">           Statistical Algorithms for Models in State Space Using SsfPack 2.2.</span>
<span class="sd">           Econometrics Journal 2 (1): 107-60. doi:10.1111/1368-423X.00023.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        update : modifies the internal state of the Model to reflect new params</span>
<span class="sd">        """</span>
        <span class="n">params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">handle_params</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="n">transformed</span><span class="p">,</span>
                                    <span class="n">includes_fixed</span><span class="o">=</span><span class="n">includes_fixed</span><span class="p">)</span>

        <span class="c1"># If we're using complex-step differentiation, then we cannot use</span>
        <span class="c1"># Cholesky factorization</span>
        <span class="k">if</span> <span class="n">complex_step</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">'inversion_method'</span><span class="p">]</span> <span class="o">=</span> <span class="n">INVERT_UNIVARIATE</span> <span class="o">|</span> <span class="n">SOLVE_LU</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">includes_fixed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="n">complex_step</span><span class="o">=</span><span class="n">complex_step</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">loglikeobs</span><span class="p">(</span><span class="n">complex_step</span><span class="o">=</span><span class="n">complex_step</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="MLEModel.simulation_smoother"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEModel.simulation_smoother.html#statsmodels.tsa.statespace.structural.MLEModel.simulation_smoother">[docs]</a>    <span class="k">def</span> <span class="nf">simulation_smoother</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">simulation_output</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">"""</span>
<span class="sd">        Retrieve a simulation smoother for the state space model.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        simulation_output : int, optional</span>
<span class="sd">            Determines which simulation smoother output is calculated.</span>
<span class="sd">            Default is all (including state and disturbances).</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Additional keyword arguments, used to set the simulation output.</span>
<span class="sd">            See `set_simulation_output` for more details.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        SimulationSmoothResults</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">simulation_smoother</span><span class="p">(</span>
            <span class="n">simulation_output</span><span class="o">=</span><span class="n">simulation_output</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_forecasts_error_partial_derivatives</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                             <span class="n">includes_fixed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                             <span class="n">approx_complex_step</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                             <span class="n">approx_centered</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                             <span class="n">res</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># We cannot use complex-step differentiation with non-transformed</span>
        <span class="c1"># parameters</span>
        <span class="k">if</span> <span class="n">approx_complex_step</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">approx_complex_step</span> <span class="o">=</span> <span class="n">transformed</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">transformed</span> <span class="ow">and</span> <span class="n">approx_complex_step</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"Cannot use complex-step approximations to"</span>
                             <span class="s2">" calculate the observed_information_matrix"</span>
                             <span class="s2">" with untransformed parameters."</span><span class="p">)</span>

        <span class="c1"># If we're using complex-step differentiation, then we cannot use</span>
        <span class="c1"># Cholesky factorization</span>
        <span class="k">if</span> <span class="n">approx_complex_step</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">'inversion_method'</span><span class="p">]</span> <span class="o">=</span> <span class="n">INVERT_UNIVARIATE</span> <span class="o">|</span> <span class="n">SOLVE_LU</span>

        <span class="c1"># Get values at the params themselves</span>
        <span class="k">if</span> <span class="n">res</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="n">transformed</span><span class="p">,</span>
                        <span class="n">includes_fixed</span><span class="o">=</span><span class="n">includes_fixed</span><span class="p">,</span>
                        <span class="n">complex_step</span><span class="o">=</span><span class="n">approx_complex_step</span><span class="p">)</span>
            <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">complex_step</span><span class="o">=</span><span class="n">approx_complex_step</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Setup</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>

        <span class="c1"># Compute partial derivatives w.r.t. forecast error and forecast</span>
        <span class="c1"># error covariance</span>
        <span class="n">partials_forecasts_error</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
        <span class="p">)</span>
        <span class="n">partials_forecasts_error_cov</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">approx_complex_step</span><span class="p">:</span>
            <span class="n">epsilon</span> <span class="o">=</span> <span class="n">_get_epsilon</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
            <span class="n">increments</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">epsilon</span>

            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ih</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">increments</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">params</span> <span class="o">+</span> <span class="n">ih</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="n">transformed</span><span class="p">,</span>
                            <span class="n">includes_fixed</span><span class="o">=</span><span class="n">includes_fixed</span><span class="p">,</span>
                            <span class="n">complex_step</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">_res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">complex_step</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

                <span class="n">partials_forecasts_error</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">_res</span><span class="o">.</span><span class="n">forecasts_error</span><span class="o">.</span><span class="n">imag</span> <span class="o">/</span> <span class="n">epsilon</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="p">)</span>

                <span class="n">partials_forecasts_error_cov</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">_res</span><span class="o">.</span><span class="n">forecasts_error_cov</span><span class="o">.</span><span class="n">imag</span> <span class="o">/</span> <span class="n">epsilon</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">approx_centered</span><span class="p">:</span>
            <span class="n">epsilon</span> <span class="o">=</span> <span class="n">_get_epsilon</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
            <span class="n">ei</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,),</span> <span class="nb">float</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="n">ei</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">epsilon</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">params</span> <span class="o">+</span> <span class="n">ei</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="n">transformed</span><span class="p">,</span>
                            <span class="n">includes_fixed</span><span class="o">=</span><span class="n">includes_fixed</span><span class="p">,</span> <span class="n">complex_step</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="n">_res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">complex_step</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

                <span class="n">partials_forecasts_error</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">_res</span><span class="o">.</span><span class="n">forecasts_error</span> <span class="o">-</span> <span class="n">res</span><span class="o">.</span><span class="n">forecasts_error</span><span class="p">)</span> <span class="o">/</span> <span class="n">epsilon</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

                <span class="n">partials_forecasts_error_cov</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">_res</span><span class="o">.</span><span class="n">forecasts_error_cov</span> <span class="o">-</span>
                    <span class="n">res</span><span class="o">.</span><span class="n">forecasts_error_cov</span><span class="p">)</span> <span class="o">/</span> <span class="n">epsilon</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">ei</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">epsilon</span> <span class="o">=</span> <span class="n">_get_epsilon</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.</span>
            <span class="n">ei</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,),</span> <span class="nb">float</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="n">ei</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">epsilon</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">params</span> <span class="o">+</span> <span class="n">ei</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="n">transformed</span><span class="p">,</span>
                            <span class="n">includes_fixed</span><span class="o">=</span><span class="n">includes_fixed</span><span class="p">,</span> <span class="n">complex_step</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="n">_res1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">complex_step</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">params</span> <span class="o">-</span> <span class="n">ei</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="n">transformed</span><span class="p">,</span>
                            <span class="n">includes_fixed</span><span class="o">=</span><span class="n">includes_fixed</span><span class="p">,</span> <span class="n">complex_step</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="n">_res2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">complex_step</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

                <span class="n">partials_forecasts_error</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="p">(</span><span class="n">_res1</span><span class="o">.</span><span class="n">forecasts_error</span> <span class="o">-</span> <span class="n">_res2</span><span class="o">.</span><span class="n">forecasts_error</span><span class="p">)</span> <span class="o">/</span>
                    <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">epsilon</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>

                <span class="n">partials_forecasts_error_cov</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="p">(</span><span class="n">_res1</span><span class="o">.</span><span class="n">forecasts_error_cov</span> <span class="o">-</span> <span class="n">_res2</span><span class="o">.</span><span class="n">forecasts_error_cov</span><span class="p">)</span> <span class="o">/</span>
                    <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">epsilon</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>

                <span class="n">ei</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="k">return</span> <span class="n">partials_forecasts_error</span><span class="p">,</span> <span class="n">partials_forecasts_error_cov</span>

<div class="viewcode-block" id="MLEModel.observed_information_matrix"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEModel.observed_information_matrix.html#statsmodels.tsa.statespace.structural.MLEModel.observed_information_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">observed_information_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                    <span class="n">includes_fixed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                    <span class="n">approx_complex_step</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                    <span class="n">approx_centered</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Observed information matrix</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array_like, optional</span>
<span class="sd">            Array of parameters at which to evaluate the loglikelihood</span>
<span class="sd">            function.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Additional keyword arguments to pass to the Kalman filter. See</span>
<span class="sd">            `KalmanFilter.filter` for more details.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method is from Harvey (1989), which shows that the information</span>
<span class="sd">        matrix only depends on terms from the gradient. This implementation is</span>
<span class="sd">        partially analytic and partially numeric approximation, therefore,</span>
<span class="sd">        because it uses the analytic formula for the information matrix, with</span>
<span class="sd">        numerically computed elements of the gradient.</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        Harvey, Andrew C. 1990.</span>
<span class="sd">        Forecasting, Structural Time Series Models and the Kalman Filter.</span>
<span class="sd">        Cambridge University Press.</span>
<span class="sd">        """</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Setup</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>

        <span class="c1"># We cannot use complex-step differentiation with non-transformed</span>
        <span class="c1"># parameters</span>
        <span class="k">if</span> <span class="n">approx_complex_step</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">approx_complex_step</span> <span class="o">=</span> <span class="n">transformed</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">transformed</span> <span class="ow">and</span> <span class="n">approx_complex_step</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"Cannot use complex-step approximations to"</span>
                             <span class="s2">" calculate the observed_information_matrix"</span>
                             <span class="s2">" with untransformed parameters."</span><span class="p">)</span>

        <span class="c1"># Get values at the params themselves</span>
        <span class="n">params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">handle_params</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="n">transformed</span><span class="p">,</span>
                                    <span class="n">includes_fixed</span><span class="o">=</span><span class="n">includes_fixed</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">includes_fixed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="n">complex_step</span><span class="o">=</span><span class="n">approx_complex_step</span><span class="p">)</span>
        <span class="c1"># If we're using complex-step differentiation, then we cannot use</span>
        <span class="c1"># Cholesky factorization</span>
        <span class="k">if</span> <span class="n">approx_complex_step</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">'inversion_method'</span><span class="p">]</span> <span class="o">=</span> <span class="n">INVERT_UNIVARIATE</span> <span class="o">|</span> <span class="n">SOLVE_LU</span>
        <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">complex_step</span><span class="o">=</span><span class="n">approx_complex_step</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">dtype</span>

        <span class="c1"># Save this for inversion later</span>
        <span class="n">inv_forecasts_error_cov</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">forecasts_error_cov</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="n">partials_forecasts_error</span><span class="p">,</span> <span class="n">partials_forecasts_error_cov</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_forecasts_error_partial_derivatives</span><span class="p">(</span>
                <span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="n">transformed</span><span class="p">,</span> <span class="n">includes_fixed</span><span class="o">=</span><span class="n">includes_fixed</span><span class="p">,</span>
                <span class="n">approx_complex_step</span><span class="o">=</span><span class="n">approx_complex_step</span><span class="p">,</span>
                <span class="n">approx_centered</span><span class="o">=</span><span class="n">approx_centered</span><span class="p">,</span> <span class="n">res</span><span class="o">=</span><span class="n">res</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>

        <span class="c1"># Compute the information matrix</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="p">,</span> <span class="n">n</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

        <span class="n">information_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">loglikelihood_burn</span><span class="p">,</span> <span class="n">res</span><span class="o">.</span><span class="n">nobs_diffuse</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="p">):</span>
            <span class="n">inv_forecasts_error_cov</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">forecasts_error_cov</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">t</span><span class="p">])</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="n">tmp</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">t</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
                    <span class="n">inv_forecasts_error_cov</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">t</span><span class="p">],</span>
                    <span class="n">partials_forecasts_error_cov</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">t</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span>
                <span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                    <span class="n">information_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span>
                        <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">tmp</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">t</span><span class="p">,</span> <span class="n">i</span><span class="p">],</span>
                                              <span class="n">tmp</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">t</span><span class="p">,</span> <span class="n">j</span><span class="p">]))</span>
                    <span class="p">)</span>
                    <span class="n">information_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span>
                        <span class="n">partials_forecasts_error</span><span class="p">[:,</span> <span class="n">t</span><span class="p">,</span> <span class="n">i</span><span class="p">],</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">inv_forecasts_error_cov</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">t</span><span class="p">],</span>
                               <span class="n">partials_forecasts_error</span><span class="p">[:,</span> <span class="n">t</span><span class="p">,</span> <span class="n">j</span><span class="p">])</span>
                    <span class="p">)</span>
        <span class="k">return</span> <span class="n">information_matrix</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nobs</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">loglikelihood_burn</span><span class="p">)</span></div>

<div class="viewcode-block" id="MLEModel.opg_information_matrix"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEModel.opg_information_matrix.html#statsmodels.tsa.statespace.structural.MLEModel.opg_information_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">opg_information_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                               <span class="n">includes_fixed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">approx_complex_step</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                               <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Outer product of gradients information matrix</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array_like, optional</span>
<span class="sd">            Array of parameters at which to evaluate the loglikelihood</span>
<span class="sd">            function.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Additional arguments to the `loglikeobs` method.</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        Berndt, Ernst R., Bronwyn Hall, Robert Hall, and Jerry Hausman. 1974.</span>
<span class="sd">        Estimation and Inference in Nonlinear Structural Models.</span>
<span class="sd">        NBER Chapters. National Bureau of Economic Research, Inc.</span>
<span class="sd">        """</span>
        <span class="c1"># We cannot use complex-step differentiation with non-transformed</span>
        <span class="c1"># parameters</span>
        <span class="k">if</span> <span class="n">approx_complex_step</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">approx_complex_step</span> <span class="o">=</span> <span class="n">transformed</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">transformed</span> <span class="ow">and</span> <span class="n">approx_complex_step</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"Cannot use complex-step approximations to"</span>
                             <span class="s2">" calculate the observed_information_matrix"</span>
                             <span class="s2">" with untransformed parameters."</span><span class="p">)</span>

        <span class="n">score_obs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">score_obs</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="n">transformed</span><span class="p">,</span>
                                   <span class="n">includes_fixed</span><span class="o">=</span><span class="n">includes_fixed</span><span class="p">,</span>
                                   <span class="n">approx_complex_step</span><span class="o">=</span><span class="n">approx_complex_step</span><span class="p">,</span>
                                   <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">score_obs</span><span class="p">,</span> <span class="n">score_obs</span><span class="p">)</span> <span class="o">/</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nobs</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">loglikelihood_burn</span><span class="p">)</span>
        <span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_score_complex_step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># the default epsilon can be too small</span>
        <span class="c1"># inversion_method = INVERT_UNIVARIATE | SOLVE_LU</span>
        <span class="n">epsilon</span> <span class="o">=</span> <span class="n">_get_epsilon</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="mf">2.</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">))</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">'transformed'</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">'complex_step'</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">approx_fprime_cs</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">loglike</span><span class="p">,</span> <span class="n">epsilon</span><span class="o">=</span><span class="n">epsilon</span><span class="p">,</span>
                                <span class="n">kwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_score_finite_difference</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">approx_centered</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                 <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">'transformed'</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">approx_fprime</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">loglike</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">,</span>
                             <span class="n">centered</span><span class="o">=</span><span class="n">approx_centered</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_score_harvey</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">approx_complex_step</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">score_obs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_score_obs_harvey</span><span class="p">(</span>
            <span class="n">params</span><span class="p">,</span> <span class="n">approx_complex_step</span><span class="o">=</span><span class="n">approx_complex_step</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">score_obs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_score_obs_harvey</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">approx_complex_step</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                          <span class="n">approx_centered</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">includes_fixed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                          <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Score</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array_like, optional</span>
<span class="sd">            Array of parameters at which to evaluate the loglikelihood</span>
<span class="sd">            function.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Additional keyword arguments to pass to the Kalman filter. See</span>
<span class="sd">            `KalmanFilter.filter` for more details.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method is from Harvey (1989), section 3.4.5</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        Harvey, Andrew C. 1990.</span>
<span class="sd">        Forecasting, Structural Time Series Models and the Kalman Filter.</span>
<span class="sd">        Cambridge University Press.</span>
<span class="sd">        """</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>

        <span class="c1"># Get values at the params themselves</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">includes_fixed</span><span class="o">=</span><span class="n">includes_fixed</span><span class="p">,</span>
                    <span class="n">complex_step</span><span class="o">=</span><span class="n">approx_complex_step</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">approx_complex_step</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">'inversion_method'</span><span class="p">]</span> <span class="o">=</span> <span class="n">INVERT_UNIVARIATE</span> <span class="o">|</span> <span class="n">SOLVE_LU</span>
        <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">complex_step</span><span class="o">=</span><span class="n">approx_complex_step</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Get forecasts error partials</span>
        <span class="n">partials_forecasts_error</span><span class="p">,</span> <span class="n">partials_forecasts_error_cov</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_forecasts_error_partial_derivatives</span><span class="p">(</span>
                <span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">includes_fixed</span><span class="o">=</span><span class="n">includes_fixed</span><span class="p">,</span>
                <span class="n">approx_complex_step</span><span class="o">=</span><span class="n">approx_complex_step</span><span class="p">,</span>
                <span class="n">approx_centered</span><span class="o">=</span><span class="n">approx_centered</span><span class="p">,</span> <span class="n">res</span><span class="o">=</span><span class="n">res</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>

        <span class="c1"># Compute partial derivatives w.r.t. likelihood function</span>
        <span class="n">partials</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
        <span class="n">k_endog</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="p">):</span>
            <span class="n">inv_forecasts_error_cov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span>
                    <span class="n">res</span><span class="o">.</span><span class="n">forecasts_error_cov</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">t</span><span class="p">])</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="n">partials</span><span class="p">[</span><span class="n">t</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">inv_forecasts_error_cov</span><span class="p">,</span>
                           <span class="n">partials_forecasts_error_cov</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">t</span><span class="p">,</span> <span class="n">i</span><span class="p">]),</span>
                    <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">k_endog</span><span class="p">)</span> <span class="o">-</span>
                     <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">inv_forecasts_error_cov</span><span class="p">,</span>
                            <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">forecasts_error</span><span class="p">[:,</span> <span class="n">t</span><span class="p">],</span>
                                     <span class="n">res</span><span class="o">.</span><span class="n">forecasts_error</span><span class="p">[:,</span> <span class="n">t</span><span class="p">])))))</span>
                <span class="c1"># 2 * dv / di * F^{-1} v_t</span>
                <span class="c1"># where x = F^{-1} v_t or F x = v</span>
                <span class="n">partials</span><span class="p">[</span><span class="n">t</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
                    <span class="n">partials_forecasts_error</span><span class="p">[:,</span> <span class="n">t</span><span class="p">,</span> <span class="n">i</span><span class="p">],</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">inv_forecasts_error_cov</span><span class="p">,</span> <span class="n">res</span><span class="o">.</span><span class="n">forecasts_error</span><span class="p">[:,</span> <span class="n">t</span><span class="p">]))</span>

        <span class="k">return</span> <span class="o">-</span><span class="n">partials</span> <span class="o">/</span> <span class="mf">2.</span>

    <span class="n">_score_param_names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">'transformed'</span><span class="p">,</span> <span class="s1">'includes_fixed'</span><span class="p">,</span> <span class="s1">'score_method'</span><span class="p">,</span>
                          <span class="s1">'approx_complex_step'</span><span class="p">,</span> <span class="s1">'approx_centered'</span><span class="p">]</span>
    <span class="n">_score_param_defaults</span> <span class="o">=</span> <span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="s1">'approx'</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">False</span><span class="p">]</span>

<div class="viewcode-block" id="MLEModel.score"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEModel.score.html#statsmodels.tsa.statespace.structural.MLEModel.score">[docs]</a>    <span class="k">def</span> <span class="nf">score</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Compute the score function at params.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array_like</span>
<span class="sd">            Array of parameters at which to evaluate the score.</span>
<span class="sd">        *args</span>
<span class="sd">            Additional positional arguments to the `loglike` method.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Additional keyword arguments to the `loglike` method.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        score : ndarray</span>
<span class="sd">            Score, evaluated at `params`.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This is a numerical approximation, calculated using first-order complex</span>
<span class="sd">        step differentiation on the `loglike` method.</span>

<span class="sd">        Both args and kwargs are necessary because the optimizer from</span>
<span class="sd">        `fit` must call this function and only supports passing arguments via</span>
<span class="sd">        args (for example `scipy.optimize.fmin_l_bfgs`).</span>
<span class="sd">        """</span>
        <span class="p">(</span><span class="n">transformed</span><span class="p">,</span> <span class="n">includes_fixed</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">approx_complex_step</span><span class="p">,</span>
         <span class="n">approx_centered</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">_handle_args</span><span class="p">(</span><span class="n">MLEModel</span><span class="o">.</span><span class="n">_score_param_names</span><span class="p">,</span>
                         <span class="n">MLEModel</span><span class="o">.</span><span class="n">_score_param_defaults</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>
        <span class="c1"># For fit() calls, the method is called 'score_method' (to distinguish</span>
        <span class="c1"># it from the method used for fit) but generally in kwargs the method</span>
        <span class="c1"># will just be called 'method'</span>
        <span class="k">if</span> <span class="s1">'method'</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">method</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">'method'</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">approx_complex_step</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">approx_complex_step</span> <span class="o">=</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">_complex_endog</span>
        <span class="k">if</span> <span class="n">approx_complex_step</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">_complex_endog</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'Cannot use complex step derivatives when data'</span>
                             <span class="s1">' or parameters are complex.'</span><span class="p">)</span>

        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">handle_params</span><span class="p">(</span>
            <span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="n">transformed</span><span class="p">,</span> <span class="n">includes_fixed</span><span class="o">=</span><span class="n">includes_fixed</span><span class="p">,</span>
            <span class="n">return_jacobian</span><span class="o">=</span><span class="ow">not</span> <span class="n">transformed</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">transformed</span><span class="p">:</span>
            <span class="n">params</span> <span class="o">=</span> <span class="n">out</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">params</span><span class="p">,</span> <span class="n">transform_score</span> <span class="o">=</span> <span class="n">out</span>

        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">'harvey'</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">'includes_fixed'</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">score</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_score_harvey</span><span class="p">(</span>
                <span class="n">params</span><span class="p">,</span> <span class="n">approx_complex_step</span><span class="o">=</span><span class="n">approx_complex_step</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">'approx'</span> <span class="ow">and</span> <span class="n">approx_complex_step</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">'includes_fixed'</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">score</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_score_complex_step</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">'approx'</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">'includes_fixed'</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">score</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_score_finite_difference</span><span class="p">(</span>
                <span class="n">params</span><span class="p">,</span> <span class="n">approx_centered</span><span class="o">=</span><span class="n">approx_centered</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">'Invalid score method.'</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">transformed</span><span class="p">:</span>
            <span class="n">score</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">transform_score</span><span class="p">,</span> <span class="n">score</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_fixed_params</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">includes_fixed</span><span class="p">:</span>
            <span class="n">score</span> <span class="o">=</span> <span class="n">score</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_free_params_index</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">score</span></div>

<div class="viewcode-block" id="MLEModel.score_obs"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEModel.score_obs.html#statsmodels.tsa.statespace.structural.MLEModel.score_obs">[docs]</a>    <span class="k">def</span> <span class="nf">score_obs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">'approx'</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                  <span class="n">includes_fixed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">approx_complex_step</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                  <span class="n">approx_centered</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Compute the score per observation, evaluated at params</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array_like</span>
<span class="sd">            Array of parameters at which to evaluate the score.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Additional arguments to the `loglike` method.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        score : ndarray</span>
<span class="sd">            Score per observation, evaluated at `params`.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This is a numerical approximation, calculated using first-order complex</span>
<span class="sd">        step differentiation on the `loglikeobs` method.</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">transformed</span> <span class="ow">and</span> <span class="n">approx_complex_step</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"Cannot use complex-step approximations to"</span>
                             <span class="s2">" calculate the score at each observation"</span>
                             <span class="s2">" with untransformed parameters."</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">approx_complex_step</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">approx_complex_step</span> <span class="o">=</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">_complex_endog</span>
        <span class="k">if</span> <span class="n">approx_complex_step</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">_complex_endog</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'Cannot use complex step derivatives when data'</span>
                             <span class="s1">' or parameters are complex.'</span><span class="p">)</span>

        <span class="n">params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">handle_params</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                    <span class="n">includes_fixed</span><span class="o">=</span><span class="n">includes_fixed</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">'transformed'</span><span class="p">]</span> <span class="o">=</span> <span class="n">transformed</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">'includes_fixed'</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">'harvey'</span><span class="p">:</span>
            <span class="n">score</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_score_obs_harvey</span><span class="p">(</span>
                <span class="n">params</span><span class="p">,</span> <span class="n">approx_complex_step</span><span class="o">=</span><span class="n">approx_complex_step</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">'approx'</span> <span class="ow">and</span> <span class="n">approx_complex_step</span><span class="p">:</span>
            <span class="c1"># the default epsilon can be too small</span>
            <span class="n">epsilon</span> <span class="o">=</span> <span class="n">_get_epsilon</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="mf">2.</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">))</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">'complex_step'</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">score</span> <span class="o">=</span> <span class="n">approx_fprime_cs</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">loglikeobs</span><span class="p">,</span> <span class="n">epsilon</span><span class="o">=</span><span class="n">epsilon</span><span class="p">,</span>
                                     <span class="n">kwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">'approx'</span><span class="p">:</span>
            <span class="n">score</span> <span class="o">=</span> <span class="n">approx_fprime</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">loglikeobs</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">,</span>
                                  <span class="n">centered</span><span class="o">=</span><span class="n">approx_centered</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">'Invalid scoreobs method.'</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">score</span></div>

    <span class="n">_hessian_param_names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">'transformed'</span><span class="p">,</span> <span class="s1">'hessian_method'</span><span class="p">,</span>
                            <span class="s1">'approx_complex_step'</span><span class="p">,</span> <span class="s1">'approx_centered'</span><span class="p">]</span>
    <span class="n">_hessian_param_defaults</span> <span class="o">=</span> <span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="s1">'approx'</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">False</span><span class="p">]</span>

<div class="viewcode-block" id="MLEModel.hessian"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEModel.hessian.html#statsmodels.tsa.statespace.structural.MLEModel.hessian">[docs]</a>    <span class="k">def</span> <span class="nf">hessian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">"""</span>
<span class="sd">        Hessian matrix of the likelihood function, evaluated at the given</span>
<span class="sd">        parameters</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array_like</span>
<span class="sd">            Array of parameters at which to evaluate the hessian.</span>
<span class="sd">        *args</span>
<span class="sd">            Additional positional arguments to the `loglike` method.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Additional keyword arguments to the `loglike` method.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        hessian : ndarray</span>
<span class="sd">            Hessian matrix evaluated at `params`</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This is a numerical approximation.</span>

<span class="sd">        Both args and kwargs are necessary because the optimizer from</span>
<span class="sd">        `fit` must call this function and only supports passing arguments via</span>
<span class="sd">        args (for example `scipy.optimize.fmin_l_bfgs`).</span>
<span class="sd">        """</span>
        <span class="n">transformed</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">approx_complex_step</span><span class="p">,</span> <span class="n">approx_centered</span><span class="p">,</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">_handle_args</span><span class="p">(</span><span class="n">MLEModel</span><span class="o">.</span><span class="n">_hessian_param_names</span><span class="p">,</span>
                         <span class="n">MLEModel</span><span class="o">.</span><span class="n">_hessian_param_defaults</span><span class="p">,</span>
                         <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>
        <span class="c1"># For fit() calls, the method is called 'hessian_method' (to</span>
        <span class="c1"># distinguish it from the method used for fit) but generally in kwargs</span>
        <span class="c1"># the method will just be called 'method'</span>
        <span class="k">if</span> <span class="s1">'method'</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">method</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">'method'</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">transformed</span> <span class="ow">and</span> <span class="n">approx_complex_step</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"Cannot use complex-step approximations to"</span>
                             <span class="s2">" calculate the hessian with untransformed"</span>
                             <span class="s2">" parameters."</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">approx_complex_step</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">approx_complex_step</span> <span class="o">=</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">_complex_endog</span>
        <span class="k">if</span> <span class="n">approx_complex_step</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">_complex_endog</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'Cannot use complex step derivatives when data'</span>
                             <span class="s1">' or parameters are complex.'</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">'oim'</span><span class="p">:</span>
            <span class="n">hessian</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hessian_oim</span><span class="p">(</span>
                <span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="n">transformed</span><span class="p">,</span>
                <span class="n">approx_complex_step</span><span class="o">=</span><span class="n">approx_complex_step</span><span class="p">,</span>
                <span class="n">approx_centered</span><span class="o">=</span><span class="n">approx_centered</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">'opg'</span><span class="p">:</span>
            <span class="n">hessian</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hessian_opg</span><span class="p">(</span>
                <span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="n">transformed</span><span class="p">,</span>
                <span class="n">approx_complex_step</span><span class="o">=</span><span class="n">approx_complex_step</span><span class="p">,</span>
                <span class="n">approx_centered</span><span class="o">=</span><span class="n">approx_centered</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">'approx'</span> <span class="ow">and</span> <span class="n">approx_complex_step</span><span class="p">:</span>
            <span class="n">hessian</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hessian_complex_step</span><span class="p">(</span>
                <span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="n">transformed</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">'approx'</span><span class="p">:</span>
            <span class="n">hessian</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hessian_finite_difference</span><span class="p">(</span>
                <span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="n">transformed</span><span class="p">,</span>
                <span class="n">approx_centered</span><span class="o">=</span><span class="n">approx_centered</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">'Invalid Hessian calculation method.'</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">hessian</span></div>

    <span class="k">def</span> <span class="nf">_hessian_oim</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Hessian matrix computed using the Harvey (1989) information matrix</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">observed_information_matrix</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_hessian_opg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Hessian matrix computed using the outer product of gradients</span>
<span class="sd">        information matrix</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">opg_information_matrix</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_hessian_finite_difference</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">approx_centered</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                   <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">'Calculation of the Hessian using finite differences'</span>
                      <span class="s1">' is usually subject to substantial approximation'</span>
                      <span class="s1">' errors.'</span><span class="p">,</span> <span class="n">PrecisionWarning</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">approx_centered</span><span class="p">:</span>
            <span class="n">epsilon</span> <span class="o">=</span> <span class="n">_get_epsilon</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">epsilon</span> <span class="o">=</span> <span class="n">_get_epsilon</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">))</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="n">hessian</span> <span class="o">=</span> <span class="n">approx_fprime</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_score_finite_difference</span><span class="p">,</span>
                                <span class="n">epsilon</span><span class="o">=</span><span class="n">epsilon</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">,</span>
                                <span class="n">centered</span><span class="o">=</span><span class="n">approx_centered</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">hessian</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nobs</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">loglikelihood_burn</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_hessian_complex_step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Hessian matrix computed by second-order complex-step differentiation</span>
<span class="sd">        on the `loglike` function.</span>
<span class="sd">        """</span>
        <span class="c1"># the default epsilon can be too small</span>
        <span class="n">epsilon</span> <span class="o">=</span> <span class="n">_get_epsilon</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="mf">3.</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">))</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">'transformed'</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">'complex_step'</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">hessian</span> <span class="o">=</span> <span class="n">approx_hess_cs</span><span class="p">(</span>
            <span class="n">params</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">loglike</span><span class="p">,</span> <span class="n">epsilon</span><span class="o">=</span><span class="n">epsilon</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">hessian</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nobs</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">loglikelihood_burn</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">start_params</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        (array) Starting parameters for maximum likelihood estimation.</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">'_start_params'</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_start_params</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">param_names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        (list of str) List of human readable parameter names (for parameters</span>
<span class="sd">        actually included in the model).</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">'_param_names'</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_param_names</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">'param.</span><span class="si">%d</span><span class="s1">'</span> <span class="o">%</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">start_params</span><span class="p">))]</span>
            <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
                <span class="n">names</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">return</span> <span class="n">names</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">state_names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        (list of str) List of human readable names for unobserved states.</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">'_state_names'</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state_names</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">'state.</span><span class="si">%d</span><span class="s1">'</span> <span class="o">%</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_states</span><span class="p">)]</span>
        <span class="k">return</span> <span class="n">names</span>

<div class="viewcode-block" id="MLEModel.transform_jacobian"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEModel.transform_jacobian.html#statsmodels.tsa.statespace.structural.MLEModel.transform_jacobian">[docs]</a>    <span class="k">def</span> <span class="nf">transform_jacobian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unconstrained</span><span class="p">,</span> <span class="n">approx_centered</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Jacobian matrix for the parameter transformation function</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        unconstrained : array_like</span>
<span class="sd">            Array of unconstrained parameters used by the optimizer.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        jacobian : ndarray</span>
<span class="sd">            Jacobian matrix of the transformation, evaluated at `unconstrained`</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This is a numerical approximation using finite differences. Note that</span>
<span class="sd">        in general complex step methods cannot be used because it is not</span>
<span class="sd">        guaranteed that the `transform_params` method is a real function (e.g.</span>
<span class="sd">        if Cholesky decomposition is used).</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        transform_params</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">approx_fprime</span><span class="p">(</span><span class="n">unconstrained</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_params</span><span class="p">,</span>
                             <span class="n">centered</span><span class="o">=</span><span class="n">approx_centered</span><span class="p">)</span></div>

<div class="viewcode-block" id="MLEModel.transform_params"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEModel.transform_params.html#statsmodels.tsa.statespace.structural.MLEModel.transform_params">[docs]</a>    <span class="k">def</span> <span class="nf">transform_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unconstrained</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Transform unconstrained parameters used by the optimizer to constrained</span>
<span class="sd">        parameters used in likelihood evaluation</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        unconstrained : array_like</span>
<span class="sd">            Array of unconstrained parameters used by the optimizer, to be</span>
<span class="sd">            transformed.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        constrained : array_like</span>
<span class="sd">            Array of constrained parameters which may be used in likelihood</span>
<span class="sd">            evaluation.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This is a noop in the base class, subclasses should override where</span>
<span class="sd">        appropriate.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">unconstrained</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span></div>

<div class="viewcode-block" id="MLEModel.untransform_params"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEModel.untransform_params.html#statsmodels.tsa.statespace.structural.MLEModel.untransform_params">[docs]</a>    <span class="k">def</span> <span class="nf">untransform_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">constrained</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Transform constrained parameters used in likelihood evaluation</span>
<span class="sd">        to unconstrained parameters used by the optimizer</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        constrained : array_like</span>
<span class="sd">            Array of constrained parameters used in likelihood evaluation, to</span>
<span class="sd">            be transformed.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        unconstrained : array_like</span>
<span class="sd">            Array of unconstrained parameters used by the optimizer.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This is a noop in the base class, subclasses should override where</span>
<span class="sd">        appropriate.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">constrained</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span></div>

<div class="viewcode-block" id="MLEModel.handle_params"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEModel.handle_params.html#statsmodels.tsa.statespace.structural.MLEModel.handle_params">[docs]</a>    <span class="k">def</span> <span class="nf">handle_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">includes_fixed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                      <span class="n">return_jacobian</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Never want integer dtype, so convert to floats</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">params</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">):</span>
            <span class="n">params</span> <span class="o">=</span> <span class="n">params</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">includes_fixed</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_fixed_params</span><span class="p">:</span>
            <span class="n">k_params</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">)</span>
            <span class="n">new_params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">k_params</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">params</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">new_params</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_free_params_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">params</span>
            <span class="n">params</span> <span class="o">=</span> <span class="n">new_params</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">transformed</span><span class="p">:</span>
            <span class="c1"># It may be the case that the transformation relies on having</span>
            <span class="c1"># "some" (non-NaN) values for the fixed parameters, even if we will</span>
            <span class="c1"># not actually be transforming the fixed parameters (as they will)</span>
            <span class="c1"># be set below regardless</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">includes_fixed</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_fixed_params</span><span class="p">:</span>
                <span class="n">params</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_fixed_params_index</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_fixed_params</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>

            <span class="k">if</span> <span class="n">return_jacobian</span><span class="p">:</span>
                <span class="n">transform_score</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_jacobian</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
            <span class="n">params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_params</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">includes_fixed</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_fixed_params</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_fixed_params_index</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_fixed_params</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">transform_score</span><span class="p">)</span> <span class="k">if</span> <span class="n">return_jacobian</span> <span class="k">else</span> <span class="n">params</span></div>

<div class="viewcode-block" id="MLEModel.update"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEModel.update.html#statsmodels.tsa.statespace.structural.MLEModel.update">[docs]</a>    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">includes_fixed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
               <span class="n">complex_step</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Update the parameters of the model</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array_like</span>
<span class="sd">            Array of new parameters.</span>
<span class="sd">        transformed : bool, optional</span>
<span class="sd">            Whether or not `params` is already transformed. If set to False,</span>
<span class="sd">            `transform_params` is called. Default is True.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        params : array_like</span>
<span class="sd">            Array of parameters.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Since Model is a base class, this method should be overridden by</span>
<span class="sd">        subclasses to perform actual updating steps.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">handle_params</span><span class="p">(</span><span class="n">params</span><span class="o">=</span><span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="n">transformed</span><span class="p">,</span>
                                  <span class="n">includes_fixed</span><span class="o">=</span><span class="n">includes_fixed</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_validate_out_of_sample_exog</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exog</span><span class="p">,</span> <span class="n">out_of_sample</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Validate given `exog` as satisfactory for out-of-sample operations</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        exog : array_like or None</span>
<span class="sd">            New observations of exogenous regressors, if applicable.</span>
<span class="sd">        out_of_sample : int</span>
<span class="sd">            Number of new observations required.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        exog : array or None</span>
<span class="sd">            A numpy array of shape (out_of_sample, k_exog) if the model</span>
<span class="sd">            contains an `exog` component, or None if it doesn't.</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="n">out_of_sample</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_exog</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">exog</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'Out-of-sample operations in a model'</span>
                                 <span class="s1">' with a regression component require'</span>
                                 <span class="s1">' additional exogenous values via the'</span>
                                 <span class="s1">' `exog` argument.'</span><span class="p">)</span>
            <span class="n">exog</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">exog</span><span class="p">)</span>
            <span class="n">required_exog_shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">out_of_sample</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_exog</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">exog</span> <span class="o">=</span> <span class="n">exog</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">required_exog_shape</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'Provided exogenous values are not of the'</span>
                                 <span class="s1">' appropriate shape. Required </span><span class="si">%s</span><span class="s1">, got </span><span class="si">%s</span><span class="s1">.'</span>
                                 <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">required_exog_shape</span><span class="p">),</span>
                                    <span class="nb">str</span><span class="p">(</span><span class="n">exog</span><span class="o">.</span><span class="n">shape</span><span class="p">)))</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_exog</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">exog</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">'Exogenous array provided, but additional data'</span>
                          <span class="s1">' is not required. `exog` argument ignored.'</span><span class="p">,</span>
                          <span class="n">ValueWarning</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">exog</span>

    <span class="k">def</span> <span class="nf">_get_extension_time_varying_matrices</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">exog</span><span class="p">,</span> <span class="n">out_of_sample</span><span class="p">,</span> <span class="n">extend_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">includes_fixed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Get updated time-varying state space system matrices</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array_like</span>
<span class="sd">            Array of parameters used to construct the time-varying system</span>
<span class="sd">            matrices.</span>
<span class="sd">        exog : array_like or None</span>
<span class="sd">            New observations of exogenous regressors, if applicable.</span>
<span class="sd">        out_of_sample : int</span>
<span class="sd">            Number of new observations required.</span>
<span class="sd">        extend_kwargs : dict, optional</span>
<span class="sd">            Dictionary of keyword arguments to pass to the state space model</span>
<span class="sd">            constructor. For example, for an SARIMAX state space model, this</span>
<span class="sd">            could be used to pass the `concentrate_scale=True` keyword</span>
<span class="sd">            argument. Any arguments that are not explicitly set in this</span>
<span class="sd">            dictionary will be copied from the current model instance.</span>
<span class="sd">        transformed : bool, optional</span>
<span class="sd">            Whether or not `start_params` is already transformed. Default is</span>
<span class="sd">            True.</span>
<span class="sd">        includes_fixed : bool, optional</span>
<span class="sd">            If parameters were previously fixed with the `fix_params` method,</span>
<span class="sd">            this argument describes whether or not `start_params` also includes</span>
<span class="sd">            the fixed parameters, in addition to the free parameters. Default</span>
<span class="sd">            is False.</span>
<span class="sd">        """</span>
        <span class="c1"># Get the appropriate exog for the extended sample</span>
        <span class="n">exog</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_validate_out_of_sample_exog</span><span class="p">(</span><span class="n">exog</span><span class="p">,</span> <span class="n">out_of_sample</span><span class="p">)</span>

        <span class="c1"># Create extended model</span>
        <span class="k">if</span> <span class="n">extend_kwargs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">extend_kwargs</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># Handle trend offset for extended model</span>
        <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">'k_trend'</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">'trend_offset'</span><span class="p">):</span>
            <span class="n">extend_kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span>
                <span class="s1">'trend_offset'</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">trend_offset</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="p">)</span>

        <span class="n">mod_extend</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span>
            <span class="n">endog</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">out_of_sample</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">)),</span> <span class="n">exog</span><span class="o">=</span><span class="n">exog</span><span class="p">,</span>
            <span class="o">**</span><span class="n">extend_kwargs</span><span class="p">)</span>
        <span class="n">mod_extend</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="n">transformed</span><span class="p">,</span>
                          <span class="n">includes_fixed</span><span class="o">=</span><span class="n">includes_fixed</span><span class="p">)</span>

        <span class="c1"># Retrieve the extensions to the time-varying system matrices and</span>
        <span class="c1"># put them in kwargs</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">shapes</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s1">'obs'</span> <span class="ow">or</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">mat</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">mod_extend</span><span class="o">.</span><span class="n">ssm</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">mat</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="o">-</span><span class="n">out_of_sample</span><span class="p">:]</span>

        <span class="k">return</span> <span class="n">kwargs</span>

<div class="viewcode-block" id="MLEModel.simulate"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEModel.simulate.html#statsmodels.tsa.statespace.structural.MLEModel.simulate">[docs]</a>    <span class="k">def</span> <span class="nf">simulate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">nsimulations</span><span class="p">,</span> <span class="n">measurement_shocks</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">state_shocks</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">initial_state</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">anchor</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">repetitions</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">exog</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">extend_model</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">extend_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">includes_fixed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">"""</span>
<span class="sd">        Simulate a new time series following the state space model</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array_like</span>
<span class="sd">            Array of parameters to use in constructing the state space</span>
<span class="sd">            representation to use when simulating.</span>
<span class="sd">        nsimulations : int</span>
<span class="sd">            The number of observations to simulate. If the model is</span>
<span class="sd">            time-invariant this can be any number. If the model is</span>
<span class="sd">            time-varying, then this number must be less than or equal to the</span>
<span class="sd">            number of observations.</span>
<span class="sd">        measurement_shocks : array_like, optional</span>
<span class="sd">            If specified, these are the shocks to the measurement equation,</span>
<span class="sd">            :math:`\varepsilon_t`. If unspecified, these are automatically</span>
<span class="sd">            generated using a pseudo-random number generator. If specified,</span>
<span class="sd">            must be shaped `nsimulations` x `k_endog`, where `k_endog` is the</span>
<span class="sd">            same as in the state space model.</span>
<span class="sd">        state_shocks : array_like, optional</span>
<span class="sd">            If specified, these are the shocks to the state equation,</span>
<span class="sd">            :math:`\eta_t`. If unspecified, these are automatically</span>
<span class="sd">            generated using a pseudo-random number generator. If specified,</span>
<span class="sd">            must be shaped `nsimulations` x `k_posdef` where `k_posdef` is the</span>
<span class="sd">            same as in the state space model.</span>
<span class="sd">        initial_state : array_like, optional</span>
<span class="sd">            If specified, this is the initial state vector to use in</span>
<span class="sd">            simulation, which should be shaped (`k_states` x 1), where</span>
<span class="sd">            `k_states` is the same as in the state space model. If unspecified,</span>
<span class="sd">            but the model has been initialized, then that initialization is</span>
<span class="sd">            used. This must be specified if `anchor` is anything other than</span>
<span class="sd">            "start" or 0 (or else you can use the `simulate` method on a</span>
<span class="sd">            results object rather than on the model object).</span>
<span class="sd">        anchor : int, str, or datetime, optional</span>
<span class="sd">            First period for simulation. The simulation will be conditional on</span>
<span class="sd">            all existing datapoints prior to the `anchor`.  Type depends on the</span>
<span class="sd">            index of the given `endog` in the model. Two special cases are the</span>
<span class="sd">            strings 'start' and 'end'. `start` refers to beginning the</span>
<span class="sd">            simulation at the first period of the sample, and `end` refers to</span>
<span class="sd">            beginning the simulation at the first period after the sample.</span>
<span class="sd">            Integer values can run from 0 to `nobs`, or can be negative to</span>
<span class="sd">            apply negative indexing. Finally, if a date/time index was provided</span>
<span class="sd">            to the model, then this argument can be a date string to parse or a</span>
<span class="sd">            datetime type. Default is 'start'.</span>
<span class="sd">        repetitions : int, optional</span>
<span class="sd">            Number of simulated paths to generate. Default is 1 simulated path.</span>
<span class="sd">        exog : array_like, optional</span>
<span class="sd">            New observations of exogenous regressors, if applicable.</span>
<span class="sd">        transformed : bool, optional</span>
<span class="sd">            Whether or not `params` is already transformed. Default is</span>
<span class="sd">            True.</span>
<span class="sd">        includes_fixed : bool, optional</span>
<span class="sd">            If parameters were previously fixed with the `fix_params` method,</span>
<span class="sd">            this argument describes whether or not `params` also includes</span>
<span class="sd">            the fixed parameters, in addition to the free parameters. Default</span>
<span class="sd">            is False.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        simulated_obs : ndarray</span>
<span class="sd">            An array of simulated observations. If `repetitions=None`, then it</span>
<span class="sd">            will be shaped (nsimulations x k_endog) or (nsimulations,) if</span>
<span class="sd">            `k_endog=1`. Otherwise it will be shaped</span>
<span class="sd">            (nsimulations x k_endog x repetitions). If the model was given</span>
<span class="sd">            Pandas input then the output will be a Pandas object. If</span>
<span class="sd">            `k_endog &gt; 1` and `repetitions` is not None, then the output will</span>
<span class="sd">            be a Pandas DataFrame that has a MultiIndex for the columns, with</span>
<span class="sd">            the first level containing the names of the `endog` variables and</span>
<span class="sd">            the second level containing the repetition number.</span>
<span class="sd">        """</span>
        <span class="c1"># Make sure the model class has the current parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="n">transformed</span><span class="p">,</span>
                    <span class="n">includes_fixed</span><span class="o">=</span><span class="n">includes_fixed</span><span class="p">)</span>

        <span class="c1"># Get the starting location</span>
        <span class="k">if</span> <span class="n">anchor</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">anchor</span> <span class="o">==</span> <span class="s1">'start'</span><span class="p">:</span>
            <span class="n">iloc</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">elif</span> <span class="n">anchor</span> <span class="o">==</span> <span class="s1">'end'</span><span class="p">:</span>
            <span class="n">iloc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">iloc</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_index_loc</span><span class="p">(</span><span class="n">anchor</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">iloc</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
                <span class="n">iloc</span> <span class="o">=</span> <span class="n">iloc</span><span class="o">.</span><span class="n">start</span>

        <span class="k">if</span> <span class="n">iloc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">iloc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span> <span class="o">+</span> <span class="n">iloc</span>
        <span class="k">if</span> <span class="n">iloc</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'Cannot anchor simulation outside of the sample.'</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">iloc</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">initial_state</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'If `anchor` is after the start of the sample,'</span>
                             <span class="s1">' must provide a value for `initial_state`.'</span><span class="p">)</span>

        <span class="c1"># Get updated time-varying system matrices in **kwargs, if necessary</span>
        <span class="n">out_of_sample</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">iloc</span> <span class="o">+</span> <span class="n">nsimulations</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">extend_model</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">extend_model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exog</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">time_invariant</span>
        <span class="k">if</span> <span class="n">out_of_sample</span> <span class="ow">and</span> <span class="n">extend_model</span><span class="p">:</span>
            <span class="n">kwargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_extension_time_varying_matrices</span><span class="p">(</span>
                <span class="n">params</span><span class="p">,</span> <span class="n">exog</span><span class="p">,</span> <span class="n">out_of_sample</span><span class="p">,</span> <span class="n">extend_kwargs</span><span class="p">,</span>
                <span class="n">transformed</span><span class="o">=</span><span class="n">transformed</span><span class="p">,</span> <span class="n">includes_fixed</span><span class="o">=</span><span class="n">includes_fixed</span><span class="p">,</span>
                <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Standardize the dimensions of the initial state</span>
        <span class="k">if</span> <span class="n">initial_state</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">initial_state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">initial_state</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">initial_state</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">initial_state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">initial_state</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

        <span class="c1"># Construct a model that represents the simulation period</span>
        <span class="n">end</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="p">,</span> <span class="n">iloc</span> <span class="o">+</span> <span class="n">nsimulations</span><span class="p">)</span>
        <span class="n">nextend</span> <span class="o">=</span> <span class="n">iloc</span> <span class="o">+</span> <span class="n">nsimulations</span> <span class="o">-</span> <span class="n">end</span>
        <span class="n">sim_model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">nextend</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">)),</span>
                                    <span class="n">start</span><span class="o">=</span><span class="n">iloc</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="n">end</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Simulate the data</span>
        <span class="n">_repetitions</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">repetitions</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">repetitions</span>
        <span class="n">sim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nsimulations</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">,</span> <span class="n">_repetitions</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">_repetitions</span><span class="p">):</span>
            <span class="n">initial_state_variates</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="n">initial_state</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">initial_state</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">initial_state_variates</span> <span class="o">=</span> <span class="n">initial_state</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">initial_state_variates</span> <span class="o">=</span> <span class="n">initial_state</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span>

            <span class="c1"># TODO: allow specifying measurement / state shocks for each</span>
            <span class="c1"># repetition?</span>

            <span class="n">out</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">sim_model</span><span class="o">.</span><span class="n">simulate</span><span class="p">(</span>
                <span class="n">nsimulations</span><span class="p">,</span> <span class="n">measurement_shocks</span><span class="p">,</span> <span class="n">state_shocks</span><span class="p">,</span>
                <span class="n">initial_state_variates</span><span class="p">)</span>

            <span class="n">sim</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">out</span>

        <span class="c1"># Wrap data / squeeze where appropriate</span>
        <span class="n">use_pandas</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">PandasData</span><span class="p">)</span>
        <span class="n">index</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">use_pandas</span><span class="p">:</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_prediction_index</span><span class="p">(</span>
                <span class="n">iloc</span><span class="p">,</span> <span class="n">iloc</span> <span class="o">+</span> <span class="n">nsimulations</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="c1"># If `repetitions` isn't set, we squeeze the last dimension(s)</span>
        <span class="k">if</span> <span class="n">repetitions</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">sim</span> <span class="o">=</span> <span class="n">sim</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">use_pandas</span><span class="p">:</span>
                    <span class="n">sim</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">sim</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">endog_names</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">sim</span> <span class="o">=</span> <span class="n">sim</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">use_pandas</span><span class="p">:</span>
                    <span class="n">sim</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">sim</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span>
                                       <span class="n">columns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">endog_names</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">use_pandas</span><span class="p">:</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">shape</span>
            <span class="n">endog_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">endog_names</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">endog_names</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="n">endog_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">endog_names</span><span class="p">]</span>
            <span class="n">columns</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="o">.</span><span class="n">from_product</span><span class="p">([</span><span class="n">endog_names</span><span class="p">,</span>
                                                  <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">])])</span>
            <span class="n">sim</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">sim</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span>
                               <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">sim</span></div>

<div class="viewcode-block" id="MLEModel.impulse_responses"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEModel.impulse_responses.html#statsmodels.tsa.statespace.structural.MLEModel.impulse_responses">[docs]</a>    <span class="k">def</span> <span class="nf">impulse_responses</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">steps</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">impulse</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                          <span class="n">orthogonalized</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">cumulative</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">anchor</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                          <span class="n">exog</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">extend_model</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">extend_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                          <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">includes_fixed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Impulse response function</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array_like</span>
<span class="sd">            Array of model parameters.</span>
<span class="sd">        steps : int, optional</span>
<span class="sd">            The number of steps for which impulse responses are calculated.</span>
<span class="sd">            Default is 1. Note that for time-invariant models, the initial</span>
<span class="sd">            impulse is not counted as a step, so if `steps=1`, the output will</span>
<span class="sd">            have 2 entries.</span>
<span class="sd">        impulse : int or array_like</span>
<span class="sd">            If an integer, the state innovation to pulse; must be between 0</span>
<span class="sd">            and `k_posdef-1`. Alternatively, a custom impulse vector may be</span>
<span class="sd">            provided; must be shaped `k_posdef x 1`.</span>
<span class="sd">        orthogonalized : bool, optional</span>
<span class="sd">            Whether or not to perform impulse using orthogonalized innovations.</span>
<span class="sd">            Note that this will also affect custum `impulse` vectors. Default</span>
<span class="sd">            is False.</span>
<span class="sd">        cumulative : bool, optional</span>
<span class="sd">            Whether or not to return cumulative impulse responses. Default is</span>
<span class="sd">            False.</span>
<span class="sd">        anchor : int, str, or datetime, optional</span>
<span class="sd">            Time point within the sample for the state innovation impulse. Type</span>
<span class="sd">            depends on the index of the given `endog` in the model. Two special</span>
<span class="sd">            cases are the strings 'start' and 'end', which refer to setting the</span>
<span class="sd">            impulse at the first and last points of the sample, respectively.</span>
<span class="sd">            Integer values can run from 0 to `nobs - 1`, or can be negative to</span>
<span class="sd">            apply negative indexing. Finally, if a date/time index was provided</span>
<span class="sd">            to the model, then this argument can be a date string to parse or a</span>
<span class="sd">            datetime type. Default is 'start'.</span>
<span class="sd">        exog : array_like, optional</span>
<span class="sd">            New observations of exogenous regressors for our-of-sample periods,</span>
<span class="sd">            if applicable.</span>
<span class="sd">        transformed : bool, optional</span>
<span class="sd">            Whether or not `params` is already transformed. Default is</span>
<span class="sd">            True.</span>
<span class="sd">        includes_fixed : bool, optional</span>
<span class="sd">            If parameters were previously fixed with the `fix_params` method,</span>
<span class="sd">            this argument describes whether or not `params` also includes</span>
<span class="sd">            the fixed parameters, in addition to the free parameters. Default</span>
<span class="sd">            is False.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            If the model has time-varying design or transition matrices and the</span>
<span class="sd">            combination of `anchor` and `steps` implies creating impulse</span>
<span class="sd">            responses for the out-of-sample period, then these matrices must</span>
<span class="sd">            have updated values provided for the out-of-sample steps. For</span>
<span class="sd">            example, if `design` is a time-varying component, `nobs` is 10,</span>
<span class="sd">            `anchor=1`, and `steps` is 15, a (`k_endog` x `k_states` x 7)</span>
<span class="sd">            matrix must be provided with the new design matrix values.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        impulse_responses : ndarray</span>
<span class="sd">            Responses for each endogenous variable due to the impulse</span>
<span class="sd">            given by the `impulse` argument. For a time-invariant model, the</span>
<span class="sd">            impulse responses are given for `steps + 1` elements (this gives</span>
<span class="sd">            the "initial impulse" followed by `steps` responses for the</span>
<span class="sd">            important cases of VAR and SARIMAX models), while for time-varying</span>
<span class="sd">            models the impulse responses are only given for `steps` elements</span>
<span class="sd">            (to avoid having to unexpectedly provide updated time-varying</span>
<span class="sd">            matrices).</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Intercepts in the measurement and state equation are ignored when</span>
<span class="sd">        calculating impulse responses.</span>

<span class="sd">        TODO: add an option to allow changing the ordering for the</span>
<span class="sd">              orthogonalized option. Will require permuting matrices when</span>
<span class="sd">              constructing the extended model.</span>
<span class="sd">        """</span>
        <span class="c1"># Make sure the model class has the current parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="n">transformed</span><span class="p">,</span>
                    <span class="n">includes_fixed</span><span class="o">=</span><span class="n">includes_fixed</span><span class="p">)</span>

        <span class="c1"># For time-invariant models, add an additional `step`. This is the</span>
        <span class="c1"># default for time-invariant models based on the expected behavior for</span>
        <span class="c1"># ARIMA and VAR models: we want to record the initial impulse and also</span>
        <span class="c1"># `steps` values of the responses afterwards.</span>
        <span class="c1"># Note: we don't modify `steps` itself, because</span>
        <span class="c1"># `KalmanFilter.impulse_responses` also adds an additional step in this</span>
        <span class="c1"># case (this is so that there isn't different behavior when calling</span>
        <span class="c1"># this method versus that method). We just need to also keep track of</span>
        <span class="c1"># this here because we need to generate the correct extended model.</span>
        <span class="n">additional_steps</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">_design</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">_transition</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">_selection</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">additional_steps</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="c1"># Get the starting location</span>
        <span class="k">if</span> <span class="n">anchor</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">anchor</span> <span class="o">==</span> <span class="s1">'start'</span><span class="p">:</span>
            <span class="n">iloc</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">elif</span> <span class="n">anchor</span> <span class="o">==</span> <span class="s1">'end'</span><span class="p">:</span>
            <span class="n">iloc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">iloc</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_index_loc</span><span class="p">(</span><span class="n">anchor</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">iloc</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
                <span class="n">iloc</span> <span class="o">=</span> <span class="n">iloc</span><span class="o">.</span><span class="n">start</span>

        <span class="k">if</span> <span class="n">iloc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">iloc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span> <span class="o">+</span> <span class="n">iloc</span>
        <span class="k">if</span> <span class="n">iloc</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'Cannot anchor impulse responses outside of the'</span>
                             <span class="s1">' sample.'</span><span class="p">)</span>

        <span class="n">time_invariant</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">_design</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">_obs_cov</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">_transition</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">_selection</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">_state_cov</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Get updated time-varying system matrices in **kwargs, if necessary</span>
        <span class="c1"># (Note: KalmanFilter adds 1 to steps to account for the first impulse)</span>
        <span class="n">out_of_sample</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span>
            <span class="n">iloc</span> <span class="o">+</span> <span class="p">(</span><span class="n">steps</span> <span class="o">+</span> <span class="n">additional_steps</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">extend_model</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">extend_model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exog</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">time_invariant</span>
        <span class="k">if</span> <span class="n">out_of_sample</span> <span class="ow">and</span> <span class="n">extend_model</span><span class="p">:</span>
            <span class="n">kwargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_extension_time_varying_matrices</span><span class="p">(</span>
                <span class="n">params</span><span class="p">,</span> <span class="n">exog</span><span class="p">,</span> <span class="n">out_of_sample</span><span class="p">,</span> <span class="n">extend_kwargs</span><span class="p">,</span>
                <span class="n">transformed</span><span class="o">=</span><span class="n">transformed</span><span class="p">,</span> <span class="n">includes_fixed</span><span class="o">=</span><span class="n">includes_fixed</span><span class="p">,</span>
                <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Special handling for matrix terms that are time-varying but</span>
        <span class="c1"># irrelevant for impulse response functions. Must be set since</span>
        <span class="c1"># ssm.extend() requires that we pass new matrices for these, but they</span>
        <span class="c1"># are ignored for IRF purposes.</span>
        <span class="n">end</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="p">,</span> <span class="n">iloc</span> <span class="o">+</span> <span class="n">steps</span> <span class="o">+</span> <span class="n">additional_steps</span><span class="p">)</span>
        <span class="n">nextend</span> <span class="o">=</span> <span class="n">iloc</span> <span class="o">+</span> <span class="p">(</span><span class="n">steps</span> <span class="o">+</span> <span class="n">additional_steps</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">end</span>
        <span class="k">if</span> <span class="p">(</span><span class="s1">'obs_intercept'</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="ow">and</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">_obs_intercept</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">'obs_intercept'</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">,</span> <span class="n">nextend</span><span class="p">))</span>
        <span class="k">if</span> <span class="p">(</span><span class="s1">'state_intercept'</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="ow">and</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">_state_intercept</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">'state_intercept'</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">k_states</span><span class="p">,</span> <span class="n">nextend</span><span class="p">))</span>
        <span class="k">if</span> <span class="s1">'obs_cov'</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">_obs_cov</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">'obs_cov'</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">,</span> <span class="n">nextend</span><span class="p">))</span>
        <span class="c1"># Special handling for matrix terms that are time-varying but</span>
        <span class="c1"># only the value at the anchor matters for IRF purposes.</span>
        <span class="k">if</span> <span class="s1">'state_cov'</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">_state_cov</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">k_posdef</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">k_posdef</span><span class="p">,</span> <span class="n">nextend</span><span class="p">))</span>
            <span class="n">tmp</span><span class="p">[:]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s1">'state_cov'</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="n">iloc</span><span class="p">:</span><span class="n">iloc</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">'state_cov'</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span>
        <span class="k">if</span> <span class="s1">'selection'</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">_selection</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">k_states</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">k_posdef</span><span class="p">,</span> <span class="n">nextend</span><span class="p">))</span>
            <span class="n">tmp</span><span class="p">[:]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s1">'selection'</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="n">iloc</span><span class="p">:</span><span class="n">iloc</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">'selection'</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span>

        <span class="c1"># Construct a model that represents the simulation period</span>
        <span class="n">sim_model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">nextend</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">)),</span>
                                    <span class="n">start</span><span class="o">=</span><span class="n">iloc</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="n">end</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Compute the impulse responses</span>
        <span class="n">irfs</span> <span class="o">=</span> <span class="n">sim_model</span><span class="o">.</span><span class="n">impulse_responses</span><span class="p">(</span>
            <span class="n">steps</span><span class="p">,</span> <span class="n">impulse</span><span class="p">,</span> <span class="n">orthogonalized</span><span class="p">,</span> <span class="n">cumulative</span><span class="p">)</span>

        <span class="c1"># IRF is (nobs x k_endog); do not want to squeeze in case of steps = 1</span>
        <span class="k">if</span> <span class="n">irfs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">irfs</span> <span class="o">=</span> <span class="n">irfs</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">irfs</span></div>

<div class="viewcode-block" id="MLEModel.from_formula"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEModel.from_formula.html#statsmodels.tsa.statespace.structural.MLEModel.from_formula">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_formula</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">formula</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">subset</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Not implemented for state space models</span>
<span class="sd">        """</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div></div>


<div class="viewcode-block" id="MLEResults"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEResults.html#statsmodels.tsa.statespace.structural.MLEResults">[docs]</a><span class="k">class</span> <span class="nc">MLEResults</span><span class="p">(</span><span class="n">tsbase</span><span class="o">.</span><span class="n">TimeSeriesModelResults</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">"""</span>
<span class="sd">    Class to hold results from fitting a state space model.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    model : MLEModel instance</span>
<span class="sd">        The fitted model instance</span>
<span class="sd">    params : ndarray</span>
<span class="sd">        Fitted parameters</span>
<span class="sd">    filter_results : KalmanFilter instance</span>
<span class="sd">        The underlying state space model and Kalman filter output</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    model : Model instance</span>
<span class="sd">        A reference to the model that was fit.</span>
<span class="sd">    filter_results : KalmanFilter instance</span>
<span class="sd">        The underlying state space model and Kalman filter output</span>
<span class="sd">    nobs : float</span>
<span class="sd">        The number of observations used to fit the model.</span>
<span class="sd">    params : ndarray</span>
<span class="sd">        The parameters of the model.</span>
<span class="sd">    scale : float</span>
<span class="sd">        This is currently set to 1.0 unless the model uses concentrated</span>
<span class="sd">        filtering.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    MLEModel</span>
<span class="sd">    statsmodels.tsa.statespace.kalman_filter.FilterResults</span>
<span class="sd">    statsmodels.tsa.statespace.representation.FrozenRepresentation</span>
<span class="sd">    """</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">results</span><span class="p">,</span> <span class="n">cov_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cov_kwds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">data</span>
        <span class="n">scale</span> <span class="o">=</span> <span class="n">results</span><span class="o">.</span><span class="n">scale</span>

        <span class="n">tsbase</span><span class="o">.</span><span class="n">TimeSeriesModelResults</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span>
                                               <span class="n">normalized_cov_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                               <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">)</span>

        <span class="c1"># Save the fixed parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_has_fixed_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">_has_fixed_params</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fixed_params_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">_fixed_params_index</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_free_params_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">_free_params_index</span>
        <span class="c1"># TODO: seems like maybe self.fixed_params should be the dictionary</span>
        <span class="c1"># itself, not just the keys?</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_fixed_params</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_fixed_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">_fixed_params</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fixed_params</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_fixed_params</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_fixed_params</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fixed_params</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">param_names</span> <span class="o">=</span> <span class="p">[</span>
            <span class="s1">'</span><span class="si">%s</span><span class="s1"> (fixed)'</span> <span class="o">%</span> <span class="n">name</span> <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fixed_params</span> <span class="k">else</span> <span class="n">name</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">param_names</span> <span class="ow">or</span> <span class="p">[])]</span>

        <span class="c1"># Save the state space representation output</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filter_results</span> <span class="o">=</span> <span class="n">results</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="n">SmootherResults</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">smoother_results</span> <span class="o">=</span> <span class="n">results</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">smoother_results</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Dimensions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_results</span><span class="o">.</span><span class="n">nobs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nobs_diffuse</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_results</span><span class="o">.</span><span class="n">nobs_diffuse</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs_diffuse</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">loglikelihood_burn</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">'Care should be used when applying a loglikelihood'</span>
                          <span class="s1">' burn to a model with exact diffuse initialization.'</span>
                          <span class="s1">' Some results objects, e.g. degrees of freedom,'</span>
                          <span class="s1">' expect only one of the two to be set.'</span><span class="p">)</span>
        <span class="c1"># This only excludes explicitly burned (usually approximate diffuse)</span>
        <span class="c1"># periods but does not exclude approximate diffuse periods. This is</span>
        <span class="c1"># because the loglikelihood remains valid for the initial periods in</span>
        <span class="c1"># the exact diffuse case (see DK, 2012, section 7.2) and so also do</span>
        <span class="c1"># e.g. information criteria (see DK, 2012, section 7.4) and the score</span>
        <span class="c1"># vector (see DK, 2012, section 7.3.3, equation 7.15).</span>
        <span class="c1"># However, other objects should be excluded in the diffuse periods</span>
        <span class="c1"># (e.g. the diffuse forecast errors, so in some cases a different</span>
        <span class="c1"># nobs_effective will have to be computed and used)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nobs_effective</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">loglikelihood_burn</span>

        <span class="n">P</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_results</span><span class="o">.</span><span class="n">initial_diffuse_state_cov</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k_diffuse_states</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">P</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diagonal</span><span class="p">(</span><span class="n">P</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Degrees of freedom (see DK 2012, section 7.4)</span>
        <span class="n">k_free_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fixed_params</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">df_model</span> <span class="o">=</span> <span class="p">(</span><span class="n">k_free_params</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_diffuse_states</span>
                         <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_results</span><span class="o">.</span><span class="n">filter_concentrated</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">df_resid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs_effective</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">df_model</span>

        <span class="c1"># Setup covariance matrix notes dictionary</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">'cov_kwds'</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cov_kwds</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">cov_type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cov_type</span> <span class="o">=</span> <span class="s1">'approx'</span> <span class="k">if</span> <span class="n">results</span><span class="o">.</span><span class="n">memory_no_likelihood</span> <span class="k">else</span> <span class="s1">'opg'</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cov_type</span> <span class="o">=</span> <span class="n">cov_type</span>

        <span class="c1"># Setup the cache</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># Handle covariance matrix calculation</span>
        <span class="k">if</span> <span class="n">cov_kwds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cov_kwds</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cov_approx_complex_step</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">cov_kwds</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">'approx_complex_step'</span><span class="p">,</span> <span class="kc">True</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cov_approx_centered</span> <span class="o">=</span> <span class="n">cov_kwds</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">'approx_centered'</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_rank</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_get_robustcov_results</span><span class="p">(</span><span class="n">cov_type</span><span class="o">=</span><span class="n">cov_type</span><span class="p">,</span> <span class="n">use_self</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                        <span class="o">**</span><span class="n">cov_kwds</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">LinAlgError</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_rank</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">k_params</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cov_params_default</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">k_params</span><span class="p">,</span> <span class="n">k_params</span><span class="p">))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cov_kwds</span><span class="p">[</span><span class="s1">'cov_type'</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s1">'Covariance matrix could not be calculated: singular.'</span>
                <span class="s1">' information matrix.'</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">includes_fixed</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># References of filter and smoother output</span>
        <span class="n">extra_arrays</span> <span class="o">=</span> <span class="p">[</span>
            <span class="s1">'filtered_state'</span><span class="p">,</span> <span class="s1">'filtered_state_cov'</span><span class="p">,</span> <span class="s1">'predicted_state'</span><span class="p">,</span>
            <span class="s1">'predicted_state_cov'</span><span class="p">,</span> <span class="s1">'forecasts'</span><span class="p">,</span> <span class="s1">'forecasts_error'</span><span class="p">,</span>
            <span class="s1">'forecasts_error_cov'</span><span class="p">,</span> <span class="s1">'standardized_forecasts_error'</span><span class="p">,</span>
            <span class="s1">'forecasts_error_diffuse_cov'</span><span class="p">,</span> <span class="s1">'predicted_diffuse_state_cov'</span><span class="p">,</span>
            <span class="s1">'scaled_smoothed_estimator'</span><span class="p">,</span>
            <span class="s1">'scaled_smoothed_estimator_cov'</span><span class="p">,</span> <span class="s1">'smoothing_error'</span><span class="p">,</span>
            <span class="s1">'smoothed_state'</span><span class="p">,</span>
            <span class="s1">'smoothed_state_cov'</span><span class="p">,</span> <span class="s1">'smoothed_state_autocov'</span><span class="p">,</span>
            <span class="s1">'smoothed_measurement_disturbance'</span><span class="p">,</span>
            <span class="s1">'smoothed_state_disturbance'</span><span class="p">,</span>
            <span class="s1">'smoothed_measurement_disturbance_cov'</span><span class="p">,</span>
            <span class="s1">'smoothed_state_disturbance_cov'</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">extra_arrays</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filter_results</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>

        <span class="c1"># Remove too-short results when memory conservation was used</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_results</span><span class="o">.</span><span class="n">memory_no_forecast_mean</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">forecasts</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">forecasts_error</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_results</span><span class="o">.</span><span class="n">memory_no_forecast_cov</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">forecasts_error_cov</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_results</span><span class="o">.</span><span class="n">memory_no_predicted_mean</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">predicted_state</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_results</span><span class="o">.</span><span class="n">memory_no_predicted_cov</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">predicted_state_cov</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_results</span><span class="o">.</span><span class="n">memory_no_filtered_mean</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">filtered_state</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_results</span><span class="o">.</span><span class="n">memory_no_filtered_cov</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">filtered_state_cov</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_results</span><span class="o">.</span><span class="n">memory_no_gain</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_results</span><span class="o">.</span><span class="n">memory_no_smoothing</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_results</span><span class="o">.</span><span class="n">memory_no_std_forecast</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">standardized_forecasts_error</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Save more convenient access to states</span>
        <span class="c1"># (will create a private attribute _states here and provide actual</span>
        <span class="c1"># access via a getter, so that we can e.g. issue a warning in the case</span>
        <span class="c1"># that a useless Pandas index was given in the model specification)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_states</span> <span class="o">=</span> <span class="n">SimpleNamespace</span><span class="p">()</span>

        <span class="n">use_pandas</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">PandasData</span><span class="p">)</span>
        <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">_index</span>
        <span class="n">columns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">state_names</span>

        <span class="c1"># Predicted states</span>
        <span class="c1"># Note: a complication here is that we also include the initial values</span>
        <span class="c1"># here, so that we need an extended index in the Pandas case</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">predicted_state</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">filter_results</span><span class="o">.</span><span class="n">memory_no_predicted_mean</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_states</span><span class="o">.</span><span class="n">predicted</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="n">use_pandas</span><span class="p">:</span>
            <span class="n">extended_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">_get_index_with_initial_state</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_states</span><span class="o">.</span><span class="n">predicted</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">predicted_state</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">extended_index</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_states</span><span class="o">.</span><span class="n">predicted</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predicted_state</span><span class="o">.</span><span class="n">T</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">predicted_state_cov</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">filter_results</span><span class="o">.</span><span class="n">memory_no_predicted_cov</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_states</span><span class="o">.</span><span class="n">predicted_cov</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="n">use_pandas</span><span class="p">:</span>
            <span class="n">extended_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">_get_index_with_initial_state</span><span class="p">()</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">predicted_state_cov</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_states</span><span class="o">.</span><span class="n">predicted_cov</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="p">(</span><span class="n">tmp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">tmp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">tmp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">])),</span>
                <span class="n">index</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="o">.</span><span class="n">from_product</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">extended_index</span><span class="p">,</span> <span class="n">columns</span><span class="p">])</span><span class="o">.</span><span class="n">swaplevel</span><span class="p">(),</span>
                <span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_states</span><span class="o">.</span><span class="n">predicted_cov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">predicted_state_cov</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

        <span class="c1"># Filtered states</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filtered_state</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">filter_results</span><span class="o">.</span><span class="n">memory_no_filtered_mean</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_states</span><span class="o">.</span><span class="n">filtered</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="n">use_pandas</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_states</span><span class="o">.</span><span class="n">filtered</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">filtered_state</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_states</span><span class="o">.</span><span class="n">filtered</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filtered_state</span><span class="o">.</span><span class="n">T</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filtered_state_cov</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">filter_results</span><span class="o">.</span><span class="n">memory_no_filtered_cov</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_states</span><span class="o">.</span><span class="n">filtered_cov</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="n">use_pandas</span><span class="p">:</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filtered_state_cov</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_states</span><span class="o">.</span><span class="n">filtered_cov</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="p">(</span><span class="n">tmp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">tmp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">tmp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">])),</span>
                <span class="n">index</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="o">.</span><span class="n">from_product</span><span class="p">([</span><span class="n">index</span><span class="p">,</span> <span class="n">columns</span><span class="p">])</span><span class="o">.</span><span class="n">swaplevel</span><span class="p">(),</span>
                <span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_states</span><span class="o">.</span><span class="n">filtered_cov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">filtered_state_cov</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

        <span class="c1"># Smoothed states</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">smoothed_state</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_states</span><span class="o">.</span><span class="n">smoothed</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="n">use_pandas</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_states</span><span class="o">.</span><span class="n">smoothed</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">smoothed_state</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_states</span><span class="o">.</span><span class="n">smoothed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">smoothed_state</span><span class="o">.</span><span class="n">T</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">smoothed_state_cov</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_states</span><span class="o">.</span><span class="n">smoothed_cov</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="n">use_pandas</span><span class="p">:</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">smoothed_state_cov</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_states</span><span class="o">.</span><span class="n">smoothed_cov</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="p">(</span><span class="n">tmp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">tmp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">tmp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">])),</span>
                <span class="n">index</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="o">.</span><span class="n">from_product</span><span class="p">([</span><span class="n">index</span><span class="p">,</span> <span class="n">columns</span><span class="p">])</span><span class="o">.</span><span class="n">swaplevel</span><span class="p">(),</span>
                <span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_states</span><span class="o">.</span><span class="n">smoothed_cov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">smoothed_state_cov</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

        <span class="c1"># Handle removing data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data_attr_model</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">'_data_attr_model'</span><span class="p">,</span> <span class="p">[])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data_attr_model</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="s1">'ssm'</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data_attr</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">extra_arrays</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data_attr</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="s1">'filter_results'</span><span class="p">,</span> <span class="s1">'smoother_results'</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_in_cache</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">'data_in_cache'</span><span class="p">,</span> <span class="p">[])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_in_cache</span><span class="o">.</span><span class="n">extend</span><span class="p">([])</span>

    <span class="k">def</span> <span class="nf">_get_robustcov_results</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cov_type</span><span class="o">=</span><span class="s1">'opg'</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Create new results instance with specified covariance estimator as</span>
<span class="sd">        default</span>

<span class="sd">        Note: creating new results instance currently not supported.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cov_type : str</span>
<span class="sd">            the type of covariance matrix estimator to use. See Notes below</span>
<span class="sd">        kwargs : depends on cov_type</span>
<span class="sd">            Required or optional arguments for covariance calculation.</span>
<span class="sd">            See Notes below.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        results : results instance</span>
<span class="sd">            This method creates a new results instance with the requested</span>
<span class="sd">            covariance as the default covariance of the parameters.</span>
<span class="sd">            Inferential statistics like p-values and hypothesis tests will be</span>
<span class="sd">            based on this covariance matrix.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The following covariance types and required or optional arguments are</span>
<span class="sd">        currently available:</span>

<span class="sd">        - 'opg' for the outer product of gradient estimator</span>
<span class="sd">        - 'oim' for the observed information matrix estimator, calculated</span>
<span class="sd">          using the method of Harvey (1989)</span>
<span class="sd">        - 'approx' for the observed information matrix estimator,</span>
<span class="sd">          calculated using a numerical approximation of the Hessian matrix.</span>
<span class="sd">          Uses complex step approximation by default, or uses finite</span>
<span class="sd">          differences if `approx_complex_step=False` in the `cov_kwds`</span>
<span class="sd">          dictionary.</span>
<span class="sd">        - 'robust' for an approximate (quasi-maximum likelihood) covariance</span>
<span class="sd">          matrix that may be valid even in the presence of some</span>
<span class="sd">          misspecifications. Intermediate calculations use the 'oim'</span>
<span class="sd">          method.</span>
<span class="sd">        - 'robust_approx' is the same as 'robust' except that the</span>
<span class="sd">          intermediate calculations use the 'approx' method.</span>
<span class="sd">        - 'none' for no covariance matrix calculation.</span>
<span class="sd">        """</span>
        <span class="kn">from</span> <span class="nn">statsmodels.base.covtype</span> <span class="kn">import</span> <span class="n">descriptions</span>

        <span class="n">use_self</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">'use_self'</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">use_self</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span>
            <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">,</span>
                <span class="n">normalized_cov_params</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">normalized_cov_params</span><span class="p">,</span>
                <span class="n">scale</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">)</span>

        <span class="c1"># Set the new covariance type</span>
        <span class="n">res</span><span class="o">.</span><span class="n">cov_type</span> <span class="o">=</span> <span class="n">cov_type</span>
        <span class="n">res</span><span class="o">.</span><span class="n">cov_kwds</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># Calculate the new covariance matrix</span>
        <span class="n">approx_complex_step</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cov_approx_complex_step</span>
        <span class="k">if</span> <span class="n">approx_complex_step</span><span class="p">:</span>
            <span class="n">approx_type_str</span> <span class="o">=</span> <span class="s1">'complex-step'</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cov_approx_centered</span><span class="p">:</span>
            <span class="n">approx_type_str</span> <span class="o">=</span> <span class="s1">'centered finite differences'</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">approx_type_str</span> <span class="o">=</span> <span class="s1">'finite differences'</span>

        <span class="n">k_params</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">k_params</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">res</span><span class="o">.</span><span class="n">cov_params_default</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
            <span class="n">res</span><span class="o">.</span><span class="n">_rank</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">res</span><span class="o">.</span><span class="n">cov_kwds</span><span class="p">[</span><span class="s1">'description'</span><span class="p">]</span> <span class="o">=</span> <span class="s1">'No parameters estimated.'</span>
        <span class="k">elif</span> <span class="n">cov_type</span> <span class="o">==</span> <span class="s1">'custom'</span><span class="p">:</span>
            <span class="n">res</span><span class="o">.</span><span class="n">cov_type</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">'custom_cov_type'</span><span class="p">]</span>
            <span class="n">res</span><span class="o">.</span><span class="n">cov_params_default</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">'custom_cov_params'</span><span class="p">]</span>
            <span class="n">res</span><span class="o">.</span><span class="n">cov_kwds</span><span class="p">[</span><span class="s1">'description'</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">'custom_description'</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fixed_params</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_free_params_index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_free_params_index</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">s_</span><span class="p">[</span><span class="o">...</span><span class="p">]</span>
            <span class="n">res</span><span class="o">.</span><span class="n">_rank</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">matrix_rank</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">cov_params_default</span><span class="p">[</span><span class="n">mask</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">cov_type</span> <span class="o">==</span> <span class="s1">'none'</span><span class="p">:</span>
            <span class="n">res</span><span class="o">.</span><span class="n">cov_params_default</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">k_params</span><span class="p">,</span> <span class="n">k_params</span><span class="p">))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">res</span><span class="o">.</span><span class="n">_rank</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">res</span><span class="o">.</span><span class="n">cov_kwds</span><span class="p">[</span><span class="s1">'description'</span><span class="p">]</span> <span class="o">=</span> <span class="n">descriptions</span><span class="p">[</span><span class="s1">'none'</span><span class="p">]</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">cov_type</span> <span class="o">==</span> <span class="s1">'approx'</span><span class="p">:</span>
            <span class="n">res</span><span class="o">.</span><span class="n">cov_params_default</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">cov_params_approx</span>
            <span class="n">res</span><span class="o">.</span><span class="n">cov_kwds</span><span class="p">[</span><span class="s1">'description'</span><span class="p">]</span> <span class="o">=</span> <span class="n">descriptions</span><span class="p">[</span><span class="s1">'approx'</span><span class="p">]</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                                <span class="n">approx_type</span><span class="o">=</span><span class="n">approx_type_str</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">cov_type</span> <span class="o">==</span> <span class="s1">'oim'</span><span class="p">:</span>
            <span class="n">res</span><span class="o">.</span><span class="n">cov_params_default</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">cov_params_oim</span>
            <span class="n">res</span><span class="o">.</span><span class="n">cov_kwds</span><span class="p">[</span><span class="s1">'description'</span><span class="p">]</span> <span class="o">=</span> <span class="n">descriptions</span><span class="p">[</span><span class="s1">'OIM'</span><span class="p">]</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                                <span class="n">approx_type</span><span class="o">=</span><span class="n">approx_type_str</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">cov_type</span> <span class="o">==</span> <span class="s1">'opg'</span><span class="p">:</span>
            <span class="n">res</span><span class="o">.</span><span class="n">cov_params_default</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">cov_params_opg</span>
            <span class="n">res</span><span class="o">.</span><span class="n">cov_kwds</span><span class="p">[</span><span class="s1">'description'</span><span class="p">]</span> <span class="o">=</span> <span class="n">descriptions</span><span class="p">[</span><span class="s1">'OPG'</span><span class="p">]</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                                <span class="n">approx_type</span><span class="o">=</span><span class="n">approx_type_str</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">cov_type</span> <span class="o">==</span> <span class="s1">'robust'</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">cov_type</span> <span class="o">==</span> <span class="s1">'robust_oim'</span><span class="p">:</span>
            <span class="n">res</span><span class="o">.</span><span class="n">cov_params_default</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">cov_params_robust_oim</span>
            <span class="n">res</span><span class="o">.</span><span class="n">cov_kwds</span><span class="p">[</span><span class="s1">'description'</span><span class="p">]</span> <span class="o">=</span> <span class="n">descriptions</span><span class="p">[</span><span class="s1">'robust-OIM'</span><span class="p">]</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                                <span class="n">approx_type</span><span class="o">=</span><span class="n">approx_type_str</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">cov_type</span> <span class="o">==</span> <span class="s1">'robust_approx'</span><span class="p">:</span>
            <span class="n">res</span><span class="o">.</span><span class="n">cov_params_default</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">cov_params_robust_approx</span>
            <span class="n">res</span><span class="o">.</span><span class="n">cov_kwds</span><span class="p">[</span><span class="s1">'description'</span><span class="p">]</span> <span class="o">=</span> <span class="n">descriptions</span><span class="p">[</span><span class="s1">'robust-approx'</span><span class="p">]</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                                <span class="n">approx_type</span><span class="o">=</span><span class="n">approx_type_str</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">'Invalid covariance matrix type.'</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">res</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">aic</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        (float) Akaike Information Criterion</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">aic</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">llf</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs_effective</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">df_model</span><span class="p">)</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">aicc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        (float) Akaike Information Criterion with small sample correction</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">aicc</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">llf</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs_effective</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">df_model</span><span class="p">)</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">bic</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        (float) Bayes Information Criterion</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">bic</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">llf</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs_effective</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">df_model</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_cov_params_approx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">approx_complex_step</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                           <span class="n">approx_centered</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="n">evaluated_hessian</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs_effective</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">hessian</span><span class="p">(</span>
            <span class="n">params</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">includes_fixed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">method</span><span class="o">=</span><span class="s1">'approx'</span><span class="p">,</span> <span class="n">approx_complex_step</span><span class="o">=</span><span class="n">approx_complex_step</span><span class="p">,</span>
            <span class="n">approx_centered</span><span class="o">=</span><span class="n">approx_centered</span><span class="p">)</span>
        <span class="c1"># TODO: Case with "not approx_complex_step" is not hit in</span>
        <span class="c1"># tests as of 2017-05-19</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fixed_params</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_free_params_index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_free_params_index</span><span class="p">)</span>
            <span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">singular_values</span><span class="p">)</span> <span class="o">=</span> <span class="n">pinv_extended</span><span class="p">(</span><span class="n">evaluated_hessian</span><span class="p">[</span><span class="n">mask</span><span class="p">])</span>
            <span class="n">neg_cov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">evaluated_hessian</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">neg_cov</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="p">(</span><span class="n">neg_cov</span><span class="p">,</span> <span class="n">singular_values</span><span class="p">)</span> <span class="o">=</span> <span class="n">pinv_extended</span><span class="p">(</span><span class="n">evaluated_hessian</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">includes_fixed</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rank</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_rank</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">matrix_rank</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">singular_values</span><span class="p">))</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">neg_cov</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">cov_params_approx</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        (array) The variance / covariance matrix. Computed using the numerical</span>
<span class="sd">        Hessian approximated by complex step or finite differences methods.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cov_params_approx</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cov_approx_complex_step</span><span class="p">,</span>
                                       <span class="bp">self</span><span class="o">.</span><span class="n">_cov_approx_centered</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_cov_params_oim</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">approx_complex_step</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">approx_centered</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="n">evaluated_hessian</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs_effective</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">hessian</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="n">hessian_method</span><span class="o">=</span><span class="s1">'oim'</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">includes_fixed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">approx_complex_step</span><span class="o">=</span><span class="n">approx_complex_step</span><span class="p">,</span>
            <span class="n">approx_centered</span><span class="o">=</span><span class="n">approx_centered</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fixed_params</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_free_params_index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_free_params_index</span><span class="p">)</span>
            <span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">singular_values</span><span class="p">)</span> <span class="o">=</span> <span class="n">pinv_extended</span><span class="p">(</span><span class="n">evaluated_hessian</span><span class="p">[</span><span class="n">mask</span><span class="p">])</span>
            <span class="n">neg_cov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">evaluated_hessian</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">neg_cov</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="p">(</span><span class="n">neg_cov</span><span class="p">,</span> <span class="n">singular_values</span><span class="p">)</span> <span class="o">=</span> <span class="n">pinv_extended</span><span class="p">(</span><span class="n">evaluated_hessian</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">includes_fixed</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rank</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_rank</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">matrix_rank</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">singular_values</span><span class="p">))</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">neg_cov</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">cov_params_oim</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        (array) The variance / covariance matrix. Computed using the method</span>
<span class="sd">        from Harvey (1989).</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cov_params_oim</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cov_approx_complex_step</span><span class="p">,</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">_cov_approx_centered</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_cov_params_opg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">approx_complex_step</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">approx_centered</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="n">evaluated_hessian</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs_effective</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">_hessian_opg</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">includes_fixed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">approx_complex_step</span><span class="o">=</span><span class="n">approx_complex_step</span><span class="p">,</span>
            <span class="n">approx_centered</span><span class="o">=</span><span class="n">approx_centered</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fixed_params</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_free_params_index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_free_params_index</span><span class="p">)</span>
            <span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">singular_values</span><span class="p">)</span> <span class="o">=</span> <span class="n">pinv_extended</span><span class="p">(</span><span class="n">evaluated_hessian</span><span class="p">[</span><span class="n">mask</span><span class="p">])</span>
            <span class="n">neg_cov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">evaluated_hessian</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">neg_cov</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="p">(</span><span class="n">neg_cov</span><span class="p">,</span> <span class="n">singular_values</span><span class="p">)</span> <span class="o">=</span> <span class="n">pinv_extended</span><span class="p">(</span><span class="n">evaluated_hessian</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">includes_fixed</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rank</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_rank</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">matrix_rank</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">singular_values</span><span class="p">))</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">neg_cov</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">cov_params_opg</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        (array) The variance / covariance matrix. Computed using the outer</span>
<span class="sd">        product of gradients method.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cov_params_opg</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cov_approx_complex_step</span><span class="p">,</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">_cov_approx_centered</span><span class="p">)</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">cov_params_robust</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        (array) The QMLE variance / covariance matrix. Alias for</span>
<span class="sd">        `cov_params_robust_oim`</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cov_params_robust_oim</span>

    <span class="k">def</span> <span class="nf">_cov_params_robust_oim</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">approx_complex_step</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                               <span class="n">approx_centered</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="n">cov_opg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cov_params_opg</span><span class="p">(</span><span class="n">approx_complex_step</span><span class="o">=</span><span class="n">approx_complex_step</span><span class="p">,</span>
                                       <span class="n">approx_centered</span><span class="o">=</span><span class="n">approx_centered</span><span class="p">)</span>

        <span class="n">evaluated_hessian</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs_effective</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">hessian</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="n">hessian_method</span><span class="o">=</span><span class="s1">'oim'</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">includes_fixed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">approx_complex_step</span><span class="o">=</span><span class="n">approx_complex_step</span><span class="p">,</span>
            <span class="n">approx_centered</span><span class="o">=</span><span class="n">approx_centered</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fixed_params</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_free_params_index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_free_params_index</span><span class="p">)</span>
            <span class="n">cov_params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">evaluated_hessian</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

            <span class="n">cov_opg</span> <span class="o">=</span> <span class="n">cov_opg</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
            <span class="n">evaluated_hessian</span> <span class="o">=</span> <span class="n">evaluated_hessian</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>

            <span class="n">tmp</span><span class="p">,</span> <span class="n">singular_values</span> <span class="o">=</span> <span class="n">pinv_extended</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">evaluated_hessian</span><span class="p">,</span> <span class="n">cov_opg</span><span class="p">),</span> <span class="n">evaluated_hessian</span><span class="p">))</span>

            <span class="n">cov_params</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="p">(</span><span class="n">cov_params</span><span class="p">,</span> <span class="n">singular_values</span><span class="p">)</span> <span class="o">=</span> <span class="n">pinv_extended</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">evaluated_hessian</span><span class="p">,</span> <span class="n">cov_opg</span><span class="p">),</span> <span class="n">evaluated_hessian</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">includes_fixed</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rank</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_rank</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">matrix_rank</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">singular_values</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">cov_params</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">cov_params_robust_oim</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        (array) The QMLE variance / covariance matrix. Computed using the</span>
<span class="sd">        method from Harvey (1989) as the evaluated hessian.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cov_params_robust_oim</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cov_approx_complex_step</span><span class="p">,</span>
                                           <span class="bp">self</span><span class="o">.</span><span class="n">_cov_approx_centered</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_cov_params_robust_approx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">approx_complex_step</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                  <span class="n">approx_centered</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="n">cov_opg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cov_params_opg</span><span class="p">(</span><span class="n">approx_complex_step</span><span class="o">=</span><span class="n">approx_complex_step</span><span class="p">,</span>
                                       <span class="n">approx_centered</span><span class="o">=</span><span class="n">approx_centered</span><span class="p">)</span>

        <span class="n">evaluated_hessian</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs_effective</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">hessian</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">includes_fixed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">method</span><span class="o">=</span><span class="s1">'approx'</span><span class="p">,</span> <span class="n">approx_complex_step</span><span class="o">=</span><span class="n">approx_complex_step</span><span class="p">)</span>
        <span class="c1"># TODO: Case with "not approx_complex_step" is not</span>
        <span class="c1"># hit in tests as of 2017-05-19</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fixed_params</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_free_params_index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_free_params_index</span><span class="p">)</span>
            <span class="n">cov_params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">evaluated_hessian</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

            <span class="n">cov_opg</span> <span class="o">=</span> <span class="n">cov_opg</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
            <span class="n">evaluated_hessian</span> <span class="o">=</span> <span class="n">evaluated_hessian</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>

            <span class="n">tmp</span><span class="p">,</span> <span class="n">singular_values</span> <span class="o">=</span> <span class="n">pinv_extended</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">evaluated_hessian</span><span class="p">,</span> <span class="n">cov_opg</span><span class="p">),</span> <span class="n">evaluated_hessian</span><span class="p">))</span>

            <span class="n">cov_params</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="p">(</span><span class="n">cov_params</span><span class="p">,</span> <span class="n">singular_values</span><span class="p">)</span> <span class="o">=</span> <span class="n">pinv_extended</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">evaluated_hessian</span><span class="p">,</span> <span class="n">cov_opg</span><span class="p">),</span> <span class="n">evaluated_hessian</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">includes_fixed</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rank</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_rank</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">matrix_rank</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">singular_values</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">cov_params</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">cov_params_robust_approx</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        (array) The QMLE variance / covariance matrix. Computed using the</span>
<span class="sd">        numerical Hessian as the evaluated hessian.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cov_params_robust_approx</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cov_approx_complex_step</span><span class="p">,</span>
                                              <span class="bp">self</span><span class="o">.</span><span class="n">_cov_approx_centered</span><span class="p">)</span>

<div class="viewcode-block" id="MLEResults.info_criteria"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEResults.info_criteria.html#statsmodels.tsa.statespace.structural.MLEResults.info_criteria">[docs]</a>    <span class="k">def</span> <span class="nf">info_criteria</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">criteria</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">'standard'</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">"""</span>
<span class="sd">        Information criteria</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        criteria : {'aic', 'bic', 'hqic'}</span>
<span class="sd">            The information criteria to compute.</span>
<span class="sd">        method : {'standard', 'lutkepohl'}</span>
<span class="sd">            The method for information criteria computation. Default is</span>
<span class="sd">            'standard' method; 'lutkepohl' computes the information criteria</span>
<span class="sd">            as in Lütkepohl (2007). See Notes for formulas.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The `'standard'` formulas are:</span>

<span class="sd">        .. math::</span>

<span class="sd">            AIC &amp; = -2 \log L(Y_n | \hat \psi) + 2 k \\</span>
<span class="sd">            BIC &amp; = -2 \log L(Y_n | \hat \psi) + k \log n \\</span>
<span class="sd">            HQIC &amp; = -2 \log L(Y_n | \hat \psi) + 2 k \log \log n \\</span>

<span class="sd">        where :math:`\hat \psi` are the maximum likelihood estimates of the</span>
<span class="sd">        parameters, :math:`n` is the number of observations, and `k` is the</span>
<span class="sd">        number of estimated parameters.</span>

<span class="sd">        Note that the `'standard'` formulas are returned from the `aic`, `bic`,</span>
<span class="sd">        and `hqic` results attributes.</span>

<span class="sd">        The `'lutkepohl'` formulas are (Lütkepohl, 2010):</span>

<span class="sd">        .. math::</span>

<span class="sd">            AIC_L &amp; = \log | Q | + \frac{2 k}{n} \\</span>
<span class="sd">            BIC_L &amp; = \log | Q | + \frac{k \log n}{n} \\</span>
<span class="sd">            HQIC_L &amp; = \log | Q | + \frac{2 k \log \log n}{n} \\</span>

<span class="sd">        where :math:`Q` is the state covariance matrix. Note that the Lütkepohl</span>
<span class="sd">        definitions do not apply to all state space models, and should be used</span>
<span class="sd">        with care outside of SARIMAX and VARMAX models.</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        .. [*] Lütkepohl, Helmut. 2007. *New Introduction to Multiple Time*</span>
<span class="sd">           *Series Analysis.* Berlin: Springer.</span>
<span class="sd">        """</span>
        <span class="n">criteria</span> <span class="o">=</span> <span class="n">criteria</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="n">method</span> <span class="o">=</span> <span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">'standard'</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">criteria</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">'lutkepohl'</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_results</span><span class="o">.</span><span class="n">state_cov</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'Cannot compute Lütkepohl statistics for'</span>
                                 <span class="s1">' models with time-varying state covariance'</span>
                                 <span class="s1">' matrix.'</span><span class="p">)</span>

            <span class="n">cov</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_results</span><span class="o">.</span><span class="n">state_cov</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">criteria</span> <span class="o">==</span> <span class="s1">'aic'</span><span class="p">:</span>
                <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">slogdet</span><span class="p">(</span><span class="n">cov</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span>
                                 <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">df_model</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs_effective</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">criteria</span> <span class="o">==</span> <span class="s1">'bic'</span><span class="p">:</span>
                <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">slogdet</span><span class="p">(</span><span class="n">cov</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span>
                                 <span class="bp">self</span><span class="o">.</span><span class="n">df_model</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nobs_effective</span><span class="p">)</span> <span class="o">/</span>
                                 <span class="bp">self</span><span class="o">.</span><span class="n">nobs_effective</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">criteria</span> <span class="o">==</span> <span class="s1">'hqic'</span><span class="p">:</span>
                <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">slogdet</span><span class="p">(</span><span class="n">cov</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span>
                                 <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">df_model</span> <span class="o">*</span>
                                 <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nobs_effective</span><span class="p">))</span> <span class="o">/</span>
                                 <span class="bp">self</span><span class="o">.</span><span class="n">nobs_effective</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'Invalid information criteria'</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'Invalid information criteria computation method'</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">out</span></div>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">fittedvalues</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        (array) The predicted values of the model. An (nobs x k_endog) array.</span>
<span class="sd">        """</span>
        <span class="c1"># This is a (k_endog x nobs array; do not want to squeeze in case of</span>
        <span class="c1"># the corner case where nobs = 1 (mostly a concern in the predict or</span>
        <span class="c1"># forecast functions, but here also to maintain consistency)</span>
        <span class="n">fittedvalues</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">forecasts</span>
        <span class="k">if</span> <span class="n">fittedvalues</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">elif</span> <span class="n">fittedvalues</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">fittedvalues</span> <span class="o">=</span> <span class="n">fittedvalues</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fittedvalues</span> <span class="o">=</span> <span class="n">fittedvalues</span><span class="o">.</span><span class="n">T</span>
        <span class="k">return</span> <span class="n">fittedvalues</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">hqic</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        (float) Hannan-Quinn Information Criterion</span>
<span class="sd">        """</span>
        <span class="c1"># return (-2 * self.llf +</span>
        <span class="c1">#         2 * np.log(np.log(self.nobs_effective)) * self.df_model)</span>
        <span class="k">return</span> <span class="n">hqic</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">llf</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs_effective</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">df_model</span><span class="p">)</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">llf_obs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        (float) The value of the log-likelihood function evaluated at `params`.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_results</span><span class="o">.</span><span class="n">llf_obs</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">llf</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        (float) The value of the log-likelihood function evaluated at `params`.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_results</span><span class="o">.</span><span class="n">llf</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">loglikelihood_burn</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        (float) The number of observations during which the likelihood is not</span>
<span class="sd">        evaluated.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_results</span><span class="o">.</span><span class="n">loglikelihood_burn</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">mae</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        (float) Mean absolute error</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">resid</span><span class="p">))</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">mse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        (float) Mean squared error</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sse</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">pvalues</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        (array) The p-values associated with the z-statistics of the</span>
<span class="sd">        coefficients. Note that the coefficients are assumed to have a Normal</span>
<span class="sd">        distribution.</span>
<span class="sd">        """</span>
        <span class="n">pvalues</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">zvalues</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">pvalues</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="n">mask</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_free_params_index</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">mask</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">zvalues</span><span class="p">)</span>
        <span class="n">pvalues</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">sf</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">zvalues</span><span class="p">[</span><span class="n">mask</span><span class="p">]))</span> <span class="o">*</span> <span class="mi">2</span>
        <span class="k">return</span> <span class="n">pvalues</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">resid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        (array) The model residuals. An (nobs x k_endog) array.</span>
<span class="sd">        """</span>
        <span class="c1"># This is a (k_endog x nobs array; do not want to squeeze in case of</span>
        <span class="c1"># the corner case where nobs = 1 (mostly a concern in the predict or</span>
        <span class="c1"># forecast functions, but here also to maintain consistency)</span>
        <span class="n">resid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">forecasts_error</span>
        <span class="k">if</span> <span class="n">resid</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">elif</span> <span class="n">resid</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">resid</span> <span class="o">=</span> <span class="n">resid</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">resid</span> <span class="o">=</span> <span class="n">resid</span><span class="o">.</span><span class="n">T</span>
        <span class="k">return</span> <span class="n">resid</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">states</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">_index_generated</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">_index_none</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">'No supported index is available. The `states`'</span>
                          <span class="s1">' DataFrame uses a generated integer index'</span><span class="p">,</span>
                          <span class="n">ValueWarning</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_states</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">sse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        (float) Sum of squared errors</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">resid</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">zvalues</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        (array) The z-statistics for the coefficients.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">bse</span>

    <span class="k">def</span> <span class="nf">test_normality</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Test for normality of standardized residuals.</span>

<span class="sd">        Null hypothesis is normality.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        method : {'jarquebera', None}</span>
<span class="sd">            The statistical test for normality. Must be 'jarquebera' for</span>
<span class="sd">            Jarque-Bera normality test. If None, an attempt is made to select</span>
<span class="sd">            an appropriate test.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Let `d` = max(loglikelihood_burn, nobs_diffuse); this test is</span>
<span class="sd">        calculated ignoring the first `d` residuals.</span>

<span class="sd">        In the case of missing data, the maintained hypothesis is that the</span>
<span class="sd">        data are missing completely at random. This test is then run on the</span>
<span class="sd">        standardized residuals excluding those corresponding to missing</span>
<span class="sd">        observations.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        statsmodels.stats.stattools.jarque_bera</span>
<span class="sd">            The Jarque-Bera test of normality.</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="n">method</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">method</span> <span class="o">=</span> <span class="s1">'jarquebera'</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">standardized_forecasts_error</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'Cannot compute test statistic when standardized'</span>
                             <span class="s1">' forecast errors have not been computed.'</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">'jarquebera'</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">statsmodels.stats.stattools</span> <span class="kn">import</span> <span class="n">jarque_bera</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loglikelihood_burn</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs_diffuse</span><span class="p">)</span>
            <span class="n">output</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">k_endog</span><span class="p">):</span>
                <span class="n">resid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_results</span><span class="o">.</span><span class="n">standardized_forecasts_error</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">d</span><span class="p">:]</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">resid</span><span class="p">)</span>
                <span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">jarque_bera</span><span class="p">(</span><span class="n">resid</span><span class="p">[</span><span class="n">mask</span><span class="p">]))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">'Invalid normality test method.'</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">test_heteroskedasticity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">alternative</span><span class="o">=</span><span class="s1">'two-sided'</span><span class="p">,</span>
                                <span class="n">use_f</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">"""</span>
<span class="sd">        Test for heteroskedasticity of standardized residuals</span>

<span class="sd">        Tests whether the sum-of-squares in the first third of the sample is</span>
<span class="sd">        significantly different than the sum-of-squares in the last third</span>
<span class="sd">        of the sample. Analogous to a Goldfeld-Quandt test. The null hypothesis</span>
<span class="sd">        is of no heteroskedasticity.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        method : {'breakvar', None}</span>
<span class="sd">            The statistical test for heteroskedasticity. Must be 'breakvar'</span>
<span class="sd">            for test of a break in the variance. If None, an attempt is</span>
<span class="sd">            made to select an appropriate test.</span>
<span class="sd">        alternative : str, 'increasing', 'decreasing' or 'two-sided'</span>
<span class="sd">            This specifies the alternative for the p-value calculation. Default</span>
<span class="sd">            is two-sided.</span>
<span class="sd">        use_f : bool, optional</span>
<span class="sd">            Whether or not to compare against the asymptotic distribution</span>
<span class="sd">            (chi-squared) or the approximate small-sample distribution (F).</span>
<span class="sd">            Default is True (i.e. default is to compare against an F</span>
<span class="sd">            distribution).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        output : ndarray</span>
<span class="sd">            An array with `(test_statistic, pvalue)` for each endogenous</span>
<span class="sd">            variable. The array is then sized `(k_endog, 2)`. If the method is</span>
<span class="sd">            called as `het = res.test_heteroskedasticity()`, then `het[0]` is</span>
<span class="sd">            an array of size 2 corresponding to the first endogenous variable,</span>
<span class="sd">            where `het[0][0]` is the test statistic, and `het[0][1]` is the</span>
<span class="sd">            p-value.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The null hypothesis is of no heteroskedasticity. That means different</span>
<span class="sd">        things depending on which alternative is selected:</span>

<span class="sd">        - Increasing: Null hypothesis is that the variance is not increasing</span>
<span class="sd">          throughout the sample; that the sum-of-squares in the later</span>
<span class="sd">          subsample is *not* greater than the sum-of-squares in the earlier</span>
<span class="sd">          subsample.</span>
<span class="sd">        - Decreasing: Null hypothesis is that the variance is not decreasing</span>
<span class="sd">          throughout the sample; that the sum-of-squares in the earlier</span>
<span class="sd">          subsample is *not* greater than the sum-of-squares in the later</span>
<span class="sd">          subsample.</span>
<span class="sd">        - Two-sided: Null hypothesis is that the variance is not changing</span>
<span class="sd">          throughout the sample. Both that the sum-of-squares in the earlier</span>
<span class="sd">          subsample is not greater than the sum-of-squares in the later</span>
<span class="sd">          subsample *and* that the sum-of-squares in the later subsample is</span>
<span class="sd">          not greater than the sum-of-squares in the earlier subsample.</span>

<span class="sd">        For :math:`h = [T/3]`, the test statistic is:</span>

<span class="sd">        .. math::</span>

<span class="sd">            H(h) = \sum_{t=T-h+1}^T  \tilde v_t^2</span>
<span class="sd">            \Bigg / \sum_{t=d+1}^{d+1+h} \tilde v_t^2</span>

<span class="sd">        where :math:`d` = max(loglikelihood_burn, nobs_diffuse)` (usually</span>
<span class="sd">        corresponding to diffuse initialization under either the approximate</span>
<span class="sd">        or exact approach).</span>

<span class="sd">        This statistic can be tested against an :math:`F(h,h)` distribution.</span>
<span class="sd">        Alternatively, :math:`h H(h)` is asymptotically distributed according</span>
<span class="sd">        to :math:`\chi_h^2`; this second test can be applied by passing</span>
<span class="sd">        `asymptotic=True` as an argument.</span>

<span class="sd">        See section 5.4 of [1]_ for the above formula and discussion, as well</span>
<span class="sd">        as additional details.</span>

<span class="sd">        TODO</span>

<span class="sd">        - Allow specification of :math:`h`</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        .. [1] Harvey, Andrew C. 1990. *Forecasting, Structural Time Series*</span>
<span class="sd">               *Models and the Kalman Filter.* Cambridge University Press.</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="n">method</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">method</span> <span class="o">=</span> <span class="s1">'breakvar'</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">standardized_forecasts_error</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'Cannot compute test statistic when standardized'</span>
                             <span class="s1">' forecast errors have not been computed.'</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">'breakvar'</span><span class="p">:</span>
            <span class="c1"># Store some values</span>
            <span class="n">squared_resid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_results</span><span class="o">.</span><span class="n">standardized_forecasts_error</span><span class="o">**</span><span class="mi">2</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loglikelihood_burn</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs_diffuse</span><span class="p">)</span>
            <span class="c1"># This differs from self.nobs_effective because here we want to</span>
            <span class="c1"># exclude exact diffuse periods, whereas self.nobs_effective only</span>
            <span class="c1"># excludes explicitly burned (usually approximate diffuse) periods.</span>
            <span class="n">nobs_effective</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span> <span class="o">-</span> <span class="n">d</span>

            <span class="n">test_statistics</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">p_values</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">k_endog</span><span class="p">):</span>
                <span class="n">h</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">nobs_effective</span> <span class="o">/</span> <span class="mi">3</span><span class="p">))</span>
                <span class="n">numer_resid</span> <span class="o">=</span> <span class="n">squared_resid</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="o">-</span><span class="n">h</span><span class="p">:]</span>
                <span class="n">numer_resid</span> <span class="o">=</span> <span class="n">numer_resid</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">numer_resid</span><span class="p">)]</span>
                <span class="n">numer_dof</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">numer_resid</span><span class="p">)</span>

                <span class="n">denom_resid</span> <span class="o">=</span> <span class="n">squared_resid</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">d</span><span class="p">:</span><span class="n">d</span><span class="o">+</span><span class="n">h</span><span class="p">]</span>
                <span class="n">denom_resid</span> <span class="o">=</span> <span class="n">denom_resid</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">denom_resid</span><span class="p">)]</span>
                <span class="n">denom_dof</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">denom_resid</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">numer_dof</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">'Early subset of data for variable </span><span class="si">%d</span><span class="s1">'</span>
                                  <span class="s1">'  has too few non-missing observations to'</span>
                                  <span class="s1">' calculate test statistic.'</span> <span class="o">%</span> <span class="n">i</span><span class="p">)</span>
                    <span class="n">numer_resid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="k">if</span> <span class="n">denom_dof</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">'Later subset of data for variable </span><span class="si">%d</span><span class="s1">'</span>
                                  <span class="s1">'  has too few non-missing observations to'</span>
                                  <span class="s1">' calculate test statistic.'</span> <span class="o">%</span> <span class="n">i</span><span class="p">)</span>
                    <span class="n">denom_resid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

                <span class="n">test_statistic</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">numer_resid</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">denom_resid</span><span class="p">)</span>

                <span class="c1"># Setup functions to calculate the p-values</span>
                <span class="k">if</span> <span class="n">use_f</span><span class="p">:</span>
                    <span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">f</span>
                    <span class="n">pval_lower</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">test_statistics</span><span class="p">:</span> <span class="n">f</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span>  <span class="c1"># noqa:E731</span>
                        <span class="n">test_statistics</span><span class="p">,</span> <span class="n">numer_dof</span><span class="p">,</span> <span class="n">denom_dof</span><span class="p">)</span>
                    <span class="n">pval_upper</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">test_statistics</span><span class="p">:</span> <span class="n">f</span><span class="o">.</span><span class="n">sf</span><span class="p">(</span>  <span class="c1"># noqa:E731</span>
                        <span class="n">test_statistics</span><span class="p">,</span> <span class="n">numer_dof</span><span class="p">,</span> <span class="n">denom_dof</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">chi2</span>
                    <span class="n">pval_lower</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">test_statistics</span><span class="p">:</span> <span class="n">chi2</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span>  <span class="c1"># noqa:E731</span>
                        <span class="n">numer_dof</span> <span class="o">*</span> <span class="n">test_statistics</span><span class="p">,</span> <span class="n">denom_dof</span><span class="p">)</span>
                    <span class="n">pval_upper</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">test_statistics</span><span class="p">:</span> <span class="n">chi2</span><span class="o">.</span><span class="n">sf</span><span class="p">(</span>  <span class="c1"># noqa:E731</span>
                        <span class="n">numer_dof</span> <span class="o">*</span> <span class="n">test_statistics</span><span class="p">,</span> <span class="n">denom_dof</span><span class="p">)</span>

                <span class="c1"># Calculate the one- or two-sided p-values</span>
                <span class="n">alternative</span> <span class="o">=</span> <span class="n">alternative</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">alternative</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">'i'</span><span class="p">,</span> <span class="s1">'inc'</span><span class="p">,</span> <span class="s1">'increasing'</span><span class="p">]:</span>
                    <span class="n">p_value</span> <span class="o">=</span> <span class="n">pval_upper</span><span class="p">(</span><span class="n">test_statistic</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">alternative</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">'d'</span><span class="p">,</span> <span class="s1">'dec'</span><span class="p">,</span> <span class="s1">'decreasing'</span><span class="p">]:</span>
                    <span class="n">test_statistic</span> <span class="o">=</span> <span class="mf">1.</span> <span class="o">/</span> <span class="n">test_statistic</span>
                    <span class="n">p_value</span> <span class="o">=</span> <span class="n">pval_upper</span><span class="p">(</span><span class="n">test_statistic</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">alternative</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">'2'</span><span class="p">,</span> <span class="s1">'2-sided'</span><span class="p">,</span> <span class="s1">'two-sided'</span><span class="p">]:</span>
                    <span class="n">p_value</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span>
                        <span class="n">pval_lower</span><span class="p">(</span><span class="n">test_statistic</span><span class="p">),</span>
                        <span class="n">pval_upper</span><span class="p">(</span><span class="n">test_statistic</span><span class="p">)</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'Invalid alternative.'</span><span class="p">)</span>

                <span class="n">test_statistics</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">test_statistic</span><span class="p">)</span>
                <span class="n">p_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p_value</span><span class="p">)</span>

            <span class="n">output</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">test_statistics</span><span class="p">,</span> <span class="n">p_values</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">'Invalid heteroskedasticity test'</span>
                                      <span class="s1">' method.'</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">output</span>

    <span class="k">def</span> <span class="nf">test_serial_correlation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">lags</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Ljung-Box test for no serial correlation of standardized residuals</span>

<span class="sd">        Null hypothesis is no serial correlation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        method : {'ljungbox','boxpierece', None}</span>
<span class="sd">            The statistical test for serial correlation. If None, an attempt is</span>
<span class="sd">            made to select an appropriate test.</span>
<span class="sd">        lags : None, int or array_like</span>
<span class="sd">            If lags is an integer then this is taken to be the largest lag</span>
<span class="sd">            that is included, the test result is reported for all smaller lag</span>
<span class="sd">            length.</span>
<span class="sd">            If lags is a list or array, then all lags are included up to the</span>
<span class="sd">            largest lag in the list, however only the tests for the lags in the</span>
<span class="sd">            list are reported.</span>
<span class="sd">            If lags is None, then the default maxlag is 12*(nobs/100)^{1/4}</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        output : ndarray</span>
<span class="sd">            An array with `(test_statistic, pvalue)` for each endogenous</span>
<span class="sd">            variable and each lag. The array is then sized</span>
<span class="sd">            `(k_endog, 2, lags)`. If the method is called as</span>
<span class="sd">            `ljungbox = res.test_serial_correlation()`, then `ljungbox[i]`</span>
<span class="sd">            holds the results of the Ljung-Box test (as would be returned by</span>
<span class="sd">            `statsmodels.stats.diagnostic.acorr_ljungbox`) for the `i` th</span>
<span class="sd">            endogenous variable.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Let `d` = max(loglikelihood_burn, nobs_diffuse); this test is</span>
<span class="sd">        calculated ignoring the first `d` residuals.</span>

<span class="sd">        Output is nan for any endogenous variable which has missing values.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        statsmodels.stats.diagnostic.acorr_ljungbox</span>
<span class="sd">            Ljung-Box test for serial correlation.</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="n">method</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">method</span> <span class="o">=</span> <span class="s1">'ljungbox'</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">standardized_forecasts_error</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'Cannot compute test statistic when standardized'</span>
                             <span class="s1">' forecast errors have not been computed.'</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">'ljungbox'</span> <span class="ow">or</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">'boxpierce'</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">statsmodels.stats.diagnostic</span> <span class="kn">import</span> <span class="n">acorr_ljungbox</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loglikelihood_burn</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs_diffuse</span><span class="p">)</span>
            <span class="c1"># This differs from self.nobs_effective because here we want to</span>
            <span class="c1"># exclude exact diffuse periods, whereas self.nobs_effective only</span>
            <span class="c1"># excludes explicitly burned (usually approximate diffuse) periods.</span>
            <span class="n">nobs_effective</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span> <span class="o">-</span> <span class="n">d</span>
            <span class="n">output</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="c1"># Default lags for acorr_ljungbox is 40, but may not always have</span>
            <span class="c1"># that many observations</span>
            <span class="k">if</span> <span class="n">lags</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">lags</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="mi">40</span><span class="p">,</span> <span class="n">nobs_effective</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">k_endog</span><span class="p">):</span>
                <span class="n">results</span> <span class="o">=</span> <span class="n">acorr_ljungbox</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">filter_results</span><span class="o">.</span><span class="n">standardized_forecasts_error</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">d</span><span class="p">:],</span>
                    <span class="n">lags</span><span class="o">=</span><span class="n">lags</span><span class="p">,</span> <span class="n">boxpierce</span><span class="o">=</span><span class="p">(</span><span class="n">method</span> <span class="o">==</span> <span class="s1">'boxpierce'</span><span class="p">),</span>
                    <span class="n">return_df</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">'ljungbox'</span><span class="p">:</span>
                    <span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="mi">2</span><span class="p">:])</span>

            <span class="n">output</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">output</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">'Invalid serial correlation test'</span>
                                      <span class="s1">' method.'</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">output</span>

<div class="viewcode-block" id="MLEResults.get_prediction"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEResults.get_prediction.html#statsmodels.tsa.statespace.structural.MLEResults.get_prediction">[docs]</a>    <span class="k">def</span> <span class="nf">get_prediction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dynamic</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                       <span class="n">index</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">exog</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">extend_model</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                       <span class="n">extend_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        In-sample prediction and out-of-sample forecasting</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        start : int, str, or datetime, optional</span>
<span class="sd">            Zero-indexed observation number at which to start forecasting,</span>
<span class="sd">            i.e., the first forecast is start. Can also be a date string to</span>
<span class="sd">            parse or a datetime type. Default is the the zeroth observation.</span>
<span class="sd">        end : int, str, or datetime, optional</span>
<span class="sd">            Zero-indexed observation number at which to end forecasting, i.e.,</span>
<span class="sd">            the last forecast is end. Can also be a date string to</span>
<span class="sd">            parse or a datetime type. However, if the dates index does not</span>
<span class="sd">            have a fixed frequency, end must be an integer index if you</span>
<span class="sd">            want out of sample prediction. Default is the last observation in</span>
<span class="sd">            the sample.</span>
<span class="sd">        dynamic : bool, int, str, or datetime, optional</span>
<span class="sd">            Integer offset relative to `start` at which to begin dynamic</span>
<span class="sd">            prediction. Can also be an absolute date string to parse or a</span>
<span class="sd">            datetime type (these are not interpreted as offsets).</span>
<span class="sd">            Prior to this observation, true endogenous values will be used for</span>
<span class="sd">            prediction; starting with this observation and continuing through</span>
<span class="sd">            the end of prediction, forecasted endogenous values will be used</span>
<span class="sd">            instead.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Additional arguments may required for forecasting beyond the end</span>
<span class="sd">            of the sample. See `FilterResults.predict` for more details.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        forecast : ndarray</span>
<span class="sd">            Array of out of in-sample predictions and / or out-of-sample</span>
<span class="sd">            forecasts. An (npredict x k_endog) array.</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Handle start, end, dynamic</span>
        <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">out_of_sample</span><span class="p">,</span> <span class="n">prediction_index</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">_get_prediction_index</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">index</span><span class="p">))</span>

        <span class="c1"># Handle `dynamic`</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dynamic</span><span class="p">,</span> <span class="p">(</span><span class="nb">bytes</span><span class="p">,</span> <span class="nb">str</span><span class="p">)):</span>
            <span class="n">dynamic</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">_get_index_loc</span><span class="p">(</span><span class="n">dynamic</span><span class="p">)</span>

        <span class="c1"># If we have out-of-sample forecasting and `exog` or in general any</span>
        <span class="c1"># kind of time-varying state space model, then we need to create an</span>
        <span class="c1"># extended model to get updated state space system matrices</span>
        <span class="k">if</span> <span class="n">extend_model</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">extend_model</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">exog</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span>
                            <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_results</span><span class="o">.</span><span class="n">time_invariant</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">out_of_sample</span> <span class="ow">and</span> <span class="n">extend_model</span><span class="p">:</span>
            <span class="n">kwargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">_get_extension_time_varying_matrices</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="n">exog</span><span class="p">,</span> <span class="n">out_of_sample</span><span class="p">,</span> <span class="n">extend_kwargs</span><span class="p">,</span>
                <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">includes_fixed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Make sure the model class has the current parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">includes_fixed</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Perform the prediction</span>
        <span class="c1"># This is a (k_endog x npredictions) array; do not want to squeeze in</span>
        <span class="c1"># case of npredictions = 1</span>
        <span class="n">prediction_results</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_results</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span>
            <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">+</span> <span class="n">out_of_sample</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dynamic</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Return a new mlemodel.PredictionResults object</span>
        <span class="k">return</span> <span class="n">PredictionResultsWrapper</span><span class="p">(</span><span class="n">PredictionResults</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">prediction_results</span><span class="p">,</span> <span class="n">row_labels</span><span class="o">=</span><span class="n">prediction_index</span><span class="p">))</span></div>

<div class="viewcode-block" id="MLEResults.get_forecast"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEResults.get_forecast.html#statsmodels.tsa.statespace.structural.MLEResults.get_forecast">[docs]</a>    <span class="k">def</span> <span class="nf">get_forecast</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">steps</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Out-of-sample forecasts</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        steps : int, str, or datetime, optional</span>
<span class="sd">            If an integer, the number of steps to forecast from the end of the</span>
<span class="sd">            sample. Can also be a date string to parse or a datetime type.</span>
<span class="sd">            However, if the dates index does not have a fixed frequency, steps</span>
<span class="sd">            must be an integer. Default</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Additional arguments may required for forecasting beyond the end</span>
<span class="sd">            of the sample. See `FilterResults.predict` for more details.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        forecast : ndarray</span>
<span class="sd">            Array of out of sample forecasts. A (steps x k_endog) array.</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">steps</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span> <span class="o">+</span> <span class="n">steps</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">end</span> <span class="o">=</span> <span class="n">steps</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_prediction</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="n">end</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="MLEResults.predict"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEResults.predict.html#statsmodels.tsa.statespace.structural.MLEResults.predict">[docs]</a>    <span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dynamic</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        In-sample prediction and out-of-sample forecasting</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        start : int, str, or datetime, optional</span>
<span class="sd">            Zero-indexed observation number at which to start forecasting,</span>
<span class="sd">            i.e., the first forecast is start. Can also be a date string to</span>
<span class="sd">            parse or a datetime type. Default is the the zeroth observation.</span>
<span class="sd">        end : int, str, or datetime, optional</span>
<span class="sd">            Zero-indexed observation number at which to end forecasting, i.e.,</span>
<span class="sd">            the last forecast is end. Can also be a date string to</span>
<span class="sd">            parse or a datetime type. However, if the dates index does not</span>
<span class="sd">            have a fixed frequency, end must be an integer index if you</span>
<span class="sd">            want out of sample prediction. Default is the last observation in</span>
<span class="sd">            the sample.</span>
<span class="sd">        dynamic : bool, int, str, or datetime, optional</span>
<span class="sd">            Integer offset relative to `start` at which to begin dynamic</span>
<span class="sd">            prediction. Can also be an absolute date string to parse or a</span>
<span class="sd">            datetime type (these are not interpreted as offsets).</span>
<span class="sd">            Prior to this observation, true endogenous values will be used for</span>
<span class="sd">            prediction; starting with this observation and continuing through</span>
<span class="sd">            the end of prediction, forecasted endogenous values will be used</span>
<span class="sd">            instead.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Additional arguments may required for forecasting beyond the end</span>
<span class="sd">            of the sample. See `FilterResults.predict` for more details.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        forecast : array_like</span>
<span class="sd">            Array of out of in-sample predictions and / or out-of-sample</span>
<span class="sd">            forecasts. An (npredict x k_endog) array.</span>
<span class="sd">        """</span>
        <span class="c1"># Perform the prediction</span>
        <span class="n">prediction_results</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_prediction</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">dynamic</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">prediction_results</span><span class="o">.</span><span class="n">predicted_mean</span></div>

<div class="viewcode-block" id="MLEResults.forecast"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEResults.forecast.html#statsmodels.tsa.statespace.structural.MLEResults.forecast">[docs]</a>    <span class="k">def</span> <span class="nf">forecast</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">steps</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Out-of-sample forecasts</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        steps : int, str, or datetime, optional</span>
<span class="sd">            If an integer, the number of steps to forecast from the end of the</span>
<span class="sd">            sample. Can also be a date string to parse or a datetime type.</span>
<span class="sd">            However, if the dates index does not have a fixed frequency, steps</span>
<span class="sd">            must be an integer. Default</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Additional arguments may required for forecasting beyond the end</span>
<span class="sd">            of the sample. See `FilterResults.predict` for more details.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        forecast : ndarray</span>
<span class="sd">            Array of out of sample forecasts. A (steps x k_endog) array.</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">steps</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span> <span class="o">+</span> <span class="n">steps</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">end</span> <span class="o">=</span> <span class="n">steps</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="n">end</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">simulate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nsimulations</span><span class="p">,</span> <span class="n">measurement_shocks</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">state_shocks</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">initial_state</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">anchor</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">repetitions</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">exog</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">extend_model</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">extend_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">"""</span>
<span class="sd">        Simulate a new time series following the state space model</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nsimulations : int</span>
<span class="sd">            The number of observations to simulate. If the model is</span>
<span class="sd">            time-invariant this can be any number. If the model is</span>
<span class="sd">            time-varying, then this number must be less than or equal to the</span>
<span class="sd">            number</span>
<span class="sd">        measurement_shocks : array_like, optional</span>
<span class="sd">            If specified, these are the shocks to the measurement equation,</span>
<span class="sd">            :math:`\varepsilon_t`. If unspecified, these are automatically</span>
<span class="sd">            generated using a pseudo-random number generator. If specified,</span>
<span class="sd">            must be shaped `nsimulations` x `k_endog`, where `k_endog` is the</span>
<span class="sd">            same as in the state space model.</span>
<span class="sd">        state_shocks : array_like, optional</span>
<span class="sd">            If specified, these are the shocks to the state equation,</span>
<span class="sd">            :math:`\eta_t`. If unspecified, these are automatically</span>
<span class="sd">            generated using a pseudo-random number generator. If specified,</span>
<span class="sd">            must be shaped `nsimulations` x `k_posdef` where `k_posdef` is the</span>
<span class="sd">            same as in the state space model.</span>
<span class="sd">        initial_state : array_like, optional</span>
<span class="sd">            If specified, this is the initial state vector to use in</span>
<span class="sd">            simulation, which should be shaped (`k_states` x 1), where</span>
<span class="sd">            `k_states` is the same as in the state space model. If unspecified,</span>
<span class="sd">            but the model has been initialized, then that initialization is</span>
<span class="sd">            used. This must be specified if `anchor` is anything other than</span>
<span class="sd">            "start" or 0.</span>
<span class="sd">        anchor : int, str, or datetime, optional</span>
<span class="sd">            Starting point from which to begin the simulations; type depends on</span>
<span class="sd">            the index of the given `endog` model. Two special cases are the</span>
<span class="sd">            strings 'start' and 'end', which refer to starting at the beginning</span>
<span class="sd">            and end of the sample, respectively. If a date/time index was</span>
<span class="sd">            provided to the model, then this argument can be a date string to</span>
<span class="sd">            parse or a datetime type. Otherwise, an integer index should be</span>
<span class="sd">            given. Default is 'start'.</span>
<span class="sd">        repetitions : int, optional</span>
<span class="sd">            Number of simulated paths to generate. Default is 1 simulated path.</span>
<span class="sd">        exog : array_like, optional</span>
<span class="sd">            New observations of exogenous regressors, if applicable.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        simulated_obs : ndarray</span>
<span class="sd">            An array of simulated observations. If `repetitions=None`, then it</span>
<span class="sd">            will be shaped (nsimulations x k_endog) or (nsimulations,) if</span>
<span class="sd">            `k_endog=1`. Otherwise it will be shaped</span>
<span class="sd">            (nsimulations x k_endog x repetitions). If the model was given</span>
<span class="sd">            Pandas input then the output will be a Pandas object. If</span>
<span class="sd">            `k_endog &gt; 1` and `repetitions` is not None, then the output will</span>
<span class="sd">            be a Pandas DataFrame that has a MultiIndex for the columns, with</span>
<span class="sd">            the first level containing the names of the `endog` variables and</span>
<span class="sd">            the second level containing the repetition number.</span>
<span class="sd">        """</span>
        <span class="c1"># Get the starting location</span>
        <span class="k">if</span> <span class="n">anchor</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">anchor</span> <span class="o">==</span> <span class="s1">'start'</span><span class="p">:</span>
            <span class="n">iloc</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">elif</span> <span class="n">anchor</span> <span class="o">==</span> <span class="s1">'end'</span><span class="p">:</span>
            <span class="n">iloc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">iloc</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">_get_index_loc</span><span class="p">(</span><span class="n">anchor</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">iloc</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
                <span class="n">iloc</span> <span class="o">=</span> <span class="n">iloc</span><span class="o">.</span><span class="n">start</span>

        <span class="k">if</span> <span class="n">iloc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">iloc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span> <span class="o">+</span> <span class="n">iloc</span>
        <span class="k">if</span> <span class="n">iloc</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'Cannot anchor simulation outside of the sample.'</span><span class="p">)</span>

        <span class="c1"># Setup the initial state</span>
        <span class="k">if</span> <span class="n">initial_state</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">initial_state_moments</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">predicted_state</span><span class="p">[:,</span> <span class="n">iloc</span><span class="p">],</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">predicted_state_cov</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">iloc</span><span class="p">])</span>

            <span class="n">_repetitions</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">repetitions</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">repetitions</span>

            <span class="n">initial_state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">multivariate_normal</span><span class="p">(</span>
                <span class="o">*</span><span class="n">initial_state_moments</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">_repetitions</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

        <span class="n">scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_results</span><span class="o">.</span><span class="n">filter_concentrated</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">fixed_scale</span><span class="p">(</span><span class="n">scale</span><span class="p">):</span>
            <span class="n">sim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">simulate</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="n">nsimulations</span><span class="p">,</span>
                <span class="n">measurement_shocks</span><span class="o">=</span><span class="n">measurement_shocks</span><span class="p">,</span>
                <span class="n">state_shocks</span><span class="o">=</span><span class="n">state_shocks</span><span class="p">,</span> <span class="n">initial_state</span><span class="o">=</span><span class="n">initial_state</span><span class="p">,</span>
                <span class="n">anchor</span><span class="o">=</span><span class="n">anchor</span><span class="p">,</span> <span class="n">repetitions</span><span class="o">=</span><span class="n">repetitions</span><span class="p">,</span> <span class="n">exog</span><span class="o">=</span><span class="n">exog</span><span class="p">,</span>
                <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">includes_fixed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">extend_model</span><span class="o">=</span><span class="n">extend_model</span><span class="p">,</span> <span class="n">extend_kwargs</span><span class="o">=</span><span class="n">extend_kwargs</span><span class="p">,</span>
                <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">sim</span>

<div class="viewcode-block" id="MLEResults.impulse_responses"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEResults.impulse_responses.html#statsmodels.tsa.statespace.structural.MLEResults.impulse_responses">[docs]</a>    <span class="k">def</span> <span class="nf">impulse_responses</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">steps</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">impulse</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">orthogonalized</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                          <span class="n">cumulative</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Impulse response function</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        steps : int, optional</span>
<span class="sd">            The number of steps for which impulse responses are calculated.</span>
<span class="sd">            Default is 1. Note that for time-invariant models, the initial</span>
<span class="sd">            impulse is not counted as a step, so if `steps=1`, the output will</span>
<span class="sd">            have 2 entries.</span>
<span class="sd">        impulse : int or array_like</span>
<span class="sd">            If an integer, the state innovation to pulse; must be between 0</span>
<span class="sd">            and `k_posdef-1`. Alternatively, a custom impulse vector may be</span>
<span class="sd">            provided; must be shaped `k_posdef x 1`.</span>
<span class="sd">        orthogonalized : bool, optional</span>
<span class="sd">            Whether or not to perform impulse using orthogonalized innovations.</span>
<span class="sd">            Note that this will also affect custum `impulse` vectors. Default</span>
<span class="sd">            is False.</span>
<span class="sd">        cumulative : bool, optional</span>
<span class="sd">            Whether or not to return cumulative impulse responses. Default is</span>
<span class="sd">            False.</span>
<span class="sd">        anchor : int, str, or datetime, optional</span>
<span class="sd">            Time point within the sample for the state innovation impulse. Type</span>
<span class="sd">            depends on the index of the given `endog` in the model. Two special</span>
<span class="sd">            cases are the strings 'start' and 'end', which refer to setting the</span>
<span class="sd">            impulse at the first and last points of the sample, respectively.</span>
<span class="sd">            Integer values can run from 0 to `nobs - 1`, or can be negative to</span>
<span class="sd">            apply negative indexing. Finally, if a date/time index was provided</span>
<span class="sd">            to the model, then this argument can be a date string to parse or a</span>
<span class="sd">            datetime type. Default is 'start'.</span>
<span class="sd">        exog : array_like, optional</span>
<span class="sd">            New observations of exogenous regressors, if applicable.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            If the model has time-varying design or transition matrices and the</span>
<span class="sd">            combination of `anchor` and `steps` implies creating impulse</span>
<span class="sd">            responses for the out-of-sample period, then these matrices must</span>
<span class="sd">            have updated values provided for the out-of-sample steps. For</span>
<span class="sd">            example, if `design` is a time-varying component, `nobs` is 10,</span>
<span class="sd">            `anchor=1`, and `steps` is 15, a (`k_endog` x `k_states` x 7)</span>
<span class="sd">            matrix must be provided with the new design matrix values.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        impulse_responses : ndarray</span>
<span class="sd">            Responses for each endogenous variable due to the impulse</span>
<span class="sd">            given by the `impulse` argument. For a time-invariant model, the</span>
<span class="sd">            impulse responses are given for `steps + 1` elements (this gives</span>
<span class="sd">            the "initial impulse" followed by `steps` responses for the</span>
<span class="sd">            important cases of VAR and SARIMAX models), while for time-varying</span>
<span class="sd">            models the impulse responses are only given for `steps` elements</span>
<span class="sd">            (to avoid having to unexpectedly provide updated time-varying</span>
<span class="sd">            matrices).</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Intercepts in the measurement and state equation are ignored when</span>
<span class="sd">        calculating impulse responses.</span>
<span class="sd">        """</span>
        <span class="n">scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_results</span><span class="o">.</span><span class="n">filter_concentrated</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">fixed_scale</span><span class="p">(</span><span class="n">scale</span><span class="p">):</span>
            <span class="n">irfs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">impulse_responses</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="n">steps</span><span class="p">,</span> <span class="n">impulse</span><span class="p">,</span>
                                                <span class="n">orthogonalized</span><span class="p">,</span> <span class="n">cumulative</span><span class="p">,</span>
                                                <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">irfs</span></div>

    <span class="k">def</span> <span class="nf">_apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mod</span><span class="p">,</span> <span class="n">refit</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fit_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">fit_kwargs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fit_kwargs</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">if</span> <span class="n">refit</span><span class="p">:</span>
            <span class="n">fit_kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">'start_params'</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_fixed_params</span><span class="p">:</span>
                <span class="n">fit_kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">'includes_fixed'</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">mod</span><span class="o">.</span><span class="n">fit_constrained</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_fixed_params</span><span class="p">,</span> <span class="o">**</span><span class="n">fit_kwargs</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">mod</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="o">**</span><span class="n">fit_kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="s1">'cov_type'</span> <span class="ow">in</span> <span class="n">fit_kwargs</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'Cannot specify covariance type in'</span>
                                 <span class="s1">' `fit_kwargs` unless refitting'</span>
                                 <span class="s1">' parameters (not available in extend).'</span><span class="p">)</span>
            <span class="k">if</span> <span class="s1">'cov_kwds'</span> <span class="ow">in</span> <span class="n">fit_kwargs</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'Cannot specify covariance keyword arguments'</span>
                                 <span class="s1">' in `fit_kwargs` unless refitting'</span>
                                 <span class="s1">' parameters (not available in extend).'</span><span class="p">)</span>

            <span class="n">fit_kwargs</span><span class="p">[</span><span class="s1">'cov_type'</span><span class="p">]</span> <span class="o">=</span> <span class="s1">'custom'</span>
            <span class="n">fit_kwargs</span><span class="p">[</span><span class="s1">'cov_kwds'</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s1">'custom_cov_type'</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">cov_type</span><span class="p">,</span>
                <span class="s1">'custom_cov_params'</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">cov_params_default</span><span class="p">,</span>
                <span class="s1">'custom_description'</span><span class="p">:</span> <span class="p">(</span><span class="s1">'Parameters and standard errors'</span>
                                       <span class="s1">' were estimated using a different'</span>
                                       <span class="s1">' dataset and were then applied to this'</span>
                                       <span class="s1">' dataset. </span><span class="si">%s</span><span class="s1">'</span>
                                       <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">cov_kwds</span><span class="p">[</span><span class="s1">'description'</span><span class="p">])}</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">smoother_results</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">func</span> <span class="o">=</span> <span class="n">mod</span><span class="o">.</span><span class="n">smooth</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">func</span> <span class="o">=</span> <span class="n">mod</span><span class="o">.</span><span class="n">filter</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_fixed_params</span><span class="p">:</span>
                <span class="k">with</span> <span class="n">mod</span><span class="o">.</span><span class="n">fix_params</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_fixed_params</span><span class="p">):</span>
                    <span class="n">fit_kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">'includes_fixed'</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
                    <span class="n">res</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="o">**</span><span class="n">fit_kwargs</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="o">**</span><span class="n">fit_kwargs</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">res</span>

<div class="viewcode-block" id="MLEResults.append"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEResults.append.html#statsmodels.tsa.statespace.structural.MLEResults.append">[docs]</a>    <span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">endog</span><span class="p">,</span> <span class="n">exog</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">refit</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fit_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Recreate the results object with new data appended to the original data</span>

<span class="sd">        Creates a new result object applied to a dataset that is created by</span>
<span class="sd">        appending new data to the end of the model's original data. The new</span>
<span class="sd">        results can then be used for analysis or forecasting.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        endog : array_like</span>
<span class="sd">            New observations from the modeled time-series process.</span>
<span class="sd">        exog : array_like, optional</span>
<span class="sd">            New observations of exogenous regressors, if applicable.</span>
<span class="sd">        refit : bool, optional</span>
<span class="sd">            Whether to re-fit the parameters, based on the combined dataset.</span>
<span class="sd">            Default is False (so parameters from the current results object</span>
<span class="sd">            are used to create the new results object).</span>
<span class="sd">        fit_kwargs : dict, optional</span>
<span class="sd">            Keyword arguments to pass to `fit` (if `refit=True`) or `filter` /</span>
<span class="sd">            `smooth`.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Keyword arguments may be used to modify model specification</span>
<span class="sd">            arguments when created the new model object.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        results</span>
<span class="sd">            Updated Results object, that includes results from both the</span>
<span class="sd">            original dataset and the new dataset.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The `endog` and `exog` arguments to this method must be formatted in</span>
<span class="sd">        the same was (e.g. Pandas Series versus Numpy array) as were the</span>
<span class="sd">        `endog` and `exog` arrays passed to the original model.</span>

<span class="sd">        The `endog` argument to this method should consist of new observations</span>
<span class="sd">        that occurred directly after the last element of `endog`. For any other</span>
<span class="sd">        kind of dataset, see the `apply` method.</span>

<span class="sd">        This method will apply filtering to all of the original data as well</span>
<span class="sd">        as to the new data. To apply filtering only to the new data (which</span>
<span class="sd">        can be much faster if the original dataset is large), see the `extend`</span>
<span class="sd">        method.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; index = pd.period_range(start='2000', periods=2, freq='A')</span>
<span class="sd">        &gt;&gt;&gt; original_observations = pd.Series([1.2, 1.5], index=index)</span>
<span class="sd">        &gt;&gt;&gt; mod = sm.tsa.SARIMAX(original_observations)</span>
<span class="sd">        &gt;&gt;&gt; res = mod.fit()</span>
<span class="sd">        &gt;&gt;&gt; print(res.params)</span>
<span class="sd">        ar.L1     0.9756</span>
<span class="sd">        sigma2    0.0889</span>
<span class="sd">        dtype: float64</span>
<span class="sd">        &gt;&gt;&gt; print(res.fittedvalues)</span>
<span class="sd">        2000    0.0000</span>
<span class="sd">        2001    1.1707</span>
<span class="sd">        Freq: A-DEC, dtype: float64</span>
<span class="sd">        &gt;&gt;&gt; print(res.forecast(1))</span>
<span class="sd">        2002    1.4634</span>
<span class="sd">        Freq: A-DEC, dtype: float64</span>

<span class="sd">        &gt;&gt;&gt; new_index = pd.period_range(start='2002', periods=1, freq='A')</span>
<span class="sd">        &gt;&gt;&gt; new_observations = pd.Series([0.9], index=new_index)</span>
<span class="sd">        &gt;&gt;&gt; updated_res = res.append(new_observations)</span>
<span class="sd">        &gt;&gt;&gt; print(updated_res.params)</span>
<span class="sd">        ar.L1     0.9756</span>
<span class="sd">        sigma2    0.0889</span>
<span class="sd">        dtype: float64</span>
<span class="sd">        &gt;&gt;&gt; print(updated_res.fittedvalues)</span>
<span class="sd">        2000    0.0000</span>
<span class="sd">        2001    1.1707</span>
<span class="sd">        2002    1.4634</span>
<span class="sd">        Freq: A-DEC, dtype: float64</span>
<span class="sd">        &gt;&gt;&gt; print(updated_res.forecast(1))</span>
<span class="sd">        2003    0.878</span>
<span class="sd">        Freq: A-DEC, dtype: float64</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        statsmodels.tsa.statespace.mlemodel.MLEResults.extend</span>
<span class="sd">        statsmodels.tsa.statespace.mlemodel.MLEResults.apply</span>
<span class="sd">        """</span>
        <span class="n">start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span>
        <span class="n">end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">endog</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">append_ix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">_get_prediction_index</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>

        <span class="c1"># Check the index of the new data</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">PandasData</span><span class="p">):</span>
            <span class="n">_check_index</span><span class="p">(</span><span class="n">append_ix</span><span class="p">,</span> <span class="n">endog</span><span class="p">,</span> <span class="s1">'`endog`'</span><span class="p">)</span>

        <span class="c1"># Concatenate the new data to original data</span>
        <span class="n">new_endog</span> <span class="o">=</span> <span class="n">concat</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">orig_endog</span><span class="p">,</span> <span class="n">endog</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                           <span class="n">allow_mix</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Create a continuous index for the combined data</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">PandasData</span><span class="p">):</span>
            <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">end</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_endog</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">new_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">_get_prediction_index</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
            <span class="c1"># Standardize `endog` to have the right index and columns</span>
            <span class="n">columns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">endog_names</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">columns</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">columns</span><span class="p">]</span>
            <span class="n">new_endog</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">new_endog</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">new_index</span><span class="p">,</span>
                                     <span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">)</span>

        <span class="c1"># Handle `exog`</span>
        <span class="k">if</span> <span class="n">exog</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">exog</span> <span class="o">=</span> <span class="n">prepare_exog</span><span class="p">(</span><span class="n">exog</span><span class="p">)</span>
            <span class="n">_check_index</span><span class="p">(</span><span class="n">append_ix</span><span class="p">,</span> <span class="n">exog</span><span class="p">,</span> <span class="s1">'`exog`'</span><span class="p">)</span>

            <span class="n">new_exog</span> <span class="o">=</span> <span class="n">concat</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">orig_exog</span><span class="p">,</span> <span class="n">exog</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                              <span class="n">allow_mix</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_exog</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">mod</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">new_endog</span><span class="p">,</span> <span class="n">exog</span><span class="o">=</span><span class="n">new_exog</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">refit</span><span class="o">=</span><span class="n">refit</span><span class="p">,</span> <span class="n">fit_kwargs</span><span class="o">=</span><span class="n">fit_kwargs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">res</span></div>

<div class="viewcode-block" id="MLEResults.extend"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEResults.extend.html#statsmodels.tsa.statespace.structural.MLEResults.extend">[docs]</a>    <span class="k">def</span> <span class="nf">extend</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">endog</span><span class="p">,</span> <span class="n">exog</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fit_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Recreate the results object for new data that extends the original data</span>

<span class="sd">        Creates a new result object applied to a new dataset that is assumed to</span>
<span class="sd">        follow directly from the end of the model's original data. The new</span>
<span class="sd">        results can then be used for analysis or forecasting.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        endog : array_like</span>
<span class="sd">            New observations from the modeled time-series process.</span>
<span class="sd">        exog : array_like, optional</span>
<span class="sd">            New observations of exogenous regressors, if applicable.</span>
<span class="sd">        fit_kwargs : dict, optional</span>
<span class="sd">            Keyword arguments to pass to `filter` or `smooth`.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Keyword arguments may be used to modify model specification</span>
<span class="sd">            arguments when created the new model object.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        results</span>
<span class="sd">            Updated Results object, that includes results only for the new</span>
<span class="sd">            dataset.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The `endog` argument to this method should consist of new observations</span>
<span class="sd">        that occurred directly after the last element of the model's original</span>
<span class="sd">        `endog` array. For any other kind of dataset, see the `apply` method.</span>

<span class="sd">        This method will apply filtering only to the new data provided by the</span>
<span class="sd">        `endog` argument, which can be much faster than re-filtering the entire</span>
<span class="sd">        dataset. However, the returned results object will only have results</span>
<span class="sd">        for the new data. To retrieve results for both the new data and the</span>
<span class="sd">        original data, see the `append` method.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; index = pd.period_range(start='2000', periods=2, freq='A')</span>
<span class="sd">        &gt;&gt;&gt; original_observations = pd.Series([1.2, 1.5], index=index)</span>
<span class="sd">        &gt;&gt;&gt; mod = sm.tsa.SARIMAX(original_observations)</span>
<span class="sd">        &gt;&gt;&gt; res = mod.fit()</span>
<span class="sd">        &gt;&gt;&gt; print(res.params)</span>
<span class="sd">        ar.L1     0.9756</span>
<span class="sd">        sigma2    0.0889</span>
<span class="sd">        dtype: float64</span>
<span class="sd">        &gt;&gt;&gt; print(res.fittedvalues)</span>
<span class="sd">        2000    0.0000</span>
<span class="sd">        2001    1.1707</span>
<span class="sd">        Freq: A-DEC, dtype: float64</span>
<span class="sd">        &gt;&gt;&gt; print(res.forecast(1))</span>
<span class="sd">        2002    1.4634</span>
<span class="sd">        Freq: A-DEC, dtype: float64</span>

<span class="sd">        &gt;&gt;&gt; new_index = pd.period_range(start='2002', periods=1, freq='A')</span>
<span class="sd">        &gt;&gt;&gt; new_observations = pd.Series([0.9], index=new_index)</span>
<span class="sd">        &gt;&gt;&gt; updated_res = res.extend(new_observations)</span>
<span class="sd">        &gt;&gt;&gt; print(updated_res.params)</span>
<span class="sd">        ar.L1     0.9756</span>
<span class="sd">        sigma2    0.0889</span>
<span class="sd">        dtype: float64</span>
<span class="sd">        &gt;&gt;&gt; print(updated_res.fittedvalues)</span>
<span class="sd">        2002    1.4634</span>
<span class="sd">        Freq: A-DEC, dtype: float64</span>
<span class="sd">        &gt;&gt;&gt; print(updated_res.forecast(1))</span>
<span class="sd">        2003    0.878</span>
<span class="sd">        Freq: A-DEC, dtype: float64</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        statsmodels.tsa.statespace.mlemodel.MLEResults.append</span>
<span class="sd">        statsmodels.tsa.statespace.mlemodel.MLEResults.apply</span>
<span class="sd">        """</span>
        <span class="n">start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span>
        <span class="n">end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">endog</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">extend_ix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">_get_prediction_index</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">PandasData</span><span class="p">):</span>
            <span class="n">_check_index</span><span class="p">(</span><span class="n">extend_ix</span><span class="p">,</span> <span class="n">endog</span><span class="p">,</span> <span class="s1">'`endog`'</span><span class="p">)</span>

            <span class="c1"># Standardize `endog` to have the right index and columns</span>
            <span class="n">columns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">endog_names</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">columns</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">columns</span><span class="p">]</span>
            <span class="n">endog</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">endog</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">extend_ix</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">)</span>
        <span class="c1"># Extend the current fit result to additional data</span>
        <span class="n">mod</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">endog</span><span class="p">,</span> <span class="n">exog</span><span class="o">=</span><span class="n">exog</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">mod</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">initialization</span> <span class="o">=</span> <span class="n">Initialization</span><span class="p">(</span>
            <span class="n">mod</span><span class="o">.</span><span class="n">k_states</span><span class="p">,</span> <span class="s1">'known'</span><span class="p">,</span> <span class="n">constant</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">predicted_state</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span>
            <span class="n">stationary_cov</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">predicted_state_cov</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">refit</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fit_kwargs</span><span class="o">=</span><span class="n">fit_kwargs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">res</span></div>

<div class="viewcode-block" id="MLEResults.apply"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEResults.apply.html#statsmodels.tsa.statespace.structural.MLEResults.apply">[docs]</a>    <span class="k">def</span> <span class="nf">apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">endog</span><span class="p">,</span> <span class="n">exog</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">refit</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fit_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Apply the fitted parameters to new data unrelated to the original data</span>

<span class="sd">        Creates a new result object using the current fitted parameters,</span>
<span class="sd">        applied to a completely new dataset that is assumed to be unrelated to</span>
<span class="sd">        the model's original data. The new results can then be used for</span>
<span class="sd">        analysis or forecasting.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        endog : array_like</span>
<span class="sd">            New observations from the modeled time-series process.</span>
<span class="sd">        exog : array_like, optional</span>
<span class="sd">            New observations of exogenous regressors, if applicable.</span>
<span class="sd">        refit : bool, optional</span>
<span class="sd">            Whether to re-fit the parameters, using the new dataset.</span>
<span class="sd">            Default is False (so parameters from the current results object</span>
<span class="sd">            are used to create the new results object).</span>
<span class="sd">        fit_kwargs : dict, optional</span>
<span class="sd">            Keyword arguments to pass to `fit` (if `refit=True`) or `filter` /</span>
<span class="sd">            `smooth`.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Keyword arguments may be used to modify model specification</span>
<span class="sd">            arguments when created the new model object.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        results</span>
<span class="sd">            Updated Results object, that includes results only for the new</span>
<span class="sd">            dataset.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The `endog` argument to this method should consist of new observations</span>
<span class="sd">        that are unrelated to the original model's `endog` dataset. For</span>
<span class="sd">        observations that continue that original dataset by follow directly</span>
<span class="sd">        after its last element, see the `append` and `extend` methods.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; index = pd.period_range(start='2000', periods=2, freq='A')</span>
<span class="sd">        &gt;&gt;&gt; original_observations = pd.Series([1.2, 1.5], index=index)</span>
<span class="sd">        &gt;&gt;&gt; mod = sm.tsa.SARIMAX(original_observations)</span>
<span class="sd">        &gt;&gt;&gt; res = mod.fit()</span>
<span class="sd">        &gt;&gt;&gt; print(res.params)</span>
<span class="sd">        ar.L1     0.9756</span>
<span class="sd">        sigma2    0.0889</span>
<span class="sd">        dtype: float64</span>
<span class="sd">        &gt;&gt;&gt; print(res.fittedvalues)</span>
<span class="sd">        2000    0.0000</span>
<span class="sd">        2001    1.1707</span>
<span class="sd">        Freq: A-DEC, dtype: float64</span>
<span class="sd">        &gt;&gt;&gt; print(res.forecast(1))</span>
<span class="sd">        2002    1.4634</span>
<span class="sd">        Freq: A-DEC, dtype: float64</span>

<span class="sd">        &gt;&gt;&gt; new_index = pd.period_range(start='1980', periods=3, freq='A')</span>
<span class="sd">        &gt;&gt;&gt; new_observations = pd.Series([1.4, 0.3, 1.2], index=new_index)</span>
<span class="sd">        &gt;&gt;&gt; new_res = res.apply(new_observations)</span>
<span class="sd">        &gt;&gt;&gt; print(new_res.params)</span>
<span class="sd">        ar.L1     0.9756</span>
<span class="sd">        sigma2    0.0889</span>
<span class="sd">        dtype: float64</span>
<span class="sd">        &gt;&gt;&gt; print(new_res.fittedvalues)</span>
<span class="sd">        1980    1.1707</span>
<span class="sd">        1981    1.3659</span>
<span class="sd">        1982    0.2927</span>
<span class="sd">        Freq: A-DEC, dtype: float64</span>
<span class="sd">        Freq: A-DEC, dtype: float64</span>
<span class="sd">        &gt;&gt;&gt; print(new_res.forecast(1))</span>
<span class="sd">        1983    1.1707</span>
<span class="sd">        Freq: A-DEC, dtype: float64</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        statsmodels.tsa.statespace.mlemodel.MLEResults.append</span>
<span class="sd">        statsmodels.tsa.statespace.mlemodel.MLEResults.apply</span>
<span class="sd">        """</span>
        <span class="n">mod</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">endog</span><span class="p">,</span> <span class="n">exog</span><span class="o">=</span><span class="n">exog</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">refit</span><span class="o">=</span><span class="n">refit</span><span class="p">,</span> <span class="n">fit_kwargs</span><span class="o">=</span><span class="n">fit_kwargs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">res</span></div>

<div class="viewcode-block" id="MLEResults.plot_diagnostics"><a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.mlemodel.MLEResults.plot_diagnostics.html#statsmodels.tsa.statespace.structural.MLEResults.plot_diagnostics">[docs]</a>    <span class="k">def</span> <span class="nf">plot_diagnostics</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variable</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">lags</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">fig</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Diagnostic plots for standardized residuals of one endogenous variable</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        variable : int, optional</span>
<span class="sd">            Index of the endogenous variable for which the diagnostic plots</span>
<span class="sd">            should be created. Default is 0.</span>
<span class="sd">        lags : int, optional</span>
<span class="sd">            Number of lags to include in the correlogram. Default is 10.</span>
<span class="sd">        fig : Figure, optional</span>
<span class="sd">            If given, subplots are created in this figure instead of in a new</span>
<span class="sd">            figure. Note that the 2x2 grid will be created in the provided</span>
<span class="sd">            figure using `fig.add_subplot()`.</span>
<span class="sd">        figsize : tuple, optional</span>
<span class="sd">            If a figure is created, this argument allows specifying a size.</span>
<span class="sd">            The tuple is (width, height).</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Produces a 2x2 plot grid with the following plots (ordered clockwise</span>
<span class="sd">        from top left):</span>

<span class="sd">        1. Standardized residuals over time</span>
<span class="sd">        2. Histogram plus estimated density of standardized residuals, along</span>
<span class="sd">           with a Normal(0,1) density plotted for reference.</span>
<span class="sd">        3. Normal Q-Q plot, with Normal reference line.</span>
<span class="sd">        4. Correlogram</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        statsmodels.graphics.gofplots.qqplot</span>
<span class="sd">        statsmodels.graphics.tsaplots.plot_acf</span>
<span class="sd">        """</span>
        <span class="kn">from</span> <span class="nn">statsmodels.graphics.utils</span> <span class="kn">import</span> <span class="n">_import_mpl</span><span class="p">,</span> <span class="n">create_mpl_fig</span>
        <span class="n">_import_mpl</span><span class="p">()</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">create_mpl_fig</span><span class="p">(</span><span class="n">fig</span><span class="p">,</span> <span class="n">figsize</span><span class="p">)</span>
        <span class="c1"># Eliminate residuals associated with burned or diffuse likelihoods</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loglikelihood_burn</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs_diffuse</span><span class="p">)</span>
        <span class="n">resid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_results</span><span class="o">.</span><span class="n">standardized_forecasts_error</span><span class="p">[</span><span class="n">variable</span><span class="p">,</span> <span class="n">d</span><span class="p">:]</span>

        <span class="c1"># Top-left: residuals vs time</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">221</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="s1">'dates'</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">dates</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">dates</span><span class="p">[</span><span class="n">d</span><span class="p">:]</span><span class="o">.</span><span class="n">_mpl_repr</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">resid</span><span class="p">))</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">resid</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">hlines</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">'Standardized residual'</span><span class="p">)</span>

        <span class="c1"># Top-right: histogram, Gaussian kernel density, Normal density</span>
        <span class="c1"># Can only do histogram and Gaussian kernel density on the non-null</span>
        <span class="c1"># elements</span>
        <span class="n">resid_nonmissing</span> <span class="o">=</span> <span class="n">resid</span><span class="p">[</span><span class="o">~</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">resid</span><span class="p">))]</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">222</span><span class="p">)</span>

        <span class="c1"># gh5792: Remove  except after support for matplotlib&gt;2.1 required</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">resid_nonmissing</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">'Hist'</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">resid_nonmissing</span><span class="p">,</span> <span class="n">normed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">'Hist'</span><span class="p">)</span>

        <span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">gaussian_kde</span><span class="p">,</span> <span class="n">norm</span>
        <span class="n">kde</span> <span class="o">=</span> <span class="n">gaussian_kde</span><span class="p">(</span><span class="n">resid_nonmissing</span><span class="p">)</span>
        <span class="n">xlim</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mf">1.96</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="mf">1.96</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">xlim</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">xlim</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">kde</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">label</span><span class="o">=</span><span class="s1">'KDE'</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">norm</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">label</span><span class="o">=</span><span class="s1">'N(0,1)'</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="n">xlim</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">'Histogram plus estimated density'</span><span class="p">)</span>

        <span class="c1"># Bottom-left: QQ plot</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">223</span><span class="p">)</span>
        <span class="kn">from</span> <span class="nn">statsmodels.graphics.gofplots</span> <span class="kn">import</span> <span class="n">qqplot</span>
        <span class="n">qqplot</span><span class="p">(</span><span class="n">resid_nonmissing</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="s1">'s'</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">'Normal Q-Q'</span><span class="p">)</span>

        <span class="c1"># Bottom-right: Correlogram</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">224</span><span class="p">)</span>
        <span class="kn">from</span> <span class="nn">statsmodels.graphics.tsaplots</span> <span class="kn">import</span> <span class="n">plot_acf</span>
        <span class="n">plot_acf</span><span class="p">(</span><span class="n">resid</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">lags</span><span class="o">=</span><span class="n">lags</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">'Correlogram'</span><span class="p">)</span>

        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">fig</span></div>

    <span class="k">def</span> <span class="nf">summary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=.</span><span class="mi">05</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">model_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">display_params</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Summarize the Model</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        alpha : float, optional</span>
<span class="sd">            Significance level for the confidence intervals. Default is 0.05.</span>
<span class="sd">        start : int, optional</span>
<span class="sd">            Integer of the start observation. Default is 0.</span>
<span class="sd">        model_name : str</span>
<span class="sd">            The name of the model used. Default is to use model class name.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        summary : Summary instance</span>
<span class="sd">            This holds the summary table and text, which can be printed or</span>
<span class="sd">            converted to various output formats.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        statsmodels.iolib.summary.Summary</span>
<span class="sd">        """</span>
        <span class="kn">from</span> <span class="nn">statsmodels.iolib.summary</span> <span class="kn">import</span> <span class="n">Summary</span>

        <span class="c1"># Model specification results</span>
        <span class="n">model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span>
        <span class="k">if</span> <span class="n">title</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">title</span> <span class="o">=</span> <span class="s1">'Statespace Model Results'</span>

        <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">_index_dates</span><span class="p">:</span>
            <span class="n">ix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">_index</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">ix</span><span class="p">[</span><span class="n">start</span><span class="p">]</span>
            <span class="n">sample</span> <span class="o">=</span> <span class="p">[</span><span class="s1">'</span><span class="si">%02d</span><span class="s1">-</span><span class="si">%02d</span><span class="s1">-</span><span class="si">%02d</span><span class="s1">'</span> <span class="o">%</span> <span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">month</span><span class="p">,</span> <span class="n">d</span><span class="o">.</span><span class="n">day</span><span class="p">,</span> <span class="n">d</span><span class="o">.</span><span class="n">year</span><span class="p">)]</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">ix</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">sample</span> <span class="o">+=</span> <span class="p">[</span><span class="s1">'- '</span> <span class="o">+</span> <span class="s1">'</span><span class="si">%02d</span><span class="s1">-</span><span class="si">%02d</span><span class="s1">-</span><span class="si">%02d</span><span class="s1">'</span> <span class="o">%</span> <span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">month</span><span class="p">,</span> <span class="n">d</span><span class="o">.</span><span class="n">day</span><span class="p">,</span> <span class="n">d</span><span class="o">.</span><span class="n">year</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sample</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">start</span><span class="p">),</span> <span class="s1">' - '</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="p">)]</span>

        <span class="c1"># Standardize the model name as a list of str</span>
        <span class="k">if</span> <span class="n">model_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">model_name</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>

        <span class="c1"># Diagnostic tests results</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">het</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">test_heteroskedasticity</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="s1">'breakvar'</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>  <span class="c1"># FIXME: catch something specific</span>
            <span class="n">het</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">]</span><span class="o">*</span><span class="mi">2</span><span class="p">])</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">lb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">test_serial_correlation</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="s1">'ljungbox'</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>  <span class="c1"># FIXME: catch something specific</span>
            <span class="n">lb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">]</span><span class="o">*</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">jb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">test_normality</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="s1">'jarquebera'</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>  <span class="c1"># FIXME: catch something specific</span>
            <span class="n">jb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">]</span><span class="o">*</span><span class="mi">4</span><span class="p">])</span>

        <span class="c1"># Create the tables</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">model_name</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">model_name</span> <span class="o">=</span> <span class="p">[</span><span class="n">model_name</span><span class="p">]</span>

        <span class="n">top_left</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">'Dep. Variable:'</span><span class="p">,</span> <span class="kc">None</span><span class="p">)]</span>
        <span class="n">top_left</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s1">'Model:'</span><span class="p">,</span> <span class="p">[</span><span class="n">model_name</span><span class="p">[</span><span class="mi">0</span><span class="p">]]))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">model_name</span><span class="p">)):</span>
            <span class="n">top_left</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s1">''</span><span class="p">,</span> <span class="p">[</span><span class="s1">'+ '</span> <span class="o">+</span> <span class="n">model_name</span><span class="p">[</span><span class="n">i</span><span class="p">]]))</span>
        <span class="n">top_left</span> <span class="o">+=</span> <span class="p">[</span>
            <span class="p">(</span><span class="s1">'Date:'</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
            <span class="p">(</span><span class="s1">'Time:'</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
            <span class="p">(</span><span class="s1">'Sample:'</span><span class="p">,</span> <span class="p">[</span><span class="n">sample</span><span class="p">[</span><span class="mi">0</span><span class="p">]]),</span>
            <span class="p">(</span><span class="s1">''</span><span class="p">,</span> <span class="p">[</span><span class="n">sample</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
        <span class="p">]</span>

        <span class="n">top_right</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="s1">'No. Observations:'</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="p">]),</span>
            <span class="p">(</span><span class="s1">'Log Likelihood'</span><span class="p">,</span> <span class="p">[</span><span class="s2">"</span><span class="si">%#5.3f</span><span class="s2">"</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">llf</span><span class="p">]),</span>
        <span class="p">]</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">'rsquared'</span><span class="p">):</span>
            <span class="n">top_right</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s1">'R-squared:'</span><span class="p">,</span> <span class="p">[</span><span class="s2">"</span><span class="si">%#8.3f</span><span class="s2">"</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">rsquared</span><span class="p">]))</span>
        <span class="n">top_right</span> <span class="o">+=</span> <span class="p">[</span>
            <span class="p">(</span><span class="s1">'AIC'</span><span class="p">,</span> <span class="p">[</span><span class="s2">"</span><span class="si">%#5.3f</span><span class="s2">"</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">aic</span><span class="p">]),</span>
            <span class="p">(</span><span class="s1">'BIC'</span><span class="p">,</span> <span class="p">[</span><span class="s2">"</span><span class="si">%#5.3f</span><span class="s2">"</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">bic</span><span class="p">]),</span>
            <span class="p">(</span><span class="s1">'HQIC'</span><span class="p">,</span> <span class="p">[</span><span class="s2">"</span><span class="si">%#5.3f</span><span class="s2">"</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">hqic</span><span class="p">])]</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filter_results</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">filter_results</span><span class="o">.</span><span class="n">filter_concentrated</span><span class="p">):</span>
            <span class="n">top_right</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s1">'Scale'</span><span class="p">,</span> <span class="p">[</span><span class="s2">"</span><span class="si">%#5.3f</span><span class="s2">"</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">]))</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">'cov_type'</span><span class="p">):</span>
            <span class="n">top_left</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s1">'Covariance Type:'</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">cov_type</span><span class="p">]))</span>

        <span class="n">format_str</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">array</span><span class="p">:</span> <span class="p">[</span>  <span class="c1"># noqa:E731</span>
            <span class="s1">', '</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s1">'</span><span class="si">{0:.2f}</span><span class="s1">'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">array</span><span class="p">])</span>
        <span class="p">]</span>
        <span class="n">diagn_left</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">'Ljung-Box (Q):'</span><span class="p">,</span> <span class="n">format_str</span><span class="p">(</span><span class="n">lb</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])),</span>
                      <span class="p">(</span><span class="s1">'Prob(Q):'</span><span class="p">,</span> <span class="n">format_str</span><span class="p">(</span><span class="n">lb</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])),</span>
                      <span class="p">(</span><span class="s1">'Heteroskedasticity (H):'</span><span class="p">,</span> <span class="n">format_str</span><span class="p">(</span><span class="n">het</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])),</span>
                      <span class="p">(</span><span class="s1">'Prob(H) (two-sided):'</span><span class="p">,</span> <span class="n">format_str</span><span class="p">(</span><span class="n">het</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]))</span>
                      <span class="p">]</span>

        <span class="n">diagn_right</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">'Jarque-Bera (JB):'</span><span class="p">,</span> <span class="n">format_str</span><span class="p">(</span><span class="n">jb</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])),</span>
                       <span class="p">(</span><span class="s1">'Prob(JB):'</span><span class="p">,</span> <span class="n">format_str</span><span class="p">(</span><span class="n">jb</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])),</span>
                       <span class="p">(</span><span class="s1">'Skew:'</span><span class="p">,</span> <span class="n">format_str</span><span class="p">(</span><span class="n">jb</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">])),</span>
                       <span class="p">(</span><span class="s1">'Kurtosis:'</span><span class="p">,</span> <span class="n">format_str</span><span class="p">(</span><span class="n">jb</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">]))</span>
                       <span class="p">]</span>

        <span class="n">summary</span> <span class="o">=</span> <span class="n">Summary</span><span class="p">()</span>
        <span class="n">summary</span><span class="o">.</span><span class="n">add_table_2cols</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gleft</span><span class="o">=</span><span class="n">top_left</span><span class="p">,</span> <span class="n">gright</span><span class="o">=</span><span class="n">top_right</span><span class="p">,</span>
                                <span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">display_params</span><span class="p">:</span>
            <span class="n">summary</span><span class="o">.</span><span class="n">add_table_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span>
                                     <span class="n">xname</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">,</span> <span class="n">use_t</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">summary</span><span class="o">.</span><span class="n">add_table_2cols</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gleft</span><span class="o">=</span><span class="n">diagn_left</span><span class="p">,</span> <span class="n">gright</span><span class="o">=</span><span class="n">diagn_right</span><span class="p">,</span>
                                <span class="n">title</span><span class="o">=</span><span class="s2">""</span><span class="p">)</span>

        <span class="c1"># Add warnings/notes, added to text format only</span>
        <span class="n">etext</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">'cov_type'</span><span class="p">)</span> <span class="ow">and</span> <span class="s1">'description'</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cov_kwds</span><span class="p">:</span>
            <span class="n">etext</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cov_kwds</span><span class="p">[</span><span class="s1">'description'</span><span class="p">])</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rank</span> <span class="o">&lt;</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fixed_params</span><span class="p">)):</span>
            <span class="n">cov_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cov_params</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fixed_params</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_free_params_index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_free_params_index</span><span class="p">)</span>
                <span class="n">cov_params</span> <span class="o">=</span> <span class="n">cov_params</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
            <span class="n">etext</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">"Covariance matrix is singular or near-singular,"</span>
                         <span class="s2">" with condition number </span><span class="si">%6.3g</span><span class="s2">. Standard errors may be"</span>
                         <span class="s2">" unstable."</span> <span class="o">%</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">cond</span><span class="p">(</span><span class="n">cov_params</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">etext</span><span class="p">:</span>
            <span class="n">etext</span> <span class="o">=</span> <span class="p">[</span><span class="s2">"[</span><span class="si">{0}</span><span class="s2">] </span><span class="si">{1}</span><span class="s2">"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>
                     <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">text</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">etext</span><span class="p">)]</span>
            <span class="n">etext</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s2">"Warnings:"</span><span class="p">)</span>
            <span class="n">summary</span><span class="o">.</span><span class="n">add_extra_txt</span><span class="p">(</span><span class="n">etext</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">summary</span></div>


<span class="k">class</span> <span class="nc">MLEResultsWrapper</span><span class="p">(</span><span class="n">wrap</span><span class="o">.</span><span class="n">ResultsWrapper</span><span class="p">):</span>
    <span class="n">_attrs</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">'zvalues'</span><span class="p">:</span> <span class="s1">'columns'</span><span class="p">,</span>
        <span class="s1">'cov_params_approx'</span><span class="p">:</span> <span class="s1">'cov'</span><span class="p">,</span>
        <span class="s1">'cov_params_default'</span><span class="p">:</span> <span class="s1">'cov'</span><span class="p">,</span>
        <span class="s1">'cov_params_oim'</span><span class="p">:</span> <span class="s1">'cov'</span><span class="p">,</span>
        <span class="s1">'cov_params_opg'</span><span class="p">:</span> <span class="s1">'cov'</span><span class="p">,</span>
        <span class="s1">'cov_params_robust'</span><span class="p">:</span> <span class="s1">'cov'</span><span class="p">,</span>
        <span class="s1">'cov_params_robust_approx'</span><span class="p">:</span> <span class="s1">'cov'</span><span class="p">,</span>
        <span class="s1">'cov_params_robust_oim'</span><span class="p">:</span> <span class="s1">'cov'</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="n">_wrap_attrs</span> <span class="o">=</span> <span class="n">wrap</span><span class="o">.</span><span class="n">union_dicts</span><span class="p">(</span><span class="n">tsbase</span><span class="o">.</span><span class="n">TimeSeriesResultsWrapper</span><span class="o">.</span><span class="n">_wrap_attrs</span><span class="p">,</span>
                                   <span class="n">_attrs</span><span class="p">)</span>
    <span class="n">_methods</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">'forecast'</span><span class="p">:</span> <span class="s1">'dates'</span><span class="p">,</span>
        <span class="s1">'impulse_responses'</span><span class="p">:</span> <span class="s1">'ynames'</span>
    <span class="p">}</span>
    <span class="n">_wrap_methods</span> <span class="o">=</span> <span class="n">wrap</span><span class="o">.</span><span class="n">union_dicts</span><span class="p">(</span>
        <span class="n">tsbase</span><span class="o">.</span><span class="n">TimeSeriesResultsWrapper</span><span class="o">.</span><span class="n">_wrap_methods</span><span class="p">,</span> <span class="n">_methods</span><span class="p">)</span>
<span class="n">wrap</span><span class="o">.</span><span class="n">populate_wrapper</span><span class="p">(</span><span class="n">MLEResultsWrapper</span><span class="p">,</span> <span class="n">MLEResults</span><span class="p">)</span>  <span class="c1"># noqa:E305</span>


<span class="k">class</span> <span class="nc">PredictionResults</span><span class="p">(</span><span class="n">pred</span><span class="o">.</span><span class="n">PredictionResults</span><span class="p">):</span>
    <span class="sd">"""</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    prediction_results : kalman_filter.PredictionResults instance</span>
<span class="sd">        Results object from prediction after fitting or filtering a state space</span>
<span class="sd">        model.</span>
<span class="sd">    row_labels : iterable</span>
<span class="sd">        Row labels for the predicted data.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    """</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">prediction_results</span><span class="p">,</span> <span class="n">row_labels</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">model</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">k_endog</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">endog</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">prediction_results</span><span class="o">.</span><span class="n">endog</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                              <span class="n">name</span><span class="o">=</span><span class="n">model</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">endog_names</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">endog</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">prediction_results</span><span class="o">.</span><span class="n">endog</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
                                 <span class="n">columns</span><span class="o">=</span><span class="n">model</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">endog_names</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">Bunch</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">model</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span>
            <span class="n">endog</span><span class="o">=</span><span class="n">endog</span><span class="p">,</span> <span class="n">predict_dates</span><span class="o">=</span><span class="n">row_labels</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prediction_results</span> <span class="o">=</span> <span class="n">prediction_results</span>

        <span class="c1"># Get required values</span>
        <span class="n">k_endog</span><span class="p">,</span> <span class="n">nobs</span> <span class="o">=</span> <span class="n">prediction_results</span><span class="o">.</span><span class="n">endog</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">prediction_results</span><span class="o">.</span><span class="n">results</span><span class="o">.</span><span class="n">memory_no_forecast_mean</span><span class="p">:</span>
            <span class="n">predicted_mean</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prediction_results</span><span class="o">.</span><span class="n">forecasts</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">predicted_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">k_endog</span><span class="p">,</span> <span class="n">nobs</span><span class="p">))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

        <span class="k">if</span> <span class="n">predicted_mean</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">predicted_mean</span> <span class="o">=</span> <span class="n">predicted_mean</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">predicted_mean</span> <span class="o">=</span> <span class="n">predicted_mean</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">prediction_results</span><span class="o">.</span><span class="n">results</span><span class="o">.</span><span class="n">memory_no_forecast_cov</span><span class="p">:</span>
            <span class="n">var_pred_mean</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prediction_results</span><span class="o">.</span><span class="n">forecasts_error_cov</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">var_pred_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">k_endog</span><span class="p">,</span> <span class="n">k_endog</span><span class="p">,</span> <span class="n">nobs</span><span class="p">))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

        <span class="k">if</span> <span class="n">var_pred_mean</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">var_pred_mean</span> <span class="o">=</span> <span class="n">var_pred_mean</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">var_pred_mean</span> <span class="o">=</span> <span class="n">var_pred_mean</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>

        <span class="c1"># Initialize</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">PredictionResults</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">predicted_mean</span><span class="p">,</span> <span class="n">var_pred_mean</span><span class="p">,</span>
                                                <span class="n">dist</span><span class="o">=</span><span class="s1">'norm'</span><span class="p">,</span>
                                                <span class="n">row_labels</span><span class="o">=</span><span class="n">row_labels</span><span class="p">,</span>
                                                <span class="n">link</span><span class="o">=</span><span class="n">identity</span><span class="p">())</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">se_mean</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">var_pred_mean</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">se_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">var_pred_mean</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">se_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">var_pred_mean</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">diagonal</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">se_mean</span>

    <span class="k">def</span> <span class="nf">conf_int</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">'endpoint'</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="c1"># TODO: this performs metadata wrapping, and that should be handled</span>
        <span class="c1">#       by attach_* methods. However, they do not currently support</span>
        <span class="c1">#       this use case.</span>
        <span class="n">conf_int</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">PredictionResults</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">conf_int</span><span class="p">(</span>
            <span class="n">method</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>

        <span class="c1"># Create a dataframe</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">row_labels</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">conf_int</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">conf_int</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">row_labels</span><span class="p">)</span>

            <span class="c1"># Attach the endog names</span>
            <span class="n">ynames</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">ynames</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">type</span><span class="p">(</span><span class="n">ynames</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span><span class="p">:</span>
                <span class="n">ynames</span> <span class="o">=</span> <span class="p">[</span><span class="n">ynames</span><span class="p">]</span>
            <span class="n">names</span> <span class="o">=</span> <span class="p">([</span><span class="s1">'lower </span><span class="si">{0}</span><span class="s1">'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">ynames</span><span class="p">]</span> <span class="o">+</span>
                     <span class="p">[</span><span class="s1">'upper </span><span class="si">{0}</span><span class="s1">'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">ynames</span><span class="p">])</span>
            <span class="n">conf_int</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="n">names</span>

        <span class="k">return</span> <span class="n">conf_int</span>

    <span class="k">def</span> <span class="nf">summary_frame</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">endog</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">what</span><span class="o">=</span><span class="s1">'all'</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.05</span><span class="p">):</span>
        <span class="c1"># TODO: finish and cleanup</span>
        <span class="c1"># import pandas as pd</span>
        <span class="c1"># ci_obs = self.conf_int(alpha=alpha, obs=True) # need to split</span>
        <span class="n">ci_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">conf_int</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">))</span>
        <span class="n">to_include</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">predicted_mean</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">yname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">ynames</span>
            <span class="n">to_include</span><span class="p">[</span><span class="s1">'mean'</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predicted_mean</span>
            <span class="n">to_include</span><span class="p">[</span><span class="s1">'mean_se'</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">se_mean</span>
            <span class="n">k_endog</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">yname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">ynames</span><span class="p">[</span><span class="n">endog</span><span class="p">]</span>
            <span class="n">to_include</span><span class="p">[</span><span class="s1">'mean'</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predicted_mean</span><span class="p">[:,</span> <span class="n">endog</span><span class="p">]</span>
            <span class="n">to_include</span><span class="p">[</span><span class="s1">'mean_se'</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">se_mean</span><span class="p">[:,</span> <span class="n">endog</span><span class="p">]</span>
            <span class="n">k_endog</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predicted_mean</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">to_include</span><span class="p">[</span><span class="s1">'mean_ci_lower'</span><span class="p">]</span> <span class="o">=</span> <span class="n">ci_mean</span><span class="p">[:,</span> <span class="n">endog</span><span class="p">]</span>
        <span class="n">to_include</span><span class="p">[</span><span class="s1">'mean_ci_upper'</span><span class="p">]</span> <span class="o">=</span> <span class="n">ci_mean</span><span class="p">[:,</span> <span class="n">k_endog</span> <span class="o">+</span> <span class="n">endog</span><span class="p">]</span>

        <span class="c1"># OrderedDict does not work to preserve sequence</span>
        <span class="c1"># pandas dict does not handle 2d_array</span>
        <span class="c1"># data = np.column_stack(list(to_include.values()))</span>
        <span class="c1"># names = ....</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">to_include</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">row_labels</span><span class="p">,</span>
                           <span class="n">columns</span><span class="o">=</span><span class="n">to_include</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">res</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">yname</span>
        <span class="k">return</span> <span class="n">res</span>


<span class="k">class</span> <span class="nc">PredictionResultsWrapper</span><span class="p">(</span><span class="n">wrap</span><span class="o">.</span><span class="n">ResultsWrapper</span><span class="p">):</span>
    <span class="n">_attrs</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">'predicted_mean'</span><span class="p">:</span> <span class="s1">'dates'</span><span class="p">,</span>
        <span class="s1">'se_mean'</span><span class="p">:</span> <span class="s1">'dates'</span><span class="p">,</span>
        <span class="s1">'t_values'</span><span class="p">:</span> <span class="s1">'dates'</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="n">_wrap_attrs</span> <span class="o">=</span> <span class="n">wrap</span><span class="o">.</span><span class="n">union_dicts</span><span class="p">(</span><span class="n">_attrs</span><span class="p">)</span>

    <span class="n">_methods</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">_wrap_methods</span> <span class="o">=</span> <span class="n">wrap</span><span class="o">.</span><span class="n">union_dicts</span><span class="p">(</span><span class="n">_methods</span><span class="p">)</span>
<span class="n">wrap</span><span class="o">.</span><span class="n">populate_wrapper</span><span class="p">(</span><span class="n">PredictionResultsWrapper</span><span class="p">,</span> <span class="n">PredictionResults</span><span class="p">)</span>  <span class="c1"># noqa:E305</span>
</pre></div>

          </article>
        </div>
      </div>
    </main>
  </div>
  <footer class="md-footer">
    <div class="md-footer-nav">
      <nav class="md-footer-nav__inner md-grid">
          
          
        </a>
        
      </nav>
    </div>
    <div class="md-footer-meta md-typeset">
      <div class="md-footer-meta__inner md-grid">
        <div class="md-footer-copyright">
          <div class="md-footer-copyright__highlight">
              &#169; Copyright 2009-2019, Josef Perktold, Skipper Seabold, Jonathan Taylor, statsmodels-developers.
              
          </div>
            Last updated on
              Feb 21, 2020.
            <br/>
            Created using
            <a href="http://www.sphinx-doc.org/">Sphinx</a> 2.4.2.
             and
            <a href="https://github.com/bashtage/sphinx-material/">Material for
              Sphinx</a>
        </div>
      </div>
    </div>
  </footer>
  <script src="../../../../_static/javascripts/application.js"></script>
  <script>app.initialize({version: "1.0.4", url: {base: ".."}})</script>
  </body>
</html>