

<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <meta name="lang:clipboard.copy" content="Copy to clipboard">
  <meta name="lang:clipboard.copied" content="Copied to clipboard">
  <meta name="lang:search.language" content="en">
  <meta name="lang:search.pipeline.stopwords" content="True">
  <meta name="lang:search.pipeline.trimmer" content="True">
  <meta name="lang:search.result.none" content="No matching documents">
  <meta name="lang:search.result.one" content="1 matching document">
  <meta name="lang:search.result.other" content="# matching documents">
  <meta name="lang:search.tokenizer" content="[\s\-]+">

  
    <link href="https://fonts.gstatic.com/" rel="preconnect" crossorigin>
    <link href="https://fonts.googleapis.com/css?family=Roboto+Mono:400,500,700|Roboto:300,400,400i,700&display=fallback" rel="stylesheet">

    <style>
      body,
      input {
        font-family: "Roboto", "Helvetica Neue", Helvetica, Arial, sans-serif
      }

      code,
      kbd,
      pre {
        font-family: "Roboto Mono", "Courier New", Courier, monospace
      }
    </style>
  

  <link rel="stylesheet" href="../../../../_static/stylesheets/application.css"/>
  <link rel="stylesheet" href="../../../../_static/stylesheets/application-palette.css"/>
  <link rel="stylesheet" href="../../../../_static/stylesheets/application-fixes.css"/>
  
  <link rel="stylesheet" href="../../../../_static/fonts/material-icons.css"/>
  
  <meta name="theme-color" content="#3f51b5">
  <script src="../../../../_static/javascripts/modernizr.js"></script>
  
  
  
    <title>statsmodels.tsa.regime_switching.markov_switching &#8212; statsmodels</title>
  <link rel="icon" type="image/png" sizes="32x32" href="../../../../_static/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="../../../../_static/icons/favicon-16x16.png">
  <link rel="manifest" href="../../../../_static/icons/site.webmanifest">
  <link rel="mask-icon" href="../../../../_static/icons/safari-pinned-tab.svg" color="#919191">
  <meta name="msapplication-TileColor" content="#2b5797">
  <meta name="msapplication-config" content="../../../../_static/icons/browserconfig.xml">
  <link rel="stylesheet" href="../../../../_static/stylesheets/examples.css">
    <link rel="stylesheet" href="../../../../_static/material.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/graphviz.css" />
    <script id="documentation_options" data-url_root="../../../../" src="../../../../_static/documentation_options.js"></script>
    <script src="../../../../_static/jquery.js"></script>
    <script src="../../../../_static/underscore.js"></script>
    <script src="../../../../_static/doctools.js"></script>
    <script src="../../../../_static/language_data.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
    <link rel="shortcut icon" href="../../../../_static/favicon.ico"/>
    <link rel="author" title="About these documents" href="../../../../about.html" />
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
  
   
  
  <script src="../../../../_static/javascripts/version_dropdown.js"></script>
  <script>
    var json_loc = "../../../../_static/versions.json",
        target_loc = "../../../../../",
        text = "Versions";
    $( document ).ready( add_version_dropdown(json_loc, target_loc, text));
  </script>


  </head>
  <body dir=ltr
        data-md-color-primary=indigo data-md-color-accent=blue>
  
  <svg class="md-svg">
    <defs data-children-count="0">
      
      <svg xmlns="http://www.w3.org/2000/svg" width="416" height="448" viewBox="0 0 416 448" id="__github"><path fill="currentColor" d="M160 304q0 10-3.125 20.5t-10.75 19T128 352t-18.125-8.5-10.75-19T96 304t3.125-20.5 10.75-19T128 256t18.125 8.5 10.75 19T160 304zm160 0q0 10-3.125 20.5t-10.75 19T288 352t-18.125-8.5-10.75-19T256 304t3.125-20.5 10.75-19T288 256t18.125 8.5 10.75 19T320 304zm40 0q0-30-17.25-51T296 232q-10.25 0-48.75 5.25Q229.5 240 208 240t-39.25-2.75Q130.75 232 120 232q-29.5 0-46.75 21T56 304q0 22 8 38.375t20.25 25.75 30.5 15 35 7.375 37.25 1.75h42q20.5 0 37.25-1.75t35-7.375 30.5-15 20.25-25.75T360 304zm56-44q0 51.75-15.25 82.75-9.5 19.25-26.375 33.25t-35.25 21.5-42.5 11.875-42.875 5.5T212 416q-19.5 0-35.5-.75t-36.875-3.125-38.125-7.5-34.25-12.875T37 371.5t-21.5-28.75Q0 312 0 260q0-59.25 34-99-6.75-20.5-6.75-42.5 0-29 12.75-54.5 27 0 47.5 9.875t47.25 30.875Q171.5 96 212 96q37 0 70 8 26.25-20.5 46.75-30.25T376 64q12.75 25.5 12.75 54.5 0 21.75-6.75 42 34 40 34 99.5z"/></svg>
      
    </defs>
  </svg>
  
  <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer">
  <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search">
  <label class="md-overlay" data-md-component="overlay" for="__drawer"></label>
  <a href="#_modules/statsmodels/tsa/regime_switching/markov_switching" tabindex="1" class="md-skip"> Skip to content </a>
  <header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid">
    <div class="md-flex navheader">
      <div class="md-flex__cell md-flex__cell--shrink">
        <a href="../../../../index.html" title="statsmodels"
           class="md-header-nav__button md-logo">
          
              <img src="../../../../_static/statsmodels-logo-v2-bw.svg" height="26"
                   alt="statsmodels logo">
          
        </a>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        <label class="md-icon md-icon--menu md-header-nav__button" for="__drawer"></label>
      </div>
      <div class="md-flex__cell md-flex__cell--stretch">
        <div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
          <span class="md-header-nav__topic">statsmodels v0.11.1</span>
          <span class="md-header-nav__topic"> statsmodels.tsa.regime_switching.markov_switching </span>
        </div>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        <label class="md-icon md-icon--search md-header-nav__button" for="__search"></label>
        
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" action="../../../../search.html" method="GET" name="search">
      <input type="text" class="md-search__input" name="q" placeholder="Search"
             autocapitalize="off" autocomplete="off" spellcheck="false"
             data-md-component="query" data-md-state="active">
      <label class="md-icon md-search__icon" for="__search"></label>
      <button type="reset" class="md-icon md-search__icon" data-md-component="reset" tabindex="-1">
        &#xE5CD;
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="result">
          <div class="md-search-result__meta">
            Type to start searching
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>

      </div>
      
        <div class="md-flex__cell md-flex__cell--shrink">
          <div class="md-header-nav__source">
            <a href="https://github.com/statsmodels/statsmodels" title="Go to repository" class="md-source" data-md-source="github">

    <div class="md-source__icon">
      <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24" width="28" height="28">
        <use xlink:href="#__github" width="24" height="24"></use>
      </svg>
    </div>
  
  <div class="md-source__repository">
    statsmodels
  </div>
</a>
          </div>
        </div>
      
    </div>
  </nav>
</header>

  
  <div class="md-container">
    
    
    
  <nav class="md-tabs" data-md-component="tabs">
    <div class="md-tabs__inner md-grid">
      <ul class="md-tabs__list">
          <li class="md-tabs__item"><a href="../../../index.html" class="md-tabs__link">Module code</a></li>
      </ul>
    </div>
  </nav>
    <main class="md-main">
      <div class="md-main__inner md-grid" data-md-component="container">
        
          <div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
            <div class="md-sidebar__scrollwrap">
              <div class="md-sidebar__inner">
                <nav class="md-nav md-nav--primary" data-md-level="0">
  <label class="md-nav__title md-nav__title--site" for="__drawer">
    <a href="../../../../index.html" title="statsmodels" class="md-nav__button md-logo">
      
        <img src="../../../../_static/statsmodels-logo-v2-bw.svg" alt=" logo" width="48" height="48">
      
    </a>
    <a href="../../../../index.html"
       title="statsmodels">statsmodels v0.11.1</a>
  </label>
    <div class="md-nav__source">
      <a href="https://github.com/statsmodels/statsmodels" title="Go to repository" class="md-source" data-md-source="github">

    <div class="md-source__icon">
      <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24" width="28" height="28">
        <use xlink:href="#__github" width="24" height="24"></use>
      </svg>
    </div>
  
  <div class="md-source__repository">
    statsmodels
  </div>
</a>
    </div>
  
  

  
  
  <ul class="md-nav__list">
    <li class="md-nav__item">
    
      <a href="../../../../install.html" class="md-nav__link">Installing statsmodels</a>
      
    </li>
    <li class="md-nav__item">
    
      <a href="../../../../gettingstarted.html" class="md-nav__link">Getting started</a>
      
    </li>
    <li class="md-nav__item">
    
      <a href="../../../../user-guide.html" class="md-nav__link">User Guide</a>
      
    </li>
    <li class="md-nav__item">
    
      <a href="../../../../examples/index.html" class="md-nav__link">Examples</a>
      
    </li>
    <li class="md-nav__item">
    
      <a href="../../../../api.html" class="md-nav__link">API Reference</a>
      
    </li>
    <li class="md-nav__item">
    
      <a href="../../../../about.html" class="md-nav__link">About statsmodels</a>
      
    </li>
    <li class="md-nav__item">
    
      <a href="../../../../dev/index.html" class="md-nav__link">Developer Page</a>
      
    </li>
    <li class="md-nav__item">
    
      <a href="../../../../release/index.html" class="md-nav__link">Release Notes</a>
      
    </li>
  </ul>
  

</nav>
              </div>
            </div>
          </div>
          <div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
            <div class="md-sidebar__scrollwrap">
              <div class="md-sidebar__inner">
                
<nav class="md-nav md-nav--secondary">
  <ul class="md-nav__list" data-md-scrollfix="">
    

<li id="searchbox" class="md-nav__item"></li>

  </ul>
</nav>
              </div>
            </div>
          </div>
        
        <div class="md-content">
          <article class="md-content__inner md-typeset" role="main">
            
  <h1 id="modules-statsmodels-tsa-regime-switching-markov-switching--page-root">Source code for statsmodels.tsa.regime_switching.markov_switching</h1><div class="highlight"><pre>
<span></span><span class="sd">"""</span>
<span class="sd">Markov switching models</span>

<span class="sd">Author: Chad Fulton</span>
<span class="sd">License: BSD-3</span>
<span class="sd">"""</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">OrderedDict</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">from</span> <span class="nn">scipy.special</span> <span class="kn">import</span> <span class="n">logsumexp</span>

<span class="kn">from</span> <span class="nn">statsmodels.tools.tools</span> <span class="kn">import</span> <span class="n">Bunch</span>
<span class="kn">from</span> <span class="nn">statsmodels.tools.numdiff</span> <span class="kn">import</span> <span class="n">approx_fprime_cs</span><span class="p">,</span> <span class="n">approx_hess_cs</span>
<span class="kn">from</span> <span class="nn">statsmodels.tools.decorators</span> <span class="kn">import</span> <span class="n">cache_readonly</span>
<span class="kn">from</span> <span class="nn">statsmodels.tools.eval_measures</span> <span class="kn">import</span> <span class="n">aic</span><span class="p">,</span> <span class="n">bic</span><span class="p">,</span> <span class="n">hqic</span>
<span class="kn">from</span> <span class="nn">statsmodels.tools.tools</span> <span class="kn">import</span> <span class="n">pinv_extended</span>
<span class="kn">from</span> <span class="nn">statsmodels.tools.sm_exceptions</span> <span class="kn">import</span> <span class="n">EstimationWarning</span>

<span class="kn">import</span> <span class="nn">statsmodels.base.wrapper</span> <span class="k">as</span> <span class="nn">wrap</span>
<span class="kn">from</span> <span class="nn">statsmodels.base.data</span> <span class="kn">import</span> <span class="n">PandasData</span>

<span class="kn">import</span> <span class="nn">statsmodels.tsa.base.tsa_model</span> <span class="k">as</span> <span class="nn">tsbase</span>
<span class="kn">from</span> <span class="nn">statsmodels.tsa.statespace.tools</span> <span class="kn">import</span> <span class="n">find_best_blas_type</span><span class="p">,</span> <span class="n">prepare_exog</span>

<span class="kn">from</span> <span class="nn">statsmodels.tsa.regime_switching._hamilton_filter</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">shamilton_filter_log</span><span class="p">,</span> <span class="n">dhamilton_filter_log</span><span class="p">,</span> <span class="n">chamilton_filter_log</span><span class="p">,</span>
    <span class="n">zhamilton_filter_log</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">statsmodels.tsa.regime_switching._kim_smoother</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">skim_smoother_log</span><span class="p">,</span> <span class="n">dkim_smoother_log</span><span class="p">,</span> <span class="n">ckim_smoother_log</span><span class="p">,</span> <span class="n">zkim_smoother_log</span><span class="p">)</span>

<span class="n">prefix_hamilton_filter_log_map</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">'s'</span><span class="p">:</span> <span class="n">shamilton_filter_log</span><span class="p">,</span> <span class="s1">'d'</span><span class="p">:</span> <span class="n">dhamilton_filter_log</span><span class="p">,</span>
    <span class="s1">'c'</span><span class="p">:</span> <span class="n">chamilton_filter_log</span><span class="p">,</span> <span class="s1">'z'</span><span class="p">:</span> <span class="n">zhamilton_filter_log</span>
<span class="p">}</span>

<span class="n">prefix_kim_smoother_log_map</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">'s'</span><span class="p">:</span> <span class="n">skim_smoother_log</span><span class="p">,</span> <span class="s1">'d'</span><span class="p">:</span> <span class="n">dkim_smoother_log</span><span class="p">,</span>
    <span class="s1">'c'</span><span class="p">:</span> <span class="n">ckim_smoother_log</span><span class="p">,</span> <span class="s1">'z'</span><span class="p">:</span> <span class="n">zkim_smoother_log</span>
<span class="p">}</span>


<span class="k">def</span> <span class="nf">_logistic</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    Note that this is not a vectorized function</span>
<span class="sd">    """</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="c1"># np.exp(x) / (1 + np.exp(x))</span>
    <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
    <span class="c1"># np.exp(x[i]) / (1 + np.sum(np.exp(x[:])))</span>
    <span class="k">elif</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
    <span class="c1"># np.exp(x[i,t]) / (1 + np.sum(np.exp(x[:,t])))</span>
    <span class="k">elif</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
    <span class="c1"># np.exp(x[i,j,t]) / (1 + np.sum(np.exp(x[:,j,t])))</span>
    <span class="k">elif</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">x</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">)),</span> <span class="n">y</span><span class="o">.</span><span class="n">T</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>
    <span class="n">evaluated</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">logsumexp</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)),</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">evaluated</span>


<span class="k">def</span> <span class="nf">_partials_logistic</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    Note that this is not a vectorized function</span>
<span class="sd">    """</span>
    <span class="n">tmp</span> <span class="o">=</span> <span class="n">_logistic</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="c1"># k</span>
    <span class="k">if</span> <span class="n">tmp</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">tmp</span> <span class="o">-</span> <span class="n">tmp</span><span class="o">**</span><span class="mi">2</span>
    <span class="c1"># k x k</span>
    <span class="k">elif</span> <span class="n">tmp</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">partials</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">tmp</span> <span class="o">-</span> <span class="n">tmp</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="c1"># k x k x t</span>
    <span class="k">elif</span> <span class="n">tmp</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">partials</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">tmp</span><span class="p">[:,</span> <span class="n">t</span><span class="p">]</span> <span class="o">-</span> <span class="n">tmp</span><span class="p">[:,</span> <span class="n">t</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">tmp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">tmp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">tmp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">partials</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">partials</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
    <span class="c1"># k x k x j x t</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">partials</span> <span class="o">=</span> <span class="p">[[</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">tmp</span><span class="p">[:,</span> <span class="n">j</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">-</span> <span class="n">tmp</span><span class="p">[:,</span> <span class="n">j</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
                     <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">tmp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">])]</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">tmp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">tmp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">tmp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">tmp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">partials</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">partials</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span>
            <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">tmp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
            <span class="n">partials</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">tmp</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">*</span> <span class="n">tmp</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
            <span class="n">partials</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">partials</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">partials</span>


<span class="k">def</span> <span class="nf">cy_hamilton_filter_log</span><span class="p">(</span><span class="n">initial_probabilities</span><span class="p">,</span> <span class="n">regime_transition</span><span class="p">,</span>
                           <span class="n">conditional_loglikelihoods</span><span class="p">,</span> <span class="n">model_order</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    Hamilton filter in log space using Cython inner loop.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    initial_probabilities : ndarray</span>
<span class="sd">        Array of initial probabilities, shaped (k_regimes,) giving the</span>
<span class="sd">        distribution of the regime process at time t = -order where order</span>
<span class="sd">        is a nonnegative integer.</span>
<span class="sd">    regime_transition : ndarray</span>
<span class="sd">        Matrix of regime transition probabilities, shaped either</span>
<span class="sd">        (k_regimes, k_regimes, 1) or if there are time-varying transition</span>
<span class="sd">        probabilities (k_regimes, k_regimes, nobs + order).  Entry [i, j,</span>
<span class="sd">        t] contains the probability of moving from j at time t-1 to i at</span>
<span class="sd">        time t, so each matrix regime_transition[:, :, t] should be left</span>
<span class="sd">        stochastic.  The first order entries and initial_probabilities are</span>
<span class="sd">        used to produce the initial joint distribution of dimension order +</span>
<span class="sd">        1 at time t=0.</span>
<span class="sd">    conditional_loglikelihoods : ndarray</span>
<span class="sd">        Array of loglikelihoods conditional on the last `order+1` regimes,</span>
<span class="sd">        shaped (k_regimes,)*(order + 1) + (nobs,).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    filtered_marginal_probabilities : ndarray</span>
<span class="sd">        Array containing Pr[S_t=s_t | Y_t] - the probability of being in each</span>
<span class="sd">        regime conditional on time t information. Shaped (k_regimes, nobs).</span>
<span class="sd">    predicted_joint_probabilities : ndarray</span>
<span class="sd">        Array containing Pr[S_t=s_t, ..., S_{t-order}=s_{t-order} | Y_{t-1}] -</span>
<span class="sd">        the joint probability of the current and previous `order` periods</span>
<span class="sd">        being in each combination of regimes conditional on time t-1</span>
<span class="sd">        information. Shaped (k_regimes,) * (order + 1) + (nobs,).</span>
<span class="sd">    joint_loglikelihoods : ndarray</span>
<span class="sd">        Array of loglikelihoods condition on time t information,</span>
<span class="sd">        shaped (nobs,).</span>
<span class="sd">    filtered_joint_probabilities : ndarray</span>
<span class="sd">        Array containing Pr[S_t=s_t, ..., S_{t-order}=s_{t-order} | Y_{t}] -</span>
<span class="sd">        the joint probability of the current and previous `order` periods</span>
<span class="sd">        being in each combination of regimes conditional on time t</span>
<span class="sd">        information. Shaped (k_regimes,) * (order + 1) + (nobs,).</span>
<span class="sd">    """</span>

    <span class="c1"># Dimensions</span>
    <span class="n">k_regimes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">initial_probabilities</span><span class="p">)</span>
    <span class="n">nobs</span> <span class="o">=</span> <span class="n">conditional_loglikelihoods</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">order</span> <span class="o">=</span> <span class="n">conditional_loglikelihoods</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">2</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="n">conditional_loglikelihoods</span><span class="o">.</span><span class="n">dtype</span>

    <span class="c1"># Check for compatible shapes.</span>
    <span class="n">incompatible_shapes</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">regime_transition</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nobs</span> <span class="o">+</span> <span class="n">model_order</span><span class="p">)</span>
        <span class="ow">or</span> <span class="n">regime_transition</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span> <span class="o">!=</span> <span class="p">(</span><span class="n">k_regimes</span><span class="p">,</span> <span class="n">k_regimes</span><span class="p">)</span>
        <span class="ow">or</span> <span class="n">conditional_loglikelihoods</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">k_regimes</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">incompatible_shapes</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'Arguments do not have compatible shapes'</span><span class="p">)</span>

    <span class="c1"># Convert to log space</span>
    <span class="n">initial_probabilities</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">initial_probabilities</span><span class="p">)</span>
    <span class="n">regime_transition</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">regime_transition</span><span class="p">,</span> <span class="mf">1e-20</span><span class="p">))</span>

    <span class="c1"># Storage</span>
    <span class="c1"># Pr[S_t = s_t | Y_t]</span>
    <span class="n">filtered_marginal_probabilities</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">k_regimes</span><span class="p">,</span> <span class="n">nobs</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">))</span>
    <span class="c1"># Pr[S_t = s_t, ... S_{t-r} = s_{t-r} | Y_{t-1}]</span>
    <span class="c1"># Has k_regimes^(order+1) elements</span>
    <span class="n">predicted_joint_probabilities</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
        <span class="p">(</span><span class="n">k_regimes</span><span class="p">,)</span> <span class="o">*</span> <span class="p">(</span><span class="n">order</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">nobs</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
    <span class="c1"># log(f(y_t | Y_{t-1}))</span>
    <span class="n">joint_loglikelihoods</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nobs</span><span class="p">,),</span> <span class="n">dtype</span><span class="p">)</span>
    <span class="c1"># Pr[S_t = s_t, ... S_{t-r+1} = s_{t-r+1} | Y_t]</span>
    <span class="c1"># Has k_regimes^order elements</span>
    <span class="n">filtered_joint_probabilities</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
        <span class="p">(</span><span class="n">k_regimes</span><span class="p">,)</span> <span class="o">*</span> <span class="p">(</span><span class="n">order</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">nobs</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

    <span class="c1"># Initial probabilities</span>
    <span class="n">filtered_marginal_probabilities</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">initial_probabilities</span>
    <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">initial_probabilities</span><span class="p">)</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">k_regimes</span><span class="p">,</span> <span class="n">k_regimes</span><span class="p">)</span>
    <span class="n">transition_t</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">order</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">regime_transition</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">transition_t</span> <span class="o">=</span> <span class="n">i</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">regime_transition</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">transition_t</span><span class="p">],</span>
                         <span class="n">shape</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span> <span class="o">*</span> <span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="n">tmp</span>
    <span class="n">filtered_joint_probabilities</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span>

    <span class="c1"># Get appropriate subset of transition matrix</span>
    <span class="k">if</span> <span class="n">regime_transition</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">regime_transition</span> <span class="o">=</span> <span class="n">regime_transition</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">model_order</span><span class="p">:]</span>

    <span class="c1"># Run Cython filter iterations</span>
    <span class="n">prefix</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">find_best_blas_type</span><span class="p">((</span>
        <span class="n">regime_transition</span><span class="p">,</span> <span class="n">conditional_loglikelihoods</span><span class="p">,</span> <span class="n">joint_loglikelihoods</span><span class="p">,</span>
        <span class="n">predicted_joint_probabilities</span><span class="p">,</span> <span class="n">filtered_joint_probabilities</span><span class="p">))</span>
    <span class="n">func</span> <span class="o">=</span> <span class="n">prefix_hamilton_filter_log_map</span><span class="p">[</span><span class="n">prefix</span><span class="p">]</span>
    <span class="n">func</span><span class="p">(</span><span class="n">nobs</span><span class="p">,</span> <span class="n">k_regimes</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">regime_transition</span><span class="p">,</span>
         <span class="n">conditional_loglikelihoods</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">k_regimes</span><span class="o">**</span><span class="p">(</span><span class="n">order</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="n">nobs</span><span class="p">),</span>
         <span class="n">joint_loglikelihoods</span><span class="p">,</span>
         <span class="n">predicted_joint_probabilities</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">k_regimes</span><span class="o">**</span><span class="p">(</span><span class="n">order</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="n">nobs</span><span class="p">),</span>
         <span class="n">filtered_joint_probabilities</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">k_regimes</span><span class="o">**</span><span class="p">(</span><span class="n">order</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="n">nobs</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>

    <span class="c1"># Save log versions for smoother</span>
    <span class="n">predicted_joint_probabilities_log</span> <span class="o">=</span> <span class="n">predicted_joint_probabilities</span>
    <span class="n">filtered_joint_probabilities_log</span> <span class="o">=</span> <span class="n">filtered_joint_probabilities</span>

    <span class="c1"># Convert out of log scale</span>
    <span class="n">predicted_joint_probabilities</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">predicted_joint_probabilities</span><span class="p">)</span>
    <span class="n">filtered_joint_probabilities</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">filtered_joint_probabilities</span><span class="p">)</span>

    <span class="c1"># S_t | t</span>
    <span class="n">filtered_marginal_probabilities</span> <span class="o">=</span> <span class="n">filtered_joint_probabilities</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">:]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">filtered_marginal_probabilities</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">filtered_marginal_probabilities</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
            <span class="n">filtered_marginal_probabilities</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">2</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">filtered_marginal_probabilities</span><span class="p">,</span> <span class="n">predicted_joint_probabilities</span><span class="p">,</span>
            <span class="n">joint_loglikelihoods</span><span class="p">,</span> <span class="n">filtered_joint_probabilities</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">:],</span>
            <span class="n">predicted_joint_probabilities_log</span><span class="p">,</span>
            <span class="n">filtered_joint_probabilities_log</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">:])</span>


<span class="k">def</span> <span class="nf">cy_kim_smoother_log</span><span class="p">(</span><span class="n">regime_transition</span><span class="p">,</span> <span class="n">predicted_joint_probabilities</span><span class="p">,</span>
                        <span class="n">filtered_joint_probabilities</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    Kim smoother in log space using Cython inner loop.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    regime_transition : ndarray</span>
<span class="sd">        Matrix of regime transition probabilities, shaped either</span>
<span class="sd">        (k_regimes, k_regimes, 1) or if there are time-varying transition</span>
<span class="sd">        probabilities (k_regimes, k_regimes, nobs).</span>
<span class="sd">    predicted_joint_probabilities : ndarray</span>
<span class="sd">        Array containing Pr[S_t=s_t, ..., S_{t-order}=s_{t-order} | Y_{t-1}] -</span>
<span class="sd">        the joint probability of the current and previous `order` periods</span>
<span class="sd">        being in each combination of regimes conditional on time t-1</span>
<span class="sd">        information. Shaped (k_regimes,) * (order + 1) + (nobs,).</span>
<span class="sd">    filtered_joint_probabilities : ndarray</span>
<span class="sd">        Array containing Pr[S_t=s_t, ..., S_{t-order}=s_{t-order} | Y_{t}] -</span>
<span class="sd">        the joint probability of the current and previous `order` periods</span>
<span class="sd">        being in each combination of regimes conditional on time t</span>
<span class="sd">        information. Shaped (k_regimes,) * (order + 1) + (nobs,).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    smoothed_joint_probabilities : ndarray</span>
<span class="sd">        Array containing Pr[S_t=s_t, ..., S_{t-order}=s_{t-order} | Y_T] -</span>
<span class="sd">        the joint probability of the current and previous `order` periods</span>
<span class="sd">        being in each combination of regimes conditional on all information.</span>
<span class="sd">        Shaped (k_regimes,) * (order + 1) + (nobs,).</span>
<span class="sd">    smoothed_marginal_probabilities : ndarray</span>
<span class="sd">        Array containing Pr[S_t=s_t | Y_T] - the probability of being in each</span>
<span class="sd">        regime conditional on all information. Shaped (k_regimes, nobs).</span>
<span class="sd">    """</span>

    <span class="c1"># Dimensions</span>
    <span class="n">k_regimes</span> <span class="o">=</span> <span class="n">filtered_joint_probabilities</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">nobs</span> <span class="o">=</span> <span class="n">filtered_joint_probabilities</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">order</span> <span class="o">=</span> <span class="n">filtered_joint_probabilities</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">2</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="n">filtered_joint_probabilities</span><span class="o">.</span><span class="n">dtype</span>

    <span class="c1"># Storage</span>
    <span class="n">smoothed_joint_probabilities</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
        <span class="p">(</span><span class="n">k_regimes</span><span class="p">,)</span> <span class="o">*</span> <span class="p">(</span><span class="n">order</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">nobs</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

    <span class="c1"># Get appropriate subset of transition matrix</span>
    <span class="k">if</span> <span class="n">regime_transition</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">nobs</span> <span class="o">+</span> <span class="n">order</span><span class="p">:</span>
        <span class="n">regime_transition</span> <span class="o">=</span> <span class="n">regime_transition</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">order</span><span class="p">:]</span>

    <span class="c1"># Convert to log space</span>
    <span class="n">regime_transition</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">regime_transition</span><span class="p">,</span> <span class="mf">1e-20</span><span class="p">))</span>

    <span class="c1"># Run Cython smoother iterations</span>
    <span class="n">prefix</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">find_best_blas_type</span><span class="p">((</span>
        <span class="n">regime_transition</span><span class="p">,</span> <span class="n">predicted_joint_probabilities</span><span class="p">,</span>
        <span class="n">filtered_joint_probabilities</span><span class="p">))</span>
    <span class="n">func</span> <span class="o">=</span> <span class="n">prefix_kim_smoother_log_map</span><span class="p">[</span><span class="n">prefix</span><span class="p">]</span>
    <span class="n">func</span><span class="p">(</span><span class="n">nobs</span><span class="p">,</span> <span class="n">k_regimes</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">regime_transition</span><span class="p">,</span>
         <span class="n">predicted_joint_probabilities</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">k_regimes</span><span class="o">**</span><span class="p">(</span><span class="n">order</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="n">nobs</span><span class="p">),</span>
         <span class="n">filtered_joint_probabilities</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">k_regimes</span><span class="o">**</span><span class="p">(</span><span class="n">order</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="n">nobs</span><span class="p">),</span>
         <span class="n">smoothed_joint_probabilities</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">k_regimes</span><span class="o">**</span><span class="p">(</span><span class="n">order</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="n">nobs</span><span class="p">))</span>

    <span class="c1"># Convert back from log space</span>
    <span class="n">smoothed_joint_probabilities</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">smoothed_joint_probabilities</span><span class="p">)</span>

    <span class="c1"># Get smoothed marginal probabilities S_t | T by integrating out</span>
    <span class="c1"># S_{t-k+1}, S_{t-k+2}, ..., S_{t-1}</span>
    <span class="n">smoothed_marginal_probabilities</span> <span class="o">=</span> <span class="n">smoothed_joint_probabilities</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">smoothed_marginal_probabilities</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">smoothed_marginal_probabilities</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
            <span class="n">smoothed_marginal_probabilities</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">2</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">smoothed_joint_probabilities</span><span class="p">,</span> <span class="n">smoothed_marginal_probabilities</span>


<span class="k">class</span> <span class="nc">MarkovSwitchingParams</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    Class to hold parameters in Markov switching models</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    k_regimes : int</span>
<span class="sd">        The number of regimes between which parameters may switch.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>

<span class="sd">    The purpose is to allow selecting parameter indexes / slices based on</span>
<span class="sd">    parameter type, regime number, or both.</span>

<span class="sd">    Parameters are lexicographically ordered in the following way:</span>

<span class="sd">    1. Named type string (e.g. "autoregressive")</span>
<span class="sd">    2. Number (e.g. the first autoregressive parameter, then the second)</span>
<span class="sd">    3. Regime (if applicable)</span>

<span class="sd">    Parameter blocks are set using dictionary setter notation where the key</span>
<span class="sd">    is the named type string and the value is a list of boolean values</span>
<span class="sd">    indicating whether a given parameter is switching or not.</span>

<span class="sd">    For example, consider the following code:</span>

<span class="sd">        parameters = MarkovSwitchingParams(k_regimes=2)</span>
<span class="sd">        parameters['regime_transition'] = [1,1]</span>
<span class="sd">        parameters['exog'] = [0, 1]</span>

<span class="sd">    This implies the model has 7 parameters: 4 "regime_transition"-related</span>
<span class="sd">    parameters (2 parameters that each switch according to regimes) and 3</span>
<span class="sd">    "exog"-related parameters (1 parameter that does not switch, and one 1 that</span>
<span class="sd">    does).</span>

<span class="sd">    The order of parameters is then:</span>

<span class="sd">    1. The first "regime_transition" parameter, regime 0</span>
<span class="sd">    2. The first "regime_transition" parameter, regime 1</span>
<span class="sd">    3. The second "regime_transition" parameter, regime 1</span>
<span class="sd">    4. The second "regime_transition" parameter, regime 1</span>
<span class="sd">    5. The first "exog" parameter</span>
<span class="sd">    6. The second "exog" parameter, regime 0</span>
<span class="sd">    7. The second "exog" parameter, regime 1</span>

<span class="sd">    Retrieving indexes / slices is done through dictionary getter notation.</span>
<span class="sd">    There are three options for the dictionary key:</span>

<span class="sd">    - Regime number (zero-indexed)</span>
<span class="sd">    - Named type string (e.g. "autoregressive")</span>
<span class="sd">    - Regime number and named type string</span>

<span class="sd">    In the above example, consider the following getters:</span>

<span class="sd">    &gt;&gt;&gt; parameters[0]</span>
<span class="sd">    array([0, 2, 4, 6])</span>
<span class="sd">    &gt;&gt;&gt; parameters[1]</span>
<span class="sd">    array([1, 3, 5, 6])</span>
<span class="sd">    &gt;&gt;&gt; parameters['exog']</span>
<span class="sd">    slice(4, 7, None)</span>
<span class="sd">    &gt;&gt;&gt; parameters[0, 'exog']</span>
<span class="sd">    [4, 6]</span>
<span class="sd">    &gt;&gt;&gt; parameters[1, 'exog']</span>
<span class="sd">    [4, 7]</span>

<span class="sd">    Notice that in the last two examples, both lists of indexes include 4.</span>
<span class="sd">    That's because that is the index of the the non-switching first "exog"</span>
<span class="sd">    parameter, which should be selected regardless of the regime.</span>

<span class="sd">    In addition to the getter, the `k_parameters` attribute is an OrderedDict</span>
<span class="sd">    with the named type strings as the keys. It can be used to get the total</span>
<span class="sd">    number of parameters of each type:</span>

<span class="sd">    &gt;&gt;&gt; parameters.k_parameters['regime_transition']</span>
<span class="sd">    4</span>
<span class="sd">    &gt;&gt;&gt; parameters.k_parameters['exog']</span>
<span class="sd">    3</span>
<span class="sd">    """</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k_regimes</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k_regimes</span> <span class="o">=</span> <span class="n">k_regimes</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">k_params</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k_parameters</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">switching</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">slices_purpose</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">relative_index_regime_purpose</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">OrderedDict</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_regimes</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">index_regime_purpose</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">OrderedDict</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_regimes</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">index_regime</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_regimes</span><span class="p">)]</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="n">_type</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

        <span class="c1"># Get a slice for a block of parameters by purpose</span>
        <span class="k">if</span> <span class="n">_type</span> <span class="ow">is</span> <span class="nb">str</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">slices_purpose</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="c1"># Get a slice for a block of parameters by regime</span>
        <span class="k">elif</span> <span class="n">_type</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">index_regime</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">_type</span> <span class="ow">is</span> <span class="nb">tuple</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s1">'Invalid index'</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="nb">str</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="nb">int</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">index_regime_purpose</span><span class="p">[</span><span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
            <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="nb">str</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="nb">int</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">index_regime_purpose</span><span class="p">[</span><span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s1">'Invalid index'</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s1">'Invalid index'</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="n">_type</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">_type</span> <span class="ow">is</span> <span class="nb">str</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">k_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_params</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">k_parameters</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">value</span><span class="o">.</span><span class="n">size</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_regimes</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">k_params</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_parameters</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">switching</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">slices_purpose</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">s_</span><span class="p">[</span><span class="n">k_params</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">k_params</span><span class="p">]</span>

            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_regimes</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">relative_index_regime_purpose</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">index_regime_purpose</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
                <span class="n">switching</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_regimes</span><span class="p">):</span>
                    <span class="c1"># Non-switching parameters</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">switching</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">relative_index_regime_purpose</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                            <span class="n">offset</span><span class="p">)</span>
                    <span class="c1"># Switching parameters</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">relative_index_regime_purpose</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                            <span class="n">offset</span> <span class="o">+</span> <span class="n">j</span><span class="p">)</span>
                <span class="n">offset</span> <span class="o">+=</span> <span class="mi">1</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">switching</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_regimes</span>

            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_regimes</span><span class="p">):</span>
                <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">indices</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">relative_index_regime_purpose</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">v</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">+</span> <span class="n">offset</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">index_regime_purpose</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
                    <span class="n">indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                    <span class="n">offset</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_parameters</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">index_regime</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s1">'Invalid index'</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">MarkovSwitching</span><span class="p">(</span><span class="n">tsbase</span><span class="o">.</span><span class="n">TimeSeriesModel</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    First-order k-regime Markov switching model</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    endog : array_like</span>
<span class="sd">        The endogenous variable.</span>
<span class="sd">    k_regimes : int</span>
<span class="sd">        The number of regimes.</span>
<span class="sd">    order : int, optional</span>
<span class="sd">        The order of the model describes the dependence of the likelihood on</span>
<span class="sd">        previous regimes. This depends on the model in question and should be</span>
<span class="sd">        set appropriately by subclasses.</span>
<span class="sd">    exog_tvtp : array_like, optional</span>
<span class="sd">        Array of exogenous or lagged variables to use in calculating</span>
<span class="sd">        time-varying transition probabilities (TVTP). TVTP is only used if this</span>
<span class="sd">        variable is provided. If an intercept is desired, a column of ones must</span>
<span class="sd">        be explicitly included in this array.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This model is new and API stability is not guaranteed, although changes</span>
<span class="sd">    will be made in a backwards compatible way if possible.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    Kim, Chang-Jin, and Charles R. Nelson. 1999.</span>
<span class="sd">    "State-Space Models with Regime Switching:</span>
<span class="sd">    Classical and Gibbs-Sampling Approaches with Applications".</span>
<span class="sd">    MIT Press Books. The MIT Press.</span>
<span class="sd">    """</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">endog</span><span class="p">,</span> <span class="n">k_regimes</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">exog_tvtp</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">exog</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">dates</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">missing</span><span class="o">=</span><span class="s1">'none'</span><span class="p">):</span>

        <span class="c1"># Properties</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k_regimes</span> <span class="o">=</span> <span class="n">k_regimes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tvtp</span> <span class="o">=</span> <span class="n">exog_tvtp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="c1"># The order of the model may be overridden in subclasses</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">order</span> <span class="o">=</span> <span class="n">order</span>

        <span class="c1"># Exogenous data</span>
        <span class="c1"># TODO add checks for exog_tvtp consistent shape and indices</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k_tvtp</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">exog_tvtp</span> <span class="o">=</span> <span class="n">prepare_exog</span><span class="p">(</span><span class="n">exog_tvtp</span><span class="p">)</span>

        <span class="c1"># Initialize the base model</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">MarkovSwitching</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">endog</span><span class="p">,</span> <span class="n">exog</span><span class="p">,</span> <span class="n">dates</span><span class="o">=</span><span class="n">dates</span><span class="p">,</span>
                                              <span class="n">freq</span><span class="o">=</span><span class="n">freq</span><span class="p">,</span> <span class="n">missing</span><span class="o">=</span><span class="n">missing</span><span class="p">)</span>

        <span class="c1"># Dimensions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">endog</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Sanity checks</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">endog</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">endog</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'Must have univariate endogenous data.'</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_regimes</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'Markov switching models must have at least two'</span>
                             <span class="s1">' regimes.'</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exog_tvtp</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">exog_tvtp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'Time-varying transition probabilities exogenous'</span>
                             <span class="s1">' array must have the same number of observations'</span>
                             <span class="s1">' as the endogenous array.'</span><span class="p">)</span>

        <span class="c1"># Parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span> <span class="o">=</span> <span class="n">MarkovSwitchingParams</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_regimes</span><span class="p">)</span>
        <span class="n">k_transition</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_regimes</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tvtp</span><span class="p">:</span>
            <span class="n">k_transition</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_tvtp</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s1">'regime_transition'</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">k_transition</span>

        <span class="c1"># Internal model properties: default is steady-state initialization</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initialization</span> <span class="o">=</span> <span class="s1">'steady-state'</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initial_probabilities</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">k_params</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        (int) Number of parameters in the model</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">k_params</span>

    <span class="k">def</span> <span class="nf">initialize_steady_state</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Set initialization of regime probabilities to be steady-state values</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Only valid if there are not time-varying transition probabilities.</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tvtp</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'Cannot use steady-state initialization when'</span>
                             <span class="s1">' the regime transition matrix is time-varying.'</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_initialization</span> <span class="o">=</span> <span class="s1">'steady-state'</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initial_probabilities</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">initialize_known</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">probabilities</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Set initialization of regime probabilities to use known values</span>
<span class="sd">        """</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initialization</span> <span class="o">=</span> <span class="s1">'known'</span>
        <span class="n">probabilities</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">probabilities</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">probabilities</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_regimes</span><span class="p">,):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'Initial probabilities must be a vector of shape'</span>
                             <span class="s1">' (k_regimes,).'</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">probabilities</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'Initial probabilities vector must sum to one.'</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initial_probabilities</span> <span class="o">=</span> <span class="n">probabilities</span>

    <span class="k">def</span> <span class="nf">initial_probabilities</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">regime_transition</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Retrieve initial probabilities</span>
<span class="sd">        """</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initialization</span> <span class="o">==</span> <span class="s1">'steady-state'</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">regime_transition</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">regime_transition</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">regime_transition_matrix</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">regime_transition</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">regime_transition</span> <span class="o">=</span> <span class="n">regime_transition</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">regime_transition</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="o">-</span> <span class="n">regime_transition</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">m</span><span class="p">)]</span><span class="o">.</span><span class="n">T</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">probabilities</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">pinv</span><span class="p">(</span><span class="n">A</span><span class="p">)[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">except</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">LinAlgError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">'Steady-state probabilities could not be'</span>
                                   <span class="s1">' constructed.'</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initialization</span> <span class="o">==</span> <span class="s1">'known'</span><span class="p">:</span>
            <span class="n">probabilities</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initial_probabilities</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">'Invalid initialization method selected.'</span><span class="p">)</span>

        <span class="c1"># Slightly bound probabilities away from zero (for filters in log</span>
        <span class="c1"># space)</span>
        <span class="n">probabilities</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">probabilities</span><span class="p">,</span> <span class="mf">1e-20</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">probabilities</span>

    <span class="k">def</span> <span class="nf">_regime_transition_matrix_tvtp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">exog_tvtp</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">exog_tvtp</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">exog_tvtp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exog_tvtp</span>
        <span class="n">nobs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">exog_tvtp</span><span class="p">)</span>

        <span class="n">regime_transition_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_regimes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_regimes</span><span class="p">,</span> <span class="n">nobs</span><span class="p">),</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">promote_types</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">params</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>

        <span class="c1"># Compute the predicted values from the regression</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_regimes</span><span class="p">):</span>
            <span class="n">coeffs</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="s1">'regime_transition'</span><span class="p">]]</span>
            <span class="n">regime_transition_matrix</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
                <span class="n">exog_tvtp</span><span class="p">,</span>
                <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">coeffs</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_regimes</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_tvtp</span><span class="p">))</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

        <span class="c1"># Perform the logistic transformation</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nobs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_regimes</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span>
                    <span class="n">regime_transition_matrix</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span><span class="o">.</span><span class="n">T</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>
        <span class="n">regime_transition_matrix</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span>
            <span class="n">regime_transition_matrix</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">logsumexp</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>

        <span class="c1"># Compute the last column of the transition matrix</span>
        <span class="n">regime_transition_matrix</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="mi">1</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">regime_transition_matrix</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">regime_transition_matrix</span>

    <span class="k">def</span> <span class="nf">regime_transition_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">exog_tvtp</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Construct the left-stochastic transition matrix</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This matrix will either be shaped (k_regimes, k_regimes, 1) or if there</span>
<span class="sd">        are time-varying transition probabilities, it will be shaped</span>
<span class="sd">        (k_regimes, k_regimes, nobs).</span>

<span class="sd">        The (i,j)th element of this matrix is the probability of transitioning</span>
<span class="sd">        from regime j to regime i; thus the previous regime is represented in a</span>
<span class="sd">        column and the next regime is represented by a row.</span>

<span class="sd">        It is left-stochastic, meaning that each column sums to one (because</span>
<span class="sd">        it is certain that from one regime (j) you will transition to *some</span>
<span class="sd">        other regime*).</span>
<span class="sd">        """</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">tvtp</span><span class="p">:</span>
            <span class="n">regime_transition_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_regimes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_regimes</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
                <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">promote_types</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">params</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>
            <span class="n">regime_transition_matrix</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
                <span class="n">params</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s1">'regime_transition'</span><span class="p">]],</span>
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_regimes</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_regimes</span><span class="p">))</span>
            <span class="n">regime_transition_matrix</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="mi">1</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">regime_transition_matrix</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">regime_transition_matrix</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_regime_transition_matrix_tvtp</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">exog_tvtp</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">regime_transition_matrix</span>

    <span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">probabilities</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">conditional</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        In-sample prediction and out-of-sample forecasting</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : ndarray</span>
<span class="sd">            Parameters at which to form predictions</span>
<span class="sd">        start : int, str, or datetime, optional</span>
<span class="sd">            Zero-indexed observation number at which to start forecasting,</span>
<span class="sd">            i.e., the first forecast is start. Can also be a date string to</span>
<span class="sd">            parse or a datetime type. Default is the the zeroth observation.</span>
<span class="sd">        end : int, str, or datetime, optional</span>
<span class="sd">            Zero-indexed observation number at which to end forecasting, i.e.,</span>
<span class="sd">            the last forecast is end. Can also be a date string to</span>
<span class="sd">            parse or a datetime type. However, if the dates index does not</span>
<span class="sd">            have a fixed frequency, end must be an integer index if you</span>
<span class="sd">            want out of sample prediction. Default is the last observation in</span>
<span class="sd">            the sample.</span>
<span class="sd">        probabilities : str or array_like, optional</span>
<span class="sd">            Specifies the weighting probabilities used in constructing the</span>
<span class="sd">            prediction as a weighted average. If a string, can be 'predicted',</span>
<span class="sd">            'filtered', or 'smoothed'. Otherwise can be an array of</span>
<span class="sd">            probabilities to use. Default is smoothed.</span>
<span class="sd">        conditional : bool or int, optional</span>
<span class="sd">            Whether or not to return predictions conditional on current or</span>
<span class="sd">            past regimes. If False, returns a single vector of weighted</span>
<span class="sd">            predictions. If True or 1, returns predictions conditional on the</span>
<span class="sd">            current regime. For larger integers, returns predictions</span>
<span class="sd">            conditional on the current regime and some number of past regimes.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        predict : ndarray</span>
<span class="sd">            Array of out of in-sample predictions and / or out-of-sample</span>
<span class="sd">            forecasts.</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Handle start, end</span>
        <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">out_of_sample</span><span class="p">,</span> <span class="n">prediction_index</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_get_prediction_index</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">out_of_sample</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span>

        <span class="c1"># Perform in-sample prediction</span>
        <span class="n">predict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predict_conditional</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
        <span class="n">squeezed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">predict</span><span class="p">)</span>

        <span class="c1"># Check if we need to do weighted averaging</span>
        <span class="k">if</span> <span class="n">squeezed</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&gt;</span> <span class="n">conditional</span><span class="p">:</span>
            <span class="c1"># Determine in-sample weighting probabilities</span>
            <span class="k">if</span> <span class="n">probabilities</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">probabilities</span> <span class="o">==</span> <span class="s1">'smoothed'</span><span class="p">:</span>
                <span class="n">results</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">smooth</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">return_raw</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">probabilities</span> <span class="o">=</span> <span class="n">results</span><span class="o">.</span><span class="n">smoothed_joint_probabilities</span>
            <span class="k">elif</span> <span class="n">probabilities</span> <span class="o">==</span> <span class="s1">'filtered'</span><span class="p">:</span>
                <span class="n">results</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">return_raw</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">probabilities</span> <span class="o">=</span> <span class="n">results</span><span class="o">.</span><span class="n">filtered_joint_probabilities</span>
            <span class="k">elif</span> <span class="n">probabilities</span> <span class="o">==</span> <span class="s1">'predicted'</span><span class="p">:</span>
                <span class="n">results</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">return_raw</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">probabilities</span> <span class="o">=</span> <span class="n">results</span><span class="o">.</span><span class="n">predicted_joint_probabilities</span>

            <span class="c1"># Compute weighted average</span>
            <span class="n">predict</span> <span class="o">=</span> <span class="p">(</span><span class="n">predict</span> <span class="o">*</span> <span class="n">probabilities</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">predict</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="nb">int</span><span class="p">(</span><span class="n">conditional</span><span class="p">)):</span>
                <span class="n">predict</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">predict</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">predict</span> <span class="o">=</span> <span class="n">squeezed</span>

        <span class="k">return</span> <span class="n">predict</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span> <span class="o">+</span> <span class="n">out_of_sample</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">predict_conditional</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        In-sample prediction, conditional on the current, and possibly past,</span>
<span class="sd">        regimes</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array_like</span>
<span class="sd">            Array of parameters at which to perform prediction.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        predict : array_like</span>
<span class="sd">            Array of predictions conditional on current, and possibly past,</span>
<span class="sd">            regimes</span>
<span class="sd">        """</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="k">def</span> <span class="nf">_conditional_loglikelihoods</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Compute likelihoods conditional on the current period's regime (and</span>
<span class="sd">        the last self.order periods' regimes if self.order &gt; 0).</span>

<span class="sd">        Must be implemented in subclasses.</span>
<span class="sd">        """</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="k">def</span> <span class="nf">_filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">regime_transition</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># Get the regime transition matrix if not provided</span>
        <span class="k">if</span> <span class="n">regime_transition</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">regime_transition</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">regime_transition_matrix</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
        <span class="c1"># Get the initial probabilities</span>
        <span class="n">initial_probabilities</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">initial_probabilities</span><span class="p">(</span>
            <span class="n">params</span><span class="p">,</span> <span class="n">regime_transition</span><span class="p">)</span>

        <span class="c1"># Compute the conditional likelihoods</span>
        <span class="n">conditional_loglikelihoods</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conditional_loglikelihoods</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>

        <span class="c1"># Apply the filter</span>
        <span class="k">return</span> <span class="p">((</span><span class="n">regime_transition</span><span class="p">,</span> <span class="n">initial_probabilities</span><span class="p">,</span>
                 <span class="n">conditional_loglikelihoods</span><span class="p">)</span> <span class="o">+</span>
                <span class="n">cy_hamilton_filter_log</span><span class="p">(</span>
                    <span class="n">initial_probabilities</span><span class="p">,</span> <span class="n">regime_transition</span><span class="p">,</span>
                    <span class="n">conditional_loglikelihoods</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">order</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cov_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cov_kwds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="n">return_raw</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">results_class</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="n">results_wrapper_class</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Apply the Hamilton filter</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array_like</span>
<span class="sd">            Array of parameters at which to perform filtering.</span>
<span class="sd">        transformed : bool, optional</span>
<span class="sd">            Whether or not `params` is already transformed. Default is True.</span>
<span class="sd">        cov_type : str, optional</span>
<span class="sd">            See `fit` for a description of covariance matrix types</span>
<span class="sd">            for results object.</span>
<span class="sd">        cov_kwds : dict or None, optional</span>
<span class="sd">            See `fit` for a description of required keywords for alternative</span>
<span class="sd">            covariance estimators</span>
<span class="sd">        return_raw : bool,optional</span>
<span class="sd">            Whether or not to return only the raw Hamilton filter output or a</span>
<span class="sd">            full results object. Default is to return a full results object.</span>
<span class="sd">        results_class : type, optional</span>
<span class="sd">            A results class to instantiate rather than</span>
<span class="sd">            `MarkovSwitchingResults`. Usually only used internally by</span>
<span class="sd">            subclasses.</span>
<span class="sd">        results_wrapper_class : type, optional</span>
<span class="sd">            A results wrapper class to instantiate rather than</span>
<span class="sd">            `MarkovSwitchingResults`. Usually only used internally by</span>
<span class="sd">            subclasses.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        MarkovSwitchingResults</span>
<span class="sd">        """</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">transformed</span><span class="p">:</span>
            <span class="n">params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_params</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>

        <span class="c1"># Save the parameter names</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">param_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_names</span>

        <span class="c1"># Get the result</span>
        <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">'regime_transition'</span><span class="p">,</span> <span class="s1">'initial_probabilities'</span><span class="p">,</span>
                 <span class="s1">'conditional_loglikelihoods'</span><span class="p">,</span>
                 <span class="s1">'filtered_marginal_probabilities'</span><span class="p">,</span>
                 <span class="s1">'predicted_joint_probabilities'</span><span class="p">,</span> <span class="s1">'joint_loglikelihoods'</span><span class="p">,</span>
                 <span class="s1">'filtered_joint_probabilities'</span><span class="p">,</span>
                 <span class="s1">'predicted_joint_probabilities_log'</span><span class="p">,</span>
                 <span class="s1">'filtered_joint_probabilities_log'</span><span class="p">]</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">HamiltonFilterResults</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">Bunch</span><span class="p">(</span><span class="o">**</span><span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filter</span><span class="p">(</span><span class="n">params</span><span class="p">)))))</span>

        <span class="c1"># Wrap in a results object</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_results</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">return_raw</span><span class="p">,</span> <span class="n">cov_type</span><span class="p">,</span>
                                  <span class="n">cov_kwds</span><span class="p">,</span> <span class="n">results_class</span><span class="p">,</span>
                                  <span class="n">results_wrapper_class</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_smooth</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">predicted_joint_probabilities_log</span><span class="p">,</span>
                <span class="n">filtered_joint_probabilities_log</span><span class="p">,</span> <span class="n">regime_transition</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># Get the regime transition matrix</span>
        <span class="k">if</span> <span class="n">regime_transition</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">regime_transition</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">regime_transition_matrix</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>

        <span class="c1"># Apply the smoother</span>
        <span class="k">return</span> <span class="n">cy_kim_smoother_log</span><span class="p">(</span><span class="n">regime_transition</span><span class="p">,</span>
                                   <span class="n">predicted_joint_probabilities_log</span><span class="p">,</span>
                                   <span class="n">filtered_joint_probabilities_log</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_res_classes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">'fit'</span><span class="p">:</span> <span class="p">(</span><span class="n">MarkovSwitchingResults</span><span class="p">,</span> <span class="n">MarkovSwitchingResultsWrapper</span><span class="p">)}</span>

    <span class="k">def</span> <span class="nf">_wrap_results</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">return_raw</span><span class="p">,</span> <span class="n">cov_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                      <span class="n">cov_kwds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">results_class</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">wrapper_class</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">return_raw</span><span class="p">:</span>
            <span class="c1"># Wrap in a results object</span>
            <span class="n">result_kwargs</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">if</span> <span class="n">cov_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">result_kwargs</span><span class="p">[</span><span class="s1">'cov_type'</span><span class="p">]</span> <span class="o">=</span> <span class="n">cov_type</span>
            <span class="k">if</span> <span class="n">cov_kwds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">result_kwargs</span><span class="p">[</span><span class="s1">'cov_kwds'</span><span class="p">]</span> <span class="o">=</span> <span class="n">cov_kwds</span>

            <span class="k">if</span> <span class="n">results_class</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">results_class</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_res_classes</span><span class="p">[</span><span class="s1">'fit'</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">wrapper_class</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">wrapper_class</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_res_classes</span><span class="p">[</span><span class="s1">'fit'</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>

            <span class="n">res</span> <span class="o">=</span> <span class="n">results_class</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="o">**</span><span class="n">result_kwargs</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">wrapper_class</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">smooth</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cov_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cov_kwds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="n">return_raw</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">results_class</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="n">results_wrapper_class</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Apply the Kim smoother and Hamilton filter</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array_like</span>
<span class="sd">            Array of parameters at which to perform filtering.</span>
<span class="sd">        transformed : bool, optional</span>
<span class="sd">            Whether or not `params` is already transformed. Default is True.</span>
<span class="sd">        cov_type : str, optional</span>
<span class="sd">            See `fit` for a description of covariance matrix types</span>
<span class="sd">            for results object.</span>
<span class="sd">        cov_kwds : dict or None, optional</span>
<span class="sd">            See `fit` for a description of required keywords for alternative</span>
<span class="sd">            covariance estimators</span>
<span class="sd">        return_raw : bool,optional</span>
<span class="sd">            Whether or not to return only the raw Hamilton filter output or a</span>
<span class="sd">            full results object. Default is to return a full results object.</span>
<span class="sd">        results_class : type, optional</span>
<span class="sd">            A results class to instantiate rather than</span>
<span class="sd">            `MarkovSwitchingResults`. Usually only used internally by</span>
<span class="sd">            subclasses.</span>
<span class="sd">        results_wrapper_class : type, optional</span>
<span class="sd">            A results wrapper class to instantiate rather than</span>
<span class="sd">            `MarkovSwitchingResults`. Usually only used internally by</span>
<span class="sd">            subclasses.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        MarkovSwitchingResults</span>
<span class="sd">        """</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">transformed</span><span class="p">:</span>
            <span class="n">params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_params</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>

        <span class="c1"># Save the parameter names</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">param_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_names</span>

        <span class="c1"># Hamilton filter</span>
        <span class="c1"># TODO add option to filter to return logged values so that we do not</span>
        <span class="c1"># need to re-log them for smoother</span>
        <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">'regime_transition'</span><span class="p">,</span> <span class="s1">'initial_probabilities'</span><span class="p">,</span>
                 <span class="s1">'conditional_loglikelihoods'</span><span class="p">,</span>
                 <span class="s1">'filtered_marginal_probabilities'</span><span class="p">,</span>
                 <span class="s1">'predicted_joint_probabilities'</span><span class="p">,</span> <span class="s1">'joint_loglikelihoods'</span><span class="p">,</span>
                 <span class="s1">'filtered_joint_probabilities'</span><span class="p">,</span>
                 <span class="s1">'predicted_joint_probabilities_log'</span><span class="p">,</span>
                 <span class="s1">'filtered_joint_probabilities_log'</span><span class="p">]</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">Bunch</span><span class="p">(</span><span class="o">**</span><span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filter</span><span class="p">(</span><span class="n">params</span><span class="p">))))</span>

        <span class="c1"># Kim smoother</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_smooth</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">result</span><span class="o">.</span><span class="n">predicted_joint_probabilities_log</span><span class="p">,</span>
                           <span class="n">result</span><span class="o">.</span><span class="n">filtered_joint_probabilities_log</span><span class="p">)</span>
        <span class="n">result</span><span class="p">[</span><span class="s1">'smoothed_joint_probabilities'</span><span class="p">]</span> <span class="o">=</span> <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">result</span><span class="p">[</span><span class="s1">'smoothed_marginal_probabilities'</span><span class="p">]</span> <span class="o">=</span> <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">KimSmootherResults</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>

        <span class="c1"># Wrap in a results object</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_results</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">return_raw</span><span class="p">,</span> <span class="n">cov_type</span><span class="p">,</span>
                                  <span class="n">cov_kwds</span><span class="p">,</span> <span class="n">results_class</span><span class="p">,</span>
                                  <span class="n">results_wrapper_class</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">loglikeobs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Loglikelihood evaluation for each period</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array_like</span>
<span class="sd">            Array of parameters at which to evaluate the loglikelihood</span>
<span class="sd">            function.</span>
<span class="sd">        transformed : bool, optional</span>
<span class="sd">            Whether or not `params` is already transformed. Default is True.</span>
<span class="sd">        """</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">transformed</span><span class="p">:</span>
            <span class="n">params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_params</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>

        <span class="n">results</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filter</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">results</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">loglike</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Loglikelihood evaluation</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array_like</span>
<span class="sd">            Array of parameters at which to evaluate the loglikelihood</span>
<span class="sd">            function.</span>
<span class="sd">        transformed : bool, optional</span>
<span class="sd">            Whether or not `params` is already transformed. Default is True.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loglikeobs</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">score</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Compute the score function at params.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array_like</span>
<span class="sd">            Array of parameters at which to evaluate the score</span>
<span class="sd">            function.</span>
<span class="sd">        transformed : bool, optional</span>
<span class="sd">            Whether or not `params` is already transformed. Default is True.</span>
<span class="sd">        """</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">approx_fprime_cs</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">loglike</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">transformed</span><span class="p">,))</span>

    <span class="k">def</span> <span class="nf">score_obs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Compute the score per observation, evaluated at params</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array_like</span>
<span class="sd">            Array of parameters at which to evaluate the score</span>
<span class="sd">            function.</span>
<span class="sd">        transformed : bool, optional</span>
<span class="sd">            Whether or not `params` is already transformed. Default is True.</span>
<span class="sd">        """</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">approx_fprime_cs</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">loglikeobs</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">transformed</span><span class="p">,))</span>

    <span class="k">def</span> <span class="nf">hessian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Hessian matrix of the likelihood function, evaluated at the given</span>
<span class="sd">        parameters</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array_like</span>
<span class="sd">            Array of parameters at which to evaluate the Hessian</span>
<span class="sd">            function.</span>
<span class="sd">        transformed : bool, optional</span>
<span class="sd">            Whether or not `params` is already transformed. Default is True.</span>
<span class="sd">        """</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">approx_hess_cs</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">loglike</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cov_type</span><span class="o">=</span><span class="s1">'approx'</span><span class="p">,</span>
            <span class="n">cov_kwds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">'bfgs'</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">full_output</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">disp</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="n">callback</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">return_params</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">em_iter</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">search_reps</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="n">search_iter</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">search_scale</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Fits the model by maximum likelihood via Hamilton filter.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        start_params : array_like, optional</span>
<span class="sd">            Initial guess of the solution for the loglikelihood maximization.</span>
<span class="sd">            If None, the default is given by Model.start_params.</span>
<span class="sd">        transformed : bool, optional</span>
<span class="sd">            Whether or not `start_params` is already transformed. Default is</span>
<span class="sd">            True.</span>
<span class="sd">        cov_type : str, optional</span>
<span class="sd">            The type of covariance matrix estimator to use. Can be one of</span>
<span class="sd">            'approx', 'opg', 'robust', or 'none'. Default is 'approx'.</span>
<span class="sd">        cov_kwds : dict or None, optional</span>
<span class="sd">            Keywords for alternative covariance estimators</span>
<span class="sd">        method : str, optional</span>
<span class="sd">            The `method` determines which solver from `scipy.optimize`</span>
<span class="sd">            is used, and it can be chosen from among the following strings:</span>

<span class="sd">            - 'newton' for Newton-Raphson, 'nm' for Nelder-Mead</span>
<span class="sd">            - 'bfgs' for Broyden-Fletcher-Goldfarb-Shanno (BFGS)</span>
<span class="sd">            - 'lbfgs' for limited-memory BFGS with optional box constraints</span>
<span class="sd">            - 'powell' for modified Powell's method</span>
<span class="sd">            - 'cg' for conjugate gradient</span>
<span class="sd">            - 'ncg' for Newton-conjugate gradient</span>
<span class="sd">            - 'basinhopping' for global basin-hopping solver</span>

<span class="sd">            The explicit arguments in `fit` are passed to the solver,</span>
<span class="sd">            with the exception of the basin-hopping solver. Each</span>
<span class="sd">            solver has several optional arguments that are not the same across</span>
<span class="sd">            solvers. See the notes section below (or scipy.optimize) for the</span>
<span class="sd">            available arguments and for the list of explicit arguments that the</span>
<span class="sd">            basin-hopping solver supports.</span>
<span class="sd">        maxiter : int, optional</span>
<span class="sd">            The maximum number of iterations to perform.</span>
<span class="sd">        full_output : bool, optional</span>
<span class="sd">            Set to True to have all available output in the Results object's</span>
<span class="sd">            mle_retvals attribute. The output is dependent on the solver.</span>
<span class="sd">            See LikelihoodModelResults notes section for more information.</span>
<span class="sd">        disp : bool, optional</span>
<span class="sd">            Set to True to print convergence messages.</span>
<span class="sd">        callback : callable callback(xk), optional</span>
<span class="sd">            Called after each iteration, as callback(xk), where xk is the</span>
<span class="sd">            current parameter vector.</span>
<span class="sd">        return_params : bool, optional</span>
<span class="sd">            Whether or not to return only the array of maximizing parameters.</span>
<span class="sd">            Default is False.</span>
<span class="sd">        em_iter : int, optional</span>
<span class="sd">            Number of initial EM iteration steps used to improve starting</span>
<span class="sd">            parameters.</span>
<span class="sd">        search_reps : int, optional</span>
<span class="sd">            Number of randomly drawn search parameters that are drawn around</span>
<span class="sd">            `start_params` to try and improve starting parameters. Default is</span>
<span class="sd">            0.</span>
<span class="sd">        search_iter : int, optional</span>
<span class="sd">            Number of initial EM iteration steps used to improve each of the</span>
<span class="sd">            search parameter repetitions.</span>
<span class="sd">        search_scale : float or array, optional.</span>
<span class="sd">            Scale of variates for random start parameter search.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Additional keyword arguments to pass to the optimizer.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        MarkovSwitchingResults</span>
<span class="sd">        """</span>

        <span class="k">if</span> <span class="n">start_params</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">start_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">start_params</span>
            <span class="n">transformed</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">start_params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">start_params</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Random search for better start parameters</span>
        <span class="k">if</span> <span class="n">search_reps</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">start_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_start_params_search</span><span class="p">(</span>
                <span class="n">search_reps</span><span class="p">,</span> <span class="n">start_params</span><span class="o">=</span><span class="n">start_params</span><span class="p">,</span>
                <span class="n">transformed</span><span class="o">=</span><span class="n">transformed</span><span class="p">,</span> <span class="n">em_iter</span><span class="o">=</span><span class="n">search_iter</span><span class="p">,</span>
                <span class="n">scale</span><span class="o">=</span><span class="n">search_scale</span><span class="p">)</span>
            <span class="n">transformed</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># Get better start params through EM algorithm</span>
        <span class="k">if</span> <span class="n">em_iter</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">tvtp</span><span class="p">:</span>
            <span class="n">start_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fit_em</span><span class="p">(</span><span class="n">start_params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="n">transformed</span><span class="p">,</span>
                                        <span class="n">maxiter</span><span class="o">=</span><span class="n">em_iter</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                        <span class="n">return_params</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">transformed</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="n">transformed</span><span class="p">:</span>
            <span class="n">start_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">untransform_params</span><span class="p">(</span><span class="n">start_params</span><span class="p">)</span>

        <span class="c1"># Maximum likelihood estimation by scoring</span>
        <span class="n">fargs</span> <span class="o">=</span> <span class="p">(</span><span class="kc">False</span><span class="p">,)</span>
        <span class="n">mlefit</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">MarkovSwitching</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">start_params</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
                                                  <span class="n">fargs</span><span class="o">=</span><span class="n">fargs</span><span class="p">,</span>
                                                  <span class="n">maxiter</span><span class="o">=</span><span class="n">maxiter</span><span class="p">,</span>
                                                  <span class="n">full_output</span><span class="o">=</span><span class="n">full_output</span><span class="p">,</span>
                                                  <span class="n">disp</span><span class="o">=</span><span class="n">disp</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="n">callback</span><span class="p">,</span>
                                                  <span class="n">skip_hessian</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Just return the fitted parameters if requested</span>
        <span class="k">if</span> <span class="n">return_params</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_params</span><span class="p">(</span><span class="n">mlefit</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>
        <span class="c1"># Otherwise construct the results class if desired</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">smooth</span><span class="p">(</span><span class="n">mlefit</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                 <span class="n">cov_type</span><span class="o">=</span><span class="n">cov_type</span><span class="p">,</span> <span class="n">cov_kwds</span><span class="o">=</span><span class="n">cov_kwds</span><span class="p">)</span>

            <span class="n">result</span><span class="o">.</span><span class="n">mlefit</span> <span class="o">=</span> <span class="n">mlefit</span>
            <span class="n">result</span><span class="o">.</span><span class="n">mle_retvals</span> <span class="o">=</span> <span class="n">mlefit</span><span class="o">.</span><span class="n">mle_retvals</span>
            <span class="n">result</span><span class="o">.</span><span class="n">mle_settings</span> <span class="o">=</span> <span class="n">mlefit</span><span class="o">.</span><span class="n">mle_settings</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">_fit_em</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cov_type</span><span class="o">=</span><span class="s1">'none'</span><span class="p">,</span>
                <span class="n">cov_kwds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mf">1e-6</span><span class="p">,</span> <span class="n">full_output</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">return_params</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Fits the model using the Expectation-Maximization (EM) algorithm</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        start_params : array_like, optional</span>
<span class="sd">            Initial guess of the solution for the loglikelihood maximization.</span>
<span class="sd">            If None, the default is given by `start_params`.</span>
<span class="sd">        transformed : bool, optional</span>
<span class="sd">            Whether or not `start_params` is already transformed. Default is</span>
<span class="sd">            True.</span>
<span class="sd">        cov_type : str, optional</span>
<span class="sd">            The type of covariance matrix estimator to use. Can be one of</span>
<span class="sd">            'approx', 'opg', 'robust', or 'none'. Default is 'none'.</span>
<span class="sd">        cov_kwds : dict or None, optional</span>
<span class="sd">            Keywords for alternative covariance estimators</span>
<span class="sd">        maxiter : int, optional</span>
<span class="sd">            The maximum number of iterations to perform.</span>
<span class="sd">        tolerance : float, optional</span>
<span class="sd">            The iteration stops when the difference between subsequent</span>
<span class="sd">            loglikelihood values is less than this tolerance.</span>
<span class="sd">        full_output : bool, optional</span>
<span class="sd">            Set to True to have all available output in the Results object's</span>
<span class="sd">            mle_retvals attribute. This includes all intermediate values for</span>
<span class="sd">            parameters and loglikelihood values</span>
<span class="sd">        return_params : bool, optional</span>
<span class="sd">            Whether or not to return only the array of maximizing parameters.</span>
<span class="sd">            Default is False.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Additional keyword arguments to pass to the optimizer.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This is a private method for finding good starting parameters for MLE</span>
<span class="sd">        by scoring. It has not been tested for a thoroughly correct EM</span>
<span class="sd">        implementation in all cases. It does not support TVTP transition</span>
<span class="sd">        probabilities.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        MarkovSwitchingResults</span>
<span class="sd">        """</span>

        <span class="k">if</span> <span class="n">start_params</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">start_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">start_params</span>
            <span class="n">transformed</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">start_params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">start_params</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">transformed</span><span class="p">:</span>
            <span class="n">start_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_params</span><span class="p">(</span><span class="n">start_params</span><span class="p">)</span>

        <span class="c1"># Perform expectation-maximization</span>
        <span class="n">llf</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">params</span> <span class="o">=</span> <span class="p">[</span><span class="n">start_params</span><span class="p">]</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">delta</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">maxiter</span> <span class="ow">and</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="ow">or</span> <span class="p">(</span><span class="n">delta</span> <span class="o">&gt;</span> <span class="n">tolerance</span><span class="p">)):</span>
            <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_em_iteration</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">llf</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">llf</span><span class="p">)</span>
            <span class="n">params</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">delta</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">llf</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">llf</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">((</span><span class="n">llf</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">llf</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]))</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># Just return the fitted parameters if requested</span>
        <span class="k">if</span> <span class="n">return_params</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># Otherwise construct the results class if desired</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                 <span class="n">cov_type</span><span class="o">=</span><span class="n">cov_type</span><span class="p">,</span> <span class="n">cov_kwds</span><span class="o">=</span><span class="n">cov_kwds</span><span class="p">)</span>

            <span class="c1"># Save the output</span>
            <span class="k">if</span> <span class="n">full_output</span><span class="p">:</span>
                <span class="n">em_retvals</span> <span class="o">=</span> <span class="n">Bunch</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="s1">'params'</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">params</span><span class="p">),</span>
                                      <span class="s1">'llf'</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">llf</span><span class="p">),</span>
                                      <span class="s1">'iter'</span><span class="p">:</span> <span class="n">i</span><span class="p">})</span>
                <span class="n">em_settings</span> <span class="o">=</span> <span class="n">Bunch</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="s1">'tolerance'</span><span class="p">:</span> <span class="n">tolerance</span><span class="p">,</span>
                                       <span class="s1">'maxiter'</span><span class="p">:</span> <span class="n">maxiter</span><span class="p">})</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">em_retvals</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">em_settings</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="n">result</span><span class="o">.</span><span class="n">mle_retvals</span> <span class="o">=</span> <span class="n">em_retvals</span>
            <span class="n">result</span><span class="o">.</span><span class="n">mle_settings</span> <span class="o">=</span> <span class="n">em_settings</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">_em_iteration</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params0</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        EM iteration</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The EM iteration in this base class only performs the EM step for</span>
<span class="sd">        non-TVTP transition probabilities.</span>
<span class="sd">        """</span>
        <span class="n">params1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">params0</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                           <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">promote_types</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">params0</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>

        <span class="c1"># Smooth at the given parameters</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">smooth</span><span class="p">(</span><span class="n">params0</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">return_raw</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># The EM with TVTP is not yet supported, just return the previous</span>
        <span class="c1"># iteration parameters</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tvtp</span><span class="p">:</span>
            <span class="n">params1</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s1">'regime_transition'</span><span class="p">]]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">params0</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s1">'regime_transition'</span><span class="p">]])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">regime_transition</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_em_regime_transition</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_regimes</span><span class="p">):</span>
                <span class="n">params1</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="s1">'regime_transition'</span><span class="p">]]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">regime_transition</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">result</span><span class="p">,</span> <span class="n">params1</span>

    <span class="k">def</span> <span class="nf">_em_regime_transition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">result</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        EM step for regime transition probabilities</span>
<span class="sd">        """</span>

        <span class="c1"># Marginalize the smoothed joint probabilites to just S_t, S_{t-1} | T</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">smoothed_joint_probabilities</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">tmp</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">3</span><span class="p">):</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">smoothed_joint_probabilities</span> <span class="o">=</span> <span class="n">tmp</span>

        <span class="c1"># Transition parameters (recall we're not yet supporting TVTP here)</span>
        <span class="n">k_transition</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="s1">'regime_transition'</span><span class="p">])</span>
        <span class="n">regime_transition</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">k_regimes</span><span class="p">,</span> <span class="n">k_transition</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_regimes</span><span class="p">):</span>  <span class="c1"># S_{t_1}</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_regimes</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>  <span class="c1"># S_t</span>
                <span class="n">regime_transition</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">smoothed_joint_probabilities</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">])</span> <span class="o">/</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">smoothed_marginal_probabilities</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>

            <span class="c1"># It may be the case that due to rounding error this estimates</span>
            <span class="c1"># transition probabilities that sum to greater than one. If so,</span>
            <span class="c1"># re-scale the probabilities and warn the user that something</span>
            <span class="c1"># is not quite right</span>
            <span class="n">delta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">regime_transition</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">delta</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">'Invalid regime transition probabilities'</span>
                              <span class="s1">' estimated in EM iteration; probabilities have'</span>
                              <span class="s1">' been re-scaled to continue estimation.'</span><span class="p">,</span>
                              <span class="n">EstimationWarning</span><span class="p">)</span>
                <span class="n">regime_transition</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">delta</span> <span class="o">+</span> <span class="mf">1e-6</span>

        <span class="k">return</span> <span class="n">regime_transition</span>

    <span class="k">def</span> <span class="nf">_start_params_search</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reps</span><span class="p">,</span> <span class="n">start_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                             <span class="n">em_iter</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mf">1.</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Search for starting parameters as random permutations of a vector</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        reps : int</span>
<span class="sd">            Number of random permutations to try.</span>
<span class="sd">        start_params : ndarray, optional</span>
<span class="sd">            Starting parameter vector. If not given, class-level start</span>
<span class="sd">            parameters are used.</span>
<span class="sd">        transformed : bool, optional</span>
<span class="sd">            If `start_params` was provided, whether or not those parameters</span>
<span class="sd">            are already transformed. Default is True.</span>
<span class="sd">        em_iter : int, optional</span>
<span class="sd">            Number of EM iterations to apply to each random permutation.</span>
<span class="sd">        scale : array or float, optional</span>
<span class="sd">            Scale of variates for random start parameter search. Can be given</span>
<span class="sd">            as an array of length equal to the number of parameters or as a</span>
<span class="sd">            single scalar.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This is a private method for finding good starting parameters for MLE</span>
<span class="sd">        by scoring, where the defaults have been set heuristically.</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="n">start_params</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">start_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">start_params</span>
            <span class="n">transformed</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">start_params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">start_params</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Random search is over untransformed space</span>
        <span class="k">if</span> <span class="n">transformed</span><span class="p">:</span>
            <span class="n">start_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">untransform_params</span><span class="p">(</span><span class="n">start_params</span><span class="p">)</span>

        <span class="c1"># Construct the standard deviations</span>
        <span class="n">scale</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">scale</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">scale</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">scale</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_params</span><span class="p">)</span> <span class="o">*</span> <span class="n">scale</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">scale</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_params</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'Scale of variates for random start'</span>
                             <span class="s1">' parameter search must be given for each'</span>
                             <span class="s1">' parameter or as a single scalar.'</span><span class="p">)</span>

        <span class="c1"># Construct the random variates</span>
        <span class="n">variates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">reps</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_params</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_params</span><span class="p">):</span>
            <span class="n">variates</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">scale</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">reps</span><span class="p">)</span>

        <span class="n">llf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">loglike</span><span class="p">(</span><span class="n">start_params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">start_params</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">reps</span><span class="p">):</span>
            <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">():</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s2">"ignore"</span><span class="p">)</span>

                <span class="k">try</span><span class="p">:</span>
                    <span class="n">proposed_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fit_em</span><span class="p">(</span>
                        <span class="n">start_params</span> <span class="o">+</span> <span class="n">variates</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                        <span class="n">maxiter</span><span class="o">=</span><span class="n">em_iter</span><span class="p">,</span> <span class="n">return_params</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="n">proposed_llf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">loglike</span><span class="p">(</span><span class="n">proposed_params</span><span class="p">)</span>

                    <span class="k">if</span> <span class="n">proposed_llf</span> <span class="o">&gt;</span> <span class="n">llf</span><span class="p">:</span>
                        <span class="n">llf</span> <span class="o">=</span> <span class="n">proposed_llf</span>
                        <span class="n">params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">untransform_params</span><span class="p">(</span><span class="n">proposed_params</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>  <span class="c1"># FIXME: catch something specific</span>
                    <span class="k">pass</span>

        <span class="c1"># Return transformed parameters</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_params</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">start_params</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        (array) Starting parameters for maximum likelihood estimation.</span>
<span class="sd">        """</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_params</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

        <span class="c1"># Transition probabilities</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tvtp</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s1">'regime_transition'</span><span class="p">]]</span> <span class="o">=</span> <span class="mf">0.</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s1">'regime_transition'</span><span class="p">]]</span> <span class="o">=</span> <span class="mf">1.</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_regimes</span>

        <span class="k">return</span> <span class="n">params</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">param_names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        (list of str) List of human readable parameter names (for parameters</span>
<span class="sd">        actually included in the model).</span>
<span class="sd">        """</span>
        <span class="n">param_names</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_params</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>

        <span class="c1"># Transition probabilities</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tvtp</span><span class="p">:</span>
            <span class="c1"># TODO add support for exog_tvtp_names</span>
            <span class="n">param_names</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s1">'regime_transition'</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[</span>
                <span class="s1">'p[</span><span class="si">%d</span><span class="s1">-&gt;</span><span class="si">%d</span><span class="s1">].tvtp</span><span class="si">%d</span><span class="s1">'</span> <span class="o">%</span> <span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_regimes</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_tvtp</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_regimes</span><span class="p">)</span>
                <span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">param_names</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s1">'regime_transition'</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[</span>
                <span class="s1">'p[</span><span class="si">%d</span><span class="s1">-&gt;</span><span class="si">%d</span><span class="s1">]'</span> <span class="o">%</span> <span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_regimes</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_regimes</span><span class="p">)]</span>

        <span class="k">return</span> <span class="n">param_names</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">transform_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unconstrained</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Transform unconstrained parameters used by the optimizer to constrained</span>
<span class="sd">        parameters used in likelihood evaluation</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        unconstrained : array_like</span>
<span class="sd">            Array of unconstrained parameters used by the optimizer, to be</span>
<span class="sd">            transformed.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        constrained : array_like</span>
<span class="sd">            Array of constrained parameters which may be used in likelihood</span>
<span class="sd">            evaluation.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        In the base class, this only transforms the transition-probability-</span>
<span class="sd">        related parameters.</span>
<span class="sd">        """</span>
        <span class="n">constrained</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">unconstrained</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">constrained</span> <span class="o">=</span> <span class="n">constrained</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">promote_types</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">constrained</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>

        <span class="c1"># Nothing to do for transition probabilities if TVTP</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tvtp</span><span class="p">:</span>
            <span class="n">constrained</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s1">'regime_transition'</span><span class="p">]]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">unconstrained</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s1">'regime_transition'</span><span class="p">]])</span>
        <span class="c1"># Otherwise do logistic transformation</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Transition probabilities</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_regimes</span><span class="p">):</span>
                <span class="n">tmp1</span> <span class="o">=</span> <span class="n">unconstrained</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="s1">'regime_transition'</span><span class="p">]]</span>
                <span class="n">tmp2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">tmp1</span><span class="p">]</span>
                <span class="n">constrained</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="s1">'regime_transition'</span><span class="p">]]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span>
                    <span class="n">tmp1</span> <span class="o">-</span> <span class="n">logsumexp</span><span class="p">(</span><span class="n">tmp2</span><span class="p">))</span>

        <span class="c1"># Do not do anything for the rest of the parameters</span>

        <span class="k">return</span> <span class="n">constrained</span>

    <span class="k">def</span> <span class="nf">_untransform_logistic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unconstrained</span><span class="p">,</span> <span class="n">constrained</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Function to allow using a numerical root-finder to reverse the</span>
<span class="sd">        logistic transform.</span>
<span class="sd">        """</span>
        <span class="n">resid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">unconstrained</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">unconstrained</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">exp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">unconstrained</span><span class="p">)</span>
        <span class="n">sum_exp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">exp</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">unconstrained</span><span class="p">)):</span>
            <span class="n">resid</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">unconstrained</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">sum_exp</span> <span class="o">-</span> <span class="n">exp</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">+</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">constrained</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">resid</span>

    <span class="k">def</span> <span class="nf">untransform_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">constrained</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Transform constrained parameters used in likelihood evaluation</span>
<span class="sd">        to unconstrained parameters used by the optimizer</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        constrained : array_like</span>
<span class="sd">            Array of constrained parameters used in likelihood evaluation, to</span>
<span class="sd">            be transformed.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        unconstrained : array_like</span>
<span class="sd">            Array of unconstrained parameters used by the optimizer.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        In the base class, this only untransforms the transition-probability-</span>
<span class="sd">        related parameters.</span>
<span class="sd">        """</span>
        <span class="n">unconstrained</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">constrained</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">unconstrained</span> <span class="o">=</span> <span class="n">unconstrained</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">promote_types</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">unconstrained</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>

        <span class="c1"># Nothing to do for transition probabilities if TVTP</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tvtp</span><span class="p">:</span>
            <span class="n">unconstrained</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s1">'regime_transition'</span><span class="p">]]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">constrained</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s1">'regime_transition'</span><span class="p">]])</span>
        <span class="c1"># Otherwise reverse logistic transformation</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_regimes</span><span class="p">):</span>
                <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="s1">'regime_transition'</span><span class="p">]</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_regimes</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">unconstrained</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mf">1.</span> <span class="o">/</span> <span class="n">constrained</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">root</span>
                    <span class="n">out</span> <span class="o">=</span> <span class="n">root</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_untransform_logistic</span><span class="p">,</span>
                               <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">unconstrained</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                                        <span class="n">unconstrained</span><span class="o">.</span><span class="n">dtype</span><span class="p">),</span>
                               <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">constrained</span><span class="p">[</span><span class="n">s</span><span class="p">],))</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">out</span><span class="p">[</span><span class="s1">'success'</span><span class="p">]:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">'Could not untransform parameters.'</span><span class="p">)</span>
                    <span class="n">unconstrained</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="n">out</span><span class="p">[</span><span class="s1">'x'</span><span class="p">]</span>

        <span class="c1"># Do not do anything for the rest of the parameters</span>

        <span class="k">return</span> <span class="n">unconstrained</span>


<span class="k">class</span> <span class="nc">HamiltonFilterResults</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    Results from applying the Hamilton filter to a state space model.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    model : Representation</span>
<span class="sd">        A Statespace representation</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    nobs : int</span>
<span class="sd">        Number of observations.</span>
<span class="sd">    k_endog : int</span>
<span class="sd">        The dimension of the observation series.</span>
<span class="sd">    k_regimes : int</span>
<span class="sd">        The number of unobserved regimes.</span>
<span class="sd">    regime_transition : ndarray</span>
<span class="sd">        The regime transition matrix.</span>
<span class="sd">    initialization : str</span>
<span class="sd">        Initialization method for regime probabilities.</span>
<span class="sd">    initial_probabilities : ndarray</span>
<span class="sd">        Initial regime probabilities</span>
<span class="sd">    conditional_loglikelihoods : ndarray</span>
<span class="sd">        The loglikelihood values at each time period, conditional on regime.</span>
<span class="sd">    predicted_joint_probabilities : ndarray</span>
<span class="sd">        Predicted joint probabilities at each time period.</span>
<span class="sd">    filtered_marginal_probabilities : ndarray</span>
<span class="sd">        Filtered marginal probabilities at each time period.</span>
<span class="sd">    filtered_joint_probabilities : ndarray</span>
<span class="sd">        Filtered joint probabilities at each time period.</span>
<span class="sd">    joint_loglikelihoods : ndarray</span>
<span class="sd">        The likelihood values at each time period.</span>
<span class="sd">    llf_obs : ndarray</span>
<span class="sd">        The loglikelihood values at each time period.</span>
<span class="sd">    """</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">result</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">model</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">nobs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">order</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">order</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k_regimes</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">k_regimes</span>

        <span class="n">attributes</span> <span class="o">=</span> <span class="p">[</span><span class="s1">'regime_transition'</span><span class="p">,</span> <span class="s1">'initial_probabilities'</span><span class="p">,</span>
                      <span class="s1">'conditional_loglikelihoods'</span><span class="p">,</span>
                      <span class="s1">'predicted_joint_probabilities'</span><span class="p">,</span>
                      <span class="s1">'filtered_marginal_probabilities'</span><span class="p">,</span>
                      <span class="s1">'filtered_joint_probabilities'</span><span class="p">,</span>
                      <span class="s1">'joint_loglikelihoods'</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">attributes</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">name</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">initialization</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">_initialization</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">llf_obs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">joint_loglikelihoods</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">llf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">llf_obs</span><span class="p">)</span>

        <span class="c1"># Subset transition if necessary (e.g. for Markov autoregression)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">regime_transition</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">order</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">regime_transition</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">regime_transition</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">order</span><span class="p">:]</span>

        <span class="c1"># Cache for predicted marginal probabilities</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_predicted_marginal_probabilities</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">predicted_marginal_probabilities</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_predicted_marginal_probabilities</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_predicted_marginal_probabilities</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">predicted_joint_probabilities</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_predicted_marginal_probabilities</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">2</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_predicted_marginal_probabilities</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_predicted_marginal_probabilities</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_predicted_marginal_probabilities</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">expected_durations</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        (array) Expected duration of a regime, possibly time-varying.</span>
<span class="sd">        """</span>
        <span class="c1"># It is possible that we will have a degenerate system, so that there</span>
        <span class="c1"># is no possibility of transitioning to a different state. In that</span>
        <span class="c1"># case, we do want the expected duration of one state to be np.inf,</span>
        <span class="c1"># and the expected duration of the other states to be np.nan</span>
        <span class="n">diag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diagonal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">regime_transition</span><span class="p">)</span>
        <span class="n">expected_durations</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">diag</span><span class="p">)</span>
        <span class="n">degenerate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">diag</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># For non-degenerate states, use the usual computation</span>
        <span class="n">expected_durations</span><span class="p">[</span><span class="o">~</span><span class="n">degenerate</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">diag</span><span class="p">[</span><span class="o">~</span><span class="n">degenerate</span><span class="p">])</span>

        <span class="c1"># For degenerate states, everything is np.nan, except for the one</span>
        <span class="c1"># state that is np.inf.</span>
        <span class="n">expected_durations</span><span class="p">[</span><span class="n">degenerate</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="n">expected_durations</span><span class="p">[</span><span class="n">diag</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>

        <span class="k">return</span> <span class="n">expected_durations</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>


<span class="k">class</span> <span class="nc">KimSmootherResults</span><span class="p">(</span><span class="n">HamiltonFilterResults</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    Results from applying the Kim smoother to a Markov switching model.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    model : MarkovSwitchingModel</span>
<span class="sd">        The model object.</span>
<span class="sd">    result : dict</span>
<span class="sd">        A dictionary containing two keys: 'smoothd_joint_probabilities' and</span>
<span class="sd">        'smoothed_marginal_probabilities'.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    nobs : int</span>
<span class="sd">        Number of observations.</span>
<span class="sd">    k_endog : int</span>
<span class="sd">        The dimension of the observation series.</span>
<span class="sd">    k_states : int</span>
<span class="sd">        The dimension of the unobserved state process.</span>
<span class="sd">    """</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">result</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">KimSmootherResults</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>

        <span class="n">attributes</span> <span class="o">=</span> <span class="p">[</span><span class="s1">'smoothed_joint_probabilities'</span><span class="p">,</span>
                      <span class="s1">'smoothed_marginal_probabilities'</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">attributes</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">name</span><span class="p">))</span>


<span class="k">class</span> <span class="nc">MarkovSwitchingResults</span><span class="p">(</span><span class="n">tsbase</span><span class="o">.</span><span class="n">TimeSeriesModelResults</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">"""</span>
<span class="sd">    Class to hold results from fitting a Markov switching model</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    model : MarkovSwitching instance</span>
<span class="sd">        The fitted model instance</span>
<span class="sd">    params : ndarray</span>
<span class="sd">        Fitted parameters</span>
<span class="sd">    filter_results : HamiltonFilterResults or KimSmootherResults instance</span>
<span class="sd">        The underlying filter and, optionally, smoother output</span>
<span class="sd">    cov_type : str</span>
<span class="sd">        The type of covariance matrix estimator to use. Can be one of 'approx',</span>
<span class="sd">        'opg', 'robust', or 'none'.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    model : Model instance</span>
<span class="sd">        A reference to the model that was fit.</span>
<span class="sd">    filter_results : HamiltonFilterResults or KimSmootherResults instance</span>
<span class="sd">        The underlying filter and, optionally, smoother output</span>
<span class="sd">    nobs : float</span>
<span class="sd">        The number of observations used to fit the model.</span>
<span class="sd">    params : ndarray</span>
<span class="sd">        The parameters of the model.</span>
<span class="sd">    scale : float</span>
<span class="sd">        This is currently set to 1.0 and not used by the model or its results.</span>
<span class="sd">    """</span>
    <span class="n">use_t</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">results</span><span class="p">,</span> <span class="n">cov_type</span><span class="o">=</span><span class="s1">'opg'</span><span class="p">,</span> <span class="n">cov_kwds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">data</span>

        <span class="n">tsbase</span><span class="o">.</span><span class="n">TimeSeriesModelResults</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span>
                                               <span class="n">normalized_cov_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                               <span class="n">scale</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span>

        <span class="c1"># Save the filter / smoother output</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filter_results</span> <span class="o">=</span> <span class="n">results</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="n">KimSmootherResults</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">smoother_results</span> <span class="o">=</span> <span class="n">results</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">smoother_results</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Dimensions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">nobs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">order</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">order</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k_regimes</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">k_regimes</span>

        <span class="c1"># Setup covariance matrix notes dictionary</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">'cov_kwds'</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cov_kwds</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cov_type</span> <span class="o">=</span> <span class="n">cov_type</span>

        <span class="c1"># Setup the cache</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># Handle covariance matrix calculation</span>
        <span class="k">if</span> <span class="n">cov_kwds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cov_kwds</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cov_approx_complex_step</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">cov_kwds</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">'approx_complex_step'</span><span class="p">,</span> <span class="kc">True</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cov_approx_centered</span> <span class="o">=</span> <span class="n">cov_kwds</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">'approx_centered'</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_rank</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_get_robustcov_results</span><span class="p">(</span><span class="n">cov_type</span><span class="o">=</span><span class="n">cov_type</span><span class="p">,</span> <span class="n">use_self</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                        <span class="o">**</span><span class="n">cov_kwds</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">LinAlgError</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_rank</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">k_params</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cov_params_default</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">k_params</span><span class="p">,</span> <span class="n">k_params</span><span class="p">))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cov_kwds</span><span class="p">[</span><span class="s1">'cov_type'</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s1">'Covariance matrix could not be calculated: singular.'</span>
                <span class="s1">' information matrix.'</span><span class="p">)</span>

        <span class="c1"># Copy over arrays</span>
        <span class="n">attributes</span> <span class="o">=</span> <span class="p">[</span><span class="s1">'regime_transition'</span><span class="p">,</span> <span class="s1">'initial_probabilities'</span><span class="p">,</span>
                      <span class="s1">'conditional_loglikelihoods'</span><span class="p">,</span>
                      <span class="s1">'predicted_marginal_probabilities'</span><span class="p">,</span>
                      <span class="s1">'predicted_joint_probabilities'</span><span class="p">,</span>
                      <span class="s1">'filtered_marginal_probabilities'</span><span class="p">,</span>
                      <span class="s1">'filtered_joint_probabilities'</span><span class="p">,</span>
                      <span class="s1">'joint_loglikelihoods'</span><span class="p">,</span> <span class="s1">'expected_durations'</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">attributes</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filter_results</span><span class="p">,</span> <span class="n">name</span><span class="p">))</span>

        <span class="n">attributes</span> <span class="o">=</span> <span class="p">[</span><span class="s1">'smoothed_joint_probabilities'</span><span class="p">,</span>
                      <span class="s1">'smoothed_marginal_probabilities'</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">attributes</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">smoother_results</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">smoother_results</span><span class="p">,</span> <span class="n">name</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="c1"># Reshape some arrays to long-format</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">predicted_marginal_probabilities</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">predicted_marginal_probabilities</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filtered_marginal_probabilities</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">filtered_marginal_probabilities</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">smoother_results</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">smoothed_marginal_probabilities</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">smoothed_marginal_probabilities</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

        <span class="c1"># Make into Pandas arrays if using Pandas data</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">PandasData</span><span class="p">):</span>
            <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">row_labels</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">expected_durations</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">expected_durations</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">expected_durations</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">predicted_marginal_probabilities</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">predicted_marginal_probabilities</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">filtered_marginal_probabilities</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">filtered_marginal_probabilities</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">smoother_results</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">smoothed_marginal_probabilities</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">smoothed_marginal_probabilities</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_robustcov_results</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cov_type</span><span class="o">=</span><span class="s1">'opg'</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">statsmodels.base.covtype</span> <span class="kn">import</span> <span class="n">descriptions</span>

        <span class="n">use_self</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">'use_self'</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">use_self</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span>
            <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">,</span>
                <span class="n">normalized_cov_params</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">normalized_cov_params</span><span class="p">,</span>
                <span class="n">scale</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">)</span>

        <span class="c1"># Set the new covariance type</span>
        <span class="n">res</span><span class="o">.</span><span class="n">cov_type</span> <span class="o">=</span> <span class="n">cov_type</span>
        <span class="n">res</span><span class="o">.</span><span class="n">cov_kwds</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="n">approx_type_str</span> <span class="o">=</span> <span class="s1">'complex-step'</span>

        <span class="c1"># Calculate the new covariance matrix</span>
        <span class="n">k_params</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">k_params</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">res</span><span class="o">.</span><span class="n">cov_params_default</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
            <span class="n">res</span><span class="o">.</span><span class="n">_rank</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">res</span><span class="o">.</span><span class="n">cov_kwds</span><span class="p">[</span><span class="s1">'description'</span><span class="p">]</span> <span class="o">=</span> <span class="s1">'No parameters estimated.'</span>
        <span class="k">elif</span> <span class="n">cov_type</span> <span class="o">==</span> <span class="s1">'custom'</span><span class="p">:</span>
            <span class="n">res</span><span class="o">.</span><span class="n">cov_type</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">'custom_cov_type'</span><span class="p">]</span>
            <span class="n">res</span><span class="o">.</span><span class="n">cov_params_default</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">'custom_cov_params'</span><span class="p">]</span>
            <span class="n">res</span><span class="o">.</span><span class="n">cov_kwds</span><span class="p">[</span><span class="s1">'description'</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">'custom_description'</span><span class="p">]</span>
            <span class="n">res</span><span class="o">.</span><span class="n">_rank</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">matrix_rank</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">cov_params_default</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">cov_type</span> <span class="o">==</span> <span class="s1">'none'</span><span class="p">:</span>
            <span class="n">res</span><span class="o">.</span><span class="n">cov_params_default</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">k_params</span><span class="p">,</span> <span class="n">k_params</span><span class="p">))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">res</span><span class="o">.</span><span class="n">_rank</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">res</span><span class="o">.</span><span class="n">cov_kwds</span><span class="p">[</span><span class="s1">'description'</span><span class="p">]</span> <span class="o">=</span> <span class="n">descriptions</span><span class="p">[</span><span class="s1">'none'</span><span class="p">]</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">cov_type</span> <span class="o">==</span> <span class="s1">'approx'</span><span class="p">:</span>
            <span class="n">res</span><span class="o">.</span><span class="n">cov_params_default</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">cov_params_approx</span>
            <span class="n">res</span><span class="o">.</span><span class="n">cov_kwds</span><span class="p">[</span><span class="s1">'description'</span><span class="p">]</span> <span class="o">=</span> <span class="n">descriptions</span><span class="p">[</span><span class="s1">'approx'</span><span class="p">]</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                                <span class="n">approx_type</span><span class="o">=</span><span class="n">approx_type_str</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">cov_type</span> <span class="o">==</span> <span class="s1">'opg'</span><span class="p">:</span>
            <span class="n">res</span><span class="o">.</span><span class="n">cov_params_default</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">cov_params_opg</span>
            <span class="n">res</span><span class="o">.</span><span class="n">cov_kwds</span><span class="p">[</span><span class="s1">'description'</span><span class="p">]</span> <span class="o">=</span> <span class="n">descriptions</span><span class="p">[</span><span class="s1">'OPG'</span><span class="p">]</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                                <span class="n">approx_type</span><span class="o">=</span><span class="n">approx_type_str</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">cov_type</span> <span class="o">==</span> <span class="s1">'robust'</span><span class="p">:</span>
            <span class="n">res</span><span class="o">.</span><span class="n">cov_params_default</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">cov_params_robust</span>
            <span class="n">res</span><span class="o">.</span><span class="n">cov_kwds</span><span class="p">[</span><span class="s1">'description'</span><span class="p">]</span> <span class="o">=</span> <span class="n">descriptions</span><span class="p">[</span><span class="s1">'robust'</span><span class="p">]</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                                <span class="n">approx_type</span><span class="o">=</span><span class="n">approx_type_str</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">'Invalid covariance matrix type.'</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">res</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">aic</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        (float) Akaike Information Criterion</span>
<span class="sd">        """</span>
        <span class="c1"># return -2*self.llf + 2*self.params.shape[0]</span>
        <span class="k">return</span> <span class="n">aic</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">llf</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">bic</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        (float) Bayes Information Criterion</span>
<span class="sd">        """</span>
        <span class="c1"># return -2*self.llf + self.params.shape[0]*np.log(self.nobs)</span>
        <span class="k">return</span> <span class="n">bic</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">llf</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">cov_params_approx</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        (array) The variance / covariance matrix. Computed using the numerical</span>
<span class="sd">        Hessian approximated by complex step or finite differences methods.</span>
<span class="sd">        """</span>
        <span class="n">evaluated_hessian</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">hessian</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">neg_cov</span><span class="p">,</span> <span class="n">singular_values</span> <span class="o">=</span> <span class="n">pinv_extended</span><span class="p">(</span><span class="n">evaluated_hessian</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rank</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_rank</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">matrix_rank</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">singular_values</span><span class="p">))</span>

        <span class="k">return</span> <span class="o">-</span><span class="n">neg_cov</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">cov_params_opg</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        (array) The variance / covariance matrix. Computed using the outer</span>
<span class="sd">        product of gradients method.</span>
<span class="sd">        """</span>
        <span class="n">score_obs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">score_obs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="n">cov_params</span><span class="p">,</span> <span class="n">singular_values</span> <span class="o">=</span> <span class="n">pinv_extended</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">score_obs</span><span class="p">,</span> <span class="n">score_obs</span><span class="p">))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rank</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_rank</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">matrix_rank</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">singular_values</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">cov_params</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">cov_params_robust</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        (array) The QMLE variance / covariance matrix. Computed using the</span>
<span class="sd">        numerical Hessian as the evaluated hessian.</span>
<span class="sd">        """</span>
        <span class="n">cov_opg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cov_params_opg</span>
        <span class="n">evaluated_hessian</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">hessian</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">cov_params</span><span class="p">,</span> <span class="n">singular_values</span> <span class="o">=</span> <span class="n">pinv_extended</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">evaluated_hessian</span><span class="p">,</span> <span class="n">cov_opg</span><span class="p">),</span> <span class="n">evaluated_hessian</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rank</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_rank</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">matrix_rank</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">singular_values</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">cov_params</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">fittedvalues</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        (array) The predicted values of the model. An (nobs x k_endog) array.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">hqic</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        (float) Hannan-Quinn Information Criterion</span>
<span class="sd">        """</span>
        <span class="c1"># return -2*self.llf + 2*np.log(np.log(self.nobs))*self.params.shape[0]</span>
        <span class="k">return</span> <span class="n">hqic</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">llf</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">llf_obs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        (float) The value of the log-likelihood function evaluated at `params`.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">loglikeobs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">llf</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        (float) The value of the log-likelihood function evaluated at `params`.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">loglike</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>

    <span class="nd">@cache_readonly</span>
    <span class="k">def</span> <span class="nf">resid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        (array) The model residuals. An (nobs x k_endog) array.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">endog</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">fittedvalues</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">joint_likelihoods</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">joint_loglikelihoods</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">probabilities</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">conditional</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        In-sample prediction and out-of-sample forecasting</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        start : int, str, or datetime, optional</span>
<span class="sd">            Zero-indexed observation number at which to start forecasting,</span>
<span class="sd">            i.e., the first forecast is start. Can also be a date string to</span>
<span class="sd">            parse or a datetime type. Default is the the zeroth observation.</span>
<span class="sd">        end : int, str, or datetime, optional</span>
<span class="sd">            Zero-indexed observation number at which to end forecasting, i.e.,</span>
<span class="sd">            the last forecast is end. Can also be a date string to</span>
<span class="sd">            parse or a datetime type. However, if the dates index does not</span>
<span class="sd">            have a fixed frequency, end must be an integer index if you</span>
<span class="sd">            want out of sample prediction. Default is the last observation in</span>
<span class="sd">            the sample.</span>
<span class="sd">        probabilities : str or array_like, optional</span>
<span class="sd">            Specifies the weighting probabilities used in constructing the</span>
<span class="sd">            prediction as a weighted average. If a string, can be 'predicted',</span>
<span class="sd">            'filtered', or 'smoothed'. Otherwise can be an array of</span>
<span class="sd">            probabilities to use. Default is smoothed.</span>
<span class="sd">        conditional : bool or int, optional</span>
<span class="sd">            Whether or not to return predictions conditional on current or</span>
<span class="sd">            past regimes. If False, returns a single vector of weighted</span>
<span class="sd">            predictions. If True or 1, returns predictions conditional on the</span>
<span class="sd">            current regime. For larger integers, returns predictions</span>
<span class="sd">            conditional on the current regime and some number of past regimes.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        predict : ndarray</span>
<span class="sd">            Array of out of in-sample predictions and / or out-of-sample</span>
<span class="sd">            forecasts. An (npredict x k_endog) array.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="n">end</span><span class="p">,</span>
                                  <span class="n">probabilities</span><span class="o">=</span><span class="n">probabilities</span><span class="p">,</span>
                                  <span class="n">conditional</span><span class="o">=</span><span class="n">conditional</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">forecast</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">steps</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Out-of-sample forecasts</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        steps : int, str, or datetime, optional</span>
<span class="sd">            If an integer, the number of steps to forecast from the end of the</span>
<span class="sd">            sample. Can also be a date string to parse or a datetime type.</span>
<span class="sd">            However, if the dates index does not have a fixed frequency, steps</span>
<span class="sd">            must be an integer. Default</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Additional arguments may required for forecasting beyond the end</span>
<span class="sd">            of the sample. See `FilterResults.predict` for more details.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        forecast : ndarray</span>
<span class="sd">            Array of out of sample forecasts. A (steps x k_endog) array.</span>
<span class="sd">        """</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="k">def</span> <span class="nf">summary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=.</span><span class="mi">05</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">model_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">display_params</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Summarize the Model</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        alpha : float, optional</span>
<span class="sd">            Significance level for the confidence intervals. Default is 0.05.</span>
<span class="sd">        start : int, optional</span>
<span class="sd">            Integer of the start observation. Default is 0.</span>
<span class="sd">        title : str, optional</span>
<span class="sd">            The title of the summary table.</span>
<span class="sd">        model_name : str</span>
<span class="sd">            The name of the model used. Default is to use model class name.</span>
<span class="sd">        display_params : bool, optional</span>
<span class="sd">            Whether or not to display tables of estimated parameters. Default</span>
<span class="sd">            is True. Usually only used internally.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        summary : Summary instance</span>
<span class="sd">            This holds the summary table and text, which can be printed or</span>
<span class="sd">            converted to various output formats.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        statsmodels.iolib.summary.Summary</span>
<span class="sd">        """</span>
        <span class="kn">from</span> <span class="nn">statsmodels.iolib.summary</span> <span class="kn">import</span> <span class="n">Summary</span>

        <span class="c1"># Model specification results</span>
        <span class="n">model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span>
        <span class="k">if</span> <span class="n">title</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">title</span> <span class="o">=</span> <span class="s1">'Markov Switching Model Results'</span>

        <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">dates</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">dates</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">dates</span><span class="p">[</span><span class="n">start</span><span class="p">]</span>
            <span class="n">sample</span> <span class="o">=</span> <span class="p">[</span><span class="s1">'</span><span class="si">%02d</span><span class="s1">-</span><span class="si">%02d</span><span class="s1">-</span><span class="si">%02d</span><span class="s1">'</span> <span class="o">%</span> <span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">month</span><span class="p">,</span> <span class="n">d</span><span class="o">.</span><span class="n">day</span><span class="p">,</span> <span class="n">d</span><span class="o">.</span><span class="n">year</span><span class="p">)]</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">dates</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">sample</span> <span class="o">+=</span> <span class="p">[</span><span class="s1">'- '</span> <span class="o">+</span> <span class="s1">'</span><span class="si">%02d</span><span class="s1">-</span><span class="si">%02d</span><span class="s1">-</span><span class="si">%02d</span><span class="s1">'</span> <span class="o">%</span> <span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">month</span><span class="p">,</span> <span class="n">d</span><span class="o">.</span><span class="n">day</span><span class="p">,</span> <span class="n">d</span><span class="o">.</span><span class="n">year</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sample</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">start</span><span class="p">),</span> <span class="s1">' - '</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">nobs</span><span class="p">)]</span>

        <span class="c1"># Standardize the model name as a list of str</span>
        <span class="k">if</span> <span class="n">model_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">model_name</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>

        <span class="c1"># Create the tables</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">model_name</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">model_name</span> <span class="o">=</span> <span class="p">[</span><span class="n">model_name</span><span class="p">]</span>

        <span class="n">top_left</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">'Dep. Variable:'</span><span class="p">,</span> <span class="kc">None</span><span class="p">)]</span>
        <span class="n">top_left</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s1">'Model:'</span><span class="p">,</span> <span class="p">[</span><span class="n">model_name</span><span class="p">[</span><span class="mi">0</span><span class="p">]]))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">model_name</span><span class="p">)):</span>
            <span class="n">top_left</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s1">''</span><span class="p">,</span> <span class="p">[</span><span class="s1">'+ '</span> <span class="o">+</span> <span class="n">model_name</span><span class="p">[</span><span class="n">i</span><span class="p">]]))</span>
        <span class="n">top_left</span> <span class="o">+=</span> <span class="p">[</span>
            <span class="p">(</span><span class="s1">'Date:'</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
            <span class="p">(</span><span class="s1">'Time:'</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
            <span class="p">(</span><span class="s1">'Sample:'</span><span class="p">,</span> <span class="p">[</span><span class="n">sample</span><span class="p">[</span><span class="mi">0</span><span class="p">]]),</span>
            <span class="p">(</span><span class="s1">''</span><span class="p">,</span> <span class="p">[</span><span class="n">sample</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
        <span class="p">]</span>

        <span class="n">top_right</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="s1">'No. Observations:'</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">nobs</span><span class="p">]),</span>
            <span class="p">(</span><span class="s1">'Log Likelihood'</span><span class="p">,</span> <span class="p">[</span><span class="s2">"</span><span class="si">%#5.3f</span><span class="s2">"</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">llf</span><span class="p">]),</span>
            <span class="p">(</span><span class="s1">'AIC'</span><span class="p">,</span> <span class="p">[</span><span class="s2">"</span><span class="si">%#5.3f</span><span class="s2">"</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">aic</span><span class="p">]),</span>
            <span class="p">(</span><span class="s1">'BIC'</span><span class="p">,</span> <span class="p">[</span><span class="s2">"</span><span class="si">%#5.3f</span><span class="s2">"</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">bic</span><span class="p">]),</span>
            <span class="p">(</span><span class="s1">'HQIC'</span><span class="p">,</span> <span class="p">[</span><span class="s2">"</span><span class="si">%#5.3f</span><span class="s2">"</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">hqic</span><span class="p">])</span>
        <span class="p">]</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">'cov_type'</span><span class="p">):</span>
            <span class="n">top_left</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s1">'Covariance Type:'</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">cov_type</span><span class="p">]))</span>

        <span class="n">summary</span> <span class="o">=</span> <span class="n">Summary</span><span class="p">()</span>
        <span class="n">summary</span><span class="o">.</span><span class="n">add_table_2cols</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gleft</span><span class="o">=</span><span class="n">top_left</span><span class="p">,</span> <span class="n">gright</span><span class="o">=</span><span class="n">top_right</span><span class="p">,</span>
                                <span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">)</span>

        <span class="c1"># Make parameters tables for each regime</span>
        <span class="kn">from</span> <span class="nn">statsmodels.iolib.summary</span> <span class="kn">import</span> <span class="n">summary_params</span>
        <span class="kn">import</span> <span class="nn">re</span>

        <span class="k">def</span> <span class="nf">make_table</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">title</span><span class="p">,</span> <span class="n">strip_end</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="n">res</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="n">mask</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">bse</span><span class="p">[</span><span class="n">mask</span><span class="p">],</span>
                   <span class="bp">self</span><span class="o">.</span><span class="n">tvalues</span><span class="p">[</span><span class="n">mask</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">pvalues</span><span class="p">[</span><span class="n">mask</span><span class="p">],</span>
                   <span class="bp">self</span><span class="o">.</span><span class="n">conf_int</span><span class="p">(</span><span class="n">alpha</span><span class="p">)[</span><span class="n">mask</span><span class="p">])</span>

            <span class="n">param_names</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">'\[\d+\]$'</span><span class="p">,</span> <span class="s1">''</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span>
                <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">param_names</span><span class="p">)[</span><span class="n">mask</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="p">]</span>

            <span class="k">return</span> <span class="n">summary_params</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">yname</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">xname</span><span class="o">=</span><span class="n">param_names</span><span class="p">,</span>
                                  <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">use_t</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">)</span>

        <span class="n">params</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">parameters</span>
        <span class="n">regime_masks</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">k_regimes</span><span class="p">)]</span>
        <span class="n">other_masks</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">switching</span> <span class="ow">in</span> <span class="n">params</span><span class="o">.</span><span class="n">switching</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">k_params</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">switching</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="s1">'regime_transition'</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">other_masks</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k_params</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">switching</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_regimes</span><span class="p">):</span>
                        <span class="n">regime_masks</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">key</span><span class="p">][</span><span class="n">i</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">other_masks</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">key</span><span class="p">][</span><span class="n">i</span><span class="p">])</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_regimes</span><span class="p">):</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">regime_masks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">table</span> <span class="o">=</span> <span class="n">make_table</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="s1">'Regime </span><span class="si">%d</span><span class="s1"> parameters'</span> <span class="o">%</span> <span class="n">i</span><span class="p">)</span>
                <span class="n">summary</span><span class="o">.</span><span class="n">tables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">table</span><span class="p">)</span>

        <span class="n">mask</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">_mask</span> <span class="ow">in</span> <span class="n">other_masks</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">mask</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">_mask</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">table</span> <span class="o">=</span> <span class="n">make_table</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="s1">'Non-switching parameters'</span><span class="p">)</span>
            <span class="n">summary</span><span class="o">.</span><span class="n">tables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">table</span><span class="p">)</span>

        <span class="c1"># Transition parameters</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s1">'regime_transition'</span><span class="p">]</span>
        <span class="n">table</span> <span class="o">=</span> <span class="n">make_table</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="s1">'Regime transition parameters'</span><span class="p">)</span>
        <span class="n">summary</span><span class="o">.</span><span class="n">tables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">table</span><span class="p">)</span>

        <span class="c1"># Add warnings/notes, added to text format only</span>
        <span class="n">etext</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">'cov_type'</span><span class="p">)</span> <span class="ow">and</span> <span class="s1">'description'</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cov_kwds</span><span class="p">:</span>
            <span class="n">etext</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cov_kwds</span><span class="p">[</span><span class="s1">'description'</span><span class="p">])</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rank</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">):</span>
            <span class="n">etext</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">"Covariance matrix is singular or near-singular,"</span>
                         <span class="s2">" with condition number </span><span class="si">%6.3g</span><span class="s2">. Standard errors may be"</span>
                         <span class="s2">" unstable."</span> <span class="o">%</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">cond</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cov_params</span><span class="p">()))</span>

        <span class="k">if</span> <span class="n">etext</span><span class="p">:</span>
            <span class="n">etext</span> <span class="o">=</span> <span class="p">[</span><span class="s2">"[</span><span class="si">{0}</span><span class="s2">] </span><span class="si">{1}</span><span class="s2">"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>
                     <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">text</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">etext</span><span class="p">)]</span>
            <span class="n">etext</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s2">"Warnings:"</span><span class="p">)</span>
            <span class="n">summary</span><span class="o">.</span><span class="n">add_extra_txt</span><span class="p">(</span><span class="n">etext</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">summary</span>


<span class="k">class</span> <span class="nc">MarkovSwitchingResultsWrapper</span><span class="p">(</span><span class="n">wrap</span><span class="o">.</span><span class="n">ResultsWrapper</span><span class="p">):</span>
    <span class="n">_attrs</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">'cov_params_approx'</span><span class="p">:</span> <span class="s1">'cov'</span><span class="p">,</span>
        <span class="s1">'cov_params_default'</span><span class="p">:</span> <span class="s1">'cov'</span><span class="p">,</span>
        <span class="s1">'cov_params_opg'</span><span class="p">:</span> <span class="s1">'cov'</span><span class="p">,</span>
        <span class="s1">'cov_params_robust'</span><span class="p">:</span> <span class="s1">'cov'</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="n">_wrap_attrs</span> <span class="o">=</span> <span class="n">wrap</span><span class="o">.</span><span class="n">union_dicts</span><span class="p">(</span><span class="n">tsbase</span><span class="o">.</span><span class="n">TimeSeriesResultsWrapper</span><span class="o">.</span><span class="n">_wrap_attrs</span><span class="p">,</span>
                                   <span class="n">_attrs</span><span class="p">)</span>
    <span class="n">_methods</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">'forecast'</span><span class="p">:</span> <span class="s1">'dates'</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="n">_wrap_methods</span> <span class="o">=</span> <span class="n">wrap</span><span class="o">.</span><span class="n">union_dicts</span><span class="p">(</span>
        <span class="n">tsbase</span><span class="o">.</span><span class="n">TimeSeriesResultsWrapper</span><span class="o">.</span><span class="n">_wrap_methods</span><span class="p">,</span> <span class="n">_methods</span><span class="p">)</span>
<span class="n">wrap</span><span class="o">.</span><span class="n">populate_wrapper</span><span class="p">(</span><span class="n">MarkovSwitchingResultsWrapper</span><span class="p">,</span>  <span class="c1"># noqa:E305</span>
                      <span class="n">MarkovSwitchingResults</span><span class="p">)</span>
</pre></div>

          </article>
        </div>
      </div>
    </main>
  </div>
  <footer class="md-footer">
    <div class="md-footer-nav">
      <nav class="md-footer-nav__inner md-grid">
          
          
        </a>
        
      </nav>
    </div>
    <div class="md-footer-meta md-typeset">
      <div class="md-footer-meta__inner md-grid">
        <div class="md-footer-copyright">
          <div class="md-footer-copyright__highlight">
              &#169; Copyright 2009-2019, Josef Perktold, Skipper Seabold, Jonathan Taylor, statsmodels-developers.
              
          </div>
            Last updated on
              Feb 21, 2020.
            <br/>
            Created using
            <a href="http://www.sphinx-doc.org/">Sphinx</a> 2.4.2.
             and
            <a href="https://github.com/bashtage/sphinx-material/">Material for
              Sphinx</a>
        </div>
      </div>
    </div>
  </footer>
  <script src="../../../../_static/javascripts/application.js"></script>
  <script>app.initialize({version: "1.0.4", url: {base: ".."}})</script>
  </body>
</html>