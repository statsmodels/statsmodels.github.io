
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>statsmodels.discrete.discrete_model &#8212; statsmodels 0.8.0 documentation</title>
    
    <link rel="stylesheet" href="../../../_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '0.8.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <link rel="shortcut icon" href="../../../_static/statsmodels_hybi_favico.ico"/>
    <link rel="author" title="About these documents" href="../../../about.html" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
<link rel="stylesheet" href="../../../_static/examples.css" type="text/css" />
<link rel="stylesheet" href="../../../_static/facebox.css" type="text/css" />
<script type="text/javascript" src="../../../_static/scripts.js">
</script>
<script type="text/javascript" src="../../../_static/facebox.js">
</script>

  </head>
  <body role="document">
<div class="headerwrap">
    <div class = "header">
        
        <a href = "../../../index.html">
<img src="../../../_static/statsmodels_hybi_banner.png" alt="Logo"
    style="padding-left: 15px"/></a>
        
    </div>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
<li><a href ="../../../install.html">Install</a></li> &nbsp;|&nbsp;
<li><a href="https://groups.google.com/group/pystatsmodels?hl=en">Support</a></li> &nbsp;|&nbsp;
<li><a href="https://github.com/statsmodels/statsmodels/issues">Bugs</a></li> &nbsp;|&nbsp;
<li><a href="../../../dev/index.html">Develop</a></li> &nbsp;|&nbsp;
<li><a href="../../../examples/index.html">Examples</a></li> &nbsp;|&nbsp;
<li><a href="../../../faq.html">FAQ</a></li> &nbsp;|&nbsp;

          <li class="nav-item nav-item-1"><a href="../../index.html" accesskey="U">Module code</a> |</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            




  <h1>Source code for statsmodels.discrete.discrete_model</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Limited dependent variable and qualitative variables.</span>

<span class="sd">Includes binary outcomes, count data, (ordered) ordinal data and limited</span>
<span class="sd">dependent variables.</span>

<span class="sd">General References</span>
<span class="sd">--------------------</span>

<span class="sd">A.C. Cameron and P.K. Trivedi.  `Regression Analysis of Count Data`.</span>
<span class="sd">    Cambridge, 1998</span>

<span class="sd">G.S. Madalla. `Limited-Dependent and Qualitative Variables in Econometrics`.</span>
<span class="sd">    Cambridge, 1983.</span>

<span class="sd">W. Greene. `Econometric Analysis`. Prentice Hall, 5th. edition. 2003.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">division</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Poisson&quot;</span><span class="p">,</span> <span class="s2">&quot;Logit&quot;</span><span class="p">,</span> <span class="s2">&quot;Probit&quot;</span><span class="p">,</span> <span class="s2">&quot;MNLogit&quot;</span><span class="p">,</span> <span class="s2">&quot;NegativeBinomial&quot;</span><span class="p">]</span>

<span class="kn">from</span> <span class="nn">statsmodels.compat.python</span> <span class="k">import</span> <span class="n">lmap</span><span class="p">,</span> <span class="n">lzip</span><span class="p">,</span> <span class="nb">range</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy.special</span> <span class="k">import</span> <span class="n">gammaln</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="k">import</span> <span class="n">stats</span><span class="p">,</span> <span class="n">special</span><span class="p">,</span> <span class="n">optimize</span>  <span class="c1"># opt just for nbin</span>
<span class="kn">import</span> <span class="nn">statsmodels.tools.tools</span> <span class="k">as</span> <span class="nn">tools</span>
<span class="kn">from</span> <span class="nn">statsmodels.tools</span> <span class="k">import</span> <span class="n">data</span> <span class="k">as</span> <span class="n">data_tools</span>
<span class="kn">from</span> <span class="nn">statsmodels.tools.decorators</span> <span class="k">import</span> <span class="p">(</span><span class="n">resettable_cache</span><span class="p">,</span>
        <span class="n">cache_readonly</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">statsmodels.regression.linear_model</span> <span class="k">import</span> <span class="n">OLS</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="k">import</span> <span class="n">stats</span><span class="p">,</span> <span class="n">special</span><span class="p">,</span> <span class="n">optimize</span>  <span class="c1"># opt just for nbin</span>
<span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="k">import</span> <span class="n">nbinom</span>
<span class="kn">from</span> <span class="nn">statsmodels.tools.sm_exceptions</span> <span class="k">import</span> <span class="n">PerfectSeparationError</span>
<span class="kn">from</span> <span class="nn">statsmodels.tools.numdiff</span> <span class="k">import</span> <span class="p">(</span><span class="n">approx_fprime</span><span class="p">,</span> <span class="n">approx_hess</span><span class="p">,</span>
                                       <span class="n">approx_hess_cs</span><span class="p">,</span> <span class="n">approx_fprime_cs</span><span class="p">)</span>
<span class="kn">import</span> <span class="nn">statsmodels.base.model</span> <span class="k">as</span> <span class="nn">base</span>
<span class="kn">from</span> <span class="nn">statsmodels.base.data</span> <span class="k">import</span> <span class="n">handle_data</span>  <span class="c1"># for mnlogit</span>
<span class="kn">import</span> <span class="nn">statsmodels.regression.linear_model</span> <span class="k">as</span> <span class="nn">lm</span>
<span class="kn">import</span> <span class="nn">statsmodels.base.wrapper</span> <span class="k">as</span> <span class="nn">wrap</span>
<span class="kn">from</span> <span class="nn">statsmodels.compat.numpy</span> <span class="k">import</span> <span class="n">np_matrix_rank</span>
<span class="kn">from</span> <span class="nn">pandas.core.api</span> <span class="k">import</span> <span class="n">get_dummies</span>

<span class="kn">from</span> <span class="nn">statsmodels.base.l1_slsqp</span> <span class="k">import</span> <span class="n">fit_l1_slsqp</span>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">cvxopt</span>
    <span class="n">have_cvxopt</span> <span class="o">=</span> <span class="kc">True</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="n">have_cvxopt</span> <span class="o">=</span> <span class="kc">False</span>

<span class="c1">#TODO: When we eventually get user-settable precision, we need to change</span>
<span class="c1">#      this</span>
<span class="n">FLOAT_EPS</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span>

<span class="c1">#TODO: add options for the parameter covariance/variance</span>
<span class="c1"># ie., OIM, EIM, and BHHH see Green 21.4</span>

<span class="n">_discrete_models_docs</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="n">_discrete_results_docs</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    </span><span class="si">%(one_line_description)s</span><span class="s2"></span>

<span class="s2">    Parameters</span>
<span class="s2">    ----------</span>
<span class="s2">    model : A DiscreteModel instance</span>
<span class="s2">    params : array-like</span>
<span class="s2">        The parameters of a fitted model.</span>
<span class="s2">    hessian : array-like</span>
<span class="s2">        The hessian of the fitted model.</span>
<span class="s2">    scale : float</span>
<span class="s2">        A scale parameter for the covariance matrix.</span>

<span class="s2">    Returns</span>
<span class="s2">    -------</span>
<span class="s2">    *Attributes*</span>

<span class="s2">    aic : float</span>
<span class="s2">        Akaike information criterion.  `-2*(llf - p)` where `p` is the number</span>
<span class="s2">        of regressors including the intercept.</span>
<span class="s2">    bic : float</span>
<span class="s2">        Bayesian information criterion. `-2*llf + ln(nobs)*p` where `p` is the</span>
<span class="s2">        number of regressors including the intercept.</span>
<span class="s2">    bse : array</span>
<span class="s2">        The standard errors of the coefficients.</span>
<span class="s2">    df_resid : float</span>
<span class="s2">        See model definition.</span>
<span class="s2">    df_model : float</span>
<span class="s2">        See model definition.</span>
<span class="s2">    fitted_values : array</span>
<span class="s2">        Linear predictor XB.</span>
<span class="s2">    llf : float</span>
<span class="s2">        Value of the loglikelihood</span>
<span class="s2">    llnull : float</span>
<span class="s2">        Value of the constant-only loglikelihood</span>
<span class="s2">    llr : float</span>
<span class="s2">        Likelihood ratio chi-squared statistic; `-2*(llnull - llf)`</span>
<span class="s2">    llr_pvalue : float</span>
<span class="s2">        The chi-squared probability of getting a log-likelihood ratio</span>
<span class="s2">        statistic greater than llr.  llr has a chi-squared distribution</span>
<span class="s2">        with degrees of freedom `df_model`.</span>
<span class="s2">    prsquared : float</span>
<span class="s2">        McFadden&#39;s pseudo-R-squared. `1 - (llf / llnull)`</span>
<span class="si">%(extra_attr)s</span><span class="s2">&quot;&quot;&quot;</span>

<span class="n">_l1_results_attr</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;    nnz_params : Integer</span>
<span class="s2">        The number of nonzero parameters in the model.  Train with</span>
<span class="s2">        trim_params == True or else numerical error will distort this.</span>
<span class="s2">    trimmed : Boolean array</span>
<span class="s2">        trimmed[i] == True if the ith parameter was trimmed from the model.&quot;&quot;&quot;</span>


<span class="c1"># helper for MNLogit (will be generally useful later)</span>

<span class="k">def</span> <span class="nf">_numpy_to_dummies</span><span class="p">(</span><span class="n">endog</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">endog</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;S&#39;</span><span class="p">,</span> <span class="s1">&#39;O&#39;</span><span class="p">]:</span>
        <span class="n">endog_dummies</span><span class="p">,</span> <span class="n">ynames</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">categorical</span><span class="p">(</span><span class="n">endog</span><span class="p">,</span> <span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                  <span class="n">dictnames</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">endog</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">endog_dummies</span> <span class="o">=</span> <span class="n">endog</span>
        <span class="n">ynames</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">endog</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">endog_dummies</span><span class="p">,</span> <span class="n">ynames</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">categorical</span><span class="p">(</span><span class="n">endog</span><span class="p">,</span> <span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                  <span class="n">dictnames</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">endog_dummies</span><span class="p">,</span> <span class="n">ynames</span>


<span class="k">def</span> <span class="nf">_pandas_to_dummies</span><span class="p">(</span><span class="n">endog</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">endog</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">endog</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">yname</span> <span class="o">=</span> <span class="n">endog</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">endog_dummies</span> <span class="o">=</span> <span class="n">get_dummies</span><span class="p">(</span><span class="n">endog</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># series</span>
            <span class="n">yname</span> <span class="o">=</span> <span class="s1">&#39;y&#39;</span>
            <span class="n">endog_dummies</span> <span class="o">=</span> <span class="n">endog</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">yname</span> <span class="o">=</span> <span class="n">endog</span><span class="o">.</span><span class="n">name</span>
        <span class="n">endog_dummies</span> <span class="o">=</span> <span class="n">get_dummies</span><span class="p">(</span><span class="n">endog</span><span class="p">)</span>
    <span class="n">ynames</span> <span class="o">=</span> <span class="n">endog_dummies</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">endog_dummies</span><span class="p">,</span> <span class="n">ynames</span><span class="p">,</span> <span class="n">yname</span>


<span class="c1">#### Private Model Classes ####</span>


<div class="viewcode-block" id="DiscreteModel"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.DiscreteModel.html#statsmodels.discrete.discrete_model.DiscreteModel">[docs]</a><span class="k">class</span> <span class="nc">DiscreteModel</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="n">LikelihoodModel</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Abstract class for discrete choice models.</span>

<span class="sd">    This class does not do anything itself but lays out the methods and</span>
<span class="sd">    call signature expected of child classes in addition to those of</span>
<span class="sd">    statsmodels.model.LikelihoodModel.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">endog</span><span class="p">,</span> <span class="n">exog</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">DiscreteModel</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">endog</span><span class="p">,</span> <span class="n">exog</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">raise_on_perfect_prediction</span> <span class="o">=</span> <span class="kc">True</span>

<div class="viewcode-block" id="DiscreteModel.initialize"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.DiscreteModel.initialize.html#statsmodels.discrete.discrete_model.DiscreteModel.initialize">[docs]</a>    <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize is called by</span>
<span class="sd">        statsmodels.model.LikelihoodModel.__init__</span>
<span class="sd">        and should contain any preprocessing that needs to be done for a model.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># assumes constant</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">df_model</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np_matrix_rank</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exog</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">df_resid</span> <span class="o">=</span> <span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exog</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span>
                         <span class="n">np_matrix_rank</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exog</span><span class="p">)))</span></div>

<div class="viewcode-block" id="DiscreteModel.cdf"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.DiscreteModel.cdf.html#statsmodels.discrete.discrete_model.DiscreteModel.cdf">[docs]</a>    <span class="k">def</span> <span class="nf">cdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The cumulative distribution function of the model.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>

<div class="viewcode-block" id="DiscreteModel.pdf"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.DiscreteModel.pdf.html#statsmodels.discrete.discrete_model.DiscreteModel.pdf">[docs]</a>    <span class="k">def</span> <span class="nf">pdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The probability density (mass) function of the model.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>

    <span class="k">def</span> <span class="nf">_check_perfect_pred</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="n">endog</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">endog</span>
        <span class="n">fittedvalues</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exog</span><span class="p">,</span> <span class="n">params</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">exog</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]]))</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">raise_on_perfect_prediction</span> <span class="ow">and</span>
                <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">fittedvalues</span> <span class="o">-</span> <span class="n">endog</span><span class="p">,</span> <span class="mi">0</span><span class="p">)):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Perfect separation detected, results not available&quot;</span>
            <span class="k">raise</span> <span class="n">PerfectSeparationError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

<div class="viewcode-block" id="DiscreteModel.fit"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.DiscreteModel.fit.html#statsmodels.discrete.discrete_model.DiscreteModel.fit">[docs]</a>    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;newton&#39;</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="mi">35</span><span class="p">,</span>
            <span class="n">full_output</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">disp</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fit the model using maximum likelihood.</span>

<span class="sd">        The rest of the docstring is from</span>
<span class="sd">        statsmodels.base.model.LikelihoodModel.fit</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">callback</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">callback</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_perfect_pred</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">pass</span> <span class="c1"># make a function factory to have multiple call-backs</span>

        <span class="n">mlefit</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">DiscreteModel</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">start_params</span><span class="o">=</span><span class="n">start_params</span><span class="p">,</span>
                <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="n">maxiter</span><span class="p">,</span> <span class="n">full_output</span><span class="o">=</span><span class="n">full_output</span><span class="p">,</span>
                <span class="n">disp</span><span class="o">=</span><span class="n">disp</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="n">callback</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">mlefit</span> <span class="c1"># up to subclasses to wrap results</span></div>

    <span class="n">fit</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">+=</span> <span class="n">base</span><span class="o">.</span><span class="n">LikelihoodModel</span><span class="o">.</span><span class="n">fit</span><span class="o">.</span><span class="vm">__doc__</span>

<div class="viewcode-block" id="DiscreteModel.fit_regularized"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.DiscreteModel.fit_regularized.html#statsmodels.discrete.discrete_model.DiscreteModel.fit_regularized">[docs]</a>    <span class="k">def</span> <span class="nf">fit_regularized</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;l1&#39;</span><span class="p">,</span>
                        <span class="n">maxiter</span><span class="o">=</span><span class="s1">&#39;defined_by_method&#39;</span><span class="p">,</span> <span class="n">full_output</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">disp</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                        <span class="n">callback</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">trim_mode</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">,</span>
                        <span class="n">auto_trim_tol</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">size_trim_tol</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">,</span> <span class="n">qc_tol</span><span class="o">=</span><span class="mf">0.03</span><span class="p">,</span>
                        <span class="n">qc_verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fit the model using a regularized maximum likelihood.</span>
<span class="sd">        The regularization method AND the solver used is determined by the</span>
<span class="sd">        argument method.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        start_params : array-like, optional</span>
<span class="sd">            Initial guess of the solution for the loglikelihood maximization.</span>
<span class="sd">            The default is an array of zeros.</span>
<span class="sd">        method : &#39;l1&#39; or &#39;l1_cvxopt_cp&#39;</span>
<span class="sd">            See notes for details.</span>
<span class="sd">        maxiter : Integer or &#39;defined_by_method&#39;</span>
<span class="sd">            Maximum number of iterations to perform.</span>
<span class="sd">            If &#39;defined_by_method&#39;, then use method defaults (see notes).</span>
<span class="sd">        full_output : bool</span>
<span class="sd">            Set to True to have all available output in the Results object&#39;s</span>
<span class="sd">            mle_retvals attribute. The output is dependent on the solver.</span>
<span class="sd">            See LikelihoodModelResults notes section for more information.</span>
<span class="sd">        disp : bool</span>
<span class="sd">            Set to True to print convergence messages.</span>
<span class="sd">        fargs : tuple</span>
<span class="sd">            Extra arguments passed to the likelihood function, i.e.,</span>
<span class="sd">            loglike(x,*args)</span>
<span class="sd">        callback : callable callback(xk)</span>
<span class="sd">            Called after each iteration, as callback(xk), where xk is the</span>
<span class="sd">            current parameter vector.</span>
<span class="sd">        retall : bool</span>
<span class="sd">            Set to True to return list of solutions at each iteration.</span>
<span class="sd">            Available in Results object&#39;s mle_retvals attribute.</span>
<span class="sd">        alpha : non-negative scalar or numpy array (same size as parameters)</span>
<span class="sd">            The weight multiplying the l1 penalty term</span>
<span class="sd">        trim_mode : &#39;auto, &#39;size&#39;, or &#39;off&#39;</span>
<span class="sd">            If not &#39;off&#39;, trim (set to zero) parameters that would have been</span>
<span class="sd">            zero if the solver reached the theoretical minimum.</span>
<span class="sd">            If &#39;auto&#39;, trim params using the Theory above.</span>
<span class="sd">            If &#39;size&#39;, trim params if they have very small absolute value</span>
<span class="sd">        size_trim_tol : float or &#39;auto&#39; (default = &#39;auto&#39;)</span>
<span class="sd">            For use when trim_mode == &#39;size&#39;</span>
<span class="sd">        auto_trim_tol : float</span>
<span class="sd">            For sue when trim_mode == &#39;auto&#39;.  Use</span>
<span class="sd">        qc_tol : float</span>
<span class="sd">            Print warning and don&#39;t allow auto trim when (ii) (above) is</span>
<span class="sd">            violated by this much.</span>
<span class="sd">        qc_verbose : Boolean</span>
<span class="sd">            If true, print out a full QC report upon failure</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Extra parameters are not penalized if alpha is given as a scalar.</span>
<span class="sd">        An example is the shape parameter in NegativeBinomial `nb1` and `nb2`.</span>

<span class="sd">        Optional arguments for the solvers (available in Results.mle_settings)::</span>

<span class="sd">            &#39;l1&#39;</span>
<span class="sd">                acc : float (default 1e-6)</span>
<span class="sd">                    Requested accuracy as used by slsqp</span>
<span class="sd">            &#39;l1_cvxopt_cp&#39;</span>
<span class="sd">                abstol : float</span>
<span class="sd">                    absolute accuracy (default: 1e-7).</span>
<span class="sd">                reltol : float</span>
<span class="sd">                    relative accuracy (default: 1e-6).</span>
<span class="sd">                feastol : float</span>
<span class="sd">                    tolerance for feasibility conditions (default: 1e-7).</span>
<span class="sd">                refinement : int</span>
<span class="sd">                    number of iterative refinement steps when solving KKT</span>
<span class="sd">                    equations (default: 1).</span>


<span class="sd">        Optimization methodology</span>

<span class="sd">        With :math:`L` the negative log likelihood, we solve the convex but</span>
<span class="sd">        non-smooth problem</span>

<span class="sd">        .. math:: \\min_\\beta L(\\beta) + \\sum_k\\alpha_k |\\beta_k|</span>

<span class="sd">        via the transformation to the smooth, convex, constrained problem</span>
<span class="sd">        in twice as many variables (adding the &quot;added variables&quot; :math:`u_k`)</span>

<span class="sd">        .. math:: \\min_{\\beta,u} L(\\beta) + \\sum_k\\alpha_k u_k,</span>

<span class="sd">        subject to</span>

<span class="sd">        .. math:: -u_k \\leq \\beta_k \\leq u_k.</span>

<span class="sd">        With :math:`\\partial_k L` the derivative of :math:`L` in the</span>
<span class="sd">        :math:`k^{th}` parameter direction, theory dictates that, at the</span>
<span class="sd">        minimum, exactly one of two conditions holds:</span>

<span class="sd">        (i) :math:`|\\partial_k L| = \\alpha_k`  and  :math:`\\beta_k \\neq 0`</span>
<span class="sd">        (ii) :math:`|\\partial_k L| \\leq \\alpha_k`  and  :math:`\\beta_k = 0`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">### Set attributes based on method</span>
        <span class="k">if</span> <span class="n">method</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;l1&#39;</span><span class="p">,</span> <span class="s1">&#39;l1_cvxopt_cp&#39;</span><span class="p">]:</span>
            <span class="n">cov_params_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cov_params_func_l1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;argument method == </span><span class="si">%s</span><span class="s2">, which is not handled&quot;</span>
                            <span class="o">%</span> <span class="n">method</span><span class="p">)</span>

        <span class="c1">### Bundle up extra kwargs for the dictionary kwargs.  These are</span>
        <span class="c1">### passed through super(...).fit() as kwargs and unpacked at</span>
        <span class="c1">### appropriate times</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">alpha</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="mi">0</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;alpha&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">alpha</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="n">kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;alpha_rescaled&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;alpha&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endog</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;trim_mode&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">trim_mode</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;size_trim_tol&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">size_trim_tol</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;auto_trim_tol&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">auto_trim_tol</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;qc_tol&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">qc_tol</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;qc_verbose&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">qc_verbose</span>

        <span class="c1">### Define default keyword arguments to be passed to super(...).fit()</span>
        <span class="k">if</span> <span class="n">maxiter</span> <span class="o">==</span> <span class="s1">&#39;defined_by_method&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;l1&#39;</span><span class="p">:</span>
                <span class="n">maxiter</span> <span class="o">=</span> <span class="mi">1000</span>
            <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;l1_cvxopt_cp&#39;</span><span class="p">:</span>
                <span class="n">maxiter</span> <span class="o">=</span> <span class="mi">70</span>

        <span class="c1">## Parameters to pass to super(...).fit()</span>
        <span class="c1"># For the &#39;extra&#39; parameters, pass all that are available,</span>
        <span class="c1"># even if we know (at this point) we will only use one.</span>
        <span class="n">extra_fit_funcs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;l1&#39;</span><span class="p">:</span> <span class="n">fit_l1_slsqp</span><span class="p">}</span>
        <span class="k">if</span> <span class="n">have_cvxopt</span> <span class="ow">and</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;l1_cvxopt_cp&#39;</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">statsmodels.base.l1_cvxopt</span> <span class="k">import</span> <span class="n">fit_l1_cvxopt_cp</span>
            <span class="n">extra_fit_funcs</span><span class="p">[</span><span class="s1">&#39;l1_cvxopt_cp&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">fit_l1_cvxopt_cp</span>
        <span class="k">elif</span> <span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;l1_cvxopt_cp&#39;</span><span class="p">:</span>
            <span class="n">message</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Attempt to use l1_cvxopt_cp failed since cvxopt &quot;</span>
                        <span class="s2">&quot;could not be imported&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">callback</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">callback</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_perfect_pred</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">pass</span> <span class="c1"># make a function factory to have multiple call-backs</span>

        <span class="n">mlefit</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">DiscreteModel</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">start_params</span><span class="o">=</span><span class="n">start_params</span><span class="p">,</span>
                <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="n">maxiter</span><span class="p">,</span> <span class="n">full_output</span><span class="o">=</span><span class="n">full_output</span><span class="p">,</span>
                <span class="n">disp</span><span class="o">=</span><span class="n">disp</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="n">callback</span><span class="p">,</span> <span class="n">extra_fit_funcs</span><span class="o">=</span><span class="n">extra_fit_funcs</span><span class="p">,</span>
                <span class="n">cov_params_func</span><span class="o">=</span><span class="n">cov_params_func</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">mlefit</span> <span class="c1"># up to subclasses to wrap results</span></div>

<div class="viewcode-block" id="DiscreteModel.cov_params_func_l1"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.DiscreteModel.cov_params_func_l1.html#statsmodels.discrete.discrete_model.DiscreteModel.cov_params_func_l1">[docs]</a>    <span class="k">def</span> <span class="nf">cov_params_func_l1</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">likelihood_model</span><span class="p">,</span> <span class="n">xopt</span><span class="p">,</span> <span class="n">retvals</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes cov_params on a reduced parameter space</span>
<span class="sd">        corresponding to the nonzero parameters resulting from the</span>
<span class="sd">        l1 regularized fit.</span>

<span class="sd">        Returns a full cov_params matrix, with entries corresponding</span>
<span class="sd">        to zero&#39;d values set to np.nan.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">H</span> <span class="o">=</span> <span class="n">likelihood_model</span><span class="o">.</span><span class="n">hessian</span><span class="p">(</span><span class="n">xopt</span><span class="p">)</span>
        <span class="n">trimmed</span> <span class="o">=</span> <span class="n">retvals</span><span class="p">[</span><span class="s1">&#39;trimmed&#39;</span><span class="p">]</span>
        <span class="n">nz_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">trimmed</span> <span class="o">==</span> <span class="kc">False</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">nnz_params</span> <span class="o">=</span> <span class="p">(</span><span class="n">trimmed</span> <span class="o">==</span> <span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">nnz_params</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">H_restricted</span> <span class="o">=</span> <span class="n">H</span><span class="p">[</span><span class="n">nz_idx</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">],</span> <span class="n">nz_idx</span><span class="p">]</span>
            <span class="c1"># Covariance estimate for the nonzero params</span>
            <span class="n">H_restricted_inv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="o">-</span><span class="n">H_restricted</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">H_restricted_inv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="n">cov_params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">cov_params</span><span class="p">[</span><span class="n">nz_idx</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">],</span> <span class="n">nz_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">H_restricted_inv</span>

        <span class="k">return</span> <span class="n">cov_params</span></div>

<div class="viewcode-block" id="DiscreteModel.predict"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.DiscreteModel.predict.html#statsmodels.discrete.discrete_model.DiscreteModel.predict">[docs]</a>    <span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">exog</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">linear</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Predict response variable of a model given exogenous variables.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>

    <span class="k">def</span> <span class="nf">_derivative_exog</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">exog</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dummy_idx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">count_idx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This should implement the derivative of the non-linear function</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>

<div class="viewcode-block" id="BinaryModel"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.BinaryModel.html#statsmodels.discrete.discrete_model.BinaryModel">[docs]</a><span class="k">class</span> <span class="nc">BinaryModel</span><span class="p">(</span><span class="n">DiscreteModel</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">endog</span><span class="p">,</span> <span class="n">exog</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">BinaryModel</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">endog</span><span class="p">,</span> <span class="n">exog</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">issubclass</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="n">MultinomialModel</span><span class="p">)</span> <span class="ow">and</span>
                <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">endog</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endog</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">))):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;endog must be in the unit interval.&quot;</span><span class="p">)</span>


<div class="viewcode-block" id="BinaryModel.predict"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.BinaryModel.predict.html#statsmodels.discrete.discrete_model.BinaryModel.predict">[docs]</a>    <span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">exog</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">linear</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Predict response variable of a model given exogenous variables.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array-like</span>
<span class="sd">            Fitted parameters of the model.</span>
<span class="sd">        exog : array-like</span>
<span class="sd">            1d or 2d array of exogenous values.  If not supplied, the</span>
<span class="sd">            whole exog attribute of the model is used.</span>
<span class="sd">        linear : bool, optional</span>
<span class="sd">            If True, returns the linear predictor dot(exog,params).  Else,</span>
<span class="sd">            returns the value of the cdf at the linear predictor.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        array</span>
<span class="sd">            Fitted values at exog.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">exog</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">exog</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exog</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">linear</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">exog</span><span class="p">,</span> <span class="n">params</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">exog</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span></div>

<div class="viewcode-block" id="BinaryModel.fit_regularized"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.BinaryModel.fit_regularized.html#statsmodels.discrete.discrete_model.BinaryModel.fit_regularized">[docs]</a>    <span class="k">def</span> <span class="nf">fit_regularized</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;l1&#39;</span><span class="p">,</span>
            <span class="n">maxiter</span><span class="o">=</span><span class="s1">&#39;defined_by_method&#39;</span><span class="p">,</span> <span class="n">full_output</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">disp</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">alpha</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">trim_mode</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="n">auto_trim_tol</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">size_trim_tol</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">,</span>
            <span class="n">qc_tol</span><span class="o">=</span><span class="mf">0.03</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">bnryfit</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">BinaryModel</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">fit_regularized</span><span class="p">(</span>
                <span class="n">start_params</span><span class="o">=</span><span class="n">start_params</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="n">maxiter</span><span class="p">,</span>
                <span class="n">full_output</span><span class="o">=</span><span class="n">full_output</span><span class="p">,</span> <span class="n">disp</span><span class="o">=</span><span class="n">disp</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="n">callback</span><span class="p">,</span>
                <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">trim_mode</span><span class="o">=</span><span class="n">trim_mode</span><span class="p">,</span> <span class="n">auto_trim_tol</span><span class="o">=</span><span class="n">auto_trim_tol</span><span class="p">,</span>
                <span class="n">size_trim_tol</span><span class="o">=</span><span class="n">size_trim_tol</span><span class="p">,</span> <span class="n">qc_tol</span><span class="o">=</span><span class="n">qc_tol</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">method</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;l1&#39;</span><span class="p">,</span> <span class="s1">&#39;l1_cvxopt_cp&#39;</span><span class="p">]:</span>
            <span class="n">discretefit</span> <span class="o">=</span> <span class="n">L1BinaryResults</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bnryfit</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                    <span class="s2">&quot;argument method == </span><span class="si">%s</span><span class="s2">, which is not handled&quot;</span> <span class="o">%</span> <span class="n">method</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">L1BinaryResultsWrapper</span><span class="p">(</span><span class="n">discretefit</span><span class="p">)</span></div>
    <span class="n">fit_regularized</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">DiscreteModel</span><span class="o">.</span><span class="n">fit_regularized</span><span class="o">.</span><span class="vm">__doc__</span>

    <span class="k">def</span> <span class="nf">_derivative_predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">exog</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">transform</span><span class="o">=</span><span class="s1">&#39;dydx&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For computing marginal effects standard errors.</span>

<span class="sd">        This is used only in the case of discrete and count regressors to</span>
<span class="sd">        get the variance-covariance of the marginal effects. It returns</span>
<span class="sd">        [d F / d params] where F is the predict.</span>

<span class="sd">        Transform can be &#39;dydx&#39; or &#39;eydx&#39;. Checking is done in margeff</span>
<span class="sd">        computations for appropriate transform.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">exog</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">exog</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exog</span>
        <span class="n">dF</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">exog</span><span class="p">,</span> <span class="n">params</span><span class="p">))[:,</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">exog</span>
        <span class="k">if</span> <span class="s1">&#39;ey&#39;</span> <span class="ow">in</span> <span class="n">transform</span><span class="p">:</span>
            <span class="n">dF</span> <span class="o">/=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">exog</span><span class="p">)[:,</span><span class="kc">None</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">dF</span>

    <span class="k">def</span> <span class="nf">_derivative_exog</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">exog</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">transform</span><span class="o">=</span><span class="s1">&#39;dydx&#39;</span><span class="p">,</span>
            <span class="n">dummy_idx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">count_idx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For computing marginal effects returns dF(XB) / dX where F(.) is</span>
<span class="sd">        the predicted probabilities</span>

<span class="sd">        transform can be &#39;dydx&#39;, &#39;dyex&#39;, &#39;eydx&#39;, or &#39;eyex&#39;.</span>

<span class="sd">        Not all of these make sense in the presence of discrete regressors,</span>
<span class="sd">        but checks are done in the results in get_margeff.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#note, this form should be appropriate for</span>
        <span class="c1">## group 1 probit, logit, logistic, cloglog, heckprob, xtprobit</span>
        <span class="k">if</span> <span class="n">exog</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">exog</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exog</span>
        <span class="n">margeff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">exog</span><span class="p">,</span> <span class="n">params</span><span class="p">))[:,</span><span class="kc">None</span><span class="p">],</span>
                                                          <span class="n">params</span><span class="p">[</span><span class="kc">None</span><span class="p">,:])</span>
        <span class="k">if</span> <span class="s1">&#39;ex&#39;</span> <span class="ow">in</span> <span class="n">transform</span><span class="p">:</span>
            <span class="n">margeff</span> <span class="o">*=</span> <span class="n">exog</span>
        <span class="k">if</span> <span class="s1">&#39;ey&#39;</span> <span class="ow">in</span> <span class="n">transform</span><span class="p">:</span>
            <span class="n">margeff</span> <span class="o">/=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">exog</span><span class="p">)[:,</span><span class="kc">None</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">count_idx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">statsmodels.discrete.discrete_margins</span> <span class="k">import</span> <span class="p">(</span>
                    <span class="n">_get_count_effects</span><span class="p">)</span>
            <span class="n">margeff</span> <span class="o">=</span> <span class="n">_get_count_effects</span><span class="p">(</span><span class="n">margeff</span><span class="p">,</span> <span class="n">exog</span><span class="p">,</span> <span class="n">count_idx</span><span class="p">,</span> <span class="n">transform</span><span class="p">,</span>
                    <span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dummy_idx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">statsmodels.discrete.discrete_margins</span> <span class="k">import</span> <span class="p">(</span>
                    <span class="n">_get_dummy_effects</span><span class="p">)</span>
            <span class="n">margeff</span> <span class="o">=</span> <span class="n">_get_dummy_effects</span><span class="p">(</span><span class="n">margeff</span><span class="p">,</span> <span class="n">exog</span><span class="p">,</span> <span class="n">dummy_idx</span><span class="p">,</span> <span class="n">transform</span><span class="p">,</span>
                    <span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">margeff</span></div>

<div class="viewcode-block" id="MultinomialModel"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.MultinomialModel.html#statsmodels.discrete.discrete_model.MultinomialModel">[docs]</a><span class="k">class</span> <span class="nc">MultinomialModel</span><span class="p">(</span><span class="n">BinaryModel</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">_handle_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">endog</span><span class="p">,</span> <span class="n">exog</span><span class="p">,</span> <span class="n">missing</span><span class="p">,</span> <span class="n">hasconst</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">data_tools</span><span class="o">.</span><span class="n">_is_using_ndarray_type</span><span class="p">(</span><span class="n">endog</span><span class="p">,</span> <span class="kc">None</span><span class="p">):</span>
            <span class="n">endog_dummies</span><span class="p">,</span> <span class="n">ynames</span> <span class="o">=</span> <span class="n">_numpy_to_dummies</span><span class="p">(</span><span class="n">endog</span><span class="p">)</span>
            <span class="n">yname</span> <span class="o">=</span> <span class="s1">&#39;y&#39;</span>
        <span class="k">elif</span> <span class="n">data_tools</span><span class="o">.</span><span class="n">_is_using_pandas</span><span class="p">(</span><span class="n">endog</span><span class="p">,</span> <span class="kc">None</span><span class="p">):</span>
            <span class="n">endog_dummies</span><span class="p">,</span> <span class="n">ynames</span><span class="p">,</span> <span class="n">yname</span> <span class="o">=</span> <span class="n">_pandas_to_dummies</span><span class="p">(</span><span class="n">endog</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">endog</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">endog</span><span class="p">)</span>
            <span class="n">endog_dummies</span><span class="p">,</span> <span class="n">ynames</span> <span class="o">=</span> <span class="n">_numpy_to_dummies</span><span class="p">(</span><span class="n">endog</span><span class="p">)</span>
            <span class="n">yname</span> <span class="o">=</span> <span class="s1">&#39;y&#39;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ynames</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">ynames</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">endog_dummies</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">ynames</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_ynames_map</span> <span class="o">=</span> <span class="n">ynames</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">handle_data</span><span class="p">(</span><span class="n">endog_dummies</span><span class="p">,</span> <span class="n">exog</span><span class="p">,</span> <span class="n">missing</span><span class="p">,</span> <span class="n">hasconst</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">data</span><span class="o">.</span><span class="n">ynames</span> <span class="o">=</span> <span class="n">yname</span>  <span class="c1"># overwrite this to single endog name</span>
        <span class="n">data</span><span class="o">.</span><span class="n">orig_endog</span> <span class="o">=</span> <span class="n">endog</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wendog</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">endog</span>

        <span class="c1"># repeating from upstream...</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">key</span><span class="p">))</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="k">pass</span>
        <span class="k">return</span> <span class="n">data</span>

<div class="viewcode-block" id="MultinomialModel.initialize"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.MultinomialModel.initialize.html#statsmodels.discrete.discrete_model.MultinomialModel.initialize">[docs]</a>    <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Preprocesses the data for MNLogit.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">MultinomialModel</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">initialize</span><span class="p">()</span>
        <span class="c1"># This is also a &quot;whiten&quot; method in other models (eg regression)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">endog</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">endog</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># turn it into an array of col idx</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">J</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wendog</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">K</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exog</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">df_model</span> <span class="o">*=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">J</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># for each J - 1 equation.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">df_resid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exog</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">df_model</span> <span class="o">-</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">J</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span></div>

<div class="viewcode-block" id="MultinomialModel.predict"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.MultinomialModel.predict.html#statsmodels.discrete.discrete_model.MultinomialModel.predict">[docs]</a>    <span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">exog</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">linear</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Predict response variable of a model given exogenous variables.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array-like</span>
<span class="sd">            2d array of fitted parameters of the model. Should be in the</span>
<span class="sd">            order returned from the model.</span>
<span class="sd">        exog : array-like</span>
<span class="sd">            1d or 2d array of exogenous values.  If not supplied, the</span>
<span class="sd">            whole exog attribute of the model is used. If a 1d array is given</span>
<span class="sd">            it assumed to be 1 row of exogenous variables. If you only have</span>
<span class="sd">            one regressor and would like to do prediction, you must provide</span>
<span class="sd">            a 2d array with shape[1] == 1.</span>
<span class="sd">        linear : bool, optional</span>
<span class="sd">            If True, returns the linear predictor dot(exog,params).  Else,</span>
<span class="sd">            returns the value of the cdf at the linear predictor.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Column 0 is the base case, the rest conform to the rows of params</span>
<span class="sd">        shifted up one for the base case.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">exog</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="c1"># do here to accomodate user-given exog</span>
            <span class="n">exog</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exog</span>
        <span class="k">if</span> <span class="n">exog</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">exog</span> <span class="o">=</span> <span class="n">exog</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span>
        <span class="n">pred</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">MultinomialModel</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">exog</span><span class="p">,</span> <span class="n">linear</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">linear</span><span class="p">:</span>
            <span class="n">pred</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">exog</span><span class="p">)),</span> <span class="n">pred</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">pred</span></div>

<div class="viewcode-block" id="MultinomialModel.fit"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.MultinomialModel.fit.html#statsmodels.discrete.discrete_model.MultinomialModel.fit">[docs]</a>    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;newton&#39;</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="mi">35</span><span class="p">,</span>
            <span class="n">full_output</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">disp</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">start_params</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">start_params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">K</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">J</span><span class="o">-</span><span class="mi">1</span><span class="p">)))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">start_params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">start_params</span><span class="p">)</span>
        <span class="n">callback</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span> <span class="p">:</span> <span class="kc">None</span> <span class="c1"># placeholder until check_perfect_pred</span>
        <span class="c1"># skip calling super to handle results from LikelihoodModel</span>
        <span class="n">mnfit</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">LikelihoodModel</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start_params</span> <span class="o">=</span> <span class="n">start_params</span><span class="p">,</span>
                <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="n">maxiter</span><span class="p">,</span> <span class="n">full_output</span><span class="o">=</span><span class="n">full_output</span><span class="p">,</span>
                <span class="n">disp</span><span class="o">=</span><span class="n">disp</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="n">callback</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">mnfit</span><span class="o">.</span><span class="n">params</span> <span class="o">=</span> <span class="n">mnfit</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>
        <span class="n">mnfit</span> <span class="o">=</span> <span class="n">MultinomialResults</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mnfit</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">MultinomialResultsWrapper</span><span class="p">(</span><span class="n">mnfit</span><span class="p">)</span></div>
    <span class="n">fit</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">DiscreteModel</span><span class="o">.</span><span class="n">fit</span><span class="o">.</span><span class="vm">__doc__</span>

<div class="viewcode-block" id="MultinomialModel.fit_regularized"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.MultinomialModel.fit_regularized.html#statsmodels.discrete.discrete_model.MultinomialModel.fit_regularized">[docs]</a>    <span class="k">def</span> <span class="nf">fit_regularized</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;l1&#39;</span><span class="p">,</span>
            <span class="n">maxiter</span><span class="o">=</span><span class="s1">&#39;defined_by_method&#39;</span><span class="p">,</span> <span class="n">full_output</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">disp</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">alpha</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">trim_mode</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="n">auto_trim_tol</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">size_trim_tol</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">,</span>
            <span class="n">qc_tol</span><span class="o">=</span><span class="mf">0.03</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">start_params</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">start_params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">K</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">J</span><span class="o">-</span><span class="mi">1</span><span class="p">)))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">start_params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">start_params</span><span class="p">)</span>
        <span class="n">mnfit</span> <span class="o">=</span> <span class="n">DiscreteModel</span><span class="o">.</span><span class="n">fit_regularized</span><span class="p">(</span>
                <span class="bp">self</span><span class="p">,</span> <span class="n">start_params</span><span class="o">=</span><span class="n">start_params</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="n">maxiter</span><span class="p">,</span>
                <span class="n">full_output</span><span class="o">=</span><span class="n">full_output</span><span class="p">,</span> <span class="n">disp</span><span class="o">=</span><span class="n">disp</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="n">callback</span><span class="p">,</span>
                <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">trim_mode</span><span class="o">=</span><span class="n">trim_mode</span><span class="p">,</span> <span class="n">auto_trim_tol</span><span class="o">=</span><span class="n">auto_trim_tol</span><span class="p">,</span>
                <span class="n">size_trim_tol</span><span class="o">=</span><span class="n">size_trim_tol</span><span class="p">,</span> <span class="n">qc_tol</span><span class="o">=</span><span class="n">qc_tol</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">mnfit</span><span class="o">.</span><span class="n">params</span> <span class="o">=</span> <span class="n">mnfit</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>
        <span class="n">mnfit</span> <span class="o">=</span> <span class="n">L1MultinomialResults</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mnfit</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">L1MultinomialResultsWrapper</span><span class="p">(</span><span class="n">mnfit</span><span class="p">)</span></div>
    <span class="n">fit_regularized</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">DiscreteModel</span><span class="o">.</span><span class="n">fit_regularized</span><span class="o">.</span><span class="vm">__doc__</span>


    <span class="k">def</span> <span class="nf">_derivative_predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">exog</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">transform</span><span class="o">=</span><span class="s1">&#39;dydx&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For computing marginal effects standard errors.</span>

<span class="sd">        This is used only in the case of discrete and count regressors to</span>
<span class="sd">        get the variance-covariance of the marginal effects. It returns</span>
<span class="sd">        [d F / d params] where F is the predicted probabilities for each</span>
<span class="sd">        choice. dFdparams is of shape nobs x (J*K) x (J-1)*K.</span>
<span class="sd">        The zero derivatives for the base category are not included.</span>

<span class="sd">        Transform can be &#39;dydx&#39; or &#39;eydx&#39;. Checking is done in margeff</span>
<span class="sd">        computations for appropriate transform.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">exog</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">exog</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exog</span>
        <span class="k">if</span> <span class="n">params</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="c1"># will get flatted from approx_fprime</span>
            <span class="n">params</span> <span class="o">=</span> <span class="n">params</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">J</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>

        <span class="n">eXB</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">exog</span><span class="p">,</span> <span class="n">params</span><span class="p">))</span>
        <span class="n">sum_eXB</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">eXB</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">))[:,</span><span class="kc">None</span><span class="p">]</span>
        <span class="n">J</span><span class="p">,</span> <span class="n">K</span> <span class="o">=</span> <span class="n">lmap</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">J</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">])</span>
        <span class="n">repeat_eXB</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">eXB</span><span class="p">,</span> <span class="n">J</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">exog</span><span class="p">,</span> <span class="n">J</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1"># this is the derivative wrt the base level</span>
        <span class="n">F0</span> <span class="o">=</span> <span class="o">-</span><span class="n">repeat_eXB</span> <span class="o">*</span> <span class="n">X</span> <span class="o">/</span> <span class="n">sum_eXB</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="c1"># this is the derivative wrt the other levels when</span>
        <span class="c1"># dF_j / dParams_j (ie., own equation)</span>
        <span class="c1">#NOTE: this computes too much, any easy way to cut down?</span>
        <span class="n">F1</span> <span class="o">=</span> <span class="n">eXB</span><span class="o">.</span><span class="n">T</span><span class="p">[:,:,</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="n">X</span> <span class="o">*</span> <span class="p">(</span><span class="n">sum_eXB</span> <span class="o">-</span> <span class="n">repeat_eXB</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">sum_eXB</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">F1</span> <span class="o">=</span> <span class="n">F1</span><span class="o">.</span><span class="n">transpose</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span> <span class="c1"># put the nobs index first</span>

        <span class="c1"># other equation index</span>
        <span class="n">other_idx</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">J</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">K</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>
        <span class="n">F1</span><span class="p">[:,</span> <span class="n">other_idx</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">eXB</span><span class="o">.</span><span class="n">T</span><span class="p">[:,:,</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="n">X</span><span class="o">*</span><span class="n">repeat_eXB</span> <span class="o">/</span> \
                           <span class="p">(</span><span class="n">sum_eXB</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">))[:,</span> <span class="n">other_idx</span><span class="p">]</span>
        <span class="n">dFdX</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">F0</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">,:],</span> <span class="n">F1</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="s1">&#39;ey&#39;</span> <span class="ow">in</span> <span class="n">transform</span><span class="p">:</span>
            <span class="n">dFdX</span> <span class="o">/=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">exog</span><span class="p">)[:,</span> <span class="p">:,</span> <span class="kc">None</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">dFdX</span>

    <span class="k">def</span> <span class="nf">_derivative_exog</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">exog</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">transform</span><span class="o">=</span><span class="s1">&#39;dydx&#39;</span><span class="p">,</span>
            <span class="n">dummy_idx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">count_idx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For computing marginal effects returns dF(XB) / dX where F(.) is</span>
<span class="sd">        the predicted probabilities</span>

<span class="sd">        transform can be &#39;dydx&#39;, &#39;dyex&#39;, &#39;eydx&#39;, or &#39;eyex&#39;.</span>

<span class="sd">        Not all of these make sense in the presence of discrete regressors,</span>
<span class="sd">        but checks are done in the results in get_margeff.</span>

<span class="sd">        For Multinomial models the marginal effects are</span>

<span class="sd">        P[j] * (params[j] - sum_k P[k]*params[k])</span>

<span class="sd">        It is returned unshaped, so that each row contains each of the J</span>
<span class="sd">        equations. This makes it easier to take derivatives of this for</span>
<span class="sd">        standard errors. If you want average marginal effects you can do</span>
<span class="sd">        margeff.reshape(nobs, K, J, order=&#39;F).mean(0) and the marginal effects</span>
<span class="sd">        for choice J are in column J</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">J</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">J</span><span class="p">)</span> <span class="c1"># number of alternative choices</span>
        <span class="n">K</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">)</span> <span class="c1"># number of variables</span>
        <span class="c1">#note, this form should be appropriate for</span>
        <span class="c1">## group 1 probit, logit, logistic, cloglog, heckprob, xtprobit</span>
        <span class="k">if</span> <span class="n">exog</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">exog</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exog</span>
        <span class="k">if</span> <span class="n">params</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="c1"># will get flatted from approx_fprime</span>
            <span class="n">params</span> <span class="o">=</span> <span class="n">params</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="n">J</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>
        <span class="n">zeroparams</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">K</span><span class="p">),</span> <span class="n">params</span><span class="p">]</span> <span class="c1"># add base in</span>

        <span class="n">cdf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">exog</span><span class="p">,</span> <span class="n">params</span><span class="p">))</span>
        <span class="n">margeff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">cdf</span><span class="p">[:,[</span><span class="n">j</span><span class="p">]]</span><span class="o">*</span> <span class="p">(</span><span class="n">zeroparams</span><span class="p">[:,</span><span class="n">j</span><span class="p">]</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">cdf</span><span class="p">[:,[</span><span class="n">i</span><span class="p">]]</span><span class="o">*</span>
            <span class="n">zeroparams</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">J</span><span class="p">))])</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
                          <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">J</span><span class="p">)])</span>
        <span class="n">margeff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">margeff</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
        <span class="c1"># swap the axes to make sure margeff are in order nobs, K, J</span>
        <span class="k">if</span> <span class="s1">&#39;ex&#39;</span> <span class="ow">in</span> <span class="n">transform</span><span class="p">:</span>
            <span class="n">margeff</span> <span class="o">*=</span> <span class="n">exog</span>
        <span class="k">if</span> <span class="s1">&#39;ey&#39;</span> <span class="ow">in</span> <span class="n">transform</span><span class="p">:</span>
            <span class="n">margeff</span> <span class="o">/=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">exog</span><span class="p">)[:,</span><span class="kc">None</span><span class="p">,:]</span>

        <span class="k">if</span> <span class="n">count_idx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">statsmodels.discrete.discrete_margins</span> <span class="k">import</span> <span class="p">(</span>
                    <span class="n">_get_count_effects</span><span class="p">)</span>
            <span class="n">margeff</span> <span class="o">=</span> <span class="n">_get_count_effects</span><span class="p">(</span><span class="n">margeff</span><span class="p">,</span> <span class="n">exog</span><span class="p">,</span> <span class="n">count_idx</span><span class="p">,</span> <span class="n">transform</span><span class="p">,</span>
                    <span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dummy_idx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">statsmodels.discrete.discrete_margins</span> <span class="k">import</span> <span class="p">(</span>
                    <span class="n">_get_dummy_effects</span><span class="p">)</span>
            <span class="n">margeff</span> <span class="o">=</span> <span class="n">_get_dummy_effects</span><span class="p">(</span><span class="n">margeff</span><span class="p">,</span> <span class="n">exog</span><span class="p">,</span> <span class="n">dummy_idx</span><span class="p">,</span> <span class="n">transform</span><span class="p">,</span>
                    <span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">margeff</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">exog</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="CountModel"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.CountModel.html#statsmodels.discrete.discrete_model.CountModel">[docs]</a><span class="k">class</span> <span class="nc">CountModel</span><span class="p">(</span><span class="n">DiscreteModel</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">endog</span><span class="p">,</span> <span class="n">exog</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">exposure</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">missing</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">CountModel</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">endog</span><span class="p">,</span> <span class="n">exog</span><span class="p">,</span> <span class="n">missing</span><span class="o">=</span><span class="n">missing</span><span class="p">,</span>
                                         <span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">,</span>
                                         <span class="n">exposure</span><span class="o">=</span><span class="n">exposure</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">exposure</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">exposure</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exposure</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_inputs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">offset</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">exposure</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">endog</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">offset</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">delattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;offset&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">exposure</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">delattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;exposure&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_check_inputs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">exposure</span><span class="p">,</span> <span class="n">endog</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">offset</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">offset</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">endog</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;offset is not the same length as endog&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">exposure</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">exposure</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">endog</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;exposure is not the same length as endog&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_init_kwds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># this is a temporary fixup because exposure has been transformed</span>
        <span class="c1"># see #1609</span>
        <span class="n">kwds</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">CountModel</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_get_init_kwds</span><span class="p">()</span>
        <span class="k">if</span> <span class="s1">&#39;exposure&#39;</span> <span class="ow">in</span> <span class="n">kwds</span> <span class="ow">and</span> <span class="n">kwds</span><span class="p">[</span><span class="s1">&#39;exposure&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">kwds</span><span class="p">[</span><span class="s1">&#39;exposure&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">kwds</span><span class="p">[</span><span class="s1">&#39;exposure&#39;</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">kwds</span>

<div class="viewcode-block" id="CountModel.predict"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.CountModel.predict.html#statsmodels.discrete.discrete_model.CountModel.predict">[docs]</a>    <span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">exog</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">exposure</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">linear</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Predict response variable of a count model given exogenous variables.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        If exposure is specified, then it will be logged by the method.</span>
<span class="sd">        The user does not need to log it first.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#TODO: add offset tp</span>
        <span class="k">if</span> <span class="n">exog</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">exog</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exog</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;offset&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">exposure</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;exposure&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">exposure</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">exposure</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">exposure</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">exposure</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">offset</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">linear</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">exog</span><span class="p">,</span> <span class="n">params</span><span class="p">[:</span><span class="n">exog</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span> <span class="o">+</span> <span class="n">exposure</span> <span class="o">+</span> <span class="n">offset</span><span class="p">)</span> <span class="c1"># not cdf</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">exog</span><span class="p">,</span> <span class="n">params</span><span class="p">[:</span><span class="n">exog</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span> <span class="o">+</span> <span class="n">exposure</span> <span class="o">+</span> <span class="n">offset</span></div>

    <span class="k">def</span> <span class="nf">_derivative_predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">exog</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">transform</span><span class="o">=</span><span class="s1">&#39;dydx&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For computing marginal effects standard errors.</span>

<span class="sd">        This is used only in the case of discrete and count regressors to</span>
<span class="sd">        get the variance-covariance of the marginal effects. It returns</span>
<span class="sd">        [d F / d params] where F is the predict.</span>

<span class="sd">        Transform can be &#39;dydx&#39; or &#39;eydx&#39;. Checking is done in margeff</span>
<span class="sd">        computations for appropriate transform.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">exog</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">exog</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exog</span>
        <span class="c1">#NOTE: this handles offset and exposure</span>
        <span class="n">dF</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">exog</span><span class="p">)[:,</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">exog</span>
        <span class="k">if</span> <span class="s1">&#39;ey&#39;</span> <span class="ow">in</span> <span class="n">transform</span><span class="p">:</span>
            <span class="n">dF</span> <span class="o">/=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">exog</span><span class="p">)[:,</span><span class="kc">None</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">dF</span>

    <span class="k">def</span> <span class="nf">_derivative_exog</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">exog</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">transform</span><span class="o">=</span><span class="s2">&quot;dydx&quot;</span><span class="p">,</span>
            <span class="n">dummy_idx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">count_idx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For computing marginal effects. These are the marginal effects</span>
<span class="sd">        d F(XB) / dX</span>
<span class="sd">        For the Poisson model F(XB) is the predicted counts rather than</span>
<span class="sd">        the probabilities.</span>

<span class="sd">        transform can be &#39;dydx&#39;, &#39;dyex&#39;, &#39;eydx&#39;, or &#39;eyex&#39;.</span>

<span class="sd">        Not all of these make sense in the presence of discrete regressors,</span>
<span class="sd">        but checks are done in the results in get_margeff.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># group 3 poisson, nbreg, zip, zinb</span>
        <span class="k">if</span> <span class="n">exog</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">exog</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exog</span>
        <span class="n">margeff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">exog</span><span class="p">)[:,</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">params</span><span class="p">[</span><span class="kc">None</span><span class="p">,:]</span>
        <span class="k">if</span> <span class="s1">&#39;ex&#39;</span> <span class="ow">in</span> <span class="n">transform</span><span class="p">:</span>
            <span class="n">margeff</span> <span class="o">*=</span> <span class="n">exog</span>
        <span class="k">if</span> <span class="s1">&#39;ey&#39;</span> <span class="ow">in</span> <span class="n">transform</span><span class="p">:</span>
            <span class="n">margeff</span> <span class="o">/=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">exog</span><span class="p">)[:,</span><span class="kc">None</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">count_idx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">statsmodels.discrete.discrete_margins</span> <span class="k">import</span> <span class="p">(</span>
                    <span class="n">_get_count_effects</span><span class="p">)</span>
            <span class="n">margeff</span> <span class="o">=</span> <span class="n">_get_count_effects</span><span class="p">(</span><span class="n">margeff</span><span class="p">,</span> <span class="n">exog</span><span class="p">,</span> <span class="n">count_idx</span><span class="p">,</span> <span class="n">transform</span><span class="p">,</span>
                    <span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dummy_idx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">statsmodels.discrete.discrete_margins</span> <span class="k">import</span> <span class="p">(</span>
                    <span class="n">_get_dummy_effects</span><span class="p">)</span>
            <span class="n">margeff</span> <span class="o">=</span> <span class="n">_get_dummy_effects</span><span class="p">(</span><span class="n">margeff</span><span class="p">,</span> <span class="n">exog</span><span class="p">,</span> <span class="n">dummy_idx</span><span class="p">,</span> <span class="n">transform</span><span class="p">,</span>
                    <span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">margeff</span>

<div class="viewcode-block" id="CountModel.fit"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.CountModel.fit.html#statsmodels.discrete.discrete_model.CountModel.fit">[docs]</a>    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;newton&#39;</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="mi">35</span><span class="p">,</span>
            <span class="n">full_output</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">disp</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">cntfit</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">CountModel</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">start_params</span><span class="o">=</span><span class="n">start_params</span><span class="p">,</span>
                <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="n">maxiter</span><span class="p">,</span> <span class="n">full_output</span><span class="o">=</span><span class="n">full_output</span><span class="p">,</span>
                <span class="n">disp</span><span class="o">=</span><span class="n">disp</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="n">callback</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">discretefit</span> <span class="o">=</span> <span class="n">CountResults</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cntfit</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">CountResultsWrapper</span><span class="p">(</span><span class="n">discretefit</span><span class="p">)</span></div>
    <span class="n">fit</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">DiscreteModel</span><span class="o">.</span><span class="n">fit</span><span class="o">.</span><span class="vm">__doc__</span>

<div class="viewcode-block" id="CountModel.fit_regularized"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.CountModel.fit_regularized.html#statsmodels.discrete.discrete_model.CountModel.fit_regularized">[docs]</a>    <span class="k">def</span> <span class="nf">fit_regularized</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;l1&#39;</span><span class="p">,</span>
            <span class="n">maxiter</span><span class="o">=</span><span class="s1">&#39;defined_by_method&#39;</span><span class="p">,</span> <span class="n">full_output</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">disp</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">alpha</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">trim_mode</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="n">auto_trim_tol</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">size_trim_tol</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">,</span>
            <span class="n">qc_tol</span><span class="o">=</span><span class="mf">0.03</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">cntfit</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">CountModel</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">fit_regularized</span><span class="p">(</span>
                <span class="n">start_params</span><span class="o">=</span><span class="n">start_params</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="n">maxiter</span><span class="p">,</span>
                <span class="n">full_output</span><span class="o">=</span><span class="n">full_output</span><span class="p">,</span> <span class="n">disp</span><span class="o">=</span><span class="n">disp</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="n">callback</span><span class="p">,</span>
                <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">trim_mode</span><span class="o">=</span><span class="n">trim_mode</span><span class="p">,</span> <span class="n">auto_trim_tol</span><span class="o">=</span><span class="n">auto_trim_tol</span><span class="p">,</span>
                <span class="n">size_trim_tol</span><span class="o">=</span><span class="n">size_trim_tol</span><span class="p">,</span> <span class="n">qc_tol</span><span class="o">=</span><span class="n">qc_tol</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">method</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;l1&#39;</span><span class="p">,</span> <span class="s1">&#39;l1_cvxopt_cp&#39;</span><span class="p">]:</span>
            <span class="n">discretefit</span> <span class="o">=</span> <span class="n">L1CountResults</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cntfit</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                    <span class="s2">&quot;argument method == </span><span class="si">%s</span><span class="s2">, which is not handled&quot;</span> <span class="o">%</span> <span class="n">method</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">L1CountResultsWrapper</span><span class="p">(</span><span class="n">discretefit</span><span class="p">)</span></div>
    <span class="n">fit_regularized</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">DiscreteModel</span><span class="o">.</span><span class="n">fit_regularized</span><span class="o">.</span><span class="vm">__doc__</span></div>


<span class="k">class</span> <span class="nc">OrderedModel</span><span class="p">(</span><span class="n">DiscreteModel</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="c1">#### Public Model Classes ####</span>

<div class="viewcode-block" id="Poisson"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.Poisson.html#statsmodels.discrete.discrete_model.Poisson">[docs]</a><span class="k">class</span> <span class="nc">Poisson</span><span class="p">(</span><span class="n">CountModel</span><span class="p">):</span>
    <span class="vm">__doc__</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    Poisson model for count data</span>

<span class="si">%(params)s</span><span class="s2"></span>
<span class="s2">    </span><span class="si">%(extra_params)s</span><span class="s2"></span>

<span class="s2">    Attributes</span>
<span class="s2">    -----------</span>
<span class="s2">    endog : array</span>
<span class="s2">        A reference to the endogenous response variable</span>
<span class="s2">    exog : array</span>
<span class="s2">        A reference to the exogenous design.</span>
<span class="s2">    &quot;&quot;&quot;</span> <span class="o">%</span> <span class="p">{</span><span class="s1">&#39;params&#39;</span> <span class="p">:</span> <span class="n">base</span><span class="o">.</span><span class="n">_model_params_doc</span><span class="p">,</span>
           <span class="s1">&#39;extra_params&#39;</span> <span class="p">:</span>
           <span class="sd">&quot;&quot;&quot;offset : array_like</span>
<span class="sd">        Offset is added to the linear prediction with coefficient equal to 1.</span>
<span class="sd">    exposure : array_like</span>
<span class="sd">        Log(exposure) is added to the linear prediction with coefficient</span>
<span class="sd">        equal to 1.</span>

<span class="sd">    &quot;&quot;&quot;</span> <span class="o">+</span> <span class="n">base</span><span class="o">.</span><span class="n">_missing_param_doc</span><span class="p">}</span>


<div class="viewcode-block" id="Poisson.cdf"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.Poisson.cdf.html#statsmodels.discrete.discrete_model.Poisson.cdf">[docs]</a>    <span class="k">def</span> <span class="nf">cdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Poisson model cumulative distribution function</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        X : array-like</span>
<span class="sd">            `X` is the linear predictor of the model.  See notes.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        The value of the Poisson CDF at each point.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The CDF is defined as</span>

<span class="sd">        .. math:: \\exp\left(-\\lambda\\right)\\sum_{i=0}^{y}\\frac{\\lambda^{i}}{i!}</span>

<span class="sd">        where :math:`\\lambda` assumes the loglinear model. I.e.,</span>

<span class="sd">        .. math:: \\ln\\lambda_{i}=X\\beta</span>

<span class="sd">        The parameter `X` is :math:`X\\beta` in the above formula.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">endog</span>
        <span class="k">return</span> <span class="n">stats</span><span class="o">.</span><span class="n">poisson</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">X</span><span class="p">))</span></div>

<div class="viewcode-block" id="Poisson.pdf"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.Poisson.pdf.html#statsmodels.discrete.discrete_model.Poisson.pdf">[docs]</a>    <span class="k">def</span> <span class="nf">pdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Poisson model probability mass function</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        X : array-like</span>
<span class="sd">            `X` is the linear predictor of the model.  See notes.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pdf : ndarray</span>
<span class="sd">            The value of the Poisson probability mass function, PMF, for each</span>
<span class="sd">            point of X.</span>

<span class="sd">        Notes</span>
<span class="sd">        --------</span>
<span class="sd">        The PMF is defined as</span>

<span class="sd">        .. math:: \\frac{e^{-\\lambda_{i}}\\lambda_{i}^{y_{i}}}{y_{i}!}</span>

<span class="sd">        where :math:`\\lambda` assumes the loglinear model. I.e.,</span>

<span class="sd">        .. math:: \\ln\\lambda_{i}=x_{i}\\beta</span>

<span class="sd">        The parameter `X` is :math:`x_{i}\\beta` in the above formula.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">endog</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">stats</span><span class="o">.</span><span class="n">poisson</span><span class="o">.</span><span class="n">logpmf</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">X</span><span class="p">)))</span></div>

<div class="viewcode-block" id="Poisson.loglike"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.Poisson.loglike.html#statsmodels.discrete.discrete_model.Poisson.loglike">[docs]</a>    <span class="k">def</span> <span class="nf">loglike</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Loglikelihood of Poisson model</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array-like</span>
<span class="sd">            The parameters of the model.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        loglike : float</span>
<span class="sd">            The log-likelihood function of the model evaluated at `params`.</span>
<span class="sd">            See notes.</span>

<span class="sd">        Notes</span>
<span class="sd">        --------</span>
<span class="sd">        .. math :: \\ln L=\\sum_{i=1}^{n}\\left[-\\lambda_{i}+y_{i}x_{i}^{\\prime}\\beta-\\ln y_{i}!\\right]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;offset&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">exposure</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;exposure&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">XB</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exog</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span> <span class="o">+</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">exposure</span>
        <span class="n">endog</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">endog</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">XB</span><span class="p">)</span> <span class="o">+</span>  <span class="n">endog</span><span class="o">*</span><span class="n">XB</span> <span class="o">-</span> <span class="n">gammaln</span><span class="p">(</span><span class="n">endog</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span></div>

<div class="viewcode-block" id="Poisson.loglikeobs"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.Poisson.loglikeobs.html#statsmodels.discrete.discrete_model.Poisson.loglikeobs">[docs]</a>    <span class="k">def</span> <span class="nf">loglikeobs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Loglikelihood for observations of Poisson model</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array-like</span>
<span class="sd">            The parameters of the model.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        loglike : ndarray (nobs,)</span>
<span class="sd">            The log likelihood for each observation of the model evaluated</span>
<span class="sd">            at `params`. See Notes</span>

<span class="sd">        Notes</span>
<span class="sd">        --------</span>
<span class="sd">        .. math :: \\ln L_{i}=\\left[-\\lambda_{i}+y_{i}x_{i}^{\\prime}\\beta-\\ln y_{i}!\\right]</span>

<span class="sd">        for observations :math:`i=1,...,n`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;offset&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">exposure</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;exposure&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">XB</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exog</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span> <span class="o">+</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">exposure</span>
        <span class="n">endog</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">endog</span>
        <span class="c1">#np.sum(stats.poisson.logpmf(endog, np.exp(XB)))</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">XB</span><span class="p">)</span> <span class="o">+</span>  <span class="n">endog</span><span class="o">*</span><span class="n">XB</span> <span class="o">-</span> <span class="n">gammaln</span><span class="p">(</span><span class="n">endog</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span></div>

<div class="viewcode-block" id="Poisson.fit"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.Poisson.fit.html#statsmodels.discrete.discrete_model.Poisson.fit">[docs]</a>    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;newton&#39;</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="mi">35</span><span class="p">,</span>
            <span class="n">full_output</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">disp</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">cntfit</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">CountModel</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">start_params</span><span class="o">=</span><span class="n">start_params</span><span class="p">,</span>
                <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="n">maxiter</span><span class="p">,</span> <span class="n">full_output</span><span class="o">=</span><span class="n">full_output</span><span class="p">,</span>
                <span class="n">disp</span><span class="o">=</span><span class="n">disp</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="n">callback</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="s1">&#39;cov_type&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">cov_kwds</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;cov_kwds&#39;</span><span class="p">,</span> <span class="p">{})</span>
            <span class="n">kwds</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;cov_type&#39;</span><span class="p">:</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;cov_type&#39;</span><span class="p">],</span> <span class="s1">&#39;cov_kwds&#39;</span><span class="p">:</span><span class="n">cov_kwds</span><span class="p">}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">kwds</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">discretefit</span> <span class="o">=</span> <span class="n">PoissonResults</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cntfit</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">PoissonResultsWrapper</span><span class="p">(</span><span class="n">discretefit</span><span class="p">)</span></div>
    <span class="n">fit</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">DiscreteModel</span><span class="o">.</span><span class="n">fit</span><span class="o">.</span><span class="vm">__doc__</span>

<div class="viewcode-block" id="Poisson.fit_regularized"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.Poisson.fit_regularized.html#statsmodels.discrete.discrete_model.Poisson.fit_regularized">[docs]</a>    <span class="k">def</span> <span class="nf">fit_regularized</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;l1&#39;</span><span class="p">,</span>
            <span class="n">maxiter</span><span class="o">=</span><span class="s1">&#39;defined_by_method&#39;</span><span class="p">,</span> <span class="n">full_output</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">disp</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">alpha</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">trim_mode</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="n">auto_trim_tol</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">size_trim_tol</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">,</span>
            <span class="n">qc_tol</span><span class="o">=</span><span class="mf">0.03</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">cntfit</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">CountModel</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">fit_regularized</span><span class="p">(</span>
                <span class="n">start_params</span><span class="o">=</span><span class="n">start_params</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="n">maxiter</span><span class="p">,</span>
                <span class="n">full_output</span><span class="o">=</span><span class="n">full_output</span><span class="p">,</span> <span class="n">disp</span><span class="o">=</span><span class="n">disp</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="n">callback</span><span class="p">,</span>
                <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">trim_mode</span><span class="o">=</span><span class="n">trim_mode</span><span class="p">,</span> <span class="n">auto_trim_tol</span><span class="o">=</span><span class="n">auto_trim_tol</span><span class="p">,</span>
                <span class="n">size_trim_tol</span><span class="o">=</span><span class="n">size_trim_tol</span><span class="p">,</span> <span class="n">qc_tol</span><span class="o">=</span><span class="n">qc_tol</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">method</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;l1&#39;</span><span class="p">,</span> <span class="s1">&#39;l1_cvxopt_cp&#39;</span><span class="p">]:</span>
            <span class="n">discretefit</span> <span class="o">=</span> <span class="n">L1PoissonResults</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cntfit</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                    <span class="s2">&quot;argument method == </span><span class="si">%s</span><span class="s2">, which is not handled&quot;</span> <span class="o">%</span> <span class="n">method</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">L1PoissonResultsWrapper</span><span class="p">(</span><span class="n">discretefit</span><span class="p">)</span></div>

    <span class="n">fit_regularized</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">DiscreteModel</span><span class="o">.</span><span class="n">fit_regularized</span><span class="o">.</span><span class="vm">__doc__</span>


<div class="viewcode-block" id="Poisson.fit_constrained"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.Poisson.fit_constrained.html#statsmodels.discrete.discrete_model.Poisson.fit_constrained">[docs]</a>    <span class="k">def</span> <span class="nf">fit_constrained</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">constraints</span><span class="p">,</span> <span class="n">start_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">fit_kwds</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;fit the model subject to linear equality constraints</span>

<span class="sd">        The constraints are of the form   `R params = q`</span>
<span class="sd">        where R is the constraint_matrix and q is the vector of</span>
<span class="sd">        constraint_values.</span>

<span class="sd">        The estimation creates a new model with transformed design matrix,</span>
<span class="sd">        exog, and converts the results back to the original parameterization.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        constraints : formula expression or tuple</span>
<span class="sd">            If it is a tuple, then the constraint needs to be given by two</span>
<span class="sd">            arrays (constraint_matrix, constraint_value), i.e. (R, q).</span>
<span class="sd">            Otherwise, the constraints can be given as strings or list of</span>
<span class="sd">            strings.</span>
<span class="sd">            see t_test for details</span>
<span class="sd">        start_params : None or array_like</span>
<span class="sd">            starting values for the optimization. `start_params` needs to be</span>
<span class="sd">            given in the original parameter space and are internally</span>
<span class="sd">            transformed.</span>
<span class="sd">        **fit_kwds : keyword arguments</span>
<span class="sd">            fit_kwds are used in the optimization of the transformed model.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        results : Results instance</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1">#constraints = (R, q)</span>
        <span class="c1"># TODO: temporary trailing underscore to not overwrite the monkey</span>
        <span class="c1">#       patched version</span>
        <span class="c1"># TODO: decide whether to move the imports</span>
        <span class="kn">from</span> <span class="nn">patsy</span> <span class="k">import</span> <span class="n">DesignInfo</span>
        <span class="kn">from</span> <span class="nn">statsmodels.base._constraints</span> <span class="k">import</span> <span class="n">fit_constrained</span>

        <span class="c1"># same pattern as in base.LikelihoodModel.t_test</span>
        <span class="n">lc</span> <span class="o">=</span> <span class="n">DesignInfo</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exog_names</span><span class="p">)</span><span class="o">.</span><span class="n">linear_constraint</span><span class="p">(</span><span class="n">constraints</span><span class="p">)</span>
        <span class="n">R</span><span class="p">,</span> <span class="n">q</span> <span class="o">=</span> <span class="n">lc</span><span class="o">.</span><span class="n">coefs</span><span class="p">,</span> <span class="n">lc</span><span class="o">.</span><span class="n">constants</span>

        <span class="c1"># TODO: add start_params option, need access to tranformation</span>
        <span class="c1">#       fit_constrained needs to do the transformation</span>
        <span class="n">params</span><span class="p">,</span> <span class="n">cov</span><span class="p">,</span> <span class="n">res_constr</span> <span class="o">=</span> <span class="n">fit_constrained</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span>
                                                  <span class="n">start_params</span><span class="o">=</span><span class="n">start_params</span><span class="p">,</span>
                                                  <span class="n">fit_kwds</span><span class="o">=</span><span class="n">fit_kwds</span><span class="p">)</span>
        <span class="c1">#create dummy results Instance, TODO: wire up properly</span>
        <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">maxiter</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;nm&#39;</span><span class="p">,</span> <span class="n">disp</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                       <span class="n">warn_convergence</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="c1"># we get a wrapper back</span>
        <span class="n">res</span><span class="o">.</span><span class="n">mle_retvals</span><span class="p">[</span><span class="s1">&#39;fcall&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">res_constr</span><span class="o">.</span><span class="n">mle_retvals</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;fcall&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="n">res</span><span class="o">.</span><span class="n">mle_retvals</span><span class="p">[</span><span class="s1">&#39;iterations&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">res_constr</span><span class="o">.</span><span class="n">mle_retvals</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                                                        <span class="s1">&#39;iterations&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="n">res</span><span class="o">.</span><span class="n">mle_retvals</span><span class="p">[</span><span class="s1">&#39;converged&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">res_constr</span><span class="o">.</span><span class="n">mle_retvals</span><span class="p">[</span><span class="s1">&#39;converged&#39;</span><span class="p">]</span>
        <span class="n">res</span><span class="o">.</span><span class="n">_results</span><span class="o">.</span><span class="n">params</span> <span class="o">=</span> <span class="n">params</span>
        <span class="n">res</span><span class="o">.</span><span class="n">_results</span><span class="o">.</span><span class="n">normalized_cov_params</span> <span class="o">=</span> <span class="n">cov</span>
        <span class="n">k_constr</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
        <span class="n">res</span><span class="o">.</span><span class="n">_results</span><span class="o">.</span><span class="n">df_resid</span> <span class="o">+=</span> <span class="n">k_constr</span>
        <span class="n">res</span><span class="o">.</span><span class="n">_results</span><span class="o">.</span><span class="n">df_model</span> <span class="o">-=</span> <span class="n">k_constr</span>
        <span class="n">res</span><span class="o">.</span><span class="n">_results</span><span class="o">.</span><span class="n">constraints</span> <span class="o">=</span> <span class="n">lc</span>
        <span class="n">res</span><span class="o">.</span><span class="n">_results</span><span class="o">.</span><span class="n">k_constr</span> <span class="o">=</span> <span class="n">k_constr</span>
        <span class="n">res</span><span class="o">.</span><span class="n">_results</span><span class="o">.</span><span class="n">results_constrained</span> <span class="o">=</span> <span class="n">res_constr</span>
        <span class="k">return</span> <span class="n">res</span></div>


<div class="viewcode-block" id="Poisson.score"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.Poisson.score.html#statsmodels.discrete.discrete_model.Poisson.score">[docs]</a>    <span class="k">def</span> <span class="nf">score</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Poisson model score (gradient) vector of the log-likelihood</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array-like</span>
<span class="sd">            The parameters of the model</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        score : ndarray, 1-D</span>
<span class="sd">            The score vector of the model, i.e. the first derivative of the</span>
<span class="sd">            loglikelihood function, evaluated at `params`</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        .. math:: \\frac{\\partial\\ln L}{\\partial\\beta}=\\sum_{i=1}^{n}\\left(y_{i}-\\lambda_{i}\\right)x_{i}</span>

<span class="sd">        where the loglinear model is assumed</span>

<span class="sd">        .. math:: \\ln\\lambda_{i}=x_{i}\\beta</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;offset&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">exposure</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;exposure&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">X</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exog</span>
        <span class="n">L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">params</span><span class="p">)</span> <span class="o">+</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">exposure</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endog</span> <span class="o">-</span> <span class="n">L</span><span class="p">,</span> <span class="n">X</span><span class="p">)</span></div>

<div class="viewcode-block" id="Poisson.score_obs"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.Poisson.score_obs.html#statsmodels.discrete.discrete_model.Poisson.score_obs">[docs]</a>    <span class="k">def</span> <span class="nf">score_obs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Poisson model Jacobian of the log-likelihood for each observation</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array-like</span>
<span class="sd">            The parameters of the model</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        score : ndarray (nobs, k_vars)</span>
<span class="sd">            The score vector of the model evaluated at `params`</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        .. math:: \\frac{\\partial\\ln L_{i}}{\\partial\\beta}=\\left(y_{i}-\\lambda_{i}\\right)x_{i}</span>

<span class="sd">        for observations :math:`i=1,...,n`</span>

<span class="sd">        where the loglinear model is assumed</span>

<span class="sd">        .. math:: \\ln\\lambda_{i}=x_{i}\\beta</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;offset&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">exposure</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;exposure&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">X</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exog</span>
        <span class="n">L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">params</span><span class="p">)</span> <span class="o">+</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">exposure</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endog</span> <span class="o">-</span> <span class="n">L</span><span class="p">)[:,</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">X</span></div>

    <span class="n">jac</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deprecate</span><span class="p">(</span><span class="n">score_obs</span><span class="p">,</span> <span class="s1">&#39;jac&#39;</span><span class="p">,</span> <span class="s1">&#39;score_obs&#39;</span><span class="p">,</span> <span class="s2">&quot;Use score_obs method.&quot;</span>
                       <span class="s2">&quot; jac will be removed in 0.7&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="Poisson.hessian"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.Poisson.hessian.html#statsmodels.discrete.discrete_model.Poisson.hessian">[docs]</a>    <span class="k">def</span> <span class="nf">hessian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Poisson model Hessian matrix of the loglikelihood</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array-like</span>
<span class="sd">            The parameters of the model</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        hess : ndarray, (k_vars, k_vars)</span>
<span class="sd">            The Hessian, second derivative of loglikelihood function,</span>
<span class="sd">            evaluated at `params`</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        .. math:: \\frac{\\partial^{2}\\ln L}{\\partial\\beta\\partial\\beta^{\\prime}}=-\\sum_{i=1}^{n}\\lambda_{i}x_{i}x_{i}^{\\prime}</span>

<span class="sd">        where the loglinear model is assumed</span>

<span class="sd">        .. math:: \\ln\\lambda_{i}=x_{i}\\beta</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;offset&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">exposure</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;exposure&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">X</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exog</span>
        <span class="n">L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">params</span><span class="p">)</span> <span class="o">+</span> <span class="n">exposure</span> <span class="o">+</span> <span class="n">offset</span><span class="p">)</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">L</span><span class="o">*</span><span class="n">X</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">X</span><span class="p">)</span></div></div>

<div class="viewcode-block" id="Logit"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.Logit.html#statsmodels.discrete.discrete_model.Logit">[docs]</a><span class="k">class</span> <span class="nc">Logit</span><span class="p">(</span><span class="n">BinaryModel</span><span class="p">):</span>
    <span class="vm">__doc__</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    Binary choice logit model</span>

<span class="si">%(params)s</span><span class="s2"></span>
<span class="s2">    </span><span class="si">%(extra_params)s</span><span class="s2"></span>

<span class="s2">    Attributes</span>
<span class="s2">    -----------</span>
<span class="s2">    endog : array</span>
<span class="s2">        A reference to the endogenous response variable</span>
<span class="s2">    exog : array</span>
<span class="s2">        A reference to the exogenous design.</span>
<span class="s2">    &quot;&quot;&quot;</span> <span class="o">%</span> <span class="p">{</span><span class="s1">&#39;params&#39;</span> <span class="p">:</span> <span class="n">base</span><span class="o">.</span><span class="n">_model_params_doc</span><span class="p">,</span>
           <span class="s1">&#39;extra_params&#39;</span> <span class="p">:</span> <span class="n">base</span><span class="o">.</span><span class="n">_missing_param_doc</span><span class="p">}</span>

<div class="viewcode-block" id="Logit.cdf"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.Logit.cdf.html#statsmodels.discrete.discrete_model.Logit.cdf">[docs]</a>    <span class="k">def</span> <span class="nf">cdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The logistic cumulative distribution function</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X : array-like</span>
<span class="sd">            `X` is the linear predictor of the logit model.  See notes.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        1/(1 + exp(-X))</span>

<span class="sd">        Notes</span>
<span class="sd">        ------</span>
<span class="sd">        In the logit model,</span>

<span class="sd">        .. math:: \\Lambda\\left(x^{\\prime}\\beta\\right)=\\text{Prob}\\left(Y=1|x\\right)=\\frac{e^{x^{\\prime}\\beta}}{1+e^{x^{\\prime}\\beta}}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">X</span><span class="p">))</span></div>

<div class="viewcode-block" id="Logit.pdf"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.Logit.pdf.html#statsmodels.discrete.discrete_model.Logit.pdf">[docs]</a>    <span class="k">def</span> <span class="nf">pdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The logistic probability density function</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        X : array-like</span>
<span class="sd">            `X` is the linear predictor of the logit model.  See notes.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pdf : ndarray</span>
<span class="sd">            The value of the Logit probability mass function, PMF, for each</span>
<span class="sd">            point of X. ``np.exp(-x)/(1+np.exp(-X))**2``</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        In the logit model,</span>

<span class="sd">        .. math:: \\lambda\\left(x^{\\prime}\\beta\\right)=\\frac{e^{-x^{\\prime}\\beta}}{\\left(1+e^{-x^{\\prime}\\beta}\\right)^{2}}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">X</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">X</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span></div>

<div class="viewcode-block" id="Logit.loglike"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.Logit.loglike.html#statsmodels.discrete.discrete_model.Logit.loglike">[docs]</a>    <span class="k">def</span> <span class="nf">loglike</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Log-likelihood of logit model.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        params : array-like</span>
<span class="sd">            The parameters of the logit model.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        loglike : float</span>
<span class="sd">            The log-likelihood function of the model evaluated at `params`.</span>
<span class="sd">            See notes.</span>

<span class="sd">        Notes</span>
<span class="sd">        ------</span>
<span class="sd">        .. math:: \\ln L=\\sum_{i}\\ln\\Lambda\\left(q_{i}x_{i}^{\\prime}\\beta\\right)</span>

<span class="sd">        Where :math:`q=2y-1`. This simplification comes from the fact that the</span>
<span class="sd">        logistic distribution is symmetric.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">q</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">endog</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">X</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exog</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">q</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">params</span><span class="p">))))</span></div>

<div class="viewcode-block" id="Logit.loglikeobs"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.Logit.loglikeobs.html#statsmodels.discrete.discrete_model.Logit.loglikeobs">[docs]</a>    <span class="k">def</span> <span class="nf">loglikeobs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Log-likelihood of logit model for each observation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        params : array-like</span>
<span class="sd">            The parameters of the logit model.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        loglike : ndarray (nobs,)</span>
<span class="sd">            The log likelihood for each observation of the model evaluated</span>
<span class="sd">            at `params`. See Notes</span>

<span class="sd">        Notes</span>
<span class="sd">        ------</span>
<span class="sd">        .. math:: \\ln L=\\sum_{i}\\ln\\Lambda\\left(q_{i}x_{i}^{\\prime}\\beta\\right)</span>

<span class="sd">        for observations :math:`i=1,...,n`</span>

<span class="sd">        where :math:`q=2y-1`. This simplification comes from the fact that the</span>
<span class="sd">        logistic distribution is symmetric.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">q</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">endog</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">X</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exog</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">q</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">params</span><span class="p">)))</span></div>

<div class="viewcode-block" id="Logit.score"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.Logit.score.html#statsmodels.discrete.discrete_model.Logit.score">[docs]</a>    <span class="k">def</span> <span class="nf">score</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Logit model score (gradient) vector of the log-likelihood</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params: array-like</span>
<span class="sd">            The parameters of the model</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        score : ndarray, 1-D</span>
<span class="sd">            The score vector of the model, i.e. the first derivative of the</span>
<span class="sd">            loglikelihood function, evaluated at `params`</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        .. math:: \\frac{\\partial\\ln L}{\\partial\\beta}=\\sum_{i=1}^{n}\\left(y_{i}-\\Lambda_{i}\\right)x_{i}</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">endog</span>
        <span class="n">X</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exog</span>
        <span class="n">L</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">params</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">L</span><span class="p">,</span><span class="n">X</span><span class="p">)</span></div>

<div class="viewcode-block" id="Logit.score_obs"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.Logit.score_obs.html#statsmodels.discrete.discrete_model.Logit.score_obs">[docs]</a>    <span class="k">def</span> <span class="nf">score_obs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Logit model Jacobian of the log-likelihood for each observation</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params: array-like</span>
<span class="sd">            The parameters of the model</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        jac : ndarray, (nobs, k_vars)</span>
<span class="sd">            The derivative of the loglikelihood for each observation evaluated</span>
<span class="sd">            at `params`.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        .. math:: \\frac{\\partial\\ln L_{i}}{\\partial\\beta}=\\left(y_{i}-\\Lambda_{i}\\right)x_{i}</span>

<span class="sd">        for observations :math:`i=1,...,n`</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">endog</span>
        <span class="n">X</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exog</span>
        <span class="n">L</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">params</span><span class="p">))</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">L</span><span class="p">)[:,</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">X</span></div>

    <span class="n">jac</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deprecate</span><span class="p">(</span><span class="n">score_obs</span><span class="p">,</span> <span class="s1">&#39;jac&#39;</span><span class="p">,</span> <span class="s1">&#39;score_obs&#39;</span><span class="p">,</span> <span class="s2">&quot;Use score_obs method.&quot;</span>
                       <span class="s2">&quot; jac will be removed in 0.7&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="Logit.hessian"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.Logit.hessian.html#statsmodels.discrete.discrete_model.Logit.hessian">[docs]</a>    <span class="k">def</span> <span class="nf">hessian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Logit model Hessian matrix of the log-likelihood</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array-like</span>
<span class="sd">            The parameters of the model</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        hess : ndarray, (k_vars, k_vars)</span>
<span class="sd">            The Hessian, second derivative of loglikelihood function,</span>
<span class="sd">            evaluated at `params`</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        .. math:: \\frac{\\partial^{2}\\ln L}{\\partial\\beta\\partial\\beta^{\\prime}}=-\\sum_{i}\\Lambda_{i}\\left(1-\\Lambda_{i}\\right)x_{i}x_{i}^{\\prime}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">X</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exog</span>
        <span class="n">L</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">params</span><span class="p">))</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">L</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">L</span><span class="p">)</span><span class="o">*</span><span class="n">X</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">X</span><span class="p">)</span></div>

<div class="viewcode-block" id="Logit.fit"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.Logit.fit.html#statsmodels.discrete.discrete_model.Logit.fit">[docs]</a>    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;newton&#39;</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="mi">35</span><span class="p">,</span>
            <span class="n">full_output</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">disp</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">bnryfit</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">Logit</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">start_params</span><span class="o">=</span><span class="n">start_params</span><span class="p">,</span>
                <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="n">maxiter</span><span class="p">,</span> <span class="n">full_output</span><span class="o">=</span><span class="n">full_output</span><span class="p">,</span>
                <span class="n">disp</span><span class="o">=</span><span class="n">disp</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="n">callback</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="n">discretefit</span> <span class="o">=</span> <span class="n">LogitResults</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bnryfit</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">BinaryResultsWrapper</span><span class="p">(</span><span class="n">discretefit</span><span class="p">)</span></div>
    <span class="n">fit</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">DiscreteModel</span><span class="o">.</span><span class="n">fit</span><span class="o">.</span><span class="vm">__doc__</span></div>

<div class="viewcode-block" id="Probit"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.Probit.html#statsmodels.discrete.discrete_model.Probit">[docs]</a><span class="k">class</span> <span class="nc">Probit</span><span class="p">(</span><span class="n">BinaryModel</span><span class="p">):</span>
    <span class="vm">__doc__</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    Binary choice Probit model</span>

<span class="si">%(params)s</span><span class="s2"></span>
<span class="s2">    </span><span class="si">%(extra_params)s</span><span class="s2"></span>

<span class="s2">    Attributes</span>
<span class="s2">    -----------</span>
<span class="s2">    endog : array</span>
<span class="s2">        A reference to the endogenous response variable</span>
<span class="s2">    exog : array</span>
<span class="s2">        A reference to the exogenous design.</span>
<span class="s2">    &quot;&quot;&quot;</span> <span class="o">%</span> <span class="p">{</span><span class="s1">&#39;params&#39;</span> <span class="p">:</span> <span class="n">base</span><span class="o">.</span><span class="n">_model_params_doc</span><span class="p">,</span>
           <span class="s1">&#39;extra_params&#39;</span> <span class="p">:</span> <span class="n">base</span><span class="o">.</span><span class="n">_missing_param_doc</span><span class="p">}</span>

<div class="viewcode-block" id="Probit.cdf"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.Probit.cdf.html#statsmodels.discrete.discrete_model.Probit.cdf">[docs]</a>    <span class="k">def</span> <span class="nf">cdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Probit (Normal) cumulative distribution function</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X : array-like</span>
<span class="sd">            The linear predictor of the model (XB).</span>

<span class="sd">        Returns</span>
<span class="sd">        --------</span>
<span class="sd">        cdf : ndarray</span>
<span class="sd">            The cdf evaluated at `X`.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This function is just an alias for scipy.stats.norm.cdf</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">_cdf</span><span class="p">(</span><span class="n">X</span><span class="p">)</span></div>

<div class="viewcode-block" id="Probit.pdf"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.Probit.pdf.html#statsmodels.discrete.discrete_model.Probit.pdf">[docs]</a>    <span class="k">def</span> <span class="nf">pdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Probit (Normal) probability density function</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X : array-like</span>
<span class="sd">            The linear predictor of the model (XB).</span>

<span class="sd">        Returns</span>
<span class="sd">        --------</span>
<span class="sd">        pdf : ndarray</span>
<span class="sd">            The value of the normal density function for each point of X.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This function is just an alias for scipy.stats.norm.pdf</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">_pdf</span><span class="p">(</span><span class="n">X</span><span class="p">)</span></div>


<div class="viewcode-block" id="Probit.loglike"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.Probit.loglike.html#statsmodels.discrete.discrete_model.Probit.loglike">[docs]</a>    <span class="k">def</span> <span class="nf">loglike</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Log-likelihood of probit model (i.e., the normal distribution).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array-like</span>
<span class="sd">            The parameters of the model.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        loglike : float</span>
<span class="sd">            The log-likelihood function of the model evaluated at `params`.</span>
<span class="sd">            See notes.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        .. math:: \\ln L=\\sum_{i}\\ln\\Phi\\left(q_{i}x_{i}^{\\prime}\\beta\\right)</span>

<span class="sd">        Where :math:`q=2y-1`. This simplification comes from the fact that the</span>
<span class="sd">        normal distribution is symmetric.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">q</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">endog</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">X</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exog</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">q</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">params</span><span class="p">)),</span>
            <span class="n">FLOAT_EPS</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span></div>

<div class="viewcode-block" id="Probit.loglikeobs"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.Probit.loglikeobs.html#statsmodels.discrete.discrete_model.Probit.loglikeobs">[docs]</a>    <span class="k">def</span> <span class="nf">loglikeobs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Log-likelihood of probit model for each observation</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array-like</span>
<span class="sd">            The parameters of the model.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        loglike : ndarray (nobs,)</span>
<span class="sd">            The log likelihood for each observation of the model evaluated</span>
<span class="sd">            at `params`. See Notes</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        .. math:: \\ln L_{i}=\\ln\\Phi\\left(q_{i}x_{i}^{\\prime}\\beta\\right)</span>

<span class="sd">        for observations :math:`i=1,...,n`</span>

<span class="sd">        where :math:`q=2y-1`. This simplification comes from the fact that the</span>
<span class="sd">        normal distribution is symmetric.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">q</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">endog</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">X</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exog</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">q</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">params</span><span class="p">)),</span> <span class="n">FLOAT_EPS</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span></div>


<div class="viewcode-block" id="Probit.score"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.Probit.score.html#statsmodels.discrete.discrete_model.Probit.score">[docs]</a>    <span class="k">def</span> <span class="nf">score</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Probit model score (gradient) vector</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array-like</span>
<span class="sd">            The parameters of the model</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        score : ndarray, 1-D</span>
<span class="sd">            The score vector of the model, i.e. the first derivative of the</span>
<span class="sd">            loglikelihood function, evaluated at `params`</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        .. math:: \\frac{\\partial\\ln L}{\\partial\\beta}=\\sum_{i=1}^{n}\\left[\\frac{q_{i}\\phi\\left(q_{i}x_{i}^{\\prime}\\beta\\right)}{\\Phi\\left(q_{i}x_{i}^{\\prime}\\beta\\right)}\\right]x_{i}</span>

<span class="sd">        Where :math:`q=2y-1`. This simplification comes from the fact that the</span>
<span class="sd">        normal distribution is symmetric.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">endog</span>
        <span class="n">X</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exog</span>
        <span class="n">XB</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">params</span><span class="p">)</span>
        <span class="n">q</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">y</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="c1"># clip to get rid of invalid divide complaint</span>
        <span class="n">L</span> <span class="o">=</span> <span class="n">q</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="n">q</span><span class="o">*</span><span class="n">XB</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">q</span><span class="o">*</span><span class="n">XB</span><span class="p">),</span> <span class="n">FLOAT_EPS</span><span class="p">,</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">FLOAT_EPS</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">X</span><span class="p">)</span></div>

<div class="viewcode-block" id="Probit.score_obs"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.Probit.score_obs.html#statsmodels.discrete.discrete_model.Probit.score_obs">[docs]</a>    <span class="k">def</span> <span class="nf">score_obs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Probit model Jacobian for each observation</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array-like</span>
<span class="sd">            The parameters of the model</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        jac : ndarray, (nobs, k_vars)</span>
<span class="sd">            The derivative of the loglikelihood for each observation evaluated</span>
<span class="sd">            at `params`.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        .. math:: \\frac{\\partial\\ln L_{i}}{\\partial\\beta}=\\left[\\frac{q_{i}\\phi\\left(q_{i}x_{i}^{\\prime}\\beta\\right)}{\\Phi\\left(q_{i}x_{i}^{\\prime}\\beta\\right)}\\right]x_{i}</span>

<span class="sd">        for observations :math:`i=1,...,n`</span>

<span class="sd">        Where :math:`q=2y-1`. This simplification comes from the fact that the</span>
<span class="sd">        normal distribution is symmetric.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">endog</span>
        <span class="n">X</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exog</span>
        <span class="n">XB</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">params</span><span class="p">)</span>
        <span class="n">q</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">y</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="c1"># clip to get rid of invalid divide complaint</span>
        <span class="n">L</span> <span class="o">=</span> <span class="n">q</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="n">q</span><span class="o">*</span><span class="n">XB</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">q</span><span class="o">*</span><span class="n">XB</span><span class="p">),</span> <span class="n">FLOAT_EPS</span><span class="p">,</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">FLOAT_EPS</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">L</span><span class="p">[:,</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">X</span></div>

    <span class="n">jac</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deprecate</span><span class="p">(</span><span class="n">score_obs</span><span class="p">,</span> <span class="s1">&#39;jac&#39;</span><span class="p">,</span> <span class="s1">&#39;score_obs&#39;</span><span class="p">,</span> <span class="s2">&quot;Use score_obs method.&quot;</span>
                       <span class="s2">&quot; jac will be removed in 0.7&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="Probit.hessian"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.Probit.hessian.html#statsmodels.discrete.discrete_model.Probit.hessian">[docs]</a>    <span class="k">def</span> <span class="nf">hessian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Probit model Hessian matrix of the log-likelihood</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array-like</span>
<span class="sd">            The parameters of the model</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        hess : ndarray, (k_vars, k_vars)</span>
<span class="sd">            The Hessian, second derivative of loglikelihood function,</span>
<span class="sd">            evaluated at `params`</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        .. math:: \\frac{\\partial^{2}\\ln L}{\\partial\\beta\\partial\\beta^{\\prime}}=-\lambda_{i}\\left(\\lambda_{i}+x_{i}^{\\prime}\\beta\\right)x_{i}x_{i}^{\\prime}</span>

<span class="sd">        where</span>

<span class="sd">        .. math:: \\lambda_{i}=\\frac{q_{i}\\phi\\left(q_{i}x_{i}^{\\prime}\\beta\\right)}{\\Phi\\left(q_{i}x_{i}^{\\prime}\\beta\\right)}</span>

<span class="sd">        and :math:`q=2y-1`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">X</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exog</span>
        <span class="n">XB</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">params</span><span class="p">)</span>
        <span class="n">q</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">endog</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">L</span> <span class="o">=</span> <span class="n">q</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="n">q</span><span class="o">*</span><span class="n">XB</span><span class="p">)</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">q</span><span class="o">*</span><span class="n">XB</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="o">-</span><span class="n">L</span><span class="o">*</span><span class="p">(</span><span class="n">L</span><span class="o">+</span><span class="n">XB</span><span class="p">)</span><span class="o">*</span><span class="n">X</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">X</span><span class="p">)</span></div>

<div class="viewcode-block" id="Probit.fit"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.Probit.fit.html#statsmodels.discrete.discrete_model.Probit.fit">[docs]</a>    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;newton&#39;</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="mi">35</span><span class="p">,</span>
            <span class="n">full_output</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">disp</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">bnryfit</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">Probit</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">start_params</span><span class="o">=</span><span class="n">start_params</span><span class="p">,</span>
                <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="n">maxiter</span><span class="p">,</span> <span class="n">full_output</span><span class="o">=</span><span class="n">full_output</span><span class="p">,</span>
                <span class="n">disp</span><span class="o">=</span><span class="n">disp</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="n">callback</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">discretefit</span> <span class="o">=</span> <span class="n">ProbitResults</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bnryfit</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">BinaryResultsWrapper</span><span class="p">(</span><span class="n">discretefit</span><span class="p">)</span></div>
    <span class="n">fit</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">DiscreteModel</span><span class="o">.</span><span class="n">fit</span><span class="o">.</span><span class="vm">__doc__</span></div>

<div class="viewcode-block" id="MNLogit"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.MNLogit.html#statsmodels.discrete.discrete_model.MNLogit">[docs]</a><span class="k">class</span> <span class="nc">MNLogit</span><span class="p">(</span><span class="n">MultinomialModel</span><span class="p">):</span>
    <span class="vm">__doc__</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    Multinomial logit model</span>

<span class="s2">    Parameters</span>
<span class="s2">    ----------</span>
<span class="s2">    endog : array-like</span>
<span class="s2">        `endog` is an 1-d vector of the endogenous response.  `endog` can</span>
<span class="s2">        contain strings, ints, or floats.  Note that if it contains strings,</span>
<span class="s2">        every distinct string will be a category.  No stripping of whitespace</span>
<span class="s2">        is done.</span>
<span class="s2">    exog : array-like</span>
<span class="s2">        A nobs x k array where `nobs` is the number of observations and `k`</span>
<span class="s2">        is the number of regressors. An intercept is not included by default</span>
<span class="s2">        and should be added by the user. See `statsmodels.tools.add_constant`.</span>
<span class="s2">    </span><span class="si">%(extra_params)s</span><span class="s2"></span>

<span class="s2">    Attributes</span>
<span class="s2">    ----------</span>
<span class="s2">    endog : array</span>
<span class="s2">        A reference to the endogenous response variable</span>
<span class="s2">    exog : array</span>
<span class="s2">        A reference to the exogenous design.</span>
<span class="s2">    J : float</span>
<span class="s2">        The number of choices for the endogenous variable. Note that this</span>
<span class="s2">        is zero-indexed.</span>
<span class="s2">    K : float</span>
<span class="s2">        The actual number of parameters for the exogenous design.  Includes</span>
<span class="s2">        the constant if the design has one.</span>
<span class="s2">    names : dict</span>
<span class="s2">        A dictionary mapping the column number in `wendog` to the variables</span>
<span class="s2">        in `endog`.</span>
<span class="s2">    wendog : array</span>
<span class="s2">        An n x j array where j is the number of unique categories in `endog`.</span>
<span class="s2">        Each column of j is a dummy variable indicating the category of</span>
<span class="s2">        each observation. See `names` for a dictionary mapping each column to</span>
<span class="s2">        its category.</span>

<span class="s2">    Notes</span>
<span class="s2">    -----</span>
<span class="s2">    See developer notes for further information on `MNLogit` internals.</span>
<span class="s2">    &quot;&quot;&quot;</span> <span class="o">%</span> <span class="p">{</span><span class="s1">&#39;extra_params&#39;</span> <span class="p">:</span> <span class="n">base</span><span class="o">.</span><span class="n">_missing_param_doc</span><span class="p">}</span>

<div class="viewcode-block" id="MNLogit.pdf"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.MNLogit.pdf.html#statsmodels.discrete.discrete_model.MNLogit.pdf">[docs]</a>    <span class="k">def</span> <span class="nf">pdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">eXB</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        NotImplemented</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>

<div class="viewcode-block" id="MNLogit.cdf"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.MNLogit.cdf.html#statsmodels.discrete.discrete_model.MNLogit.cdf">[docs]</a>    <span class="k">def</span> <span class="nf">cdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Multinomial logit cumulative distribution function.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X : array</span>
<span class="sd">            The linear predictor of the model XB.</span>

<span class="sd">        Returns</span>
<span class="sd">        --------</span>
<span class="sd">        cdf : ndarray</span>
<span class="sd">            The cdf evaluated at `X`.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        In the multinomial logit model.</span>
<span class="sd">        .. math:: \\frac{\\exp\\left(\\beta_{j}^{\\prime}x_{i}\\right)}{\\sum_{k=0}^{J}\\exp\\left(\\beta_{k}^{\\prime}x_{i}\\right)}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">eXB</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">X</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">eXB</span><span class="o">/</span><span class="n">eXB</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">)[:,</span><span class="kc">None</span><span class="p">]</span></div>

<div class="viewcode-block" id="MNLogit.loglike"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.MNLogit.loglike.html#statsmodels.discrete.discrete_model.MNLogit.loglike">[docs]</a>    <span class="k">def</span> <span class="nf">loglike</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Log-likelihood of the multinomial logit model.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array-like</span>
<span class="sd">            The parameters of the multinomial logit model.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        loglike : float</span>
<span class="sd">            The log-likelihood function of the model evaluated at `params`.</span>
<span class="sd">            See notes.</span>

<span class="sd">        Notes</span>
<span class="sd">        ------</span>
<span class="sd">        .. math:: \\ln L=\\sum_{i=1}^{n}\\sum_{j=0}^{J}d_{ij}\\ln\\left(\\frac{\\exp\\left(\\beta_{j}^{\\prime}x_{i}\\right)}{\\sum_{k=0}^{J}\\exp\\left(\\beta_{k}^{\\prime}x_{i}\\right)}\\right)</span>

<span class="sd">        where :math:`d_{ij}=1` if individual `i` chose alternative `j` and 0</span>
<span class="sd">        if not.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">params</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wendog</span>
        <span class="n">logprob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exog</span><span class="p">,</span><span class="n">params</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">d</span> <span class="o">*</span> <span class="n">logprob</span><span class="p">)</span></div>

<div class="viewcode-block" id="MNLogit.loglikeobs"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.MNLogit.loglikeobs.html#statsmodels.discrete.discrete_model.MNLogit.loglikeobs">[docs]</a>    <span class="k">def</span> <span class="nf">loglikeobs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Log-likelihood of the multinomial logit model for each observation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array-like</span>
<span class="sd">            The parameters of the multinomial logit model.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        loglike : ndarray (nobs,)</span>
<span class="sd">            The log likelihood for each observation of the model evaluated</span>
<span class="sd">            at `params`. See Notes</span>

<span class="sd">        Notes</span>
<span class="sd">        ------</span>
<span class="sd">        .. math:: \\ln L_{i}=\\sum_{j=0}^{J}d_{ij}\\ln\\left(\\frac{\\exp\\left(\\beta_{j}^{\\prime}x_{i}\\right)}{\\sum_{k=0}^{J}\\exp\\left(\\beta_{k}^{\\prime}x_{i}\\right)}\\right)</span>

<span class="sd">        for observations :math:`i=1,...,n`</span>

<span class="sd">        where :math:`d_{ij}=1` if individual `i` chose alternative `j` and 0</span>
<span class="sd">        if not.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">params</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wendog</span>
        <span class="n">logprob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exog</span><span class="p">,</span><span class="n">params</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">d</span> <span class="o">*</span> <span class="n">logprob</span></div>

<div class="viewcode-block" id="MNLogit.score"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.MNLogit.score.html#statsmodels.discrete.discrete_model.MNLogit.score">[docs]</a>    <span class="k">def</span> <span class="nf">score</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Score matrix for multinomial logit model log-likelihood</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array</span>
<span class="sd">            The parameters of the multinomial logit model.</span>

<span class="sd">        Returns</span>
<span class="sd">        --------</span>
<span class="sd">        score : ndarray, (K * (J-1),)</span>
<span class="sd">            The 2-d score vector, i.e. the first derivative of the</span>
<span class="sd">            loglikelihood function, of the multinomial logit model evaluated at</span>
<span class="sd">            `params`.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        .. math:: \\frac{\\partial\\ln L}{\\partial\\beta_{j}}=\\sum_{i}\\left(d_{ij}-\\frac{\\exp\\left(\\beta_{j}^{\\prime}x_{i}\\right)}{\\sum_{k=0}^{J}\\exp\\left(\\beta_{k}^{\\prime}x_{i}\\right)}\\right)x_{i}</span>

<span class="sd">        for :math:`j=1,...,J`</span>

<span class="sd">        In the multinomial model the score matrix is K x J-1 but is returned</span>
<span class="sd">        as a flattened array to work with the solvers.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">params</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>
        <span class="n">firstterm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wendog</span><span class="p">[:,</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exog</span><span class="p">,</span>
                                                  <span class="n">params</span><span class="p">))[:,</span><span class="mi">1</span><span class="p">:]</span>
        <span class="c1">#NOTE: might need to switch terms if params is reshaped</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">firstterm</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">exog</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span></div>

<div class="viewcode-block" id="MNLogit.loglike_and_score"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.MNLogit.loglike_and_score.html#statsmodels.discrete.discrete_model.MNLogit.loglike_and_score">[docs]</a>    <span class="k">def</span> <span class="nf">loglike_and_score</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns log likelihood and score, efficiently reusing calculations.</span>

<span class="sd">        Note that both of these returned quantities will need to be negated</span>
<span class="sd">        before being minimized by the maximum likelihood fitting machinery.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">params</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>
        <span class="n">cdf_dot_exog_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exog</span><span class="p">,</span> <span class="n">params</span><span class="p">))</span>
        <span class="n">loglike_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wendog</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">cdf_dot_exog_params</span><span class="p">))</span>
        <span class="n">firstterm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wendog</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">cdf_dot_exog_params</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:]</span>
        <span class="n">score_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">firstterm</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">exog</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">loglike_value</span><span class="p">,</span> <span class="n">score_array</span></div>

<div class="viewcode-block" id="MNLogit.score_obs"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.MNLogit.score_obs.html#statsmodels.discrete.discrete_model.MNLogit.score_obs">[docs]</a>    <span class="k">def</span> <span class="nf">score_obs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Jacobian matrix for multinomial logit model log-likelihood</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array</span>
<span class="sd">            The parameters of the multinomial logit model.</span>

<span class="sd">        Returns</span>
<span class="sd">        --------</span>
<span class="sd">        jac : ndarray, (nobs, k_vars*(J-1))</span>
<span class="sd">            The derivative of the loglikelihood for each observation evaluated</span>
<span class="sd">            at `params` .</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        .. math:: \\frac{\\partial\\ln L_{i}}{\\partial\\beta_{j}}=\\left(d_{ij}-\\frac{\\exp\\left(\\beta_{j}^{\\prime}x_{i}\\right)}{\\sum_{k=0}^{J}\\exp\\left(\\beta_{k}^{\\prime}x_{i}\\right)}\\right)x_{i}</span>

<span class="sd">        for :math:`j=1,...,J`, for observations :math:`i=1,...,n`</span>

<span class="sd">        In the multinomial model the score vector is K x (J-1) but is returned</span>
<span class="sd">        as a flattened array. The Jacobian has the observations in rows and</span>
<span class="sd">        the flatteded array of derivatives in columns.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">params</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>
        <span class="n">firstterm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wendog</span><span class="p">[:,</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exog</span><span class="p">,</span>
                                                  <span class="n">params</span><span class="p">))[:,</span><span class="mi">1</span><span class="p">:]</span>
        <span class="c1">#NOTE: might need to switch terms if params is reshaped</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">firstterm</span><span class="p">[:,:,</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">exog</span><span class="p">[:,</span><span class="kc">None</span><span class="p">,:])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exog</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span></div>

    <span class="n">jac</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deprecate</span><span class="p">(</span><span class="n">score_obs</span><span class="p">,</span> <span class="s1">&#39;jac&#39;</span><span class="p">,</span> <span class="s1">&#39;score_obs&#39;</span><span class="p">,</span> <span class="s2">&quot;Use score_obs method.&quot;</span>
                       <span class="s2">&quot; jac will be removed in 0.7&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="MNLogit.hessian"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.MNLogit.hessian.html#statsmodels.discrete.discrete_model.MNLogit.hessian">[docs]</a>    <span class="k">def</span> <span class="nf">hessian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Multinomial logit Hessian matrix of the log-likelihood</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        params : array-like</span>
<span class="sd">            The parameters of the model</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        hess : ndarray, (J*K, J*K)</span>
<span class="sd">            The Hessian, second derivative of loglikelihood function with</span>
<span class="sd">            respect to the flattened parameters, evaluated at `params`</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        .. math:: \\frac{\\partial^{2}\\ln L}{\\partial\\beta_{j}\\partial\\beta_{l}}=-\\sum_{i=1}^{n}\\frac{\\exp\\left(\\beta_{j}^{\\prime}x_{i}\\right)}{\\sum_{k=0}^{J}\\exp\\left(\\beta_{k}^{\\prime}x_{i}\\right)}\\left[\\boldsymbol{1}\\left(j=l\\right)-\\frac{\\exp\\left(\\beta_{l}^{\\prime}x_{i}\\right)}{\\sum_{k=0}^{J}\\exp\\left(\\beta_{k}^{\\prime}x_{i}\\right)}\\right]x_{i}x_{l}^{\\prime}</span>

<span class="sd">        where</span>
<span class="sd">        :math:`\\boldsymbol{1}\\left(j=l\\right)` equals 1 if `j` = `l` and 0</span>
<span class="sd">        otherwise.</span>

<span class="sd">        The actual Hessian matrix has J**2 * K x K elements. Our Hessian</span>
<span class="sd">        is reshaped to be square (J*K, J*K) so that the solvers can use it.</span>

<span class="sd">        This implementation does not take advantage of the symmetry of</span>
<span class="sd">        the Hessian and could probably be refactored for speed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">params</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>
        <span class="n">X</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exog</span>
        <span class="n">pr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">params</span><span class="p">))</span>
        <span class="n">partials</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">J</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wendog</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">K</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exog</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">J</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">J</span><span class="p">):</span> <span class="c1"># this loop assumes we drop the first col.</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">:</span>
                    <span class="n">partials</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>\
                        <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(((</span><span class="n">pr</span><span class="p">[:,</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">pr</span><span class="p">[:,</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]))[:,</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="n">X</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">X</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">partials</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(((</span><span class="n">pr</span><span class="p">[:,</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">*-</span><span class="n">pr</span><span class="p">[:,</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">])[:,</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="n">X</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">X</span><span class="p">))</span>
        <span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">partials</span><span class="p">)</span>
        <span class="c1"># the developer&#39;s notes on multinomial should clear this math up</span>
        <span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">J</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">K</span><span class="p">,</span><span class="n">K</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">J</span><span class="o">*</span><span class="n">K</span><span class="p">,</span><span class="n">J</span><span class="o">*</span><span class="n">K</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">H</span></div></div>


<span class="c1">#TODO: Weibull can replaced by a survival analsysis function</span>
<span class="c1"># like stat&#39;s streg (The cox model as well)</span>
<span class="c1">#class Weibull(DiscreteModel):</span>
<span class="c1">#    &quot;&quot;&quot;</span>
<span class="c1">#    Binary choice Weibull model</span>
<span class="c1">#</span>
<span class="c1">#    Notes</span>
<span class="c1">#    ------</span>
<span class="c1">#    This is unfinished and untested.</span>
<span class="c1">#    &quot;&quot;&quot;</span>
<span class="c1">##TODO: add analytic hessian for Weibull</span>
<span class="c1">#    def initialize(self):</span>
<span class="c1">#        pass</span>
<span class="c1">#</span>
<span class="c1">#    def cdf(self, X):</span>
<span class="c1">#        &quot;&quot;&quot;</span>
<span class="c1">#        Gumbell (Log Weibull) cumulative distribution function</span>
<span class="c1">#        &quot;&quot;&quot;</span>
<span class="c1">##        return np.exp(-np.exp(-X))</span>
<span class="c1">#        return stats.gumbel_r.cdf(X)</span>
<span class="c1">#        # these two are equivalent.</span>
<span class="c1">#        # Greene table and discussion is incorrect.</span>
<span class="c1">#</span>
<span class="c1">#    def pdf(self, X):</span>
<span class="c1">#        &quot;&quot;&quot;</span>
<span class="c1">#        Gumbell (LogWeibull) probability distribution function</span>
<span class="c1">#        &quot;&quot;&quot;</span>
<span class="c1">#        return stats.gumbel_r.pdf(X)</span>
<span class="c1">#</span>
<span class="c1">#    def loglike(self, params):</span>
<span class="c1">#        &quot;&quot;&quot;</span>
<span class="c1">#        Loglikelihood of Weibull distribution</span>
<span class="c1">#        &quot;&quot;&quot;</span>
<span class="c1">#        X = self.exog</span>
<span class="c1">#        cdf = self.cdf(np.dot(X,params))</span>
<span class="c1">#        y = self.endog</span>
<span class="c1">#        return np.sum(y*np.log(cdf) + (1-y)*np.log(1-cdf))</span>
<span class="c1">#</span>
<span class="c1">#    def score(self, params):</span>
<span class="c1">#        y = self.endog</span>
<span class="c1">#        X = self.exog</span>
<span class="c1">#        F = self.cdf(np.dot(X,params))</span>
<span class="c1">#        f = self.pdf(np.dot(X,params))</span>
<span class="c1">#        term = (y*f/F + (1 - y)*-f/(1-F))</span>
<span class="c1">#        return np.dot(term,X)</span>
<span class="c1">#</span>
<span class="c1">#    def hessian(self, params):</span>
<span class="c1">#        hess = nd.Jacobian(self.score)</span>
<span class="c1">#        return hess(params)</span>
<span class="c1">#</span>
<span class="c1">#    def fit(self, start_params=None, method=&#39;newton&#39;, maxiter=35, tol=1e-08):</span>
<span class="c1">## The example had problems with all zero start values, Hessian = 0</span>
<span class="c1">#        if start_params is None:</span>
<span class="c1">#            start_params = OLS(self.endog, self.exog).fit().params</span>
<span class="c1">#        mlefit = super(Weibull, self).fit(start_params=start_params,</span>
<span class="c1">#                method=method, maxiter=maxiter, tol=tol)</span>
<span class="c1">#        return mlefit</span>
<span class="c1">#</span>

<div class="viewcode-block" id="NegativeBinomial"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.NegativeBinomial.html#statsmodels.discrete.discrete_model.NegativeBinomial">[docs]</a><span class="k">class</span> <span class="nc">NegativeBinomial</span><span class="p">(</span><span class="n">CountModel</span><span class="p">):</span>
    <span class="vm">__doc__</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    Negative Binomial Model for count data</span>

<span class="si">%(params)s</span><span class="s2"></span>
<span class="s2">    </span><span class="si">%(extra_params)s</span><span class="s2"></span>

<span class="s2">    Attributes</span>
<span class="s2">    -----------</span>
<span class="s2">    endog : array</span>
<span class="s2">        A reference to the endogenous response variable</span>
<span class="s2">    exog : array</span>
<span class="s2">        A reference to the exogenous design.</span>

<span class="s2">    References</span>
<span class="s2">    ----------</span>

<span class="s2">    References:</span>

<span class="s2">    Greene, W. 2008. &quot;Functional forms for the negtive binomial model</span>
<span class="s2">        for count data&quot;. Economics Letters. Volume 99, Number 3, pp.585-590.</span>
<span class="s2">    Hilbe, J.M. 2011. &quot;Negative binomial regression&quot;. Cambridge University</span>
<span class="s2">        Press.</span>
<span class="s2">    &quot;&quot;&quot;</span> <span class="o">%</span> <span class="p">{</span><span class="s1">&#39;params&#39;</span> <span class="p">:</span> <span class="n">base</span><span class="o">.</span><span class="n">_model_params_doc</span><span class="p">,</span>
           <span class="s1">&#39;extra_params&#39;</span> <span class="p">:</span>
           <span class="sd">&quot;&quot;&quot;loglike_method : string</span>
<span class="sd">        Log-likelihood type. &#39;nb2&#39;,&#39;nb1&#39;, or &#39;geometric&#39;.</span>
<span class="sd">        Fitted value :math:`\\mu`</span>
<span class="sd">        Heterogeneity parameter :math:`\\alpha`</span>

<span class="sd">        - nb2: Variance equal to :math:`\\mu + \\alpha\\mu^2` (most common)</span>
<span class="sd">        - nb1: Variance equal to :math:`\\mu + \\alpha\\mu`</span>
<span class="sd">        - geometric: Variance equal to :math:`\\mu + \\mu^2`</span>
<span class="sd">    offset : array_like</span>
<span class="sd">        Offset is added to the linear prediction with coefficient equal to 1.</span>
<span class="sd">    exposure : array_like</span>
<span class="sd">        Log(exposure) is added to the linear prediction with coefficient</span>
<span class="sd">        equal to 1.</span>

<span class="sd">    &quot;&quot;&quot;</span> <span class="o">+</span> <span class="n">base</span><span class="o">.</span><span class="n">_missing_param_doc</span><span class="p">}</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">endog</span><span class="p">,</span> <span class="n">exog</span><span class="p">,</span> <span class="n">loglike_method</span><span class="o">=</span><span class="s1">&#39;nb2&#39;</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                       <span class="n">exposure</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">missing</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">NegativeBinomial</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">endog</span><span class="p">,</span> <span class="n">exog</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">,</span>
                                               <span class="n">exposure</span><span class="o">=</span><span class="n">exposure</span><span class="p">,</span>
                                               <span class="n">missing</span><span class="o">=</span><span class="n">missing</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loglike_method</span> <span class="o">=</span> <span class="n">loglike_method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initialize</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">loglike_method</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;nb2&#39;</span><span class="p">,</span> <span class="s1">&#39;nb1&#39;</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">exog_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;alpha&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">k_extra</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">k_extra</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># store keys for extras if we need to recreate model instance</span>
        <span class="c1"># we need to append keys that don&#39;t go to super</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_init_keys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;loglike_method&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_initialize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">loglike_method</span> <span class="o">==</span> <span class="s1">&#39;nb2&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">hessian</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hessian_nb2</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">score</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_score_nbin</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">loglikeobs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_nb2</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_transparams</span> <span class="o">=</span> <span class="kc">True</span> <span class="c1"># transform lnalpha -&gt; alpha in fit</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">loglike_method</span> <span class="o">==</span> <span class="s1">&#39;nb1&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">hessian</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hessian_nb1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">score</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_score_nb1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">loglikeobs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_nb1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_transparams</span> <span class="o">=</span> <span class="kc">True</span> <span class="c1"># transform lnalpha -&gt; alpha in fit</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">loglike_method</span> <span class="o">==</span> <span class="s1">&#39;geometric&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">hessian</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hessian_geom</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">score</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_score_geom</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">loglikeobs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_geometric</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Likelihood type must nb1, nb2 or &quot;</span>
                                      <span class="s2">&quot;geometric&quot;</span><span class="p">)</span>

    <span class="c1"># Workaround to pickle instance methods</span>
    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">odict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="c1"># copy the dict since we change it</span>
        <span class="k">del</span> <span class="n">odict</span><span class="p">[</span><span class="s1">&#39;hessian&#39;</span><span class="p">]</span>
        <span class="k">del</span> <span class="n">odict</span><span class="p">[</span><span class="s1">&#39;score&#39;</span><span class="p">]</span>
        <span class="k">del</span> <span class="n">odict</span><span class="p">[</span><span class="s1">&#39;loglikeobs&#39;</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">odict</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indict</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">indict</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initialize</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_ll_nbin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">Q</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="n">endog</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">endog</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
        <span class="n">size</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">alpha</span> <span class="o">*</span> <span class="n">mu</span><span class="o">**</span><span class="n">Q</span>
        <span class="n">prob</span> <span class="o">=</span> <span class="n">size</span><span class="o">/</span><span class="p">(</span><span class="n">size</span><span class="o">+</span><span class="n">mu</span><span class="p">)</span>
        <span class="n">coeff</span> <span class="o">=</span> <span class="p">(</span><span class="n">gammaln</span><span class="p">(</span><span class="n">size</span><span class="o">+</span><span class="n">endog</span><span class="p">)</span> <span class="o">-</span> <span class="n">gammaln</span><span class="p">(</span><span class="n">endog</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span>
                 <span class="n">gammaln</span><span class="p">(</span><span class="n">size</span><span class="p">))</span>
        <span class="n">llf</span> <span class="o">=</span> <span class="n">coeff</span> <span class="o">+</span> <span class="n">size</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">prob</span><span class="p">)</span> <span class="o">+</span> <span class="n">endog</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">prob</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">llf</span>

    <span class="k">def</span> <span class="nf">_ll_nb2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transparams</span><span class="p">:</span> <span class="c1"># got lnalpha during fit</span>
            <span class="n">alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">alpha</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_nbin</span><span class="p">(</span><span class="n">params</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">Q</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_ll_nb1</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transparams</span><span class="p">:</span> <span class="c1"># got lnalpha during fit</span>
            <span class="n">alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">alpha</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_nbin</span><span class="p">(</span><span class="n">params</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">Q</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_ll_geometric</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="c1"># we give alpha of 1 because it&#39;s actually log(alpha) where alpha=0</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_nbin</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

<div class="viewcode-block" id="NegativeBinomial.loglike"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.NegativeBinomial.loglike.html#statsmodels.discrete.discrete_model.NegativeBinomial.loglike">[docs]</a>    <span class="k">def</span> <span class="nf">loglike</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Loglikelihood for negative binomial model</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array-like</span>
<span class="sd">            The parameters of the model. If `loglike_method` is nb1 or</span>
<span class="sd">            nb2, then the ancillary parameter is expected to be the</span>
<span class="sd">            last element.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        llf : float</span>
<span class="sd">            The loglikelihood value at `params`</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Following notation in Greene (2008), with negative binomial</span>
<span class="sd">        heterogeneity parameter :math:`\alpha`:</span>

<span class="sd">        .. math::</span>

<span class="sd">           \lambda_i &amp;= exp(X\beta) \\</span>
<span class="sd">           \theta &amp;= 1 / \alpha \\</span>
<span class="sd">           g_i &amp;= \theta \lambda_i^Q \\</span>
<span class="sd">           w_i &amp;= g_i/(g_i + \lambda_i) \\</span>
<span class="sd">           r_i &amp;= \theta / (\theta+\lambda_i) \\</span>
<span class="sd">           ln \mathcal{L}_i &amp;= ln \Gamma(y_i+g_i) - ln \Gamma(1+y_i) + g_iln (r_i) + y_i ln(1-r_i)</span>

<span class="sd">        where :math`Q=0` for NB2 and geometric and :math:`Q=1` for NB1.</span>
<span class="sd">        For the geometric, :math:`\alpha=0` as well.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">llf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loglikeobs</span><span class="p">(</span><span class="n">params</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">llf</span></div>

    <span class="k">def</span> <span class="nf">_score_geom</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="n">exog</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exog</span>
        <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">endog</span><span class="p">[:,</span><span class="kc">None</span><span class="p">]</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">params</span><span class="p">)[:,</span><span class="kc">None</span><span class="p">]</span>
        <span class="n">dparams</span> <span class="o">=</span> <span class="n">exog</span> <span class="o">*</span> <span class="p">(</span><span class="n">y</span><span class="o">-</span><span class="n">mu</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">mu</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dparams</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_score_nbin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">Q</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Score vector for NB2 model</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transparams</span><span class="p">:</span> <span class="c1"># lnalpha came in during fit</span>
            <span class="n">alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">alpha</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">params</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">exog</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exog</span>
        <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">endog</span><span class="p">[:,</span><span class="kc">None</span><span class="p">]</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">params</span><span class="p">)[:,</span><span class="kc">None</span><span class="p">]</span>
        <span class="n">a1</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">alpha</span> <span class="o">*</span> <span class="n">mu</span><span class="o">**</span><span class="n">Q</span>
        <span class="k">if</span> <span class="n">Q</span><span class="p">:</span> <span class="c1"># nb1</span>
            <span class="n">dparams</span> <span class="o">=</span> <span class="n">exog</span><span class="o">*</span><span class="n">mu</span><span class="o">/</span><span class="n">alpha</span><span class="o">*</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">alpha</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="o">+</span>
                       <span class="n">special</span><span class="o">.</span><span class="n">digamma</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">mu</span><span class="o">/</span><span class="n">alpha</span><span class="p">)</span> <span class="o">-</span>
                       <span class="n">special</span><span class="o">.</span><span class="n">digamma</span><span class="p">(</span><span class="n">mu</span><span class="o">/</span><span class="n">alpha</span><span class="p">))</span>
            <span class="n">dalpha</span> <span class="o">=</span> <span class="p">((</span><span class="n">alpha</span><span class="o">*</span><span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">mu</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">alpha</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="o">-</span>
                              <span class="n">mu</span><span class="o">*</span><span class="p">(</span><span class="n">special</span><span class="o">.</span><span class="n">digamma</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">mu</span><span class="o">/</span><span class="n">alpha</span><span class="p">)</span> <span class="o">-</span>
                              <span class="n">special</span><span class="o">.</span><span class="n">digamma</span><span class="p">(</span><span class="n">mu</span><span class="o">/</span><span class="n">alpha</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="o">-</span>
                       <span class="n">mu</span><span class="o">*</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">alpha</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="o">+</span>
                           <span class="n">special</span><span class="o">.</span><span class="n">digamma</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">mu</span><span class="o">/</span><span class="n">alpha</span><span class="p">)</span> <span class="o">-</span>
                           <span class="n">special</span><span class="o">.</span><span class="n">digamma</span><span class="p">(</span><span class="n">mu</span><span class="o">/</span><span class="n">alpha</span><span class="p">)))</span><span class="o">/</span>
                       <span class="p">(</span><span class="n">alpha</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">alpha</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

        <span class="k">else</span><span class="p">:</span> <span class="c1"># nb2</span>
            <span class="n">dparams</span> <span class="o">=</span> <span class="n">exog</span><span class="o">*</span><span class="n">a1</span> <span class="o">*</span> <span class="p">(</span><span class="n">y</span><span class="o">-</span><span class="n">mu</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">mu</span><span class="o">+</span><span class="n">a1</span><span class="p">)</span>
            <span class="n">da1</span> <span class="o">=</span> <span class="o">-</span><span class="n">alpha</span><span class="o">**-</span><span class="mi">2</span>
            <span class="n">dalpha</span> <span class="o">=</span> <span class="p">(</span><span class="n">special</span><span class="o">.</span><span class="n">digamma</span><span class="p">(</span><span class="n">a1</span><span class="o">+</span><span class="n">y</span><span class="p">)</span> <span class="o">-</span> <span class="n">special</span><span class="o">.</span><span class="n">digamma</span><span class="p">(</span><span class="n">a1</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">a1</span><span class="p">)</span>
                        <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">a1</span><span class="o">+</span><span class="n">mu</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">a1</span><span class="o">+</span><span class="n">y</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">a1</span><span class="o">+</span><span class="n">mu</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">*</span><span class="n">da1</span>

        <span class="c1">#multiply above by constant outside sum to reduce rounding error</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transparams</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">dparams</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">dalpha</span><span class="o">*</span><span class="n">alpha</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">dparams</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">dalpha</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_score_nb1</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_score_nbin</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">Q</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_hessian_geom</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="n">exog</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exog</span>
        <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">endog</span><span class="p">[:,</span><span class="kc">None</span><span class="p">]</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">params</span><span class="p">)[:,</span><span class="kc">None</span><span class="p">]</span>

        <span class="c1"># for dl/dparams dparams</span>
        <span class="n">dim</span> <span class="o">=</span> <span class="n">exog</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">hess_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">dim</span><span class="p">,</span> <span class="n">dim</span><span class="p">))</span>
        <span class="n">const_arr</span> <span class="o">=</span> <span class="n">mu</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">y</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">mu</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="n">i</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">hess_arr</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">-</span><span class="n">exog</span><span class="p">[:,</span><span class="n">i</span><span class="p">,</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">exog</span><span class="p">[:,</span><span class="n">j</span><span class="p">,</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span>
                                       <span class="n">const_arr</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">tri_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">triu_indices</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">hess_arr</span><span class="p">[</span><span class="n">tri_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">hess_arr</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="n">tri_idx</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">hess_arr</span>


    <span class="k">def</span> <span class="nf">_hessian_nb1</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Hessian of NB1 model.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transparams</span><span class="p">:</span> <span class="c1"># lnalpha came in during fit</span>
            <span class="n">alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">alpha</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">params</span> <span class="o">=</span> <span class="n">params</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">exog</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exog</span>
        <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">endog</span><span class="p">[:,</span><span class="kc">None</span><span class="p">]</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">params</span><span class="p">)[:,</span><span class="kc">None</span><span class="p">]</span>

        <span class="n">a1</span> <span class="o">=</span> <span class="n">mu</span><span class="o">/</span><span class="n">alpha</span>

        <span class="c1"># for dl/dparams dparams</span>
        <span class="n">dim</span> <span class="o">=</span> <span class="n">exog</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">hess_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">dim</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">dim</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
        <span class="c1">#const_arr = a1*mu*(a1+y)/(mu+a1)**2</span>
        <span class="c1"># not all of dparams</span>
        <span class="n">dparams</span> <span class="o">=</span> <span class="n">exog</span><span class="o">/</span><span class="n">alpha</span><span class="o">*</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">alpha</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="o">+</span>
                              <span class="n">special</span><span class="o">.</span><span class="n">digamma</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">mu</span><span class="o">/</span><span class="n">alpha</span><span class="p">)</span> <span class="o">-</span>
                              <span class="n">special</span><span class="o">.</span><span class="n">digamma</span><span class="p">(</span><span class="n">mu</span><span class="o">/</span><span class="n">alpha</span><span class="p">))</span>

        <span class="n">dmudb</span> <span class="o">=</span> <span class="n">exog</span><span class="o">*</span><span class="n">mu</span>
        <span class="n">xmu_alpha</span> <span class="o">=</span> <span class="n">exog</span><span class="o">*</span><span class="n">mu</span><span class="o">/</span><span class="n">alpha</span>
        <span class="n">trigamma</span> <span class="o">=</span> <span class="p">(</span><span class="n">special</span><span class="o">.</span><span class="n">polygamma</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">mu</span><span class="o">/</span><span class="n">alpha</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span> <span class="o">-</span>
                    <span class="n">special</span><span class="o">.</span><span class="n">polygamma</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">mu</span><span class="o">/</span><span class="n">alpha</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="n">i</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">hess_arr</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dparams</span><span class="p">[:,</span><span class="n">i</span><span class="p">,</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">dmudb</span><span class="p">[:,</span><span class="n">j</span><span class="p">,</span><span class="kc">None</span><span class="p">]</span> <span class="o">+</span>
                                 <span class="n">xmu_alpha</span><span class="p">[:,</span><span class="n">i</span><span class="p">,</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">xmu_alpha</span><span class="p">[:,</span><span class="n">j</span><span class="p">,</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span>
                                 <span class="n">trigamma</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">tri_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">triu_indices</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">hess_arr</span><span class="p">[</span><span class="n">tri_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">hess_arr</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="n">tri_idx</span><span class="p">]</span>

        <span class="c1"># for dl/dparams dalpha</span>
        <span class="n">da1</span> <span class="o">=</span> <span class="o">-</span><span class="n">alpha</span><span class="o">**-</span><span class="mi">2</span>
        <span class="n">dldpda</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">-</span><span class="n">mu</span><span class="o">/</span><span class="n">alpha</span> <span class="o">*</span> <span class="n">dparams</span> <span class="o">+</span> <span class="n">exog</span><span class="o">*</span><span class="n">mu</span><span class="o">/</span><span class="n">alpha</span> <span class="o">*</span>
                        <span class="p">(</span><span class="o">-</span><span class="n">trigamma</span><span class="o">*</span><span class="n">mu</span><span class="o">/</span><span class="n">alpha</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">alpha</span><span class="o">+</span><span class="mi">1</span><span class="p">)),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="n">hess_arr</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">dldpda</span>
        <span class="n">hess_arr</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">dldpda</span>

        <span class="c1"># for dl/dalpha dalpha</span>
        <span class="n">digamma_part</span> <span class="o">=</span> <span class="p">(</span><span class="n">special</span><span class="o">.</span><span class="n">digamma</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">mu</span><span class="o">/</span><span class="n">alpha</span><span class="p">)</span> <span class="o">-</span>
                        <span class="n">special</span><span class="o">.</span><span class="n">digamma</span><span class="p">(</span><span class="n">mu</span><span class="o">/</span><span class="n">alpha</span><span class="p">))</span>

        <span class="n">log_alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">alpha</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">alpha3</span> <span class="o">=</span> <span class="n">alpha</span><span class="o">**</span><span class="mi">3</span>
        <span class="n">alpha2</span> <span class="o">=</span> <span class="n">alpha</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">mu2</span> <span class="o">=</span> <span class="n">mu</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">dada</span> <span class="o">=</span> <span class="p">((</span><span class="n">alpha3</span><span class="o">*</span><span class="n">mu</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">log_alpha</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">digamma_part</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span> <span class="o">-</span>
                <span class="mi">2</span><span class="o">*</span><span class="n">alpha3</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="n">alpha2</span><span class="o">*</span><span class="n">mu2</span><span class="o">*</span><span class="n">trigamma</span> <span class="o">+</span>
                <span class="mi">4</span><span class="o">*</span><span class="n">alpha2</span><span class="o">*</span><span class="n">mu</span><span class="o">*</span><span class="p">(</span><span class="n">log_alpha</span> <span class="o">+</span> <span class="n">digamma_part</span><span class="p">)</span> <span class="o">+</span>
                <span class="n">alpha2</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">mu</span> <span class="o">-</span> <span class="n">y</span><span class="p">)</span> <span class="o">+</span>
                <span class="mi">2</span><span class="o">*</span><span class="n">alpha</span><span class="o">*</span><span class="n">mu2</span><span class="o">*</span><span class="n">trigamma</span> <span class="o">+</span>
                <span class="mi">2</span><span class="o">*</span><span class="n">alpha</span><span class="o">*</span><span class="n">mu</span><span class="o">*</span><span class="p">(</span><span class="n">log_alpha</span> <span class="o">+</span> <span class="n">digamma_part</span><span class="p">)</span> <span class="o">+</span>
                <span class="n">mu2</span><span class="o">*</span><span class="n">trigamma</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">alpha</span><span class="o">**</span><span class="mi">4</span><span class="o">*</span><span class="p">(</span><span class="n">alpha2</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">alpha</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span>
        <span class="n">hess_arr</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">dada</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">hess_arr</span>

    <span class="k">def</span> <span class="nf">_hessian_nb2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Hessian of NB2 model.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transparams</span><span class="p">:</span> <span class="c1"># lnalpha came in during fit</span>
            <span class="n">alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">alpha</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">a1</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">alpha</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">params</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">exog</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exog</span>
        <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">endog</span><span class="p">[:,</span><span class="kc">None</span><span class="p">]</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">params</span><span class="p">)[:,</span><span class="kc">None</span><span class="p">]</span>

        <span class="c1"># for dl/dparams dparams</span>
        <span class="n">dim</span> <span class="o">=</span> <span class="n">exog</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">hess_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">dim</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">dim</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">const_arr</span> <span class="o">=</span> <span class="n">a1</span><span class="o">*</span><span class="n">mu</span><span class="o">*</span><span class="p">(</span><span class="n">a1</span><span class="o">+</span><span class="n">y</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">mu</span><span class="o">+</span><span class="n">a1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="n">i</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">hess_arr</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">-</span><span class="n">exog</span><span class="p">[:,</span><span class="n">i</span><span class="p">,</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">exog</span><span class="p">[:,</span><span class="n">j</span><span class="p">,</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span>
                                       <span class="n">const_arr</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">tri_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">triu_indices</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">hess_arr</span><span class="p">[</span><span class="n">tri_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">hess_arr</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="n">tri_idx</span><span class="p">]</span>

        <span class="c1"># for dl/dparams dalpha</span>
        <span class="n">da1</span> <span class="o">=</span> <span class="o">-</span><span class="n">alpha</span><span class="o">**-</span><span class="mi">2</span>
        <span class="n">dldpda</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">mu</span><span class="o">*</span><span class="n">exog</span><span class="o">*</span><span class="p">(</span><span class="n">y</span><span class="o">-</span><span class="n">mu</span><span class="p">)</span><span class="o">*</span><span class="n">da1</span><span class="o">/</span><span class="p">(</span><span class="n">mu</span><span class="o">+</span><span class="n">a1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">hess_arr</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">dldpda</span>
        <span class="n">hess_arr</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">dldpda</span>

        <span class="c1"># for dl/dalpha dalpha</span>
        <span class="c1">#NOTE: polygamma(1,x) is the trigamma function</span>
        <span class="n">da2</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">alpha</span><span class="o">**-</span><span class="mi">3</span>
        <span class="n">dalpha</span> <span class="o">=</span> <span class="n">da1</span> <span class="o">*</span> <span class="p">(</span><span class="n">special</span><span class="o">.</span><span class="n">digamma</span><span class="p">(</span><span class="n">a1</span><span class="o">+</span><span class="n">y</span><span class="p">)</span> <span class="o">-</span> <span class="n">special</span><span class="o">.</span><span class="n">digamma</span><span class="p">(</span><span class="n">a1</span><span class="p">)</span> <span class="o">+</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">a1</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">a1</span><span class="o">+</span><span class="n">mu</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">a1</span><span class="o">+</span><span class="n">y</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">a1</span><span class="o">+</span><span class="n">mu</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">dada</span> <span class="o">=</span> <span class="p">(</span><span class="n">da2</span> <span class="o">*</span> <span class="n">dalpha</span><span class="o">/</span><span class="n">da1</span> <span class="o">+</span> <span class="n">da1</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">special</span><span class="o">.</span><span class="n">polygamma</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">a1</span><span class="o">+</span><span class="n">y</span><span class="p">)</span> <span class="o">-</span>
                    <span class="n">special</span><span class="o">.</span><span class="n">polygamma</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">a1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">/</span><span class="n">a1</span> <span class="o">-</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">a1</span> <span class="o">+</span> <span class="n">mu</span><span class="p">)</span> <span class="o">+</span>
                    <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">mu</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">mu</span> <span class="o">+</span> <span class="n">a1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">hess_arr</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">dada</span>

        <span class="k">return</span> <span class="n">hess_arr</span>

    <span class="c1">#TODO: replace this with analytic where is it used?</span>
<div class="viewcode-block" id="NegativeBinomial.score_obs"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.NegativeBinomial.score_obs.html#statsmodels.discrete.discrete_model.NegativeBinomial.score_obs">[docs]</a>    <span class="k">def</span> <span class="nf">score_obs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="n">sc</span> <span class="o">=</span> <span class="n">approx_fprime_cs</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">loglikeobs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">sc</span></div>

    <span class="n">jac</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deprecate</span><span class="p">(</span><span class="n">score_obs</span><span class="p">,</span> <span class="s1">&#39;jac&#39;</span><span class="p">,</span> <span class="s1">&#39;score_obs&#39;</span><span class="p">,</span> <span class="s2">&quot;Use score_obs method.&quot;</span>
                       <span class="s2">&quot; jac will be removed in 0.7&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="NegativeBinomial.fit"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.NegativeBinomial.fit.html#statsmodels.discrete.discrete_model.NegativeBinomial.fit">[docs]</a>    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;bfgs&#39;</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="mi">35</span><span class="p">,</span>
            <span class="n">full_output</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">disp</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">cov_type</span><span class="o">=</span><span class="s1">&#39;nonrobust&#39;</span><span class="p">,</span> <span class="n">cov_kwds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">use_t</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

        <span class="c1"># Note: don&#39;t let super handle robust covariance because it has</span>
        <span class="c1"># transformed params</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">loglike_method</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;nb&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">method</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;newton&#39;</span><span class="p">,</span>
                                                                   <span class="s1">&#39;ncg&#39;</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_transparams</span> <span class="o">=</span> <span class="kc">True</span> <span class="c1"># in case same Model instance is refit</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">loglike_method</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;nb&#39;</span><span class="p">):</span> <span class="c1"># method is newton/ncg</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_transparams</span> <span class="o">=</span> <span class="kc">False</span> <span class="c1"># because we need to step in alpha space</span>

        <span class="k">if</span> <span class="n">start_params</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Use poisson fit as first guess.</span>
            <span class="c1">#TODO, Warning: this assumes exposure is logged</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;offset&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;exposure&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">offset</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">offset</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">offset</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">mod_poi</span> <span class="o">=</span> <span class="n">Poisson</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endog</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">exog</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">)</span>
            <span class="n">start_params</span> <span class="o">=</span> <span class="n">mod_poi</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">disp</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">params</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">loglike_method</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;nb&#39;</span><span class="p">):</span>
                <span class="n">start_params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">start_params</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)</span>
        <span class="n">mlefit</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">NegativeBinomial</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">start_params</span><span class="o">=</span><span class="n">start_params</span><span class="p">,</span>
                        <span class="n">maxiter</span><span class="o">=</span><span class="n">maxiter</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">disp</span><span class="o">=</span><span class="n">disp</span><span class="p">,</span>
                        <span class="n">full_output</span><span class="o">=</span><span class="n">full_output</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span><span class="n">x</span><span class="p">,</span>
                        <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                        <span class="c1"># TODO: Fix NBin _check_perfect_pred</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">loglike_method</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;nb&#39;</span><span class="p">):</span>
            <span class="c1"># mlefit is a wrapped counts results</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_transparams</span> <span class="o">=</span> <span class="kc">False</span> <span class="c1"># don&#39;t need to transform anymore now</span>
            <span class="c1"># change from lnalpha to alpha</span>
            <span class="k">if</span> <span class="n">method</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;newton&quot;</span><span class="p">,</span> <span class="s2">&quot;ncg&quot;</span><span class="p">]:</span>
                <span class="n">mlefit</span><span class="o">.</span><span class="n">_results</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mlefit</span><span class="o">.</span><span class="n">_results</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

            <span class="n">nbinfit</span> <span class="o">=</span> <span class="n">NegativeBinomialResults</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mlefit</span><span class="o">.</span><span class="n">_results</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">NegativeBinomialResultsWrapper</span><span class="p">(</span><span class="n">nbinfit</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">mlefit</span>

        <span class="k">if</span> <span class="n">cov_kwds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cov_kwds</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1">#TODO: make this unnecessary ?</span>
        <span class="n">result</span><span class="o">.</span><span class="n">_get_robustcov_results</span><span class="p">(</span><span class="n">cov_type</span><span class="o">=</span><span class="n">cov_type</span><span class="p">,</span>
                                    <span class="n">use_self</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">use_t</span><span class="o">=</span><span class="n">use_t</span><span class="p">,</span> <span class="o">**</span><span class="n">cov_kwds</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="NegativeBinomial.fit_regularized"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.NegativeBinomial.fit_regularized.html#statsmodels.discrete.discrete_model.NegativeBinomial.fit_regularized">[docs]</a>    <span class="k">def</span> <span class="nf">fit_regularized</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;l1&#39;</span><span class="p">,</span>
            <span class="n">maxiter</span><span class="o">=</span><span class="s1">&#39;defined_by_method&#39;</span><span class="p">,</span> <span class="n">full_output</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">disp</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">alpha</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">trim_mode</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="n">auto_trim_tol</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">size_trim_tol</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">,</span>
            <span class="n">qc_tol</span><span class="o">=</span><span class="mf">0.03</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">loglike_method</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;nb&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span>
                                                     <span class="n">alpha</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">):</span>
            <span class="c1"># don&#39;t penalize alpha if alpha is scalar</span>
            <span class="n">k_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exog</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_extra</span>
            <span class="n">alpha</span> <span class="o">=</span> <span class="n">alpha</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">k_params</span><span class="p">)</span>
            <span class="n">alpha</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># alpha for regularized poisson to get starting values</span>
        <span class="n">alpha_p</span> <span class="o">=</span> <span class="n">alpha</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_extra</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="k">else</span> <span class="n">alpha</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_transparams</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">start_params</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Use poisson fit as first guess.</span>
            <span class="c1">#TODO, Warning: this assumes exposure is logged</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;offset&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;exposure&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">offset</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">offset</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">offset</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">mod_poi</span> <span class="o">=</span> <span class="n">Poisson</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endog</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">exog</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">)</span>
            <span class="n">start_params</span> <span class="o">=</span> <span class="n">mod_poi</span><span class="o">.</span><span class="n">fit_regularized</span><span class="p">(</span>
                <span class="n">start_params</span><span class="o">=</span><span class="n">start_params</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="n">maxiter</span><span class="p">,</span>
                <span class="n">full_output</span><span class="o">=</span><span class="n">full_output</span><span class="p">,</span> <span class="n">disp</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="n">callback</span><span class="p">,</span>
                <span class="n">alpha</span><span class="o">=</span><span class="n">alpha_p</span><span class="p">,</span> <span class="n">trim_mode</span><span class="o">=</span><span class="n">trim_mode</span><span class="p">,</span> <span class="n">auto_trim_tol</span><span class="o">=</span><span class="n">auto_trim_tol</span><span class="p">,</span>
                <span class="n">size_trim_tol</span><span class="o">=</span><span class="n">size_trim_tol</span><span class="p">,</span> <span class="n">qc_tol</span><span class="o">=</span><span class="n">qc_tol</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">.</span><span class="n">params</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">loglike_method</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;nb&#39;</span><span class="p">):</span>
                <span class="n">start_params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">start_params</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)</span>

        <span class="n">cntfit</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">CountModel</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">fit_regularized</span><span class="p">(</span>
                <span class="n">start_params</span><span class="o">=</span><span class="n">start_params</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="n">maxiter</span><span class="p">,</span>
                <span class="n">full_output</span><span class="o">=</span><span class="n">full_output</span><span class="p">,</span> <span class="n">disp</span><span class="o">=</span><span class="n">disp</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="n">callback</span><span class="p">,</span>
                <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">trim_mode</span><span class="o">=</span><span class="n">trim_mode</span><span class="p">,</span> <span class="n">auto_trim_tol</span><span class="o">=</span><span class="n">auto_trim_tol</span><span class="p">,</span>
                <span class="n">size_trim_tol</span><span class="o">=</span><span class="n">size_trim_tol</span><span class="p">,</span> <span class="n">qc_tol</span><span class="o">=</span><span class="n">qc_tol</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">method</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;l1&#39;</span><span class="p">,</span> <span class="s1">&#39;l1_cvxopt_cp&#39;</span><span class="p">]:</span>
            <span class="n">discretefit</span> <span class="o">=</span> <span class="n">L1NegativeBinomialResults</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cntfit</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                    <span class="s2">&quot;argument method == </span><span class="si">%s</span><span class="s2">, which is not handled&quot;</span> <span class="o">%</span> <span class="n">method</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">L1NegativeBinomialResultsWrapper</span><span class="p">(</span><span class="n">discretefit</span><span class="p">)</span></div></div>


<span class="c1">### Results Class ###</span>

<div class="viewcode-block" id="DiscreteResults"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.DiscreteResults.html#statsmodels.discrete.discrete_model.DiscreteResults">[docs]</a><span class="k">class</span> <span class="nc">DiscreteResults</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="n">LikelihoodModelResults</span><span class="p">):</span>
    <span class="vm">__doc__</span> <span class="o">=</span> <span class="n">_discrete_results_docs</span> <span class="o">%</span> <span class="p">{</span><span class="s2">&quot;one_line_description&quot;</span> <span class="p">:</span>
        <span class="s2">&quot;A results class for the discrete dependent variable models.&quot;</span><span class="p">,</span>
        <span class="s2">&quot;extra_attr&quot;</span> <span class="p">:</span> <span class="s2">&quot;&quot;</span><span class="p">}</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">mlefit</span><span class="p">,</span> <span class="n">cov_type</span><span class="o">=</span><span class="s1">&#39;nonrobust&#39;</span><span class="p">,</span> <span class="n">cov_kwds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">use_t</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1">#super(DiscreteResults, self).__init__(model, params,</span>
        <span class="c1">#        np.linalg.inv(-hessian), scale=1.)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">df_model</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">df_model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">df_resid</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">df_resid</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span> <span class="o">=</span> <span class="n">resettable_cache</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">exog</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">mlefit</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;cov_type&#39;</span><span class="p">):</span>
            <span class="c1"># do this only if super, i.e. mlefit didn&#39;t already add cov_type</span>
            <span class="c1"># robust covariance</span>
            <span class="k">if</span> <span class="n">use_t</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">use_t</span> <span class="o">=</span> <span class="n">use_t</span>
            <span class="k">if</span> <span class="n">cov_type</span> <span class="o">==</span> <span class="s1">&#39;nonrobust&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cov_type</span> <span class="o">=</span> <span class="s1">&#39;nonrobust&#39;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cov_kwds</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;description&#39;</span> <span class="p">:</span> <span class="s1">&#39;Standard Errors assume that the &#39;</span> <span class="o">+</span>
                                 <span class="s1">&#39;covariance matrix of the errors is correctly &#39;</span> <span class="o">+</span>
                                 <span class="s1">&#39;specified.&#39;</span><span class="p">}</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">cov_kwds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">cov_kwds</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="kn">from</span> <span class="nn">statsmodels.base.covtype</span> <span class="k">import</span> <span class="n">get_robustcov_results</span>
                <span class="n">get_robustcov_results</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cov_type</span><span class="o">=</span><span class="n">cov_type</span><span class="p">,</span> <span class="n">use_self</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                           <span class="o">**</span><span class="n">cov_kwds</span><span class="p">)</span>



    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1">#remove unpicklable callback</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mle_settings</span><span class="p">[</span><span class="s1">&#39;callback&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">AttributeError</span><span class="p">,</span> <span class="ne">KeyError</span><span class="p">):</span>
            <span class="k">pass</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span>

    <span class="nd">@cache_readonly</span>
<div class="viewcode-block" id="DiscreteResults.prsquared"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.DiscreteResults.prsquared.html#statsmodels.discrete.discrete_model.DiscreteResults.prsquared">[docs]</a>    <span class="k">def</span> <span class="nf">prsquared</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="mi">1</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">llf</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">llnull</span></div>

    <span class="nd">@cache_readonly</span>
<div class="viewcode-block" id="DiscreteResults.llr"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.DiscreteResults.llr.html#statsmodels.discrete.discrete_model.DiscreteResults.llr">[docs]</a>    <span class="k">def</span> <span class="nf">llr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">llnull</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">llf</span><span class="p">)</span></div>

    <span class="nd">@cache_readonly</span>
<div class="viewcode-block" id="DiscreteResults.llr_pvalue"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.DiscreteResults.llr_pvalue.html#statsmodels.discrete.discrete_model.DiscreteResults.llr_pvalue">[docs]</a>    <span class="k">def</span> <span class="nf">llr_pvalue</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">stats</span><span class="o">.</span><span class="n">chisqprob</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">llr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">df_model</span><span class="p">)</span></div>

    <span class="nd">@cache_readonly</span>
<div class="viewcode-block" id="DiscreteResults.llnull"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.DiscreteResults.llnull.html#statsmodels.discrete.discrete_model.DiscreteResults.llnull">[docs]</a>    <span class="k">def</span> <span class="nf">llnull</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="n">model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span>
        <span class="n">kwds</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">_get_init_kwds</span><span class="p">()</span>
        <span class="c1"># TODO: what parameters to pass to fit?</span>
        <span class="n">mod_null</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">endog</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="p">),</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
        <span class="c1"># TODO: consider catching and warning on convergence failure?</span>
        <span class="c1"># in the meantime, try hard to converge. see</span>
        <span class="c1"># TestPoissonConstrained1a.test_smoke</span>
        <span class="n">res_null</span> <span class="o">=</span> <span class="n">mod_null</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">disp</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">warn_convergence</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                <span class="n">maxiter</span><span class="o">=</span><span class="mi">10000</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res_null</span><span class="o">.</span><span class="n">llf</span></div>

    <span class="nd">@cache_readonly</span>
<div class="viewcode-block" id="DiscreteResults.fittedvalues"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.DiscreteResults.fittedvalues.html#statsmodels.discrete.discrete_model.DiscreteResults.fittedvalues">[docs]</a>    <span class="k">def</span> <span class="nf">fittedvalues</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">exog</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">exog</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span></div>

    <span class="nd">@cache_readonly</span>
<div class="viewcode-block" id="DiscreteResults.aic"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.DiscreteResults.aic.html#statsmodels.discrete.discrete_model.DiscreteResults.aic">[docs]</a>    <span class="k">def</span> <span class="nf">aic</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">llf</span> <span class="o">-</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">df_model</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span></div>

    <span class="nd">@cache_readonly</span>
<div class="viewcode-block" id="DiscreteResults.bic"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.DiscreteResults.bic.html#statsmodels.discrete.discrete_model.DiscreteResults.bic">[docs]</a>    <span class="k">def</span> <span class="nf">bic</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">llf</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">df_model</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_get_endog_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">yname</span><span class="p">,</span> <span class="n">yname_list</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">yname</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">yname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">endog_names</span>
        <span class="k">if</span> <span class="n">yname_list</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">yname_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">endog_names</span>
        <span class="k">return</span> <span class="n">yname</span><span class="p">,</span> <span class="n">yname_list</span>

<div class="viewcode-block" id="DiscreteResults.get_margeff"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.DiscreteResults.get_margeff.html#statsmodels.discrete.discrete_model.DiscreteResults.get_margeff">[docs]</a>    <span class="k">def</span> <span class="nf">get_margeff</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">at</span><span class="o">=</span><span class="s1">&#39;overall&#39;</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;dydx&#39;</span><span class="p">,</span> <span class="n">atexog</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">dummy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get marginal effects of the fitted model.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        at : str, optional</span>
<span class="sd">            Options are:</span>

<span class="sd">            - &#39;overall&#39;, The average of the marginal effects at each</span>
<span class="sd">              observation.</span>
<span class="sd">            - &#39;mean&#39;, The marginal effects at the mean of each regressor.</span>
<span class="sd">            - &#39;median&#39;, The marginal effects at the median of each regressor.</span>
<span class="sd">            - &#39;zero&#39;, The marginal effects at zero for each regressor.</span>
<span class="sd">            - &#39;all&#39;, The marginal effects at each observation. If `at` is all</span>
<span class="sd">              only margeff will be available from the returned object.</span>

<span class="sd">            Note that if `exog` is specified, then marginal effects for all</span>
<span class="sd">            variables not specified by `exog` are calculated using the `at`</span>
<span class="sd">            option.</span>
<span class="sd">        method : str, optional</span>
<span class="sd">            Options are:</span>

<span class="sd">            - &#39;dydx&#39; - dy/dx - No transformation is made and marginal effects</span>
<span class="sd">              are returned.  This is the default.</span>
<span class="sd">            - &#39;eyex&#39; - estimate elasticities of variables in `exog` --</span>
<span class="sd">              d(lny)/d(lnx)</span>
<span class="sd">            - &#39;dyex&#39; - estimate semielasticity -- dy/d(lnx)</span>
<span class="sd">            - &#39;eydx&#39; - estimate semeilasticity -- d(lny)/dx</span>

<span class="sd">            Note that tranformations are done after each observation is</span>
<span class="sd">            calculated.  Semi-elasticities for binary variables are computed</span>
<span class="sd">            using the midpoint method. &#39;dyex&#39; and &#39;eyex&#39; do not make sense</span>
<span class="sd">            for discrete variables.</span>
<span class="sd">        atexog : array-like, optional</span>
<span class="sd">            Optionally, you can provide the exogenous variables over which to</span>
<span class="sd">            get the marginal effects.  This should be a dictionary with the key</span>
<span class="sd">            as the zero-indexed column number and the value of the dictionary.</span>
<span class="sd">            Default is None for all independent variables less the constant.</span>
<span class="sd">        dummy : bool, optional</span>
<span class="sd">            If False, treats binary variables (if present) as continuous.  This</span>
<span class="sd">            is the default.  Else if True, treats binary variables as</span>
<span class="sd">            changing from 0 to 1.  Note that any variable that is either 0 or 1</span>
<span class="sd">            is treated as binary.  Each binary variable is treated separately</span>
<span class="sd">            for now.</span>
<span class="sd">        count : bool, optional</span>
<span class="sd">            If False, treats count variables (if present) as continuous.  This</span>
<span class="sd">            is the default.  Else if True, the marginal effect is the</span>
<span class="sd">            change in probabilities when each observation is increased by one.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        DiscreteMargins : marginal effects instance</span>
<span class="sd">            Returns an object that holds the marginal effects, standard</span>
<span class="sd">            errors, confidence intervals, etc. See</span>
<span class="sd">            `statsmodels.discrete.discrete_margins.DiscreteMargins` for more</span>
<span class="sd">            information.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        When using after Poisson, returns the expected number of events</span>
<span class="sd">        per period, assuming that the model is loglinear.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">statsmodels.discrete.discrete_margins</span> <span class="k">import</span> <span class="n">DiscreteMargins</span>
        <span class="k">return</span> <span class="n">DiscreteMargins</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="p">(</span><span class="n">at</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">atexog</span><span class="p">,</span> <span class="n">dummy</span><span class="p">,</span> <span class="n">count</span><span class="p">))</span></div>

<div class="viewcode-block" id="DiscreteResults.summary"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.DiscreteResults.summary.html#statsmodels.discrete.discrete_model.DiscreteResults.summary">[docs]</a>    <span class="k">def</span> <span class="nf">summary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">yname</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">xname</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=.</span><span class="mi">05</span><span class="p">,</span>
                <span class="n">yname_list</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Summarize the Regression Results</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        yname : string, optional</span>
<span class="sd">            Default is `y`</span>
<span class="sd">        xname : list of strings, optional</span>
<span class="sd">            Default is `var_##` for ## in p the number of regressors</span>
<span class="sd">        title : string, optional</span>
<span class="sd">            Title for the top table. If not None, then this replaces the</span>
<span class="sd">            default title</span>
<span class="sd">        alpha : float</span>
<span class="sd">            significance level for the confidence intervals</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        smry : Summary instance</span>
<span class="sd">            this holds the summary tables and text, which can be printed or</span>
<span class="sd">            converted to various output formats.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        statsmodels.iolib.summary.Summary : class to hold summary</span>
<span class="sd">            results</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">top_left</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;Dep. Variable:&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                     <span class="p">(</span><span class="s1">&#39;Model:&#39;</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">]),</span>
                     <span class="p">(</span><span class="s1">&#39;Method:&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;MLE&#39;</span><span class="p">]),</span>
                     <span class="p">(</span><span class="s1">&#39;Date:&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                     <span class="p">(</span><span class="s1">&#39;Time:&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                     <span class="c1">#(&#39;No. iterations:&#39;, [&quot;%d&quot; % self.mle_retvals[&#39;iterations&#39;]]),</span>
                     <span class="p">(</span><span class="s1">&#39;converged:&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">mle_retvals</span><span class="p">[</span><span class="s1">&#39;converged&#39;</span><span class="p">]])</span>
                      <span class="p">]</span>

        <span class="n">top_right</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;No. Observations:&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                     <span class="p">(</span><span class="s1">&#39;Df Residuals:&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                     <span class="p">(</span><span class="s1">&#39;Df Model:&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                     <span class="p">(</span><span class="s1">&#39;Pseudo R-squ.:&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;</span><span class="si">%#6.4g</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">prsquared</span><span class="p">]),</span>
                     <span class="p">(</span><span class="s1">&#39;Log-Likelihood:&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                     <span class="p">(</span><span class="s1">&#39;LL-Null:&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;</span><span class="si">%#8.5g</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">llnull</span><span class="p">]),</span>
                     <span class="p">(</span><span class="s1">&#39;LLR p-value:&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;</span><span class="si">%#6.4g</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">llr_pvalue</span><span class="p">])</span>
                     <span class="p">]</span>

        <span class="k">if</span> <span class="n">title</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">title</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span> <span class="o">+</span> <span class="s2">&quot;Regression Results&quot;</span>

        <span class="c1">#boiler plate</span>
        <span class="kn">from</span> <span class="nn">statsmodels.iolib.summary</span> <span class="k">import</span> <span class="n">Summary</span>
        <span class="n">smry</span> <span class="o">=</span> <span class="n">Summary</span><span class="p">()</span>
        <span class="n">yname</span><span class="p">,</span> <span class="n">yname_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_endog_name</span><span class="p">(</span><span class="n">yname</span><span class="p">,</span> <span class="n">yname_list</span><span class="p">)</span>
        <span class="c1"># for top of table</span>
        <span class="n">smry</span><span class="o">.</span><span class="n">add_table_2cols</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gleft</span><span class="o">=</span><span class="n">top_left</span><span class="p">,</span> <span class="n">gright</span><span class="o">=</span><span class="n">top_right</span><span class="p">,</span> <span class="c1">#[],</span>
                          <span class="n">yname</span><span class="o">=</span><span class="n">yname</span><span class="p">,</span> <span class="n">xname</span><span class="o">=</span><span class="n">xname</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">)</span>
        <span class="c1"># for parameters, etc</span>
        <span class="n">smry</span><span class="o">.</span><span class="n">add_table_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">yname</span><span class="o">=</span><span class="n">yname_list</span><span class="p">,</span> <span class="n">xname</span><span class="o">=</span><span class="n">xname</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span>
                             <span class="n">use_t</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">use_t</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;constraints&#39;</span><span class="p">):</span>
            <span class="n">smry</span><span class="o">.</span><span class="n">add_extra_txt</span><span class="p">([</span><span class="s1">&#39;Model has been estimated subject to linear &#39;</span>
                          <span class="s1">&#39;equality constraints.&#39;</span><span class="p">])</span>

        <span class="c1">#diagnostic table not used yet</span>
        <span class="c1">#smry.add_table_2cols(self, gleft=diagn_left, gright=diagn_right,</span>
        <span class="c1">#                   yname=yname, xname=xname,</span>
        <span class="c1">#                   title=&quot;&quot;)</span>
        <span class="k">return</span> <span class="n">smry</span></div>

<div class="viewcode-block" id="DiscreteResults.summary2"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.DiscreteResults.summary2.html#statsmodels.discrete.discrete_model.DiscreteResults.summary2">[docs]</a>    <span class="k">def</span> <span class="nf">summary2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">yname</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">xname</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=.</span><span class="mi">05</span><span class="p">,</span>
            <span class="n">float_format</span><span class="o">=</span><span class="s2">&quot;</span><span class="si">%.4f</span><span class="s2">&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Experimental function to summarize regression results</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        xname : List of strings of length equal to the number of parameters</span>
<span class="sd">            Names of the independent variables (optional)</span>
<span class="sd">        yname : string</span>
<span class="sd">            Name of the dependent variable (optional)</span>
<span class="sd">        title : string, optional</span>
<span class="sd">            Title for the top table. If not None, then this replaces the</span>
<span class="sd">            default title</span>
<span class="sd">        alpha : float</span>
<span class="sd">            significance level for the confidence intervals</span>
<span class="sd">        float_format: string</span>
<span class="sd">            print format for floats in parameters summary</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        smry : Summary instance</span>
<span class="sd">            this holds the summary tables and text, which can be printed or</span>
<span class="sd">            converted to various output formats.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        statsmodels.iolib.summary.Summary : class to hold summary</span>
<span class="sd">            results</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Summary</span>
        <span class="kn">from</span> <span class="nn">statsmodels.iolib</span> <span class="k">import</span> <span class="n">summary2</span>
        <span class="n">smry</span> <span class="o">=</span> <span class="n">summary2</span><span class="o">.</span><span class="n">Summary</span><span class="p">()</span>
        <span class="n">smry</span><span class="o">.</span><span class="n">add_base</span><span class="p">(</span><span class="n">results</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">float_format</span><span class="o">=</span><span class="n">float_format</span><span class="p">,</span>
                <span class="n">xname</span><span class="o">=</span><span class="n">xname</span><span class="p">,</span> <span class="n">yname</span><span class="o">=</span><span class="n">yname</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;constraints&#39;</span><span class="p">):</span>
            <span class="n">smry</span><span class="o">.</span><span class="n">add_text</span><span class="p">(</span><span class="s1">&#39;Model has been estimated subject to linear &#39;</span>
                          <span class="s1">&#39;equality constraints.&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">smry</span></div></div>



<div class="viewcode-block" id="CountResults"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.CountResults.html#statsmodels.discrete.discrete_model.CountResults">[docs]</a><span class="k">class</span> <span class="nc">CountResults</span><span class="p">(</span><span class="n">DiscreteResults</span><span class="p">):</span>
    <span class="vm">__doc__</span> <span class="o">=</span> <span class="n">_discrete_results_docs</span> <span class="o">%</span> <span class="p">{</span>
                    <span class="s2">&quot;one_line_description&quot;</span> <span class="p">:</span> <span class="s2">&quot;A results class for count data&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;extra_attr&quot;</span> <span class="p">:</span> <span class="s2">&quot;&quot;</span><span class="p">}</span>
    <span class="nd">@cache_readonly</span>
<div class="viewcode-block" id="CountResults.resid"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.CountResults.resid.html#statsmodels.discrete.discrete_model.CountResults.resid">[docs]</a>    <span class="k">def</span> <span class="nf">resid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Residuals</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The residuals for Count models are defined as</span>

<span class="sd">        .. math:: y - p</span>

<span class="sd">        where :math:`p = \\exp(X\\beta)`. Any exposure and offset variables</span>
<span class="sd">        are also handled.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">endog</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">predict</span><span class="p">()</span></div></div>

<div class="viewcode-block" id="NegativeBinomialResults"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.NegativeBinomialResults.html#statsmodels.discrete.discrete_model.NegativeBinomialResults">[docs]</a><span class="k">class</span> <span class="nc">NegativeBinomialResults</span><span class="p">(</span><span class="n">CountResults</span><span class="p">):</span>
    <span class="vm">__doc__</span> <span class="o">=</span> <span class="n">_discrete_results_docs</span> <span class="o">%</span> <span class="p">{</span>
        <span class="s2">&quot;one_line_description&quot;</span> <span class="p">:</span> <span class="s2">&quot;A results class for NegativeBinomial 1 and 2&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;extra_attr&quot;</span> <span class="p">:</span> <span class="s2">&quot;&quot;</span><span class="p">}</span>

    <span class="nd">@cache_readonly</span>
<div class="viewcode-block" id="NegativeBinomialResults.lnalpha"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.NegativeBinomialResults.lnalpha.html#statsmodels.discrete.discrete_model.NegativeBinomialResults.lnalpha">[docs]</a>    <span class="k">def</span> <span class="nf">lnalpha</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span></div>

    <span class="nd">@cache_readonly</span>
<div class="viewcode-block" id="NegativeBinomialResults.lnalpha_std_err"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.NegativeBinomialResults.lnalpha_std_err.html#statsmodels.discrete.discrete_model.NegativeBinomialResults.lnalpha_std_err">[docs]</a>    <span class="k">def</span> <span class="nf">lnalpha_std_err</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">bse</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span></div>

    <span class="nd">@cache_readonly</span>
<div class="viewcode-block" id="NegativeBinomialResults.aic"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.NegativeBinomialResults.aic.html#statsmodels.discrete.discrete_model.NegativeBinomialResults.aic">[docs]</a>    <span class="k">def</span> <span class="nf">aic</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># + 1 because we estimate alpha</span>
        <span class="n">k_extra</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">,</span> <span class="s1">&#39;k_extra&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">llf</span> <span class="o">-</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">df_model</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_constant</span> <span class="o">+</span> <span class="n">k_extra</span><span class="p">))</span></div>

    <span class="nd">@cache_readonly</span>
<div class="viewcode-block" id="NegativeBinomialResults.bic"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.NegativeBinomialResults.bic.html#statsmodels.discrete.discrete_model.NegativeBinomialResults.bic">[docs]</a>    <span class="k">def</span> <span class="nf">bic</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># + 1 because we estimate alpha</span>
        <span class="n">k_extra</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">,</span> <span class="s1">&#39;k_extra&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">llf</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">df_model</span> <span class="o">+</span>
                                                <span class="bp">self</span><span class="o">.</span><span class="n">k_constant</span> <span class="o">+</span> <span class="n">k_extra</span><span class="p">)</span></div></div>

<span class="k">class</span> <span class="nc">L1CountResults</span><span class="p">(</span><span class="n">DiscreteResults</span><span class="p">):</span>
    <span class="vm">__doc__</span> <span class="o">=</span> <span class="n">_discrete_results_docs</span> <span class="o">%</span> <span class="p">{</span><span class="s2">&quot;one_line_description&quot;</span> <span class="p">:</span>
            <span class="s2">&quot;A results class for count data fit by l1 regularization&quot;</span><span class="p">,</span>
            <span class="s2">&quot;extra_attr&quot;</span> <span class="p">:</span> <span class="n">_l1_results_attr</span><span class="p">}</span>
        <span class="c1">#discretefit = CountResults(self, cntfit)</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">cntfit</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">L1CountResults</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">cntfit</span><span class="p">)</span>
        <span class="c1"># self.trimmed is a boolean array with T/F telling whether or not that</span>
        <span class="c1"># entry in params has been set zero&#39;d out.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">trimmed</span> <span class="o">=</span> <span class="n">cntfit</span><span class="o">.</span><span class="n">mle_retvals</span><span class="p">[</span><span class="s1">&#39;trimmed&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nnz_params</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">trimmed</span> <span class="o">==</span> <span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="c1"># update degrees of freedom</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">df_model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nnz_params</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">df_resid</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">endog</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">nnz_params</span><span class="p">)</span>
        <span class="c1"># adjust for extra parameter in NegativeBinomial nb1 and nb2</span>
        <span class="c1"># extra parameter is not included in df_model</span>
        <span class="n">k_extra</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">,</span> <span class="s1">&#39;k_extra&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">df_model</span> <span class="o">-=</span> <span class="n">k_extra</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">df_resid</span> <span class="o">+=</span> <span class="n">k_extra</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">df_model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">df_model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">df_resid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">df_resid</span>

<span class="k">class</span> <span class="nc">PoissonResults</span><span class="p">(</span><span class="n">CountResults</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">predict_prob</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">exog</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">exposure</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">transform</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return predicted probability of each count level for each observation</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n : array-like or int</span>
<span class="sd">            The counts for which you want the probabilities. If n is None</span>
<span class="sd">            then the probabilities for each count from 0 to max(y) are</span>
<span class="sd">            given.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ndarray</span>
<span class="sd">            A nobs x n array where len(`n`) columns are indexed by the count</span>
<span class="sd">            n. If n is None, then column 0 is the probability that each</span>
<span class="sd">            observation is 0, column 1 is the probability that each</span>
<span class="sd">            observation is 1, etc.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">endog</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">exog</span><span class="o">=</span><span class="n">exog</span><span class="p">,</span> <span class="n">exposure</span><span class="o">=</span><span class="n">exposure</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">,</span>
                          <span class="n">transform</span><span class="o">=</span><span class="n">transform</span><span class="p">,</span> <span class="n">linear</span><span class="o">=</span><span class="kc">False</span><span class="p">)[:,</span><span class="kc">None</span><span class="p">]</span>
        <span class="c1"># uses broadcasting</span>
        <span class="k">return</span> <span class="n">stats</span><span class="o">.</span><span class="n">poisson</span><span class="o">.</span><span class="n">pmf</span><span class="p">(</span><span class="n">counts</span><span class="p">,</span> <span class="n">mu</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">L1PoissonResults</span><span class="p">(</span><span class="n">L1CountResults</span><span class="p">,</span> <span class="n">PoissonResults</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">L1NegativeBinomialResults</span><span class="p">(</span><span class="n">L1CountResults</span><span class="p">,</span> <span class="n">NegativeBinomialResults</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">OrderedResults</span><span class="p">(</span><span class="n">DiscreteResults</span><span class="p">):</span>
    <span class="vm">__doc__</span> <span class="o">=</span> <span class="n">_discrete_results_docs</span> <span class="o">%</span> <span class="p">{</span><span class="s2">&quot;one_line_description&quot;</span> <span class="p">:</span> <span class="s2">&quot;A results class for ordered discrete data.&quot;</span> <span class="p">,</span> <span class="s2">&quot;extra_attr&quot;</span> <span class="p">:</span> <span class="s2">&quot;&quot;</span><span class="p">}</span>
    <span class="k">pass</span>

<div class="viewcode-block" id="BinaryResults"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.BinaryResults.html#statsmodels.discrete.discrete_model.BinaryResults">[docs]</a><span class="k">class</span> <span class="nc">BinaryResults</span><span class="p">(</span><span class="n">DiscreteResults</span><span class="p">):</span>
    <span class="vm">__doc__</span> <span class="o">=</span> <span class="n">_discrete_results_docs</span> <span class="o">%</span> <span class="p">{</span><span class="s2">&quot;one_line_description&quot;</span> <span class="p">:</span> <span class="s2">&quot;A results class for binary data&quot;</span><span class="p">,</span> <span class="s2">&quot;extra_attr&quot;</span> <span class="p">:</span> <span class="s2">&quot;&quot;</span><span class="p">}</span>

<div class="viewcode-block" id="BinaryResults.pred_table"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.BinaryResults.pred_table.html#statsmodels.discrete.discrete_model.BinaryResults.pred_table">[docs]</a>    <span class="k">def</span> <span class="nf">pred_table</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=.</span><span class="mi">5</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Prediction table</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        threshold : scalar</span>
<span class="sd">            Number between 0 and 1. Threshold above which a prediction is</span>
<span class="sd">            considered 1 and below which a prediction is considered 0.</span>

<span class="sd">        Notes</span>
<span class="sd">        ------</span>
<span class="sd">        pred_table[i,j] refers to the number of times &quot;i&quot; was observed and</span>
<span class="sd">        the model predicted &quot;j&quot;. Correct predictions are along the diagonal.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span>
        <span class="n">actual</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">endog</span>
        <span class="n">pred</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">predict</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram2d</span><span class="p">(</span><span class="n">actual</span><span class="p">,</span> <span class="n">pred</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">bins</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span></div>


<div class="viewcode-block" id="BinaryResults.summary"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.BinaryResults.summary.html#statsmodels.discrete.discrete_model.BinaryResults.summary">[docs]</a>    <span class="k">def</span> <span class="nf">summary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">yname</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">xname</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=.</span><span class="mi">05</span><span class="p">,</span>
                <span class="n">yname_list</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">smry</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">BinaryResults</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">summary</span><span class="p">(</span><span class="n">yname</span><span class="p">,</span> <span class="n">xname</span><span class="p">,</span> <span class="n">title</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span>
                     <span class="n">yname_list</span><span class="p">)</span>
        <span class="n">fittedvalues</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fittedvalues</span><span class="p">)</span>
        <span class="n">absprederror</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">endog</span> <span class="o">-</span> <span class="n">fittedvalues</span><span class="p">)</span>
        <span class="n">predclose_sum</span> <span class="o">=</span> <span class="p">(</span><span class="n">absprederror</span> <span class="o">&lt;</span> <span class="mf">1e-4</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">predclose_frac</span> <span class="o">=</span> <span class="n">predclose_sum</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">fittedvalues</span><span class="p">)</span>

        <span class="c1">#add warnings/notes</span>
        <span class="n">etext</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">predclose_sum</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">fittedvalues</span><span class="p">):</span> <span class="c1">#nobs?</span>
            <span class="n">wstr</span> <span class="o">=</span> <span class="s2">&quot;Complete Separation: The results show that there is&quot;</span>
            <span class="n">wstr</span> <span class="o">+=</span> <span class="s2">&quot;complete separation.</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="n">wstr</span> <span class="o">+=</span> <span class="s2">&quot;In this case the Maximum Likelihood Estimator does &quot;</span>
            <span class="n">wstr</span> <span class="o">+=</span> <span class="s2">&quot;not exist and the parameters</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="n">wstr</span> <span class="o">+=</span> <span class="s2">&quot;are not identified.&quot;</span>
            <span class="n">etext</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">wstr</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">predclose_frac</span> <span class="o">&gt;</span> <span class="mf">0.1</span><span class="p">:</span>  <span class="c1"># TODO: get better diagnosis</span>
            <span class="n">wstr</span> <span class="o">=</span> <span class="s2">&quot;Possibly complete quasi-separation: A fraction &quot;</span>
            <span class="n">wstr</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="si">%4.2f</span><span class="s2"> of observations can be</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">predclose_frac</span>
            <span class="n">wstr</span> <span class="o">+=</span> <span class="s2">&quot;perfectly predicted. This might indicate that there &quot;</span>
            <span class="n">wstr</span> <span class="o">+=</span> <span class="s2">&quot;is complete</span><span class="se">\n</span><span class="s2">quasi-separation. In this case some &quot;</span>
            <span class="n">wstr</span> <span class="o">+=</span> <span class="s2">&quot;parameters will not be identified.&quot;</span>
            <span class="n">etext</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">wstr</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">etext</span><span class="p">:</span>
            <span class="n">smry</span><span class="o">.</span><span class="n">add_extra_txt</span><span class="p">(</span><span class="n">etext</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">smry</span></div>
    <span class="n">summary</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">DiscreteResults</span><span class="o">.</span><span class="n">summary</span><span class="o">.</span><span class="vm">__doc__</span>

    <span class="nd">@cache_readonly</span>
<div class="viewcode-block" id="BinaryResults.resid_dev"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.BinaryResults.resid_dev.html#statsmodels.discrete.discrete_model.BinaryResults.resid_dev">[docs]</a>    <span class="k">def</span> <span class="nf">resid_dev</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Deviance residuals</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Deviance residuals are defined</span>

<span class="sd">        .. math:: d_j = \\pm\\left(2\\left[Y_j\\ln\\left(\\frac{Y_j}{M_jp_j}\\right) + (M_j - Y_j\\ln\\left(\\frac{M_j-Y_j}{M_j(1-p_j)} \\right) \\right] \\right)^{1/2}</span>

<span class="sd">        where</span>

<span class="sd">        :math:`p_j = cdf(X\\beta)` and :math:`M_j` is the total number of</span>
<span class="sd">        observations sharing the covariate pattern :math:`j`.</span>

<span class="sd">        For now :math:`M_j` is always set to 1.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#These are the deviance residuals</span>
        <span class="c1">#model = self.model</span>
        <span class="n">endog</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">endog</span>
        <span class="c1">#exog = model.exog</span>
        <span class="c1"># M = # of individuals that share a covariate pattern</span>
        <span class="c1"># so M[i] = 2 for i = two share a covariate pattern</span>
        <span class="n">M</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predict</span><span class="p">()</span>
        <span class="c1">#Y_0 = np.where(exog == 0)</span>
        <span class="c1">#Y_M = np.where(exog == M)</span>
        <span class="c1">#NOTE: Common covariate patterns are not yet handled</span>
        <span class="n">res</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">endog</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">M</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">p</span><span class="p">)))</span> <span class="o">+</span> \
                <span class="n">endog</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">M</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">p</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">res</span></div>

    <span class="nd">@cache_readonly</span>
<div class="viewcode-block" id="BinaryResults.resid_pearson"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.BinaryResults.resid_pearson.html#statsmodels.discrete.discrete_model.BinaryResults.resid_pearson">[docs]</a>    <span class="k">def</span> <span class="nf">resid_pearson</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pearson residuals</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Pearson residuals are defined to be</span>

<span class="sd">        .. math:: r_j = \\frac{(y - M_jp_j)}{\\sqrt{M_jp_j(1-p_j)}}</span>

<span class="sd">        where :math:`p_j=cdf(X\\beta)` and :math:`M_j` is the total number of</span>
<span class="sd">        observations sharing the covariate pattern :math:`j`.</span>

<span class="sd">        For now :math:`M_j` is always set to 1.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Pearson residuals</span>
        <span class="c1">#model = self.model</span>
        <span class="n">endog</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">endog</span>
        <span class="c1">#exog = model.exog</span>
        <span class="c1"># M = # of individuals that share a covariate pattern</span>
        <span class="c1"># so M[i] = 2 for i = two share a covariate pattern</span>
        <span class="c1"># use unique row pattern?</span>
        <span class="n">M</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predict</span><span class="p">()</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">endog</span> <span class="o">-</span> <span class="n">M</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">M</span><span class="o">*</span><span class="n">p</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">p</span><span class="p">))</span></div>

    <span class="nd">@cache_readonly</span>
<div class="viewcode-block" id="BinaryResults.resid_response"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.BinaryResults.resid_response.html#statsmodels.discrete.discrete_model.BinaryResults.resid_response">[docs]</a>    <span class="k">def</span> <span class="nf">resid_response</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The response residuals</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Response residuals are defined to be</span>

<span class="sd">        .. math:: y - p</span>

<span class="sd">        where :math:`p=cdf(X\\beta)`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">endog</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">predict</span><span class="p">()</span></div></div>

<div class="viewcode-block" id="LogitResults"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.LogitResults.html#statsmodels.discrete.discrete_model.LogitResults">[docs]</a><span class="k">class</span> <span class="nc">LogitResults</span><span class="p">(</span><span class="n">BinaryResults</span><span class="p">):</span>
    <span class="vm">__doc__</span> <span class="o">=</span> <span class="n">_discrete_results_docs</span> <span class="o">%</span> <span class="p">{</span>
        <span class="s2">&quot;one_line_description&quot;</span> <span class="p">:</span> <span class="s2">&quot;A results class for Logit Model&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;extra_attr&quot;</span> <span class="p">:</span> <span class="s2">&quot;&quot;</span><span class="p">}</span>
    <span class="nd">@cache_readonly</span>
<div class="viewcode-block" id="LogitResults.resid_generalized"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.LogitResults.resid_generalized.html#statsmodels.discrete.discrete_model.LogitResults.resid_generalized">[docs]</a>    <span class="k">def</span> <span class="nf">resid_generalized</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generalized residuals</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The generalized residuals for the Logit model are defined</span>

<span class="sd">        .. math:: y - p</span>

<span class="sd">        where :math:`p=cdf(X\\beta)`. This is the same as the `resid_response`</span>
<span class="sd">        for the Logit model.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Generalized residuals</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">endog</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">predict</span><span class="p">()</span></div></div>

<div class="viewcode-block" id="ProbitResults"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.ProbitResults.html#statsmodels.discrete.discrete_model.ProbitResults">[docs]</a><span class="k">class</span> <span class="nc">ProbitResults</span><span class="p">(</span><span class="n">BinaryResults</span><span class="p">):</span>
    <span class="vm">__doc__</span> <span class="o">=</span> <span class="n">_discrete_results_docs</span> <span class="o">%</span> <span class="p">{</span>
        <span class="s2">&quot;one_line_description&quot;</span> <span class="p">:</span> <span class="s2">&quot;A results class for Probit Model&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;extra_attr&quot;</span> <span class="p">:</span> <span class="s2">&quot;&quot;</span><span class="p">}</span>
    <span class="nd">@cache_readonly</span>
<div class="viewcode-block" id="ProbitResults.resid_generalized"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.ProbitResults.resid_generalized.html#statsmodels.discrete.discrete_model.ProbitResults.resid_generalized">[docs]</a>    <span class="k">def</span> <span class="nf">resid_generalized</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generalized residuals</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The generalized residuals for the Probit model are defined</span>

<span class="sd">        .. math:: y\\frac{\phi(X\\beta)}{\\Phi(X\\beta)}-(1-y)\\frac{\\phi(X\\beta)}{1-\\Phi(X\\beta)}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># generalized residuals</span>
        <span class="n">model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span>
        <span class="n">endog</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">endog</span>
        <span class="n">XB</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">linear</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">pdf</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="n">XB</span><span class="p">)</span>
        <span class="n">cdf</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">XB</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">endog</span> <span class="o">*</span> <span class="n">pdf</span><span class="o">/</span><span class="n">cdf</span> <span class="o">-</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">endog</span><span class="p">)</span><span class="o">*</span><span class="n">pdf</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">cdf</span><span class="p">)</span></div></div>

<span class="k">class</span> <span class="nc">L1BinaryResults</span><span class="p">(</span><span class="n">BinaryResults</span><span class="p">):</span>
    <span class="vm">__doc__</span> <span class="o">=</span> <span class="n">_discrete_results_docs</span> <span class="o">%</span> <span class="p">{</span><span class="s2">&quot;one_line_description&quot;</span> <span class="p">:</span>
    <span class="s2">&quot;Results instance for binary data fit by l1 regularization&quot;</span><span class="p">,</span>
    <span class="s2">&quot;extra_attr&quot;</span> <span class="p">:</span> <span class="n">_l1_results_attr</span><span class="p">}</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">bnryfit</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">L1BinaryResults</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">bnryfit</span><span class="p">)</span>
        <span class="c1"># self.trimmed is a boolean array with T/F telling whether or not that</span>
        <span class="c1"># entry in params has been set zero&#39;d out.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">trimmed</span> <span class="o">=</span> <span class="n">bnryfit</span><span class="o">.</span><span class="n">mle_retvals</span><span class="p">[</span><span class="s1">&#39;trimmed&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nnz_params</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">trimmed</span> <span class="o">==</span> <span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">df_model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nnz_params</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">df_resid</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">endog</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">nnz_params</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">df_model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">df_model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">df_resid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">df_resid</span>


<div class="viewcode-block" id="MultinomialResults"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.MultinomialResults.html#statsmodels.discrete.discrete_model.MultinomialResults">[docs]</a><span class="k">class</span> <span class="nc">MultinomialResults</span><span class="p">(</span><span class="n">DiscreteResults</span><span class="p">):</span>
    <span class="vm">__doc__</span> <span class="o">=</span> <span class="n">_discrete_results_docs</span> <span class="o">%</span> <span class="p">{</span><span class="s2">&quot;one_line_description&quot;</span> <span class="p">:</span>
            <span class="s2">&quot;A results class for multinomial data&quot;</span><span class="p">,</span> <span class="s2">&quot;extra_attr&quot;</span> <span class="p">:</span> <span class="s2">&quot;&quot;</span><span class="p">}</span>
    <span class="k">def</span> <span class="nf">_maybe_convert_ynames_int</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ynames</span><span class="p">):</span>
        <span class="c1"># see if they&#39;re integers</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ynames</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">ynames</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">%</span> <span class="mi">1</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">ynames</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">ynames</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">return</span> <span class="n">ynames</span>

    <span class="k">def</span> <span class="nf">_get_endog_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">yname</span><span class="p">,</span> <span class="n">yname_list</span><span class="p">,</span> <span class="nb">all</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        If all is False, the first variable name is dropped</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span>
        <span class="k">if</span> <span class="n">yname</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">yname</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">endog_names</span>
        <span class="k">if</span> <span class="n">yname_list</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ynames</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">_ynames_map</span>
            <span class="n">ynames</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maybe_convert_ynames_int</span><span class="p">(</span><span class="n">ynames</span><span class="p">)</span>
            <span class="c1"># use range below to ensure sortedness</span>
            <span class="n">ynames</span> <span class="o">=</span> <span class="p">[</span><span class="n">ynames</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">J</span><span class="p">))]</span>
            <span class="n">ynames</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;=&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">yname</span><span class="p">,</span> <span class="n">name</span><span class="p">])</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">ynames</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">:</span>
                <span class="n">yname_list</span> <span class="o">=</span> <span class="n">ynames</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="c1"># assumes first variable is dropped</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">yname_list</span> <span class="o">=</span> <span class="n">ynames</span>
        <span class="k">return</span> <span class="n">yname</span><span class="p">,</span> <span class="n">yname_list</span>

<div class="viewcode-block" id="MultinomialResults.pred_table"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.MultinomialResults.pred_table.html#statsmodels.discrete.discrete_model.MultinomialResults.pred_table">[docs]</a>    <span class="k">def</span> <span class="nf">pred_table</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the J x J prediction table.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        pred_table[i,j] refers to the number of times &quot;i&quot; was observed and</span>
<span class="sd">        the model predicted &quot;j&quot;. Correct predictions are along the diagonal.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ju</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">J</span> <span class="o">-</span> <span class="mi">1</span>  <span class="c1"># highest index</span>
        <span class="c1"># these are the actual, predicted indices</span>
        <span class="c1">#idx = lzip(self.model.endog, self.predict().argmax(1))</span>
        <span class="n">bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(([</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">ju</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">ju</span><span class="p">),</span> <span class="p">[</span><span class="n">ju</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram2d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">endog</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">predict</span><span class="p">()</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
                              <span class="n">bins</span><span class="o">=</span><span class="n">bins</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span></div>

    <span class="nd">@cache_readonly</span>
<div class="viewcode-block" id="MultinomialResults.bse"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.MultinomialResults.bse.html#statsmodels.discrete.discrete_model.MultinomialResults.bse">[docs]</a>    <span class="k">def</span> <span class="nf">bse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">bse</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cov_params</span><span class="p">()))</span>
        <span class="k">return</span> <span class="n">bse</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span></div>

    <span class="nd">@cache_readonly</span>
<div class="viewcode-block" id="MultinomialResults.aic"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.MultinomialResults.aic.html#statsmodels.discrete.discrete_model.MultinomialResults.aic">[docs]</a>    <span class="k">def</span> <span class="nf">aic</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">llf</span> <span class="o">-</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">df_model</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">J</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span></div>

    <span class="nd">@cache_readonly</span>
<div class="viewcode-block" id="MultinomialResults.bic"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.MultinomialResults.bic.html#statsmodels.discrete.discrete_model.MultinomialResults.bic">[docs]</a>    <span class="k">def</span> <span class="nf">bic</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">llf</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">df_model</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">J</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span></div>

<div class="viewcode-block" id="MultinomialResults.conf_int"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.MultinomialResults.conf_int.html#statsmodels.discrete.discrete_model.MultinomialResults.conf_int">[docs]</a>    <span class="k">def</span> <span class="nf">conf_int</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=.</span><span class="mi">05</span><span class="p">,</span> <span class="n">cols</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">confint</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">DiscreteResults</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">conf_int</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span>
                                                            <span class="n">cols</span><span class="o">=</span><span class="n">cols</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">confint</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span></div>

<div class="viewcode-block" id="MultinomialResults.margeff"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.MultinomialResults.margeff.html#statsmodels.discrete.discrete_model.MultinomialResults.margeff">[docs]</a>    <span class="k">def</span> <span class="nf">margeff</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Use get_margeff instead&quot;</span><span class="p">)</span></div>

    <span class="nd">@cache_readonly</span>
<div class="viewcode-block" id="MultinomialResults.resid_misclassified"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.MultinomialResults.resid_misclassified.html#statsmodels.discrete.discrete_model.MultinomialResults.resid_misclassified">[docs]</a>    <span class="k">def</span> <span class="nf">resid_misclassified</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Residuals indicating which observations are misclassified.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The residuals for the multinomial model are defined as</span>

<span class="sd">        .. math:: argmax(y_i) \\neq argmax(p_i)</span>

<span class="sd">        where :math:`argmax(y_i)` is the index of the category for the</span>
<span class="sd">        endogenous variable and :math:`argmax(p_i)` is the index of the</span>
<span class="sd">        predicted probabilities for each category. That is, the residual</span>
<span class="sd">        is a binary indicator that is 0 if the category with the highest</span>
<span class="sd">        predicted probability is the same as that of the observed variable</span>
<span class="sd">        and 1 otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># it&#39;s 0 or 1 - 0 for correct prediction and 1 for a missed one</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">wendog</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">!=</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">predict</span><span class="p">()</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span></div>

<div class="viewcode-block" id="MultinomialResults.summary2"><a class="viewcode-back" href="../../../generated/statsmodels.discrete.discrete_model.MultinomialResults.summary2.html#statsmodels.discrete.discrete_model.MultinomialResults.summary2">[docs]</a>    <span class="k">def</span> <span class="nf">summary2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">float_format</span><span class="o">=</span><span class="s2">&quot;</span><span class="si">%.4f</span><span class="s2">&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Experimental function to summarize regression results</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        alpha : float</span>
<span class="sd">            significance level for the confidence intervals</span>
<span class="sd">        float_format: string</span>
<span class="sd">            print format for floats in parameters summary</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        smry : Summary instance</span>
<span class="sd">            this holds the summary tables and text, which can be printed or</span>
<span class="sd">            converted to various output formats.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        statsmodels.iolib.summary2.Summary : class to hold summary</span>
<span class="sd">            results</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="kn">from</span> <span class="nn">statsmodels.iolib</span> <span class="k">import</span> <span class="n">summary2</span>
        <span class="n">smry</span> <span class="o">=</span> <span class="n">summary2</span><span class="o">.</span><span class="n">Summary</span><span class="p">()</span>
        <span class="n">smry</span><span class="o">.</span><span class="n">add_dict</span><span class="p">(</span><span class="n">summary2</span><span class="o">.</span><span class="n">summary_model</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="c1"># One data frame per value of endog</span>
        <span class="n">eqn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">confint</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">conf_int</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">eqn</span><span class="p">):</span>
            <span class="n">coefs</span> <span class="o">=</span> <span class="n">summary2</span><span class="o">.</span><span class="n">summary_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[:,</span><span class="n">i</span><span class="p">],</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">bse</span><span class="p">[:,</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">tvalues</span><span class="p">[:,</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">pvalues</span><span class="p">[:,</span><span class="n">i</span><span class="p">],</span>
                    <span class="n">confint</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="c1"># Header must show value of endog</span>
            <span class="n">level_str</span> <span class="o">=</span>  <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">endog_names</span> <span class="o">+</span> <span class="s1">&#39; = &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">coefs</span><span class="p">[</span><span class="n">level_str</span><span class="p">]</span> <span class="o">=</span> <span class="n">coefs</span><span class="o">.</span><span class="n">index</span>
            <span class="n">coefs</span> <span class="o">=</span> <span class="n">coefs</span><span class="o">.</span><span class="n">ix</span><span class="p">[:,[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]]</span>
            <span class="n">smry</span><span class="o">.</span><span class="n">add_df</span><span class="p">(</span><span class="n">coefs</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">float_format</span><span class="o">=</span><span class="n">float_format</span><span class="p">)</span>
            <span class="n">smry</span><span class="o">.</span><span class="n">add_title</span><span class="p">(</span><span class="n">results</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">smry</span></div></div>


<span class="k">class</span> <span class="nc">L1MultinomialResults</span><span class="p">(</span><span class="n">MultinomialResults</span><span class="p">):</span>
    <span class="vm">__doc__</span> <span class="o">=</span> <span class="n">_discrete_results_docs</span> <span class="o">%</span> <span class="p">{</span><span class="s2">&quot;one_line_description&quot;</span> <span class="p">:</span>
        <span class="s2">&quot;A results class for multinomial data fit by l1 regularization&quot;</span><span class="p">,</span>
        <span class="s2">&quot;extra_attr&quot;</span> <span class="p">:</span> <span class="n">_l1_results_attr</span><span class="p">}</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">mlefit</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">L1MultinomialResults</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">mlefit</span><span class="p">)</span>
        <span class="c1"># self.trimmed is a boolean array with T/F telling whether or not that</span>
        <span class="c1"># entry in params has been set zero&#39;d out.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">trimmed</span> <span class="o">=</span> <span class="n">mlefit</span><span class="o">.</span><span class="n">mle_retvals</span><span class="p">[</span><span class="s1">&#39;trimmed&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nnz_params</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">trimmed</span> <span class="o">==</span> <span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

        <span class="c1">#Note: J-1 constants</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">df_model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nnz_params</span> <span class="o">-</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">J</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">df_resid</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">endog</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">nnz_params</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">df_model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">df_model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">df_resid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">df_resid</span>


<span class="c1">#### Results Wrappers ####</span>

<span class="k">class</span> <span class="nc">OrderedResultsWrapper</span><span class="p">(</span><span class="n">lm</span><span class="o">.</span><span class="n">RegressionResultsWrapper</span><span class="p">):</span>
    <span class="k">pass</span>
<span class="n">wrap</span><span class="o">.</span><span class="n">populate_wrapper</span><span class="p">(</span><span class="n">OrderedResultsWrapper</span><span class="p">,</span> <span class="n">OrderedResults</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">CountResultsWrapper</span><span class="p">(</span><span class="n">lm</span><span class="o">.</span><span class="n">RegressionResultsWrapper</span><span class="p">):</span>
    <span class="k">pass</span>
<span class="n">wrap</span><span class="o">.</span><span class="n">populate_wrapper</span><span class="p">(</span><span class="n">CountResultsWrapper</span><span class="p">,</span> <span class="n">CountResults</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">NegativeBinomialResultsWrapper</span><span class="p">(</span><span class="n">lm</span><span class="o">.</span><span class="n">RegressionResultsWrapper</span><span class="p">):</span>
    <span class="k">pass</span>
<span class="n">wrap</span><span class="o">.</span><span class="n">populate_wrapper</span><span class="p">(</span><span class="n">NegativeBinomialResultsWrapper</span><span class="p">,</span>
                      <span class="n">NegativeBinomialResults</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">PoissonResultsWrapper</span><span class="p">(</span><span class="n">lm</span><span class="o">.</span><span class="n">RegressionResultsWrapper</span><span class="p">):</span>
    <span class="k">pass</span>
    <span class="c1">#_methods = {</span>
    <span class="c1">#        &quot;predict_prob&quot; : &quot;rows&quot;,</span>
    <span class="c1">#        }</span>
    <span class="c1">#_wrap_methods = lm.wrap.union_dicts(</span>
    <span class="c1">#                            lm.RegressionResultsWrapper._wrap_methods,</span>
    <span class="c1">#                            _methods)</span>
<span class="n">wrap</span><span class="o">.</span><span class="n">populate_wrapper</span><span class="p">(</span><span class="n">PoissonResultsWrapper</span><span class="p">,</span> <span class="n">PoissonResults</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">L1CountResultsWrapper</span><span class="p">(</span><span class="n">lm</span><span class="o">.</span><span class="n">RegressionResultsWrapper</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">L1PoissonResultsWrapper</span><span class="p">(</span><span class="n">lm</span><span class="o">.</span><span class="n">RegressionResultsWrapper</span><span class="p">):</span>
    <span class="k">pass</span>
    <span class="c1">#_methods = {</span>
    <span class="c1">#        &quot;predict_prob&quot; : &quot;rows&quot;,</span>
    <span class="c1">#        }</span>
    <span class="c1">#_wrap_methods = lm.wrap.union_dicts(</span>
    <span class="c1">#                            lm.RegressionResultsWrapper._wrap_methods,</span>
    <span class="c1">#                            _methods)</span>
<span class="n">wrap</span><span class="o">.</span><span class="n">populate_wrapper</span><span class="p">(</span><span class="n">L1PoissonResultsWrapper</span><span class="p">,</span> <span class="n">L1PoissonResults</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">L1NegativeBinomialResultsWrapper</span><span class="p">(</span><span class="n">lm</span><span class="o">.</span><span class="n">RegressionResultsWrapper</span><span class="p">):</span>
    <span class="k">pass</span>
<span class="n">wrap</span><span class="o">.</span><span class="n">populate_wrapper</span><span class="p">(</span><span class="n">L1NegativeBinomialResultsWrapper</span><span class="p">,</span>
                      <span class="n">L1NegativeBinomialResults</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">BinaryResultsWrapper</span><span class="p">(</span><span class="n">lm</span><span class="o">.</span><span class="n">RegressionResultsWrapper</span><span class="p">):</span>
    <span class="n">_attrs</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;resid_dev&quot;</span> <span class="p">:</span> <span class="s2">&quot;rows&quot;</span><span class="p">,</span>
              <span class="s2">&quot;resid_generalized&quot;</span> <span class="p">:</span> <span class="s2">&quot;rows&quot;</span><span class="p">,</span>
              <span class="s2">&quot;resid_pearson&quot;</span> <span class="p">:</span> <span class="s2">&quot;rows&quot;</span><span class="p">,</span>
              <span class="s2">&quot;resid_response&quot;</span> <span class="p">:</span> <span class="s2">&quot;rows&quot;</span>
              <span class="p">}</span>
    <span class="n">_wrap_attrs</span> <span class="o">=</span> <span class="n">wrap</span><span class="o">.</span><span class="n">union_dicts</span><span class="p">(</span><span class="n">lm</span><span class="o">.</span><span class="n">RegressionResultsWrapper</span><span class="o">.</span><span class="n">_wrap_attrs</span><span class="p">,</span>
                                   <span class="n">_attrs</span><span class="p">)</span>
<span class="n">wrap</span><span class="o">.</span><span class="n">populate_wrapper</span><span class="p">(</span><span class="n">BinaryResultsWrapper</span><span class="p">,</span> <span class="n">BinaryResults</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">L1BinaryResultsWrapper</span><span class="p">(</span><span class="n">lm</span><span class="o">.</span><span class="n">RegressionResultsWrapper</span><span class="p">):</span>
    <span class="k">pass</span>
<span class="n">wrap</span><span class="o">.</span><span class="n">populate_wrapper</span><span class="p">(</span><span class="n">L1BinaryResultsWrapper</span><span class="p">,</span> <span class="n">L1BinaryResults</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">MultinomialResultsWrapper</span><span class="p">(</span><span class="n">lm</span><span class="o">.</span><span class="n">RegressionResultsWrapper</span><span class="p">):</span>
    <span class="n">_attrs</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;resid_misclassified&quot;</span> <span class="p">:</span> <span class="s2">&quot;rows&quot;</span><span class="p">}</span>
    <span class="n">_wrap_attrs</span> <span class="o">=</span> <span class="n">wrap</span><span class="o">.</span><span class="n">union_dicts</span><span class="p">(</span><span class="n">lm</span><span class="o">.</span><span class="n">RegressionResultsWrapper</span><span class="o">.</span><span class="n">_wrap_attrs</span><span class="p">,</span>
            <span class="n">_attrs</span><span class="p">)</span>
<span class="n">wrap</span><span class="o">.</span><span class="n">populate_wrapper</span><span class="p">(</span><span class="n">MultinomialResultsWrapper</span><span class="p">,</span> <span class="n">MultinomialResults</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">L1MultinomialResultsWrapper</span><span class="p">(</span><span class="n">lm</span><span class="o">.</span><span class="n">RegressionResultsWrapper</span><span class="p">):</span>
    <span class="k">pass</span>
<span class="n">wrap</span><span class="o">.</span><span class="n">populate_wrapper</span><span class="p">(</span><span class="n">L1MultinomialResultsWrapper</span><span class="p">,</span> <span class="n">L1MultinomialResults</span><span class="p">)</span>


<span class="k">if</span> <span class="vm">__name__</span><span class="o">==</span><span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
    <span class="kn">import</span> <span class="nn">statsmodels.api</span> <span class="k">as</span> <span class="nn">sm</span>
<span class="c1"># Scratch work for negative binomial models</span>
<span class="c1"># dvisits was written using an R package, I can provide the dataset</span>
<span class="c1"># on request until the copyright is cleared up</span>
<span class="c1">#TODO: request permission to use dvisits</span>
    <span class="n">data2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">genfromtxt</span><span class="p">(</span><span class="s1">&#39;../datasets/dvisits/dvisits.csv&#39;</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="c1"># note that this has missing values for Accident</span>
    <span class="n">endog</span> <span class="o">=</span> <span class="n">data2</span><span class="p">[</span><span class="s1">&#39;doctorco&#39;</span><span class="p">]</span>
    <span class="n">exog</span> <span class="o">=</span> <span class="n">data2</span><span class="p">[[</span><span class="s1">&#39;sex&#39;</span><span class="p">,</span><span class="s1">&#39;age&#39;</span><span class="p">,</span><span class="s1">&#39;agesq&#39;</span><span class="p">,</span><span class="s1">&#39;income&#39;</span><span class="p">,</span><span class="s1">&#39;levyplus&#39;</span><span class="p">,</span><span class="s1">&#39;freepoor&#39;</span><span class="p">,</span>
            <span class="s1">&#39;freerepa&#39;</span><span class="p">,</span><span class="s1">&#39;illness&#39;</span><span class="p">,</span><span class="s1">&#39;actdays&#39;</span><span class="p">,</span><span class="s1">&#39;hscore&#39;</span><span class="p">,</span><span class="s1">&#39;chcond1&#39;</span><span class="p">,</span>
            <span class="s1">&#39;chcond2&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data2</span><span class="p">),</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">exog</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">add_constant</span><span class="p">(</span><span class="n">exog</span><span class="p">,</span> <span class="n">prepend</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">poisson_mod</span> <span class="o">=</span> <span class="n">Poisson</span><span class="p">(</span><span class="n">endog</span><span class="p">,</span> <span class="n">exog</span><span class="p">)</span>
    <span class="n">poisson_res</span> <span class="o">=</span> <span class="n">poisson_mod</span><span class="o">.</span><span class="n">fit</span><span class="p">()</span>
<span class="c1">#    nb2_mod = NegBinTwo(endog, exog)</span>
<span class="c1">#    nb2_res = nb2_mod.fit()</span>
<span class="c1"># solvers hang (with no error and no maxiter warn...)</span>
<span class="c1"># haven&#39;t derived hessian (though it will be block diagonal) to check</span>
<span class="c1"># newton, note that Lawless (1987) has the derivations</span>
<span class="c1"># appear to be something wrong with the score?</span>
<span class="c1"># according to Lawless, traditionally the likelihood is maximized wrt to B</span>
<span class="c1"># and a gridsearch on a to determin ahat?</span>
<span class="c1"># or the Breslow approach, which is 2 step iterative.</span>
    <span class="n">nb2_params</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mf">2.190</span><span class="p">,</span><span class="o">.</span><span class="mi">217</span><span class="p">,</span><span class="o">-.</span><span class="mi">216</span><span class="p">,</span><span class="o">.</span><span class="mi">609</span><span class="p">,</span><span class="o">-.</span><span class="mi">142</span><span class="p">,</span><span class="o">.</span><span class="mi">118</span><span class="p">,</span><span class="o">-.</span><span class="mi">497</span><span class="p">,</span><span class="o">.</span><span class="mi">145</span><span class="p">,</span><span class="o">.</span><span class="mi">214</span><span class="p">,</span><span class="o">.</span><span class="mi">144</span><span class="p">,</span>
            <span class="o">.</span><span class="mi">038</span><span class="p">,</span><span class="o">.</span><span class="mi">099</span><span class="p">,</span><span class="o">.</span><span class="mi">190</span><span class="p">,</span><span class="mf">1.077</span><span class="p">]</span> <span class="c1"># alpha is last</span>
    <span class="c1"># taken from Cameron and Trivedi</span>
<span class="c1"># the below is from Cameron and Trivedi as well</span>
<span class="c1">#    endog2 = np.array(endog&gt;=1, dtype=float)</span>
<span class="c1"># skipped for now, binary poisson results look off?</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">datasets</span><span class="o">.</span><span class="n">randhie</span><span class="o">.</span><span class="n">load</span><span class="p">()</span>
    <span class="n">nbreg</span> <span class="o">=</span> <span class="n">NegativeBinomial</span>
    <span class="n">mod</span> <span class="o">=</span> <span class="n">nbreg</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">endog</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">exog</span><span class="o">.</span><span class="n">view</span><span class="p">((</span><span class="nb">float</span><span class="p">,</span><span class="mi">9</span><span class="p">)))</span>
<span class="c1">#FROM STATA:</span>
    <span class="n">params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="o">-.</span><span class="mi">05654133</span><span class="p">,</span>  <span class="o">-.</span><span class="mi">21214282</span><span class="p">,</span> <span class="o">.</span><span class="mi">0878311</span><span class="p">,</span> <span class="o">-.</span><span class="mi">02991813</span><span class="p">,</span> <span class="o">.</span><span class="mi">22903632</span><span class="p">,</span>
            <span class="o">.</span><span class="mi">06210226</span><span class="p">,</span> <span class="o">.</span><span class="mi">06799715</span><span class="p">,</span> <span class="o">.</span><span class="mi">08407035</span><span class="p">,</span> <span class="o">.</span><span class="mi">18532336</span><span class="p">])</span>
    <span class="n">bse</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0062541</span><span class="p">,</span> <span class="mf">0.0231818</span><span class="p">,</span> <span class="mf">0.0036942</span><span class="p">,</span> <span class="mf">0.0034796</span><span class="p">,</span> <span class="mf">0.0305176</span><span class="p">,</span> <span class="mf">0.0012397</span><span class="p">,</span>
            <span class="mf">0.0198008</span><span class="p">,</span> <span class="mf">0.0368707</span><span class="p">,</span> <span class="mf">0.0766506</span><span class="p">]</span>
    <span class="n">lnalpha</span> <span class="o">=</span> <span class="o">.</span><span class="mi">31221786</span>
    <span class="n">mod</span><span class="o">.</span><span class="n">loglike</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">params</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">lnalpha</span><span class="p">)])</span>
    <span class="n">poiss_res</span> <span class="o">=</span> <span class="n">Poisson</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">endog</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">exog</span><span class="o">.</span><span class="n">view</span><span class="p">((</span><span class="nb">float</span><span class="p">,</span><span class="mi">9</span><span class="p">)))</span><span class="o">.</span><span class="n">fit</span><span class="p">()</span>
    <span class="n">func</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="o">-</span><span class="n">mod</span><span class="o">.</span><span class="n">loglike</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">grad</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="o">-</span><span class="n">mod</span><span class="o">.</span><span class="n">score</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="kn">from</span> <span class="nn">scipy</span> <span class="k">import</span> <span class="n">optimize</span>
<span class="c1">#    res1 = optimize.fmin_l_bfgs_b(func, np.r_[poiss_res.params,.1],</span>
<span class="c1">#                        approx_grad=True)</span>
    <span class="n">res1</span> <span class="o">=</span> <span class="n">optimize</span><span class="o">.</span><span class="n">fmin_bfgs</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">poiss_res</span><span class="o">.</span><span class="n">params</span><span class="p">,</span><span class="o">.</span><span class="mi">1</span><span class="p">],</span> <span class="n">fprime</span><span class="o">=</span><span class="n">grad</span><span class="p">)</span>
    <span class="kn">from</span> <span class="nn">statsmodels.tools.numdiff</span> <span class="k">import</span> <span class="n">approx_hess_cs</span>
<span class="c1">#    np.sqrt(np.diag(-np.linalg.inv(approx_hess_cs(np.r_[params,lnalpha], mod.loglike))))</span>
<span class="c1">#NOTE: this is the hessian in terms of alpha _not_ lnalpha</span>
    <span class="n">hess_arr</span> <span class="o">=</span> <span class="n">mod</span><span class="o">.</span><span class="n">hessian</span><span class="p">(</span><span class="n">res1</span><span class="p">)</span>
</pre></div>




          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2009-2017, Josef Perktold, Skipper Seabold, Jonathan Taylor, statsmodels-developers.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.5.3.
    </div>
  </body>
</html>