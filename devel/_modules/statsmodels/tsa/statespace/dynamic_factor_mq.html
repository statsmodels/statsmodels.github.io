



<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      
      
      <link rel="icon" href="../../../../_static/favicon.ico">
    
    
  
      
        <title>statsmodels.tsa.statespace.dynamic_factor_mq - statsmodels 0.15.0 (+638)</title>
      
    
  <link rel="icon" type="image/png" sizes="32x32" href="../../../../_static/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="../../../../_static/icons/favicon-16x16.png">
  <link rel="manifest" href="../../../../_static/icons/site.webmanifest">
  <link rel="mask-icon" href="../../../../_static/icons/safari-pinned-tab.svg" color="#919191">
  <meta name="msapplication-TileColor" content="#2b5797">
  <meta name="msapplication-config" content="../../../../_static/icons/browserconfig.xml">
  <link rel="stylesheet" href="../../../../_static/stylesheets/examples.css">
  <link rel="stylesheet" href="../../../../_static/stylesheets/deprecation.css">
    
      
        
      
      


    
    
      
    
    
      
        
        
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
        <link rel="stylesheet" type="text/css" href="../../../../_static/sphinx_immaterial_theme.96fe8683ff2bd71e9.min.css?v=13adf062" />
        <link rel="stylesheet" type="text/css" href="../../../../_static/graphviz.css?v=fd3f3429" />
        <link rel="stylesheet" type="text/css" href="../../../../_static/plot_directive.css" />
    <script>__md_scope=new URL("../../../..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="indigo" data-md-color-accent="blue">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
      <div data-md-color-scheme="default" data-md-component="outdated" hidden>
        
      </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../../../../index.html" title="statsmodels 0.15.0 (+638)" class="md-header__button md-logo" aria-label="statsmodels 0.15.0 (+638)" data-md-component="logo">
      <img src="../../../../_static/statsmodels-logo-v2-bw.svg" alt="logo">
    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            statsmodels 0.15.0 (+638)
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              statsmodels.tsa.statespace.dynamic_factor_mq
            
          </span>
        </div>
      </div>
    </div>
    
      
    
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header__source">
        <a href="https://github.com/statsmodels/statsmodels/" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6m-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3m44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9M244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8M97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1m-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7m32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1m-11.4-14.7c-1.6 1-1.6 3.6 0 5.9s4.3 3.3 5.6 2.3c1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2"/></svg>
  </div>
  <div class="md-source__repository">
    statsmodels
  </div>
</a>
      </div>
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../../../../index.html" title="statsmodels 0.15.0 (+638)" class="md-nav__button md-logo" aria-label="statsmodels 0.15.0 (+638)" data-md-component="logo">
      <img src="../../../../_static/statsmodels-logo-v2-bw.svg" alt="logo">
    </a>
    statsmodels 0.15.0 (+638)
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/statsmodels/statsmodels/" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6m-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3m44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9M244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8M97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1m-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7m32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1m-11.4-14.7c-1.6 1-1.6 3.6 0 5.9s4.3 3.3 5.6 2.3c1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2"/></svg>
  </div>
  <div class="md-source__repository">
    statsmodels
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../install.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    <span title="/install.rst (reference label)">Installing statsmodels</span>
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../gettingstarted.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    <span title="/gettingstarted.rst (reference label)">Getting started</span>
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../user-guide.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    <span title="/user-guide.rst (reference label)">User Guide</span>
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../examples/index.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    <span title="/examples/index.rst (reference label)">Examples</span>
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../api.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    <span title="/api.rst (reference label)">API Reference</span>
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../about.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    <span title="/about.rst (reference label)">About statsmodels</span>
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../dev/index.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    <span title="/dev/index.rst (reference label)">Developer Page</span>
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../release/index.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    <span title="/release/index.rst (reference label)">Release Notes</span>
    
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

  

<nav class="md-nav md-nav--secondary">
  
  
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset" role="main">
                
                
                  


<h1>Source code for statsmodels.tsa.statespace.dynamic_factor_mq</h1><div class="highlight"><pre>
<span></span><code><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Dynamic factor model.</span>

<span class="sd">Author: Chad Fulton</span>
<span class="sd">License: BSD-3</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">statsmodels.compat.pandas</span><span class="w"> </span><span class="kn">import</span> <span class="n">MONTH_END</span><span class="p">,</span> <span class="n">QUARTER_END</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">OrderedDict</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">warnings</span><span class="w"> </span><span class="kn">import</span> <span class="n">warn</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.linalg</span><span class="w"> </span><span class="kn">import</span> <span class="n">cho_factor</span><span class="p">,</span> <span class="n">cho_solve</span><span class="p">,</span> <span class="n">LinAlgError</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">statsmodels.tools.data</span><span class="w"> </span><span class="kn">import</span> <span class="n">_is_using_pandas</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">statsmodels.tools.validation</span><span class="w"> </span><span class="kn">import</span> <span class="n">int_like</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">statsmodels.tools.decorators</span><span class="w"> </span><span class="kn">import</span> <span class="n">cache_readonly</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">statsmodels.regression.linear_model</span><span class="w"> </span><span class="kn">import</span> <span class="n">OLS</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">statsmodels.genmod.generalized_linear_model</span><span class="w"> </span><span class="kn">import</span> <span class="n">GLM</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">statsmodels.multivariate.pca</span><span class="w"> </span><span class="kn">import</span> <span class="n">PCA</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">statsmodels.tsa.statespace.sarimax</span><span class="w"> </span><span class="kn">import</span> <span class="n">SARIMAX</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">statsmodels.tsa.statespace._quarterly_ar1</span><span class="w"> </span><span class="kn">import</span> <span class="n">QuarterlyAR1</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">statsmodels.tsa.vector_ar.var_model</span><span class="w"> </span><span class="kn">import</span> <span class="n">VAR</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">statsmodels.tools.tools</span><span class="w"> </span><span class="kn">import</span> <span class="n">Bunch</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">statsmodels.tools.validation</span><span class="w"> </span><span class="kn">import</span> <span class="n">string_like</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">statsmodels.tsa.tsatools</span><span class="w"> </span><span class="kn">import</span> <span class="n">lagmat</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">statsmodels.tsa.statespace</span><span class="w"> </span><span class="kn">import</span> <span class="n">mlemodel</span><span class="p">,</span> <span class="n">initialization</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">statsmodels.tsa.statespace.tools</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">companion_matrix</span><span class="p">,</span> <span class="n">is_invertible</span><span class="p">,</span> <span class="n">constrain_stationary_univariate</span><span class="p">,</span>
    <span class="n">constrain_stationary_multivariate</span><span class="p">,</span> <span class="n">unconstrain_stationary_univariate</span><span class="p">,</span>
    <span class="n">unconstrain_stationary_multivariate</span><span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">statsmodels.tsa.statespace.kalman_smoother</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">SMOOTHER_STATE</span><span class="p">,</span> <span class="n">SMOOTHER_STATE_COV</span><span class="p">,</span> <span class="n">SMOOTHER_STATE_AUTOCOV</span><span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">statsmodels.base.data</span><span class="w"> </span><span class="kn">import</span> <span class="n">PandasData</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">statsmodels.iolib.table</span><span class="w"> </span><span class="kn">import</span> <span class="n">SimpleTable</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">statsmodels.iolib.summary</span><span class="w"> </span><span class="kn">import</span> <span class="n">Summary</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">statsmodels.iolib.tableformatting</span><span class="w"> </span><span class="kn">import</span> <span class="n">fmt_params</span>


<span class="k">class</span><span class="w"> </span><span class="nc">FactorBlock</span><span class="p">(</span><span class="nb">dict</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Helper class for describing and indexing a block of factors.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    factor_names : tuple of str</span>
<span class="sd">        Tuple of factor names in the block (in the order that they will appear</span>
<span class="sd">        in the state vector).</span>
<span class="sd">    factor_order : int</span>
<span class="sd">        Order of the vector autoregression governing the factor block dynamics.</span>
<span class="sd">    endog_factor_map : pd.DataFrame</span>
<span class="sd">        Mapping from endog variable names to factor names.</span>
<span class="sd">    state_offset : int</span>
<span class="sd">        Offset of this factor block in the state vector.</span>
<span class="sd">    has_endog_Q : bool</span>
<span class="sd">        Flag if the model contains quarterly data.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The goal of this class is, in particular, to make it easier to retrieve</span>
<span class="sd">    indexes of subsets of the state vector that are associated with a</span>
<span class="sd">    particular block of factors.</span>

<span class="sd">    - `factors_ix` is a matrix of indices, with rows corresponding to factors</span>
<span class="sd">      in the block and columns corresponding to lags</span>
<span class="sd">    - `factors` is vec(factors_ix) (i.e. it stacks columns, so that it is</span>
<span class="sd">      `factors_ix.ravel(order=&#39;F&#39;)`). Thinking about a VAR system, the first</span>
<span class="sd">       k*p elements correspond to the equation for the first variable. The next</span>
<span class="sd">       k*p elements correspond to the equation for the second variable, and so</span>
<span class="sd">       on. It contains all of the lags in the state vector, which is max(5, p)</span>
<span class="sd">    - `factors_ar` is the subset of `factors` that have nonzero coefficients,</span>
<span class="sd">      so it contains lags up to p.</span>
<span class="sd">    - `factors_L1` only contains the first lag of the factors</span>
<span class="sd">    - `factors_L1_5` contains the first - fifth lags of the factors</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">factor_names</span><span class="p">,</span> <span class="n">factor_order</span><span class="p">,</span> <span class="n">endog_factor_map</span><span class="p">,</span>
                 <span class="n">state_offset</span><span class="p">,</span> <span class="n">k_endog_Q</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">factor_names</span> <span class="o">=</span> <span class="n">factor_names</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k_factors</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">factor_names</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">factor_order</span> <span class="o">=</span> <span class="n">factor_order</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">endog_factor_map</span> <span class="o">=</span> <span class="n">endog_factor_map</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">factor_names</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state_offset</span> <span class="o">=</span> <span class="n">state_offset</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k_endog_Q</span> <span class="o">=</span> <span class="n">k_endog_Q</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog_Q</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_factor_order</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">factor_order</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_factor_order</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">factor_order</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k_states</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_factors</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_factor_order</span>

        <span class="c1"># Save items</span>
        <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;factors&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">factors</span>
        <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;factors_ar&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">factors_ar</span>
        <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;factors_ix&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">factors_ix</span>
        <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;factors_L1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">factors_L1</span>
        <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;factors_L1_5&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">factors_L1_5</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">factors_ix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Factor state index array, shaped (k_factors, lags).&quot;&quot;&quot;</span>
        <span class="c1"># i.e. the position in the state vector of the second lag of the third</span>
        <span class="c1"># factor is factors_ix[2, 1]</span>
        <span class="c1"># ravel(order=&#39;F&#39;) gives e.g (f0.L1, f1.L1, f0.L2, f1.L2, f0.L3, ...)</span>
        <span class="c1"># while</span>
        <span class="c1"># ravel(order=&#39;C&#39;) gives e.g (f0.L1, f0.L2, f0.L3, f1.L1, f1.L2, ...)</span>
        <span class="n">o</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">state_offset</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">o</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_factors</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_factor_order</span><span class="p">),</span>
                          <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_factor_order</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_factors</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">factors</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Factors and all lags in the state vector (max(5, p)).&quot;&quot;&quot;</span>
        <span class="c1"># Note that this is equivalent to factors_ix with ravel(order=&#39;F&#39;)</span>
        <span class="n">o</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">state_offset</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">s_</span><span class="p">[</span><span class="n">o</span><span class="p">:</span><span class="n">o</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_factors</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_factor_order</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">factors_ar</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Factors and all lags used in the factor autoregression (p).&quot;&quot;&quot;</span>
        <span class="n">o</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">state_offset</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">s_</span><span class="p">[</span><span class="n">o</span><span class="p">:</span><span class="n">o</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_factors</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">factor_order</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">factors_L1</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Factors (first block / lag only).&quot;&quot;&quot;</span>
        <span class="n">o</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">state_offset</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">s_</span><span class="p">[</span><span class="n">o</span><span class="p">:</span><span class="n">o</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_factors</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">factors_L1_5</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Factors plus four lags.&quot;&quot;&quot;</span>
        <span class="n">o</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">state_offset</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">s_</span><span class="p">[</span><span class="n">o</span><span class="p">:</span><span class="n">o</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_factors</span> <span class="o">*</span> <span class="mi">5</span><span class="p">]</span>


<span class="k">class</span><span class="w"> </span><span class="nc">DynamicFactorMQStates</span><span class="p">(</span><span class="nb">dict</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Helper class for describing and indexing the state vector.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    k_endog_M : int</span>
<span class="sd">        Number of monthly (or non-time-specific, if k_endog_Q=0) variables.</span>
<span class="sd">    k_endog_Q : int</span>
<span class="sd">        Number of quarterly variables.</span>
<span class="sd">    endog_names : list</span>
<span class="sd">        Names of the endogenous variables.</span>
<span class="sd">    factors : int, list, or dict</span>
<span class="sd">        Integer giving the number of (global) factors, a list with the names of</span>
<span class="sd">        (global) factors, or a dictionary with:</span>

<span class="sd">        - keys : names of endogenous variables</span>
<span class="sd">        - values : lists of factor names.</span>

<span class="sd">        If this is an integer, then the factor names will be 0, 1, ....</span>
<span class="sd">    factor_orders : int or dict</span>
<span class="sd">        Integer describing the order of the vector autoregression (VAR)</span>
<span class="sd">        governing all factor block dynamics or dictionary with:</span>

<span class="sd">        - keys : factor name or tuples of factor names in a block</span>
<span class="sd">        - values : integer describing the VAR order for that factor block</span>

<span class="sd">        If a dictionary, this defines the order of the factor blocks in the</span>
<span class="sd">        state vector. Otherwise, factors are ordered so that factors that load</span>
<span class="sd">        on more variables come first (and then alphabetically, to break ties).</span>
<span class="sd">    factor_multiplicities : int or dict</span>
<span class="sd">        This argument provides a convenient way to specify multiple factors</span>
<span class="sd">        that load identically on variables. For example, one may want two</span>
<span class="sd">        &quot;global&quot; factors (factors that load on all variables) that evolve</span>
<span class="sd">        jointly according to a VAR. One could specify two global factors in the</span>
<span class="sd">        `factors` argument and specify that they are in the same block in the</span>
<span class="sd">        `factor_orders` argument, but it is easier to specify a single global</span>
<span class="sd">        factor in the `factors` argument, and set the order in the</span>
<span class="sd">        `factor_orders` argument, and then set the factor multiplicity to 2.</span>

<span class="sd">        This argument must be an integer describing the factor multiplicity for</span>
<span class="sd">        all factors or dictionary with:</span>

<span class="sd">        - keys : factor name</span>
<span class="sd">        - values : integer describing the factor multiplicity for the factors</span>
<span class="sd">          in the given block</span>
<span class="sd">    idiosyncratic_ar1 : bool</span>
<span class="sd">        Whether or not to model the idiosyncratic component for each series as</span>
<span class="sd">        an AR(1) process. If False, the idiosyncratic component is instead</span>
<span class="sd">        modeled as white noise.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    k_endog : int</span>
<span class="sd">        Total number of endogenous variables.</span>
<span class="sd">    k_states : int</span>
<span class="sd">        Total number of state variables (those associated with the factors and</span>
<span class="sd">        those associated with the idiosyncratic disturbances).</span>
<span class="sd">    k_posdef : int</span>
<span class="sd">        Total number of state disturbance terms (those associated with the</span>
<span class="sd">        factors and those associated with the idiosyncratic disturbances).</span>
<span class="sd">    k_endog_M : int</span>
<span class="sd">        Number of monthly (or non-time-specific, if k_endog_Q=0) variables.</span>
<span class="sd">    k_endog_Q : int</span>
<span class="sd">        Number of quarterly variables.</span>
<span class="sd">    k_factors : int</span>
<span class="sd">        Total number of factors. Note that factor multiplicities will have</span>
<span class="sd">        already been expanded.</span>
<span class="sd">    k_states_factors : int</span>
<span class="sd">        The number of state variables associated with factors (includes both</span>
<span class="sd">        factors and lags of factors included in the state vector).</span>
<span class="sd">    k_posdef_factors : int</span>
<span class="sd">        The number of state disturbance terms associated with factors.</span>
<span class="sd">    k_states_idio : int</span>
<span class="sd">        Total number of state variables associated with idiosyncratic</span>
<span class="sd">        disturbances.</span>
<span class="sd">    k_posdef_idio : int</span>
<span class="sd">        Total number of state disturbance terms associated with idiosyncratic</span>
<span class="sd">        disturbances.</span>
<span class="sd">    k_states_idio_M : int</span>
<span class="sd">        The number of state variables associated with idiosyncratic</span>
<span class="sd">        disturbances for monthly (or non-time-specific if there are no</span>
<span class="sd">        quarterly variables) variables. If the disturbances are AR(1), then</span>
<span class="sd">        this will be equal to `k_endog_M`, otherwise it will be equal to zero.</span>
<span class="sd">    k_states_idio_Q : int</span>
<span class="sd">        The number of state variables associated with idiosyncratic</span>
<span class="sd">        disturbances for quarterly variables. This will always be equal to</span>
<span class="sd">        `k_endog_Q * 5`, even if the disturbances are not AR(1).</span>
<span class="sd">    k_posdef_idio_M : int</span>
<span class="sd">        The number of state disturbance terms associated with idiosyncratic</span>
<span class="sd">        disturbances for monthly (or non-time-specific if there are no</span>
<span class="sd">        quarterly variables) variables. If the disturbances are AR(1), then</span>
<span class="sd">        this will be equal to `k_endog_M`, otherwise it will be equal to zero.</span>
<span class="sd">    k_posdef_idio_Q : int</span>
<span class="sd">        The number of state disturbance terms associated with idiosyncratic</span>
<span class="sd">        disturbances for quarterly variables. This will always be equal to</span>
<span class="sd">        `k_endog_Q`, even if the disturbances are not AR(1).</span>
<span class="sd">    idiosyncratic_ar1 : bool</span>
<span class="sd">        Whether or not to model the idiosyncratic component for each series as</span>
<span class="sd">        an AR(1) process.</span>
<span class="sd">    factor_blocks : list of FactorBlock</span>
<span class="sd">        List of `FactorBlock` helper instances for each factor block.</span>
<span class="sd">    factor_names : list of str</span>
<span class="sd">        List of factor names.</span>
<span class="sd">    factors : dict</span>
<span class="sd">        Dictionary with:</span>

<span class="sd">        - keys : names of endogenous variables</span>
<span class="sd">        - values : lists of factor names.</span>

<span class="sd">        Note that factor multiplicities will have already been expanded.</span>
<span class="sd">    factor_orders : dict</span>
<span class="sd">        Dictionary with:</span>

<span class="sd">        - keys : tuple of factor names</span>
<span class="sd">        - values : integer describing autoregression order</span>

<span class="sd">        Note that factor multiplicities will have already been expanded.</span>
<span class="sd">    max_factor_order : int</span>
<span class="sd">        Maximum autoregression order across all factor blocks.</span>
<span class="sd">    factor_block_orders : pd.Series</span>
<span class="sd">        Series containing lag orders, with the factor block (a tuple of factor</span>
<span class="sd">        names) as the index.</span>
<span class="sd">    factor_multiplicities : dict</span>
<span class="sd">        Dictionary with:</span>

<span class="sd">        - keys : factor name</span>
<span class="sd">        - values : integer describing the factor multiplicity for the factors</span>
<span class="sd">          in the given block</span>
<span class="sd">    endog_factor_map : dict</span>
<span class="sd">        Dictionary with:</span>

<span class="sd">        - keys : endog name</span>
<span class="sd">        - values : list of factor names</span>
<span class="sd">    loading_counts : pd.Series</span>
<span class="sd">        Series containing number of endogenous variables loading on each</span>
<span class="sd">        factor, with the factor name as the index.</span>
<span class="sd">    block_loading_counts : dict</span>
<span class="sd">        Dictionary with:</span>

<span class="sd">        - keys : tuple of factor names</span>
<span class="sd">        - values : average number of endogenous variables loading on the block</span>
<span class="sd">          (note that average is over the factors in the block)</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The goal of this class is, in particular, to make it easier to retrieve</span>
<span class="sd">    indexes of subsets of the state vector.</span>

<span class="sd">    Note that the ordering of the factor blocks in the state vector is</span>
<span class="sd">    determined by the `factor_orders` argument if a dictionary. Otherwise,</span>
<span class="sd">    factors are ordered so that factors that load on more variables come first</span>
<span class="sd">    (and then alphabetically, to break ties).</span>

<span class="sd">    - `factors_L1` is an array with the indexes of first lag of the factors</span>
<span class="sd">      from each block. Ordered first by block, and then by lag.</span>
<span class="sd">    - `factors_L1_5` is an array with the indexes contains the first - fifth</span>
<span class="sd">      lags of the factors from each block. Ordered first by block, and then by</span>
<span class="sd">      lag.</span>
<span class="sd">    - `factors_L1_5_ix` is an array shaped (5, k_factors) with the indexes</span>
<span class="sd">      of the first - fifth lags of the factors from each block.</span>
<span class="sd">    - `idio_ar_L1` is an array with the indexes of the first lag of the</span>
<span class="sd">      idiosyncratic AR states, both monthly (if appliable) and quarterly.</span>
<span class="sd">    - `idio_ar_M` is a slice with the indexes of the idiosyncratic disturbance</span>
<span class="sd">      states for the monthly (or non-time-specific if there are no quarterly</span>
<span class="sd">      variables) variables. It is an empty slice if</span>
<span class="sd">      `idiosyncratic_ar1 = False`.</span>
<span class="sd">    - `idio_ar_Q` is a slice with the indexes of the idiosyncratic disturbance</span>
<span class="sd">      states and all lags, for the quarterly variables. It is an empty slice if</span>
<span class="sd">      there are no quarterly variable.</span>
<span class="sd">    - `idio_ar_Q_ix` is an array shaped (k_endog_Q, 5) with the indexes of the</span>
<span class="sd">      first - fifth lags of the idiosyncratic disturbance states for the</span>
<span class="sd">      quarterly variables.</span>
<span class="sd">    - `endog_factor_iloc` is a list of lists, with entries for each endogenous</span>
<span class="sd">      variable. The entry for variable `i`, `endog_factor_iloc[i]` is a list of</span>
<span class="sd">      indexes of the factors that variable `i` loads on. This does not include</span>
<span class="sd">      any lags, but it can be used with e.g. `factors_L1_5_ix` to get lags.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k_endog_M</span><span class="p">,</span> <span class="n">k_endog_Q</span><span class="p">,</span> <span class="n">endog_names</span><span class="p">,</span> <span class="n">factors</span><span class="p">,</span>
                 <span class="n">factor_orders</span><span class="p">,</span> <span class="n">factor_multiplicities</span><span class="p">,</span> <span class="n">idiosyncratic_ar1</span><span class="p">):</span>
        <span class="c1"># Save model parameterization</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k_endog_M</span> <span class="o">=</span> <span class="n">k_endog_M</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k_endog_Q</span> <span class="o">=</span> <span class="n">k_endog_Q</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog_M</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog_Q</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">idiosyncratic_ar1</span> <span class="o">=</span> <span class="n">idiosyncratic_ar1</span>

        <span class="c1"># Validate factor-related inputs</span>
        <span class="n">factors_is_int</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">factors</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)</span>
        <span class="n">factors_is_list</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">factors</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">))</span>
        <span class="n">orders_is_int</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">factor_orders</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">factor_multiplicities</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">factor_multiplicities</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">mult_is_int</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">factor_multiplicities</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">factors_is_int</span> <span class="ow">or</span> <span class="n">factors_is_list</span> <span class="ow">or</span>
                <span class="nb">isinstance</span><span class="p">(</span><span class="n">factors</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;`factors` argument must an integer number of&#39;</span>
                             <span class="s1">&#39; factors, a list of global factor names, or a&#39;</span>
                             <span class="s1">&#39; dictionary, mapping observed variables to&#39;</span>
                             <span class="s1">&#39; factors.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">orders_is_int</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">factor_orders</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;`factor_orders` argument must either be an&#39;</span>
                             <span class="s1">&#39; integer or a dictionary.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">mult_is_int</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">factor_multiplicities</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;`factor_multiplicities` argument must either be&#39;</span>
                             <span class="s1">&#39; an integer or a dictionary.&#39;</span><span class="p">)</span>

        <span class="c1"># Expand integers</span>
        <span class="c1"># If `factors` is an integer, we assume that it denotes the number of</span>
        <span class="c1"># global factors (factors that load on each variable)</span>
        <span class="k">if</span> <span class="n">factors_is_int</span> <span class="ow">or</span> <span class="n">factors_is_list</span><span class="p">:</span>
            <span class="c1"># Validate this here for a more informative error message</span>
            <span class="k">if</span> <span class="p">((</span><span class="n">factors_is_int</span> <span class="ow">and</span> <span class="n">factors</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span>
                    <span class="p">(</span><span class="n">factors_is_list</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">factors</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The model must contain at least one factor.&#39;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">factors_is_list</span><span class="p">:</span>
                <span class="n">factor_names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">factors</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">factor_names</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">&#39;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">factors</span><span class="p">)]</span>
            <span class="n">factors</span> <span class="o">=</span> <span class="p">{</span><span class="n">name</span><span class="p">:</span> <span class="n">factor_names</span><span class="p">[:]</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">endog_names</span><span class="p">}</span>
        <span class="n">_factor_names</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">factors</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">_factor_names</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
        <span class="n">factor_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">_factor_names</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">orders_is_int</span><span class="p">:</span>
            <span class="n">factor_orders</span> <span class="o">=</span> <span class="p">{</span><span class="n">factor_name</span><span class="p">:</span> <span class="n">factor_orders</span>
                             <span class="k">for</span> <span class="n">factor_name</span> <span class="ow">in</span> <span class="n">factor_names</span><span class="p">}</span>
        <span class="k">if</span> <span class="n">mult_is_int</span><span class="p">:</span>
            <span class="n">factor_multiplicities</span> <span class="o">=</span> <span class="p">{</span><span class="n">factor_name</span><span class="p">:</span> <span class="n">factor_multiplicities</span>
                                     <span class="k">for</span> <span class="n">factor_name</span> <span class="ow">in</span> <span class="n">factor_names</span><span class="p">}</span>

        <span class="c1"># Apply the factor multiplicities</span>
        <span class="n">factors</span><span class="p">,</span> <span class="n">factor_orders</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_factor_multiplicities</span><span class="p">(</span>
            <span class="n">factors</span><span class="p">,</span> <span class="n">factor_orders</span><span class="p">,</span> <span class="n">factor_multiplicities</span><span class="p">)</span>

        <span class="c1"># Save the (potentially expanded) variables</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">factors</span> <span class="o">=</span> <span class="n">factors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">factor_orders</span> <span class="o">=</span> <span class="n">factor_orders</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">factor_multiplicities</span> <span class="o">=</span> <span class="n">factor_multiplicities</span>

        <span class="c1"># Get the mapping between endog and factors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">endog_factor_map</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_construct_endog_factor_map</span><span class="p">(</span>
            <span class="n">factors</span><span class="p">,</span> <span class="n">endog_names</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k_factors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">endog_factor_map</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Validate number of factors</span>
        <span class="c1"># TODO: could do more extensive validation here.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_factors</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog_M</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Number of factors (</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">k_factors</span><span class="si">}</span><span class="s1">) cannot be&#39;</span>
                             <span class="s1">&#39; greater than the number of monthly endogenous&#39;</span>
                             <span class="sa">f</span><span class="s1">&#39; variables (</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">k_endog_M</span><span class="si">}</span><span class="s1">).&#39;</span><span class="p">)</span>

        <span class="c1"># Get `loading_counts`: factor -&gt; # endog loading on the factor</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loading_counts</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">endog_factor_map</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s1">&#39;count&#39;</span><span class="p">)</span>
                <span class="o">.</span><span class="n">reset_index</span><span class="p">()</span><span class="o">.</span><span class="n">sort_values</span><span class="p">([</span><span class="s1">&#39;count&#39;</span><span class="p">,</span> <span class="s1">&#39;factor&#39;</span><span class="p">],</span>
                                           <span class="n">ascending</span><span class="o">=</span><span class="p">[</span><span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">])</span>
                <span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s1">&#39;factor&#39;</span><span class="p">))</span>
        <span class="c1"># `block_loading_counts`: block -&gt; average of (# loading on factor)</span>
        <span class="c1"># across each factor in the block</span>
        <span class="n">block_loading_counts</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">block</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">loading_counts</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">block</span><span class="p">),</span> <span class="s1">&#39;count&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="n">factor_orders</span><span class="o">.</span><span class="n">keys</span><span class="p">()}</span>
        <span class="n">ix</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">(</span><span class="n">block_loading_counts</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span> <span class="n">tupleize_cols</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                      <span class="n">name</span><span class="o">=</span><span class="s1">&#39;block&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">block_loading_counts</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span>
            <span class="nb">list</span><span class="p">(</span><span class="n">block_loading_counts</span><span class="o">.</span><span class="n">values</span><span class="p">()),</span>
            <span class="n">index</span><span class="o">=</span><span class="n">ix</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;count&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">to_frame</span><span class="p">()</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span>
                <span class="p">[</span><span class="s1">&#39;count&#39;</span><span class="p">,</span> <span class="s1">&#39;block&#39;</span><span class="p">],</span> <span class="n">ascending</span><span class="o">=</span><span class="p">[</span><span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">])[</span><span class="s1">&#39;count&#39;</span><span class="p">]</span>

        <span class="c1"># Get the mapping between factor blocks and VAR order</span>

        <span class="c1"># `factor_block_orders`: pd.Series of factor block -&gt; lag order</span>
        <span class="n">ix</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">(</span><span class="n">factor_orders</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span> <span class="n">tupleize_cols</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;block&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">factor_block_orders</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span>
            <span class="nb">list</span><span class="p">(</span><span class="n">factor_orders</span><span class="o">.</span><span class="n">values</span><span class="p">()),</span> <span class="n">index</span><span class="o">=</span><span class="n">ix</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;order&#39;</span><span class="p">)</span>

        <span class="c1"># If the `factor_orders` variable was an integer, then it did not</span>
        <span class="c1"># define an ordering for the factor blocks. In this case, we use the</span>
        <span class="c1"># loading counts to do so. This ensures that e.g. global factors are</span>
        <span class="c1"># listed first.</span>
        <span class="k">if</span> <span class="n">orders_is_int</span><span class="p">:</span>
            <span class="n">keys</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">block_loading_counts</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">factor_block_orders</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">factor_block_orders</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">keys</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">factor_block_orders</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;block&#39;</span>

        <span class="c1"># Define factor_names based on factor_block_orders (instead of on those</span>
        <span class="c1"># from `endog_factor_map`) to (a) make sure that factors are allocated</span>
        <span class="c1"># to only one block, and (b) order the factor names to be consistent</span>
        <span class="c1"># with the block definitions.</span>
        <span class="n">factor_names</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">factor_block_orders</span><span class="o">.</span><span class="n">index</span><span class="p">)))</span>
        <span class="n">missing</span> <span class="o">=</span> <span class="p">[</span><span class="n">name</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">endog_factor_map</span><span class="o">.</span><span class="n">columns</span>
                   <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">factor_names</span><span class="o">.</span><span class="n">tolist</span><span class="p">()]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">missing</span><span class="p">):</span>
            <span class="n">ix</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">([(</span><span class="n">factor_name</span><span class="p">,)</span> <span class="k">for</span> <span class="n">factor_name</span> <span class="ow">in</span> <span class="n">missing</span><span class="p">],</span>
                          <span class="n">tupleize_cols</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;block&#39;</span><span class="p">)</span>
            <span class="n">default_block_orders</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ix</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">),</span>
                                             <span class="n">index</span><span class="o">=</span><span class="n">ix</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;order&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">factor_block_orders</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span>
                <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">factor_block_orders</span><span class="p">,</span> <span class="n">default_block_orders</span><span class="p">])</span>
            <span class="n">factor_names</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">factor_block_orders</span><span class="o">.</span><span class="n">index</span><span class="p">)))</span>
        <span class="n">duplicates</span> <span class="o">=</span> <span class="n">factor_names</span><span class="o">.</span><span class="n">duplicated</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">duplicates</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="n">duplicate_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">factor_names</span><span class="p">[</span><span class="n">duplicates</span><span class="p">])</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Each factor can be assigned to at most one&#39;</span>
                             <span class="s1">&#39; block of factors in `factor_orders`.&#39;</span>
                             <span class="sa">f</span><span class="s1">&#39; Duplicate entries for </span><span class="si">{</span><span class="n">duplicate_names</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">factor_names</span> <span class="o">=</span> <span class="n">factor_names</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_factor_order</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">factor_block_orders</span><span class="p">)</span>

        <span class="c1"># Re-order the columns of the endog factor mapping to reflect the</span>
        <span class="c1"># orderings of endog_names and factor_names</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">endog_factor_map</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">endog_factor_map</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">endog_names</span><span class="p">,</span> <span class="n">factor_names</span><span class="p">])</span>

        <span class="c1"># Create factor block helpers, and get factor-related state and posdef</span>
        <span class="c1"># dimensions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k_states_factors</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k_posdef_factors</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">state_offset</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">factor_blocks</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">factor_names</span><span class="p">,</span> <span class="n">factor_order</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">factor_block_orders</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">block</span> <span class="o">=</span> <span class="n">FactorBlock</span><span class="p">(</span><span class="n">factor_names</span><span class="p">,</span> <span class="n">factor_order</span><span class="p">,</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">endog_factor_map</span><span class="p">,</span> <span class="n">state_offset</span><span class="p">,</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">k_endog_Q</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">k_states_factors</span> <span class="o">+=</span> <span class="n">block</span><span class="o">.</span><span class="n">k_states</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">k_posdef_factors</span> <span class="o">+=</span> <span class="n">block</span><span class="o">.</span><span class="n">k_factors</span>
            <span class="n">state_offset</span> <span class="o">+=</span> <span class="n">block</span><span class="o">.</span><span class="n">k_states</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">factor_blocks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">block</span><span class="p">)</span>

        <span class="c1"># Idiosyncratic state dimensions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k_states_idio_M</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog_M</span> <span class="k">if</span> <span class="n">idiosyncratic_ar1</span> <span class="k">else</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k_states_idio_Q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog_Q</span> <span class="o">*</span> <span class="mi">5</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k_states_idio</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_states_idio_M</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_states_idio_Q</span>

        <span class="c1"># Idiosyncratic posdef dimensions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k_posdef_idio_M</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog_M</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">idiosyncratic_ar1</span> <span class="k">else</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k_posdef_idio_Q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog_Q</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k_posdef_idio</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_posdef_idio_M</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_posdef_idio_Q</span>

        <span class="c1"># Total states, posdef</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k_states</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_states_factors</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_states_idio</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k_posdef</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_posdef_factors</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_posdef_idio</span>

        <span class="c1"># Cache</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_endog_factor_iloc</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_apply_factor_multiplicities</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">factors</span><span class="p">,</span> <span class="n">factor_orders</span><span class="p">,</span>
                                     <span class="n">factor_multiplicities</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Expand `factors` and `factor_orders` to account for factor multiplity.</span>

<span class="sd">        For example, if there is a `global` factor with multiplicity 2, then</span>
<span class="sd">        this method expands that into `global.1` and `global.2` in both the</span>
<span class="sd">        `factors` and `factor_orders` dictionaries.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        factors : dict</span>
<span class="sd">            Dictionary of {endog_name: list of factor names}</span>
<span class="sd">        factor_orders : dict</span>
<span class="sd">            Dictionary of {tuple of factor names: factor order}</span>
<span class="sd">        factor_multiplicities : dict</span>
<span class="sd">            Dictionary of {factor name: factor multiplicity}</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        new_factors : dict</span>
<span class="sd">            Dictionary of {endog_name: list of factor names}, with factor names</span>
<span class="sd">            expanded to incorporate multiplicities.</span>
<span class="sd">        new_factors : dict</span>
<span class="sd">            Dictionary of {tuple of factor names: factor order}, with factor</span>
<span class="sd">            names in each tuple expanded to incorporate multiplicities.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Expand the factors to account for the multiplicities</span>
        <span class="n">new_factors</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">endog_name</span><span class="p">,</span> <span class="n">factors_list</span> <span class="ow">in</span> <span class="n">factors</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">new_factor_list</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">factor_name</span> <span class="ow">in</span> <span class="n">factors_list</span><span class="p">:</span>
                <span class="n">n</span> <span class="o">=</span> <span class="n">factor_multiplicities</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">factor_name</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">new_factor_list</span> <span class="o">+=</span> <span class="p">[</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">factor_name</span><span class="si">}</span><span class="s1">.</span><span class="si">{</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s1">&#39;</span>
                                        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">new_factor_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">factor_name</span><span class="p">)</span>
            <span class="n">new_factors</span><span class="p">[</span><span class="n">endog_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_factor_list</span>

        <span class="c1"># Expand the factor orders to account for the multiplicities</span>
        <span class="n">new_factor_orders</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">block</span><span class="p">,</span> <span class="n">factor_order</span> <span class="ow">in</span> <span class="n">factor_orders</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                <span class="n">block</span> <span class="o">=</span> <span class="p">(</span><span class="n">block</span><span class="p">,)</span>
            <span class="n">new_block</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">factor_name</span> <span class="ow">in</span> <span class="n">block</span><span class="p">:</span>
                <span class="n">n</span> <span class="o">=</span> <span class="n">factor_multiplicities</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">factor_name</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">new_block</span> <span class="o">+=</span> <span class="p">[</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">factor_name</span><span class="si">}</span><span class="s1">.</span><span class="si">{</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s1">&#39;</span>
                                  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">new_block</span> <span class="o">+=</span> <span class="p">[</span><span class="n">factor_name</span><span class="p">]</span>
            <span class="n">new_factor_orders</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">new_block</span><span class="p">)]</span> <span class="o">=</span> <span class="n">factor_order</span>

        <span class="k">return</span> <span class="n">new_factors</span><span class="p">,</span> <span class="n">new_factor_orders</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_construct_endog_factor_map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">factors</span><span class="p">,</span> <span class="n">endog_names</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct mapping of observed variables to factors.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        factors : dict</span>
<span class="sd">            Dictionary of {endog_name: list of factor names}</span>
<span class="sd">        endog_names : list of str</span>
<span class="sd">            List of the names of the observed variables.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        endog_factor_map : pd.DataFrame</span>
<span class="sd">            Boolean dataframe with `endog_names` as the index and the factor</span>
<span class="sd">            names (computed from the `factors` input) as the columns. Each cell</span>
<span class="sd">            is True if the associated factor is allowed to load on the</span>
<span class="sd">            associated observed variable.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Validate that all entries in the factors dictionary have associated</span>
        <span class="c1"># factors</span>
        <span class="n">missing</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">factors</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">))</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">missing</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">missing</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Each observed variable must be mapped to at&#39;</span>
                             <span class="s1">&#39; least one factor in the `factors` dictionary.&#39;</span>
                             <span class="sa">f</span><span class="s1">&#39; Variables missing factors are: </span><span class="si">{</span><span class="n">missing</span><span class="si">}</span><span class="s1">.&#39;</span><span class="p">)</span>

        <span class="c1"># Validate that we have been told about the factors for each endog</span>
        <span class="c1"># variable. This is because it doesn&#39;t make sense to include an</span>
        <span class="c1"># observed variable that doesn&#39;t load on any factor</span>
        <span class="n">missing</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">endog_names</span><span class="p">)</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">factors</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">missing</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;If a `factors` dictionary is provided, then&#39;</span>
                             <span class="s1">&#39; it must include entries for each observed&#39;</span>
                             <span class="sa">f</span><span class="s1">&#39; variable. Missing variables are: </span><span class="si">{</span><span class="n">missing</span><span class="si">}</span><span class="s1">.&#39;</span><span class="p">)</span>

        <span class="c1"># Figure out the set of factor names</span>
        <span class="c1"># (0 is just a dummy value for the dict - we just do it this way to</span>
        <span class="c1"># collect the keys, in order, without duplicates.)</span>
        <span class="n">factor_names</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">factors</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">factor_names</span><span class="p">[</span><span class="n">value</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">factor_names</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">v</span><span class="p">:</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">value</span><span class="p">})</span>
        <span class="n">factor_names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">factor_names</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">k_factors</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">factor_names</span><span class="p">)</span>

        <span class="n">endog_factor_map</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">,</span> <span class="n">k_factors</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">),</span>
            <span class="n">index</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">(</span><span class="n">endog_names</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;endog&#39;</span><span class="p">),</span>
            <span class="n">columns</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">(</span><span class="n">factor_names</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;factor&#39;</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">factors</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">endog_factor_map</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">return</span> <span class="n">endog_factor_map</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">factors_L1</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Factors.&quot;&quot;&quot;</span>
        <span class="n">ix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_states_factors</span><span class="p">)</span>
        <span class="n">iloc</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">ix</span><span class="p">[</span><span class="n">block</span><span class="o">.</span><span class="n">factors_L1</span><span class="p">]</span> <span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">factor_blocks</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">iloc</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">factors_L1_5_ix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Factors plus any lags, index shaped (5, k_factors).&quot;&quot;&quot;</span>
        <span class="n">ix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_states_factors</span><span class="p">)</span>
        <span class="n">iloc</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">factor_blocks</span><span class="p">:</span>
            <span class="n">iloc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ix</span><span class="p">[</span><span class="n">block</span><span class="o">.</span><span class="n">factors_L1_5</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">block</span><span class="o">.</span><span class="n">k_factors</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">iloc</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">idio_ar_L1</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Idiosyncratic AR states, (first block / lag only).&quot;&quot;&quot;</span>
        <span class="n">ix1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_states_factors</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">idiosyncratic_ar1</span><span class="p">:</span>
            <span class="n">ix2</span> <span class="o">=</span> <span class="n">ix1</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ix2</span> <span class="o">=</span> <span class="n">ix1</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog_Q</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">s_</span><span class="p">[</span><span class="n">ix1</span><span class="p">:</span><span class="n">ix2</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">idio_ar_M</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Idiosyncratic AR states for monthly variables.&quot;&quot;&quot;</span>
        <span class="n">ix1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_states_factors</span>
        <span class="n">ix2</span> <span class="o">=</span> <span class="n">ix1</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">idiosyncratic_ar1</span><span class="p">:</span>
            <span class="n">ix2</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog_M</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">s_</span><span class="p">[</span><span class="n">ix1</span><span class="p">:</span><span class="n">ix2</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">idio_ar_Q</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Idiosyncratic AR states and all lags for quarterly variables.&quot;&quot;&quot;</span>
        <span class="c1"># Note that this is equivalent to idio_ar_Q_ix with ravel(order=&#39;F&#39;)</span>
        <span class="n">ix1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_states_factors</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">idiosyncratic_ar1</span><span class="p">:</span>
            <span class="n">ix1</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog_M</span>
        <span class="n">ix2</span> <span class="o">=</span> <span class="n">ix1</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog_Q</span> <span class="o">*</span> <span class="mi">5</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">s_</span><span class="p">[</span><span class="n">ix1</span><span class="p">:</span><span class="n">ix2</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">idio_ar_Q_ix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Idiosyncratic AR (quarterly) state index, (k_endog_Q, lags).&quot;&quot;&quot;</span>
        <span class="c1"># i.e. the position in the state vector of the second lag of the third</span>
        <span class="c1"># quarterly variable is idio_ar_Q_ix[2, 1]</span>
        <span class="c1"># ravel(order=&#39;F&#39;) gives e.g (y1.L1, y2.L1, y1.L2, y2.L3, y1.L3, ...)</span>
        <span class="c1"># while</span>
        <span class="c1"># ravel(order=&#39;C&#39;) gives e.g (y1.L1, y1.L2, y1.L3, y2.L1, y2.L2, ...)</span>
        <span class="n">start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_states_factors</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">idiosyncratic_ar1</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog_M</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog_Q</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog_Q</span><span class="p">))</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">endog_factor_iloc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;List of list of int, factor indexes for each observed variable.&quot;&quot;&quot;</span>
        <span class="c1"># i.e. endog_factor_iloc[i] is a list of integer locations of the</span>
        <span class="c1"># factors that load on the ith observed variable</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_endog_factor_iloc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ilocs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">):</span>
                <span class="n">ilocs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endog_factor_map</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">i</span><span class="p">])[</span><span class="mi">0</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_endog_factor_iloc</span> <span class="o">=</span> <span class="n">ilocs</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_endog_factor_iloc</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Use square brackets to access index / slice elements.</span>

<span class="sd">        This is convenient in highlighting the indexing / slice quality of</span>
<span class="sd">        these attributes in the code below.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;factors_L1&#39;</span><span class="p">,</span> <span class="s1">&#39;factors_L1_5_ix&#39;</span><span class="p">,</span> <span class="s1">&#39;idio_ar_L1&#39;</span><span class="p">,</span> <span class="s1">&#39;idio_ar_M&#39;</span><span class="p">,</span>
                   <span class="s1">&#39;idio_ar_Q&#39;</span><span class="p">,</span> <span class="s1">&#39;idio_ar_Q_ix&#39;</span><span class="p">]:</span>
            <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>


<div class="viewcode-block" id="DynamicFactorMQ">
<a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.dynamic_factor_mq.DynamicFactorMQ.html#statsmodels.tsa.statespace.dynamic_factor_mq.DynamicFactorMQ">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">DynamicFactorMQ</span><span class="p">(</span><span class="n">mlemodel</span><span class="o">.</span><span class="n">MLEModel</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Dynamic factor model with EM algorithm; option for monthly/quarterly data.</span>

<span class="sd">    Implementation of the dynamic factor model of Babura and Modugno (2014)</span>
<span class="sd">    ([1]_) and Babura, Giannone, and Reichlin (2011) ([2]_). Uses the EM</span>
<span class="sd">    algorithm for parameter fitting, and so can accommodate a large number of</span>
<span class="sd">    left-hand-side variables. Specifications can include any collection of</span>
<span class="sd">    blocks of factors, including different factor autoregression orders, and</span>
<span class="sd">    can include AR(1) processes for idiosyncratic disturbances. Can</span>
<span class="sd">    incorporate monthly/quarterly mixed frequency data along the lines of</span>
<span class="sd">    Mariano and Murasawa (2011) ([4]_). A special case of this model is the</span>
<span class="sd">    Nowcasting model of Bok et al. (2017) ([3]_). Moreover, this model can be</span>
<span class="sd">    used to compute the news associated with updated data releases.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    endog : array_like</span>
<span class="sd">        Observed time-series process :math:`y`. See the &quot;Notes&quot; section for</span>
<span class="sd">        details on how to set up a model with monthly/quarterly mixed frequency</span>
<span class="sd">        data.</span>
<span class="sd">    k_endog_monthly : int, optional</span>
<span class="sd">        If specifying a monthly/quarterly mixed frequency model in which the</span>
<span class="sd">        provided `endog` dataset contains both the monthly and quarterly data,</span>
<span class="sd">        this variable should be used to indicate how many of the variables</span>
<span class="sd">        are monthly. Note that when using the `k_endog_monthly` argument, the</span>
<span class="sd">        columns with monthly variables in `endog` should be ordered first, and</span>
<span class="sd">        the columns with quarterly variables should come afterwards. See the</span>
<span class="sd">        &quot;Notes&quot; section for details on how to set up a model with</span>
<span class="sd">        monthly/quarterly mixed frequency data.</span>
<span class="sd">    factors : int, list, or dict, optional</span>
<span class="sd">        Integer giving the number of (global) factors, a list with the names of</span>
<span class="sd">        (global) factors, or a dictionary with:</span>

<span class="sd">        - keys : names of endogenous variables</span>
<span class="sd">        - values : lists of factor names.</span>

<span class="sd">        If this is an integer, then the factor names will be 0, 1, .... The</span>
<span class="sd">        default is a single factor that loads on all variables. Note that there</span>
<span class="sd">        cannot be more factors specified than there are monthly variables.</span>
<span class="sd">    factor_orders : int or dict, optional</span>
<span class="sd">        Integer describing the order of the vector autoregression (VAR)</span>
<span class="sd">        governing all factor block dynamics or dictionary with:</span>

<span class="sd">        - keys : factor name or tuples of factor names in a block</span>
<span class="sd">        - values : integer describing the VAR order for that factor block</span>

<span class="sd">        If a dictionary, this defines the order of the factor blocks in the</span>
<span class="sd">        state vector. Otherwise, factors are ordered so that factors that load</span>
<span class="sd">        on more variables come first (and then alphabetically, to break ties).</span>
<span class="sd">    factor_multiplicities : int or dict, optional</span>
<span class="sd">        This argument provides a convenient way to specify multiple factors</span>
<span class="sd">        that load identically on variables. For example, one may want two</span>
<span class="sd">        &quot;global&quot; factors (factors that load on all variables) that evolve</span>
<span class="sd">        jointly according to a VAR. One could specify two global factors in the</span>
<span class="sd">        `factors` argument and specify that they are in the same block in the</span>
<span class="sd">        `factor_orders` argument, but it is easier to specify a single global</span>
<span class="sd">        factor in the `factors` argument, and set the order in the</span>
<span class="sd">        `factor_orders` argument, and then set the factor multiplicity to 2.</span>

<span class="sd">        This argument must be an integer describing the factor multiplicity for</span>
<span class="sd">        all factors or dictionary with:</span>

<span class="sd">        - keys : factor name</span>
<span class="sd">        - values : integer describing the factor multiplicity for the factors</span>
<span class="sd">          in the given block</span>

<span class="sd">    idiosyncratic_ar1 : bool</span>
<span class="sd">        Whether or not to model the idiosyncratic component for each series as</span>
<span class="sd">        an AR(1) process. If False, the idiosyncratic component is instead</span>
<span class="sd">        modeled as white noise.</span>
<span class="sd">    standardize : bool or tuple, optional</span>
<span class="sd">        If a boolean, whether or not to standardize each endogenous variable to</span>
<span class="sd">        have mean zero and standard deviation 1 before fitting the model. See</span>
<span class="sd">        &quot;Notes&quot; for details about how this option works with postestimation</span>
<span class="sd">        output. If a tuple (usually only used internally), then the tuple must</span>
<span class="sd">        have length 2, with each element containing a Pandas series with index</span>
<span class="sd">        equal to the names of the endogenous variables. The first element</span>
<span class="sd">        should contain the mean values and the second element should contain</span>
<span class="sd">        the standard deviations. Default is True.</span>
<span class="sd">    endog_quarterly : pandas.Series or pandas.DataFrame</span>
<span class="sd">        Observed quarterly variables. If provided, must be a Pandas Series or</span>
<span class="sd">        DataFrame with a DatetimeIndex or PeriodIndex at the quarterly</span>
<span class="sd">        frequency. See the &quot;Notes&quot; section for details on how to set up a model</span>
<span class="sd">        with monthly/quarterly mixed frequency data.</span>
<span class="sd">    init_t0 : bool, optional</span>
<span class="sd">        If True, this option initializes the Kalman filter with the</span>
<span class="sd">        distribution for :math:`\alpha_0` rather than :math:`\alpha_1`. See</span>
<span class="sd">        the &quot;Notes&quot; section for more details. This option is rarely used except</span>
<span class="sd">        for testing. Default is False.</span>
<span class="sd">    obs_cov_diag : bool, optional</span>
<span class="sd">        If True and if `idiosyncratic_ar1 is True`, then this option puts small</span>
<span class="sd">        positive values in the observation disturbance covariance matrix. This</span>
<span class="sd">        is not required for estimation and is rarely used except for testing.</span>
<span class="sd">        (It is sometimes used to prevent numerical errors, for example those</span>
<span class="sd">        associated with a positive semi-definite forecast error covariance</span>
<span class="sd">        matrix at the first time step when using EM initialization, but state</span>
<span class="sd">        space models in Statsmodels switch to the univariate approach in those</span>
<span class="sd">        cases, and so do not need to use this trick). Default is False.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The basic model is:</span>

<span class="sd">    .. math::</span>

<span class="sd">        y_t &amp; = \Lambda f_t + \epsilon_t \\</span>
<span class="sd">        f_t &amp; = A_1 f_{t-1} + \dots + A_p f_{t-p} + u_t</span>

<span class="sd">    where:</span>

<span class="sd">    - :math:`y_t` is observed data at time t</span>
<span class="sd">    - :math:`\epsilon_t` is idiosyncratic disturbance at time t (see below for</span>
<span class="sd">      details, including modeling serial correlation in this term)</span>
<span class="sd">    - :math:`f_t` is the unobserved factor at time t</span>
<span class="sd">    - :math:`u_t \sim N(0, Q)` is the factor disturbance at time t</span>

<span class="sd">    and:</span>

<span class="sd">    - :math:`\Lambda` is referred to as the matrix of factor loadings</span>
<span class="sd">    - :math:`A_i` are matrices of autoregression coefficients</span>

<span class="sd">    Furthermore, we allow the idiosyncratic disturbances to be serially</span>
<span class="sd">    correlated, so that, if `idiosyncratic_ar1=True`,</span>
<span class="sd">    :math:`\epsilon_{i,t} = \rho_i \epsilon_{i,t-1} + e_{i,t}`, where</span>
<span class="sd">    :math:`e_{i,t} \sim N(0, \sigma_i^2)`. If `idiosyncratic_ar1=False`,</span>
<span class="sd">    then we instead have :math:`\epsilon_{i,t} = e_{i,t}`.</span>

<span class="sd">    This basic setup can be found in [1]_, [2]_, [3]_, and [4]_.</span>

<span class="sd">    We allow for two generalizations of this model:</span>

<span class="sd">    1. Following [2]_, we allow multiple &quot;blocks&quot; of factors, which are</span>
<span class="sd">       independent from the other blocks of factors. Different blocks can be</span>
<span class="sd">       set to load on different subsets of the observed variables, and can be</span>
<span class="sd">       specified with different lag orders.</span>
<span class="sd">    2. Following [4]_ and [2]_, we allow mixed frequency models in which both</span>
<span class="sd">       monthly and quarterly data are used. See the section on &quot;Mixed frequency</span>
<span class="sd">       models&quot;, below, for more details.</span>

<span class="sd">    Additional notes:</span>

<span class="sd">    - The observed data may contain arbitrary patterns of missing entries.</span>

<span class="sd">    **EM algorithm**</span>

<span class="sd">    This model contains a potentially very large number of parameters, and it</span>
<span class="sd">    can be difficult and take a prohibitively long time to numerically optimize</span>
<span class="sd">    the likelihood function using quasi-Newton methods. Instead, the default</span>
<span class="sd">    fitting method in this model uses the EM algorithm, as detailed in [1]_.</span>
<span class="sd">    As a result, the model can accommodate datasets with hundreds of</span>
<span class="sd">    observed variables.</span>

<span class="sd">    **Mixed frequency data**</span>

<span class="sd">    This model can handle mixed frequency data in two ways. In this section,</span>
<span class="sd">    we only briefly describe this, and refer readers to [2]_ and [4]_ for all</span>
<span class="sd">    details.</span>

<span class="sd">    First, because there can be arbitrary patterns of missing data in the</span>
<span class="sd">    observed vector, one can simply include lower frequency variables as</span>
<span class="sd">    observed in a particular higher frequency period, and missing otherwise.</span>
<span class="sd">    For example, in a monthly model, one could include quarterly data as</span>
<span class="sd">    occurring on the third month of each quarter. To use this method, one</span>
<span class="sd">    simply needs to combine the data into a single dataset at the higher</span>
<span class="sd">    frequency that can be passed to this model as the `endog` argument.</span>
<span class="sd">    However, depending on the type of variables used in the analysis and the</span>
<span class="sd">    assumptions about the data generating process, this approach may not be</span>
<span class="sd">    valid.</span>

<span class="sd">    For example, suppose that we are interested in the growth rate of real GDP,</span>
<span class="sd">    which is measured at a quarterly frequency. If the basic factor model is</span>
<span class="sd">    specified at a monthly frequency, then the quarterly growth rate in the</span>
<span class="sd">    third month of each quarter -- which is what we actually observe -- is</span>
<span class="sd">    approximated by a particular weighted average of unobserved monthly growth</span>
<span class="sd">    rates. We need to take this particular weight moving average into account</span>
<span class="sd">    in constructing our model, and this is what the second approach does.</span>

<span class="sd">    The second approach follows [2]_ and [4]_ in constructing a state space</span>
<span class="sd">    form to explicitly model the quarterly growth rates in terms of the</span>
<span class="sd">    unobserved monthly growth rates. To use this approach, there are two</span>
<span class="sd">    methods:</span>

<span class="sd">    1. Combine the monthly and quarterly data into a single dataset at the</span>
<span class="sd">       monthly frequency, with the monthly data in the first columns and the</span>
<span class="sd">       quarterly data in the last columns. Pass this dataset to the model as</span>
<span class="sd">       the `endog` argument and give the number of the variables that are</span>
<span class="sd">       monthly as the `k_endog_monthly` argument.</span>
<span class="sd">    2. Construct a monthly dataset as a Pandas DataFrame with a DatetimeIndex</span>
<span class="sd">       or PeriodIndex at the monthly frequency and separately construct a</span>
<span class="sd">       quarterly dataset as a Pandas DataFrame with a DatetimeIndex or</span>
<span class="sd">       PeriodIndex at the quarterly frequency. Pass the monthly DataFrame to</span>
<span class="sd">       the model as the `endog` argument and pass the quarterly DataFrame to</span>
<span class="sd">       the model as the `endog_quarterly` argument.</span>

<span class="sd">    Note that this only incorporates one particular type of mixed frequency</span>
<span class="sd">    data. See also Banbura et al. (2013). &quot;Now-Casting and the Real-Time Data</span>
<span class="sd">    Flow.&quot; for discussion about other types of mixed frequency data that are</span>
<span class="sd">    not supported by this framework.</span>

<span class="sd">    **Nowcasting and the news**</span>

<span class="sd">    Through its support for monthly/quarterly mixed frequency data, this model</span>
<span class="sd">    can allow for the nowcasting of quarterly variables based on monthly</span>
<span class="sd">    observations. In particular, [2]_ and [3]_ use this model to construct</span>
<span class="sd">    nowcasts of real GDP and analyze the impacts of &quot;the news&quot;, derived from</span>
<span class="sd">    incoming data on a real-time basis. This latter functionality can be</span>
<span class="sd">    accessed through the `news` method of the results object.</span>

<span class="sd">    **Standardizing data**</span>

<span class="sd">    As is often the case in formulating a dynamic factor model, we do not</span>
<span class="sd">    explicitly account for the mean of each observed variable. Instead, the</span>
<span class="sd">    default behavior is to standardize each variable prior to estimation. Thus</span>
<span class="sd">    if :math:`y_t` are the given observed data, the dynamic factor model is</span>
<span class="sd">    actually estimated on the standardized data defined by:</span>

<span class="sd">    .. math::</span>

<span class="sd">        x_{i, t} = (y_{i, t} - \bar y_i) / s_i</span>

<span class="sd">    where :math:`\bar y_i` is the sample mean and :math:`s_i` is the sample</span>
<span class="sd">    standard deviation.</span>

<span class="sd">    By default, if standardization is applied prior to estimation, results such</span>
<span class="sd">    as in-sample predictions, out-of-sample forecasts, and the computation of</span>
<span class="sd">    the &quot;news&quot;  are reported in the scale of the original data (i.e. the model</span>
<span class="sd">    output has the reverse transformation applied before it is returned to the</span>
<span class="sd">    user).</span>

<span class="sd">    Standardization can be disabled by passing `standardization=False` to the</span>
<span class="sd">    model constructor.</span>

<span class="sd">    **Identification of factors and loadings**</span>

<span class="sd">    The estimated factors and the factor loadings in this model are only</span>
<span class="sd">    identified up to an invertible transformation. As described in (the working</span>
<span class="sd">    paper version of) [2]_, while it is possible to impose normalizations to</span>
<span class="sd">    achieve identification, the EM algorithm does will converge regardless.</span>
<span class="sd">    Moreover, for nowcasting and forecasting purposes, identification is not</span>
<span class="sd">    required. This model does not impose any normalization to identify the</span>
<span class="sd">    factors and the factor loadings.</span>

<span class="sd">    **Miscellaneous**</span>

<span class="sd">    There are two arguments available in the model constructor that are rarely</span>
<span class="sd">    used but which deserve a brief mention: `init_t0` and `obs_cov_diag`. These</span>
<span class="sd">    arguments are provided to allow exactly matching the output of other</span>
<span class="sd">    packages that have slight differences in how the underlying state space</span>
<span class="sd">    model is set up / applied.</span>

<span class="sd">    - `init_t0`: state space models in Statsmodels follow Durbin and Koopman in</span>
<span class="sd">      initializing the model with :math:`\alpha_1 \sim N(a_1, P_1)`. Other</span>
<span class="sd">      implementations sometimes initialize instead with</span>
<span class="sd">      :math:`\alpha_0 \sim N(a_0, P_0)`. We can accommodate this by prepending</span>
<span class="sd">      a row of NaNs to the observed dataset.</span>
<span class="sd">    - `obs_cov_diag`: the state space form in [1]_ incorporates non-zero (but</span>
<span class="sd">      very small) diagonal elements for the observation disturbance covariance</span>
<span class="sd">      matrix.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Constructing and fitting a `DynamicFactorMQ` model.</span>

<span class="sd">    &gt;&gt;&gt; data = sm.datasets.macrodata.load_pandas().data.iloc[-100:]</span>
<span class="sd">    &gt;&gt;&gt; data.index = pd.period_range(start=&#39;1984Q4&#39;, end=&#39;2009Q3&#39;, freq=&#39;Q&#39;)</span>
<span class="sd">    &gt;&gt;&gt; endog = data[[&#39;infl&#39;, &#39;tbilrate&#39;]].resample(&#39;M&#39;).last()</span>
<span class="sd">    &gt;&gt;&gt; endog_Q = np.log(data[[&#39;realgdp&#39;, &#39;realcons&#39;]]).diff().iloc[1:] * 400</span>

<span class="sd">    **Basic usage**</span>

<span class="sd">    In the simplest case, passing only the `endog` argument results in a model</span>
<span class="sd">    with a single factor that follows an AR(1) process. Note that because we</span>
<span class="sd">    are not also providing an `endog_quarterly` dataset, `endog` can be a numpy</span>
<span class="sd">    array or Pandas DataFrame with any index (it does not have to be monthly).</span>

<span class="sd">    The `summary` method can be useful in checking the model specification.</span>

<span class="sd">    &gt;&gt;&gt; mod = sm.tsa.DynamicFactorMQ(endog)</span>
<span class="sd">    &gt;&gt;&gt; print(mod.summary())</span>
<span class="sd">                        Model Specification: Dynamic Factor Model</span>
<span class="sd">    ==========================================================================</span>
<span class="sd">    Model:         Dynamic Factor Model   # of monthly variables:          2</span>
<span class="sd">                + 1 factors in 1 blocks   # of factors:                    1</span>
<span class="sd">                  + AR(1) idiosyncratic   Idiosyncratic disturbances:  AR(1)</span>
<span class="sd">    Sample:                     1984-10   Standardize variables:        True</span>
<span class="sd">                              - 2009-09</span>
<span class="sd">    Observed variables / factor loadings</span>
<span class="sd">    ========================</span>
<span class="sd">    Dep. variable          0</span>
<span class="sd">    ------------------------</span>
<span class="sd">             infl          X</span>
<span class="sd">         tbilrate          X</span>
<span class="sd">        Factor blocks:</span>
<span class="sd">    =====================</span>
<span class="sd">         block      order</span>
<span class="sd">    ---------------------</span>
<span class="sd">             0          1</span>
<span class="sd">    =====================</span>

<span class="sd">    **Factors**</span>

<span class="sd">    With `factors=2`, there will be two independent factors that will each</span>
<span class="sd">    evolve according to separate AR(1) processes.</span>

<span class="sd">    &gt;&gt;&gt; mod = sm.tsa.DynamicFactorMQ(endog, factors=2)</span>
<span class="sd">    &gt;&gt;&gt; print(mod.summary())</span>
<span class="sd">                        Model Specification: Dynamic Factor Model</span>
<span class="sd">    ==========================================================================</span>
<span class="sd">    Model:         Dynamic Factor Model   # of monthly variables:          2</span>
<span class="sd">                + 2 factors in 2 blocks   # of factors:                    2</span>
<span class="sd">                  + AR(1) idiosyncratic   Idiosyncratic disturbances:  AR(1)</span>
<span class="sd">    Sample:                     1984-10   Standardize variables:        True</span>
<span class="sd">                              - 2009-09</span>
<span class="sd">    Observed variables / factor loadings</span>
<span class="sd">    ===================================</span>
<span class="sd">    Dep. variable          0          1</span>
<span class="sd">    -----------------------------------</span>
<span class="sd">             infl          X          X</span>
<span class="sd">         tbilrate          X          X</span>
<span class="sd">        Factor blocks:</span>
<span class="sd">    =====================</span>
<span class="sd">         block      order</span>
<span class="sd">    ---------------------</span>
<span class="sd">             0          1</span>
<span class="sd">             1          1</span>
<span class="sd">    =====================</span>

<span class="sd">    **Factor multiplicities**</span>

<span class="sd">    By instead specifying `factor_multiplicities=2`, we would still have two</span>
<span class="sd">    factors, but they would be dependent and would evolve jointly according</span>
<span class="sd">    to a VAR(1) process.</span>

<span class="sd">    &gt;&gt;&gt; mod = sm.tsa.DynamicFactorMQ(endog, factor_multiplicities=2)</span>
<span class="sd">    &gt;&gt;&gt; print(mod.summary())</span>
<span class="sd">                        Model Specification: Dynamic Factor Model</span>
<span class="sd">    ==========================================================================</span>
<span class="sd">    Model:         Dynamic Factor Model   # of monthly variables:          2</span>
<span class="sd">                + 2 factors in 1 blocks   # of factors:                    2</span>
<span class="sd">                  + AR(1) idiosyncratic   Idiosyncratic disturbances:  AR(1)</span>
<span class="sd">    Sample:                     1984-10   Standardize variables:        True</span>
<span class="sd">                              - 2009-09</span>
<span class="sd">    Observed variables / factor loadings</span>
<span class="sd">    ===================================</span>
<span class="sd">    Dep. variable        0.1        0.2</span>
<span class="sd">    -----------------------------------</span>
<span class="sd">             infl         X          X</span>
<span class="sd">         tbilrate         X          X</span>
<span class="sd">        Factor blocks:</span>
<span class="sd">    =====================</span>
<span class="sd">         block      order</span>
<span class="sd">    ---------------------</span>
<span class="sd">      0.1, 0.2          1</span>
<span class="sd">    =====================</span>

<span class="sd">    **Factor orders**</span>

<span class="sd">    In either of the above cases, we could extend the order of the (vector)</span>
<span class="sd">    autoregressions by using the `factor_orders` argument. For example, the</span>
<span class="sd">    below model would contain two independent factors that each evolve</span>
<span class="sd">    according to a separate AR(2) process:</span>

<span class="sd">    &gt;&gt;&gt; mod = sm.tsa.DynamicFactorMQ(endog, factors=2, factor_orders=2)</span>
<span class="sd">    &gt;&gt;&gt; print(mod.summary())</span>
<span class="sd">                        Model Specification: Dynamic Factor Model</span>
<span class="sd">    ==========================================================================</span>
<span class="sd">    Model:         Dynamic Factor Model   # of monthly variables:          2</span>
<span class="sd">                + 2 factors in 2 blocks   # of factors:                    2</span>
<span class="sd">                  + AR(1) idiosyncratic   Idiosyncratic disturbances:  AR(1)</span>
<span class="sd">    Sample:                     1984-10   Standardize variables:        True</span>
<span class="sd">                              - 2009-09</span>
<span class="sd">    Observed variables / factor loadings</span>
<span class="sd">    ===================================</span>
<span class="sd">    Dep. variable          0          1</span>
<span class="sd">    -----------------------------------</span>
<span class="sd">             infl          X          X</span>
<span class="sd">         tbilrate          X          X</span>
<span class="sd">        Factor blocks:</span>
<span class="sd">    =====================</span>
<span class="sd">         block      order</span>
<span class="sd">    ---------------------</span>
<span class="sd">             0          2</span>
<span class="sd">             1          2</span>
<span class="sd">    =====================</span>

<span class="sd">    **Serial correlation in the idiosyncratic disturbances**</span>

<span class="sd">    By default, the model allows each idiosyncratic disturbance terms to evolve</span>
<span class="sd">    according to an AR(1) process. If preferred, they can instead be specified</span>
<span class="sd">    to be serially independent by passing `ididosyncratic_ar1=False`.</span>

<span class="sd">    &gt;&gt;&gt; mod = sm.tsa.DynamicFactorMQ(endog, idiosyncratic_ar1=False)</span>
<span class="sd">    &gt;&gt;&gt; print(mod.summary())</span>
<span class="sd">                        Model Specification: Dynamic Factor Model</span>
<span class="sd">    ==========================================================================</span>
<span class="sd">    Model:         Dynamic Factor Model   # of monthly variables:          2</span>
<span class="sd">                + 1 factors in 1 blocks   # of factors:                    1</span>
<span class="sd">                    + iid idiosyncratic   Idiosyncratic disturbances:    iid</span>
<span class="sd">    Sample:                     1984-10   Standardize variables:        True</span>
<span class="sd">                              - 2009-09</span>
<span class="sd">    Observed variables / factor loadings</span>
<span class="sd">    ========================</span>
<span class="sd">    Dep. variable          0</span>
<span class="sd">    ------------------------</span>
<span class="sd">             infl          X</span>
<span class="sd">         tbilrate          X</span>
<span class="sd">        Factor blocks:</span>
<span class="sd">    =====================</span>
<span class="sd">         block      order</span>
<span class="sd">    ---------------------</span>
<span class="sd">             0          1</span>
<span class="sd">    =====================</span>

<span class="sd">    *Monthly / Quarterly mixed frequency*</span>

<span class="sd">    To specify a monthly / quarterly mixed frequency model see the (Notes</span>
<span class="sd">    section for more details about these models):</span>

<span class="sd">    &gt;&gt;&gt; mod = sm.tsa.DynamicFactorMQ(endog, endog_quarterly=endog_Q)</span>
<span class="sd">    &gt;&gt;&gt; print(mod.summary())</span>
<span class="sd">                        Model Specification: Dynamic Factor Model</span>
<span class="sd">    ==========================================================================</span>
<span class="sd">    Model:         Dynamic Factor Model   # of monthly variables:          2</span>
<span class="sd">                + 1 factors in 1 blocks   # of quarterly variables:        2</span>
<span class="sd">                + Mixed frequency (M/Q)   # of factors:                    1</span>
<span class="sd">                  + AR(1) idiosyncratic   Idiosyncratic disturbances:  AR(1)</span>
<span class="sd">    Sample:                     1984-10   Standardize variables:        True</span>
<span class="sd">                              - 2009-09</span>
<span class="sd">    Observed variables / factor loadings</span>
<span class="sd">    ========================</span>
<span class="sd">    Dep. variable          0</span>
<span class="sd">    ------------------------</span>
<span class="sd">             infl          X</span>
<span class="sd">         tbilrate          X</span>
<span class="sd">          realgdp          X</span>
<span class="sd">         realcons          X</span>
<span class="sd">        Factor blocks:</span>
<span class="sd">    =====================</span>
<span class="sd">         block      order</span>
<span class="sd">    ---------------------</span>
<span class="sd">             0          1</span>
<span class="sd">    =====================</span>

<span class="sd">    *Customize observed variable / factor loadings*</span>

<span class="sd">    To specify that certain that certain observed variables only load on</span>
<span class="sd">    certain factors, it is possible to pass a dictionary to the `factors`</span>
<span class="sd">    argument.</span>

<span class="sd">    &gt;&gt;&gt; factors = {&#39;infl&#39;: [&#39;global&#39;]</span>
<span class="sd">    ...            &#39;tbilrate&#39;: [&#39;global&#39;]</span>
<span class="sd">    ...            &#39;realgdp&#39;: [&#39;global&#39;, &#39;real&#39;]</span>
<span class="sd">    ...            &#39;realcons&#39;: [&#39;global&#39;, &#39;real&#39;]}</span>
<span class="sd">    &gt;&gt;&gt; mod = sm.tsa.DynamicFactorMQ(endog, endog_quarterly=endog_Q)</span>
<span class="sd">    &gt;&gt;&gt; print(mod.summary())</span>
<span class="sd">                        Model Specification: Dynamic Factor Model</span>
<span class="sd">    ==========================================================================</span>
<span class="sd">    Model:         Dynamic Factor Model   # of monthly variables:          2</span>
<span class="sd">                + 2 factors in 2 blocks   # of quarterly variables:        2</span>
<span class="sd">                + Mixed frequency (M/Q)   # of factor blocks:              2</span>
<span class="sd">                  + AR(1) idiosyncratic   Idiosyncratic disturbances:  AR(1)</span>
<span class="sd">    Sample:                     1984-10   Standardize variables:        True</span>
<span class="sd">                              - 2009-09</span>
<span class="sd">    Observed variables / factor loadings</span>
<span class="sd">    ===================================</span>
<span class="sd">    Dep. variable     global       real</span>
<span class="sd">    -----------------------------------</span>
<span class="sd">             infl       X</span>
<span class="sd">         tbilrate       X</span>
<span class="sd">          realgdp       X           X</span>
<span class="sd">         realcons       X           X</span>
<span class="sd">        Factor blocks:</span>
<span class="sd">    =====================</span>
<span class="sd">         block      order</span>
<span class="sd">    ---------------------</span>
<span class="sd">        global          1</span>
<span class="sd">          real          1</span>
<span class="sd">    =====================</span>

<span class="sd">    **Fitting parameters**</span>

<span class="sd">    To fit the model, use the `fit` method. This method uses the EM algorithm</span>
<span class="sd">    by default.</span>

<span class="sd">    &gt;&gt;&gt; mod = sm.tsa.DynamicFactorMQ(endog)</span>
<span class="sd">    &gt;&gt;&gt; res = mod.fit()</span>
<span class="sd">    &gt;&gt;&gt; print(res.summary())</span>
<span class="sd">                              Dynamic Factor Results</span>
<span class="sd">    ==========================================================================</span>
<span class="sd">    Dep. Variable:      [&#39;infl&#39;, &#39;tbilrate&#39;]   No. Observations:         300</span>
<span class="sd">    Model:              Dynamic Factor Model   Log Likelihood       -127.909</span>
<span class="sd">                     + 1 factors in 1 blocks   AIC                   271.817</span>
<span class="sd">                       + AR(1) idiosyncratic   BIC                   301.447</span>
<span class="sd">    Date:                   Tue, 04 Aug 2020   HQIC                  283.675</span>
<span class="sd">    Time:                           15:59:11   EM Iterations              83</span>
<span class="sd">    Sample:                       10-31-1984</span>
<span class="sd">                                - 09-30-2009</span>
<span class="sd">    Covariance Type:            Not computed</span>
<span class="sd">                        Observation equation:</span>
<span class="sd">    ==============================================================</span>
<span class="sd">    Factor loadings:          0    idiosyncratic: AR(1)       var.</span>
<span class="sd">    --------------------------------------------------------------</span>
<span class="sd">                infl      -0.67                    0.39       0.73</span>
<span class="sd">            tbilrate      -0.63                    0.99       0.01</span>
<span class="sd">           Transition: Factor block 0</span>
<span class="sd">    =======================================</span>
<span class="sd">                     L1.0    error variance</span>
<span class="sd">    ---------------------------------------</span>
<span class="sd">             0       0.98              0.01</span>
<span class="sd">    =======================================</span>
<span class="sd">    Warnings:</span>
<span class="sd">    [1] Covariance matrix not calculated.</span>

<span class="sd">    *Displaying iteration progress*</span>

<span class="sd">    To display information about the EM iterations, use the `disp` argument.</span>

<span class="sd">    &gt;&gt;&gt; mod = sm.tsa.DynamicFactorMQ(endog)</span>
<span class="sd">    &gt;&gt;&gt; res = mod.fit(disp=10)</span>
<span class="sd">    EM start iterations, llf=-291.21</span>
<span class="sd">    EM iteration 10, llf=-157.17, convergence criterion=0.053801</span>
<span class="sd">    EM iteration 20, llf=-128.99, convergence criterion=0.0035545</span>
<span class="sd">    EM iteration 30, llf=-127.97, convergence criterion=0.00010224</span>
<span class="sd">    EM iteration 40, llf=-127.93, convergence criterion=1.3281e-05</span>
<span class="sd">    EM iteration 50, llf=-127.92, convergence criterion=5.4725e-06</span>
<span class="sd">    EM iteration 60, llf=-127.91, convergence criterion=2.8665e-06</span>
<span class="sd">    EM iteration 70, llf=-127.91, convergence criterion=1.6999e-06</span>
<span class="sd">    EM iteration 80, llf=-127.91, convergence criterion=1.1085e-06</span>
<span class="sd">    EM converged at iteration 83, llf=-127.91,</span>
<span class="sd">       convergence criterion=9.9004e-07 &lt; tolerance=1e-06</span>

<span class="sd">    **Results: forecasting, impulse responses, and more**</span>

<span class="sd">    One the model is fitted, there are a number of methods available from the</span>
<span class="sd">    results object. Some examples include:</span>

<span class="sd">    *Forecasting*</span>

<span class="sd">    &gt;&gt;&gt; mod = sm.tsa.DynamicFactorMQ(endog)</span>
<span class="sd">    &gt;&gt;&gt; res = mod.fit()</span>
<span class="sd">    &gt;&gt;&gt; print(res.forecast(steps=5))</span>
<span class="sd">                 infl  tbilrate</span>
<span class="sd">    2009-10  1.784169  0.260401</span>
<span class="sd">    2009-11  1.735848  0.305981</span>
<span class="sd">    2009-12  1.730674  0.350968</span>
<span class="sd">    2010-01  1.742110  0.395369</span>
<span class="sd">    2010-02  1.759786  0.439194</span>

<span class="sd">    *Impulse responses*</span>

<span class="sd">    &gt;&gt;&gt; mod = sm.tsa.DynamicFactorMQ(endog)</span>
<span class="sd">    &gt;&gt;&gt; res = mod.fit()</span>
<span class="sd">    &gt;&gt;&gt; print(res.impulse_responses(steps=5))</span>
<span class="sd">           infl  tbilrate</span>
<span class="sd">    0 -1.511956 -1.341498</span>
<span class="sd">    1 -1.483172 -1.315960</span>
<span class="sd">    2 -1.454937 -1.290908</span>
<span class="sd">    3 -1.427240 -1.266333</span>
<span class="sd">    4 -1.400069 -1.242226</span>
<span class="sd">    5 -1.373416 -1.218578</span>

<span class="sd">    For other available methods (including in-sample prediction, simulation of</span>
<span class="sd">    time series, extending the results to incorporate new data, and the news),</span>
<span class="sd">    see the documentation for state space models.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Babura, Marta, and Michele Modugno.</span>
<span class="sd">           &quot;Maximum likelihood estimation of factor models on datasets with</span>
<span class="sd">           arbitrary pattern of missing data.&quot;</span>
<span class="sd">           Journal of Applied Econometrics 29, no. 1 (2014): 133-160.</span>
<span class="sd">    .. [2] Babura, Marta, Domenico Giannone, and Lucrezia Reichlin.</span>
<span class="sd">           &quot;Nowcasting.&quot;</span>
<span class="sd">           The Oxford Handbook of Economic Forecasting. July 8, 2011.</span>
<span class="sd">    .. [3] Bok, Brandyn, Daniele Caratelli, Domenico Giannone,</span>
<span class="sd">           Argia M. Sbordone, and Andrea Tambalotti. 2018.</span>
<span class="sd">           &quot;Macroeconomic Nowcasting and Forecasting with Big Data.&quot;</span>
<span class="sd">           Annual Review of Economics 10 (1): 615-43.</span>
<span class="sd">           https://doi.org/10.1146/annurev-economics-080217-053214.</span>
<span class="sd">    .. [4] Mariano, Roberto S., and Yasutomo Murasawa.</span>
<span class="sd">           &quot;A coincident index, common factors, and monthly real GDP.&quot;</span>
<span class="sd">           Oxford Bulletin of Economics and Statistics 72, no. 1 (2010): 27-46.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">endog</span><span class="p">,</span> <span class="n">k_endog_monthly</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">factors</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">factor_orders</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                 <span class="n">factor_multiplicities</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">idiosyncratic_ar1</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">standardize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">endog_quarterly</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">init_t0</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">obs_cov_diag</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># Handle endog variables</span>
        <span class="k">if</span> <span class="n">endog_quarterly</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">k_endog_monthly</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;If `endog_quarterly` is specified, then&#39;</span>
                                 <span class="s1">&#39; `endog` must contain only monthly&#39;</span>
                                 <span class="s1">&#39; variables, and so `k_endog_monthly` cannot&#39;</span>
                                 <span class="s1">&#39; be specified since it will be inferred from&#39;</span>
                                 <span class="s1">&#39; the shape of `endog`.&#39;</span><span class="p">)</span>
            <span class="n">endog</span><span class="p">,</span> <span class="n">k_endog_monthly</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">construct_endog</span><span class="p">(</span>
                <span class="n">endog</span><span class="p">,</span> <span class="n">endog_quarterly</span><span class="p">)</span>
        <span class="n">endog_is_pandas</span> <span class="o">=</span> <span class="n">_is_using_pandas</span><span class="p">(</span><span class="n">endog</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">endog_is_pandas</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">endog</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">):</span>
                <span class="n">endog</span> <span class="o">=</span> <span class="n">endog</span><span class="o">.</span><span class="n">to_frame</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">endog</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">endog</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">endog</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

        <span class="k">if</span> <span class="n">k_endog_monthly</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">k_endog_monthly</span> <span class="o">=</span> <span class="n">endog</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">endog_is_pandas</span><span class="p">:</span>
            <span class="n">endog_names</span> <span class="o">=</span> <span class="n">endog</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">endog</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">endog_names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">endog_names</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s1">&#39;y</span><span class="si">{</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s1">&#39;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">endog</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">k_endog_M</span> <span class="o">=</span> <span class="n">int_like</span><span class="p">(</span><span class="n">k_endog_monthly</span><span class="p">,</span> <span class="s1">&#39;k_endog_monthly&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k_endog_Q</span> <span class="o">=</span> <span class="n">endog</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog_M</span>

        <span class="c1"># Compute helper for handling factors / state indexing</span>
        <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s</span> <span class="o">=</span> <span class="n">DynamicFactorMQStates</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">k_endog_M</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog_Q</span><span class="p">,</span> <span class="n">endog_names</span><span class="p">,</span> <span class="n">factors</span><span class="p">,</span>
            <span class="n">factor_orders</span><span class="p">,</span> <span class="n">factor_multiplicities</span><span class="p">,</span> <span class="n">idiosyncratic_ar1</span><span class="p">)</span>

        <span class="c1"># Save parameterization</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">factors</span> <span class="o">=</span> <span class="n">factors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">factor_orders</span> <span class="o">=</span> <span class="n">factor_orders</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">factor_multiplicities</span> <span class="o">=</span> <span class="n">factor_multiplicities</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">endog_factor_map</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s</span><span class="o">.</span><span class="n">endog_factor_map</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">factor_block_orders</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s</span><span class="o">.</span><span class="n">factor_block_orders</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">factor_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s</span><span class="o">.</span><span class="n">factor_names</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k_factors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s</span><span class="o">.</span><span class="n">k_factors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k_factor_blocks</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">factor_block_orders</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_factor_order</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s</span><span class="o">.</span><span class="n">max_factor_order</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">idiosyncratic_ar1</span> <span class="o">=</span> <span class="n">idiosyncratic_ar1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">init_t0</span> <span class="o">=</span> <span class="n">init_t0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">obs_cov_diag</span> <span class="o">=</span> <span class="n">obs_cov_diag</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">init_t0</span><span class="p">:</span>
            <span class="c1"># TODO: test each of these options</span>
            <span class="k">if</span> <span class="n">endog_is_pandas</span><span class="p">:</span>
                <span class="n">ix</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">period_range</span><span class="p">(</span><span class="n">endog</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">endog</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                                     <span class="n">freq</span><span class="o">=</span><span class="n">endog</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">freq</span><span class="p">)</span>
                <span class="n">endog</span> <span class="o">=</span> <span class="n">endog</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">ix</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">endog</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">]</span> <span class="o">*</span> <span class="n">endog</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">endog</span><span class="o">.</span><span class="n">T</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>

        <span class="c1"># Standardize endog, if requested</span>
        <span class="c1"># Note: endog_mean and endog_std will always each be 1-dimensional with</span>
        <span class="c1"># length equal to the number of endog variables</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">standardize</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">standardize</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">endog_mean</span><span class="p">,</span> <span class="n">endog_std</span> <span class="o">=</span> <span class="n">standardize</span>

            <span class="c1"># Validate the input</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">endog</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">endog_mean</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span>
                    <span class="n">endog_mean</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">(</span><span class="n">endog_names</span><span class="p">))):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid value passed for `standardize`:&#39;</span>
                                 <span class="s1">&#39; if a Pandas Series, must have index&#39;</span>
                                 <span class="sa">f</span><span class="s1">&#39; </span><span class="si">{</span><span class="n">endog_names</span><span class="si">}</span><span class="s1">. Got </span><span class="si">{</span><span class="n">endog_mean</span><span class="o">.</span><span class="n">index</span><span class="si">}</span><span class="s1">.&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">endog_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">endog_mean</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">endog_std</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span>
                    <span class="n">endog_std</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">(</span><span class="n">endog_names</span><span class="p">))):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid value passed for `standardize`:&#39;</span>
                                 <span class="s1">&#39; if a Pandas Series, must have index&#39;</span>
                                 <span class="sa">f</span><span class="s1">&#39; </span><span class="si">{</span><span class="n">endog_names</span><span class="si">}</span><span class="s1">. Got </span><span class="si">{</span><span class="n">endog_std</span><span class="o">.</span><span class="n">index</span><span class="si">}</span><span class="s1">.&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">endog_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">endog_std</span><span class="p">)</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">endog_mean</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="n">n</span><span class="p">,)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">endog_std</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="n">n</span><span class="p">,)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid value passed for `standardize`: each&#39;</span>
                                 <span class="sa">f</span><span class="s1">&#39; element must be shaped (</span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s1">,).&#39;</span><span class="p">)</span>
            <span class="n">standardize</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="c1"># Make sure we have Pandas if endog is Pandas</span>
            <span class="k">if</span> <span class="n">endog_is_pandas</span><span class="p">:</span>
                <span class="n">endog_mean</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">endog_mean</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">endog_names</span><span class="p">)</span>
                <span class="n">endog_std</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">endog_std</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">endog_names</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">standardize</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="kc">True</span><span class="p">]:</span>
            <span class="n">endog_mean</span> <span class="o">=</span> <span class="n">endog</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">endog_std</span> <span class="o">=</span> <span class="n">endog</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">standardize</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="kc">False</span><span class="p">]:</span>
            <span class="n">endog_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">endog</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">endog_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">endog</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid value passed for `standardize`.&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_endog_mean</span> <span class="o">=</span> <span class="n">endog_mean</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_endog_std</span> <span class="o">=</span> <span class="n">endog_std</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">standardize</span> <span class="o">=</span> <span class="n">standardize</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_endog_std</span> <span class="o">&lt;</span> <span class="mf">1e-10</span><span class="p">):</span>
            <span class="n">ix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_endog_std</span> <span class="o">&lt;</span> <span class="mf">1e-10</span><span class="p">)</span>
            <span class="n">names</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">endog_names</span><span class="p">)[</span><span class="n">ix</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Constant variable(s) found in observed&#39;</span>
                             <span class="s1">&#39; variables, but constants cannot be included&#39;</span>
                             <span class="sa">f</span><span class="s1">&#39; in this model. These variables are: </span><span class="si">{</span><span class="n">names</span><span class="si">}</span><span class="s1">.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">standardize</span><span class="p">:</span>
            <span class="n">endog</span> <span class="o">=</span> <span class="p">(</span><span class="n">endog</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_endog_mean</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_endog_std</span>

        <span class="c1"># Observation / states slices</span>
        <span class="n">o</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_o</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;M&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">s_</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">k_endog_M</span><span class="p">],</span>
            <span class="s1">&#39;Q&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">s_</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">k_endog_M</span><span class="p">:]}</span>

        <span class="c1"># Construct the basic state space representation</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">endog</span><span class="p">,</span> <span class="n">k_states</span><span class="o">=</span><span class="n">s</span><span class="o">.</span><span class="n">k_states</span><span class="p">,</span> <span class="n">k_posdef</span><span class="o">=</span><span class="n">s</span><span class="o">.</span><span class="n">k_posdef</span><span class="p">,</span>
                         <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Revert the standardization for orig_endog</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">standardize</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">orig_endog</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">orig_endog</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_endog_std</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_endog_mean</span><span class="p">)</span>

        <span class="c1"># State initialization</span>
        <span class="c1"># Note: we could just initialize the entire thing as stationary, but</span>
        <span class="c1"># doing each block separately should be faster and avoid numerical</span>
        <span class="c1"># issues</span>
        <span class="k">if</span> <span class="s1">&#39;initialization&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">initialize</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_default_initialization</span><span class="p">())</span>

        <span class="c1"># Fixed components of the state space representation</span>

        <span class="c1"># &gt; design</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">idiosyncratic_ar1</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;design&#39;</span><span class="p">,</span> <span class="n">o</span><span class="p">[</span><span class="s1">&#39;M&#39;</span><span class="p">],</span> <span class="n">s</span><span class="p">[</span><span class="s1">&#39;idio_ar_M&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_endog_M</span><span class="p">)</span>
        <span class="n">multipliers</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">multipliers</span><span class="p">)):</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">multipliers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;design&#39;</span><span class="p">,</span> <span class="n">o</span><span class="p">[</span><span class="s1">&#39;Q&#39;</span><span class="p">],</span> <span class="n">s</span><span class="p">[</span><span class="s1">&#39;idio_ar_Q_ix&#39;</span><span class="p">][:,</span> <span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">m</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_endog_Q</span><span class="p">))</span>

        <span class="c1"># &gt; obs cov</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">obs_cov_diag</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;obs_cov&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">)</span> <span class="o">*</span> <span class="mf">1e-4</span>

        <span class="c1"># &gt; transition</span>
        <span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="n">s</span><span class="o">.</span><span class="n">factor_blocks</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">block</span><span class="o">.</span><span class="n">k_factors</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">tmp</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">block</span><span class="o">.</span><span class="n">k_factors</span><span class="p">,</span> <span class="n">block</span><span class="o">.</span><span class="n">k_factors</span><span class="p">))</span>
            <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;transition&#39;</span><span class="p">,</span> <span class="n">block</span><span class="p">[</span><span class="s1">&#39;factors&#39;</span><span class="p">],</span> <span class="n">block</span><span class="p">[</span><span class="s1">&#39;factors&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">companion_matrix</span><span class="p">([</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">tmp</span><span class="p">]</span> <span class="o">*</span> <span class="n">block</span><span class="o">.</span><span class="n">_factor_order</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog_Q</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">k_endog_Q</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog_Q</span><span class="p">))</span>
        <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;transition&#39;</span><span class="p">,</span> <span class="n">s</span><span class="p">[</span><span class="s1">&#39;idio_ar_Q&#39;</span><span class="p">],</span> <span class="n">s</span><span class="p">[</span><span class="s1">&#39;idio_ar_Q&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">companion_matrix</span><span class="p">([</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">tmp</span><span class="p">]</span> <span class="o">*</span> <span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

        <span class="c1"># &gt; selection</span>
        <span class="n">ix1</span> <span class="o">=</span> <span class="n">ix2</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="n">s</span><span class="o">.</span><span class="n">factor_blocks</span><span class="p">:</span>
            <span class="n">ix2</span> <span class="o">+=</span> <span class="n">block</span><span class="o">.</span><span class="n">k_factors</span>
            <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;selection&#39;</span><span class="p">,</span> <span class="n">block</span><span class="p">[</span><span class="s1">&#39;factors_ix&#39;</span><span class="p">][:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">ix1</span><span class="p">:</span><span class="n">ix2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">block</span><span class="o">.</span><span class="n">k_factors</span><span class="p">))</span>
            <span class="n">ix1</span> <span class="o">=</span> <span class="n">ix2</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">idiosyncratic_ar1</span><span class="p">:</span>
            <span class="n">ix2</span> <span class="o">=</span> <span class="n">ix1</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog_M</span>
            <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;selection&#39;</span><span class="p">,</span> <span class="n">s</span><span class="p">[</span><span class="s1">&#39;idio_ar_M&#39;</span><span class="p">],</span> <span class="n">ix1</span><span class="p">:</span><span class="n">ix2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_endog_M</span><span class="p">)</span>
            <span class="n">ix1</span> <span class="o">=</span> <span class="n">ix2</span>

        <span class="n">ix2</span> <span class="o">=</span> <span class="n">ix1</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog_Q</span>
        <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;selection&#39;</span><span class="p">,</span> <span class="n">s</span><span class="p">[</span><span class="s1">&#39;idio_ar_Q_ix&#39;</span><span class="p">][:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">ix1</span><span class="p">:</span><span class="n">ix2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_endog_Q</span><span class="p">))</span>

        <span class="c1"># Parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">params</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">([</span>
            <span class="p">(</span><span class="s1">&#39;loadings&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endog_factor_map</span><span class="o">.</span><span class="n">values</span><span class="p">)),</span>
            <span class="p">(</span><span class="s1">&#39;factor_ar&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">block</span><span class="o">.</span><span class="n">k_factors</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">block</span><span class="o">.</span><span class="n">factor_order</span>
                                  <span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="n">s</span><span class="o">.</span><span class="n">factor_blocks</span><span class="p">])),</span>
            <span class="p">(</span><span class="s1">&#39;factor_cov&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">block</span><span class="o">.</span><span class="n">k_factors</span> <span class="o">*</span> <span class="p">(</span><span class="n">block</span><span class="o">.</span><span class="n">k_factors</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
                                   <span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="n">s</span><span class="o">.</span><span class="n">factor_blocks</span><span class="p">])),</span>
            <span class="p">(</span><span class="s1">&#39;idiosyncratic_ar1&#39;</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">idiosyncratic_ar1</span> <span class="k">else</span> <span class="mi">0</span><span class="p">),</span>
            <span class="p">(</span><span class="s1">&#39;idiosyncratic_var&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">)])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k_params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>

        <span class="c1"># Parameter slices</span>
        <span class="n">ix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_params</span><span class="p">),</span>
                      <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">values</span><span class="p">()))[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_p</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span> <span class="n">ix</span><span class="p">))</span>

        <span class="c1"># Cache</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_loading_constraints</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># Initialization kwarg keys, e.g. for cloning</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_init_keys</span> <span class="o">+=</span> <span class="p">[</span>
            <span class="s1">&#39;factors&#39;</span><span class="p">,</span> <span class="s1">&#39;factor_orders&#39;</span><span class="p">,</span> <span class="s1">&#39;factor_multiplicities&#39;</span><span class="p">,</span>
            <span class="s1">&#39;idiosyncratic_ar1&#39;</span><span class="p">,</span> <span class="s1">&#39;standardize&#39;</span><span class="p">,</span> <span class="s1">&#39;init_t0&#39;</span><span class="p">,</span>
            <span class="s1">&#39;obs_cov_diag&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

<div class="viewcode-block" id="DynamicFactorMQ.construct_endog">
<a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.dynamic_factor_mq.DynamicFactorMQ.construct_endog.html#statsmodels.tsa.statespace.dynamic_factor_mq.DynamicFactorMQ.construct_endog">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">construct_endog</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">endog_monthly</span><span class="p">,</span> <span class="n">endog_quarterly</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a combined dataset from separate monthly and quarterly data.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        endog_monthly : array_like</span>
<span class="sd">            Monthly dataset. If a quarterly dataset is given, then this must</span>
<span class="sd">            be a Pandas object with a PeriodIndex or DatetimeIndex at a monthly</span>
<span class="sd">            frequency.</span>
<span class="sd">        endog_quarterly : array_like or None</span>
<span class="sd">            Quarterly dataset. If not None, then this must be a Pandas object</span>
<span class="sd">            with a PeriodIndex or DatetimeIndex at a quarterly frequency.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        endog : array_like</span>
<span class="sd">            If both endog_monthly and endog_quarterly were given, this is a</span>
<span class="sd">            Pandas DataFrame with a PeriodIndex at the monthly frequency, with</span>
<span class="sd">            all of the columns from `endog_monthly` ordered first and the</span>
<span class="sd">            columns from `endog_quarterly` ordered afterwards. Otherwise it is</span>
<span class="sd">            simply the input `endog_monthly` dataset.</span>
<span class="sd">        k_endog_monthly : int</span>
<span class="sd">            The number of monthly variables (which are ordered first) in the</span>
<span class="sd">            returned `endog` dataset.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Create combined dataset</span>
        <span class="k">if</span> <span class="n">endog_quarterly</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Validate endog_monthly</span>
            <span class="n">base_msg</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;If given both monthly and quarterly data&#39;</span>
                        <span class="s1">&#39; then the monthly dataset must be a Pandas&#39;</span>
                        <span class="s1">&#39; object with a date index at a monthly frequency.&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">endog_monthly</span><span class="p">,</span> <span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Given monthly dataset is not a&#39;</span>
                                 <span class="s1">&#39; Pandas object. &#39;</span> <span class="o">+</span> <span class="n">base_msg</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">endog_monthly</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">inferred_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;datetime64&quot;</span><span class="p">,</span>
                                                           <span class="s2">&quot;period&quot;</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Given monthly dataset has an&#39;</span>
                                 <span class="s1">&#39; index with non-date values. &#39;</span> <span class="o">+</span> <span class="n">base_msg</span><span class="p">)</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">endog_monthly</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="s1">&#39;freqstr&#39;</span><span class="p">,</span> <span class="s1">&#39;N&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;M&#39;</span><span class="p">:</span>
                <span class="n">freqstr</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">endog_monthly</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="s1">&#39;freqstr&#39;</span><span class="p">,</span> <span class="s1">&#39;None&#39;</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Index of given monthly dataset has a&#39;</span>
                                 <span class="s1">&#39; non-monthly frequency (to check this,&#39;</span>
                                 <span class="s1">&#39; examine the `freqstr` attribute of the&#39;</span>
                                 <span class="s1">&#39; index of the dataset - it should start with&#39;</span>
                                 <span class="s1">&#39; M if it is monthly).&#39;</span>
                                 <span class="sa">f</span><span class="s1">&#39; Got </span><span class="si">{</span><span class="n">freqstr</span><span class="si">}</span><span class="s1">. &#39;</span> <span class="o">+</span> <span class="n">base_msg</span><span class="p">)</span>

            <span class="c1"># Validate endog_quarterly</span>
            <span class="n">base_msg</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;If a quarterly dataset is given, then it must be a&#39;</span>
                        <span class="s1">&#39; Pandas object with a date index at a quarterly&#39;</span>
                        <span class="s1">&#39; frequency.&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">endog_quarterly</span><span class="p">,</span> <span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Given quarterly dataset is not a&#39;</span>
                                 <span class="s1">&#39; Pandas object. &#39;</span> <span class="o">+</span> <span class="n">base_msg</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">endog_quarterly</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">inferred_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;datetime64&quot;</span><span class="p">,</span>
                                                             <span class="s2">&quot;period&quot;</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Given quarterly dataset has an&#39;</span>
                                 <span class="s1">&#39; index with non-date values. &#39;</span> <span class="o">+</span> <span class="n">base_msg</span><span class="p">)</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">endog_quarterly</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="s1">&#39;freqstr&#39;</span><span class="p">,</span> <span class="s1">&#39;N&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;Q&#39;</span><span class="p">:</span>
                <span class="n">freqstr</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">endog_quarterly</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="s1">&#39;freqstr&#39;</span><span class="p">,</span> <span class="s1">&#39;None&#39;</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Index of given quarterly dataset&#39;</span>
                                 <span class="s1">&#39; has a non-quarterly frequency (to check&#39;</span>
                                 <span class="s1">&#39; this, examine the `freqstr` attribute of&#39;</span>
                                 <span class="s1">&#39; the index of the dataset - it should start&#39;</span>
                                 <span class="s1">&#39; with Q if it is quarterly).&#39;</span>
                                 <span class="sa">f</span><span class="s1">&#39; Got </span><span class="si">{</span><span class="n">freqstr</span><span class="si">}</span><span class="s1">. &#39;</span> <span class="o">+</span> <span class="n">base_msg</span><span class="p">)</span>

            <span class="c1"># Convert to PeriodIndex, if applicable</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">endog_monthly</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="s1">&#39;to_period&#39;</span><span class="p">):</span>
                <span class="n">endog_monthly</span> <span class="o">=</span> <span class="n">endog_monthly</span><span class="o">.</span><span class="n">to_period</span><span class="p">(</span><span class="s1">&#39;M&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">endog_quarterly</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="s1">&#39;to_period&#39;</span><span class="p">):</span>
                <span class="n">endog_quarterly</span> <span class="o">=</span> <span class="n">endog_quarterly</span><span class="o">.</span><span class="n">to_period</span><span class="p">(</span><span class="s1">&#39;Q&#39;</span><span class="p">)</span>

            <span class="c1"># Combine the datasets</span>
            <span class="n">quarterly_resamp</span> <span class="o">=</span> <span class="n">endog_quarterly</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">quarterly_resamp</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">quarterly_resamp</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">to_timestamp</span><span class="p">()</span>
            <span class="n">quarterly_resamp</span> <span class="o">=</span> <span class="n">quarterly_resamp</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span><span class="n">QUARTER_END</span><span class="p">)</span><span class="o">.</span><span class="n">first</span><span class="p">()</span>
            <span class="n">quarterly_resamp</span> <span class="o">=</span> <span class="n">quarterly_resamp</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span><span class="n">MONTH_END</span><span class="p">)</span><span class="o">.</span><span class="n">first</span><span class="p">()</span>
            <span class="n">quarterly_resamp</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">quarterly_resamp</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">to_period</span><span class="p">()</span>

            <span class="n">endog</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">endog_monthly</span><span class="p">,</span> <span class="n">quarterly_resamp</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

            <span class="c1"># Make sure we didn&#39;t accidentally get duplicate column names</span>
            <span class="n">column_counts</span> <span class="o">=</span> <span class="n">endog</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">value_counts</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">column_counts</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">columns</span> <span class="o">=</span> <span class="n">endog</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">object</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">column_counts</span><span class="o">.</span><span class="n">index</span><span class="p">:</span>
                    <span class="n">count</span> <span class="o">=</span> <span class="n">column_counts</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">count</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="n">mask</span> <span class="o">=</span> <span class="n">columns</span> <span class="o">==</span> <span class="n">name</span>
                    <span class="n">columns</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}{</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s1">&#39;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">count</span><span class="p">)]</span>
                <span class="n">endog</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="n">columns</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">endog</span> <span class="o">=</span> <span class="n">endog_monthly</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="n">endog_monthly</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">k_endog_monthly</span> <span class="o">=</span> <span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="k">else</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">endog</span><span class="p">,</span> <span class="n">k_endog_monthly</span></div>


<div class="viewcode-block" id="DynamicFactorMQ.clone">
<a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.dynamic_factor_mq.DynamicFactorMQ.clone.html#statsmodels.tsa.statespace.dynamic_factor_mq.DynamicFactorMQ.clone">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">clone</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">endog</span><span class="p">,</span> <span class="n">k_endog_monthly</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">endog_quarterly</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
              <span class="n">retain_standardization</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Clone state space model with new data and optionally new specification.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        endog : array_like</span>
<span class="sd">            The observed time-series process :math:`y`</span>
<span class="sd">        k_endog_monthly : int, optional</span>
<span class="sd">            If specifying a monthly/quarterly mixed frequency model in which</span>
<span class="sd">            the provided `endog` dataset contains both the monthly and</span>
<span class="sd">            quarterly data, this variable should be used to indicate how many</span>
<span class="sd">            of the variables are monthly.</span>
<span class="sd">        endog_quarterly : array_like, optional</span>
<span class="sd">            Observations of quarterly variables. If provided, must be a</span>
<span class="sd">            Pandas Series or DataFrame with a DatetimeIndex or PeriodIndex at</span>
<span class="sd">            the quarterly frequency.</span>
<span class="sd">        kwargs</span>
<span class="sd">            Keyword arguments to pass to the new model class to change the</span>
<span class="sd">            model specification.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        model : DynamicFactorMQ instance</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">retain_standardization</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">standardize</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;standardize&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_endog_mean</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_endog_std</span><span class="p">)</span>
        <span class="n">mod</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_clone_from_init_kwds</span><span class="p">(</span>
            <span class="n">endog</span><span class="p">,</span> <span class="n">k_endog_monthly</span><span class="o">=</span><span class="n">k_endog_monthly</span><span class="p">,</span>
            <span class="n">endog_quarterly</span><span class="o">=</span><span class="n">endog_quarterly</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">mod</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_res_classes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;fit&#39;</span><span class="p">:</span> <span class="p">(</span><span class="n">DynamicFactorMQResults</span><span class="p">,</span> <span class="n">mlemodel</span><span class="o">.</span><span class="n">MLEResultsWrapper</span><span class="p">)}</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_default_initialization</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s</span>
        <span class="n">init</span> <span class="o">=</span> <span class="n">initialization</span><span class="o">.</span><span class="n">Initialization</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_states</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="n">s</span><span class="o">.</span><span class="n">factor_blocks</span><span class="p">:</span>
            <span class="n">init</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">block</span><span class="p">[</span><span class="s1">&#39;factors&#39;</span><span class="p">],</span> <span class="s1">&#39;stationary&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">idiosyncratic_ar1</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="s1">&#39;idio_ar_M&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">s</span><span class="p">[</span><span class="s1">&#39;idio_ar_M&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">stop</span><span class="p">):</span>
                <span class="n">init</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="s1">&#39;stationary&#39;</span><span class="p">)</span>
        <span class="n">init</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="s1">&#39;idio_ar_Q&#39;</span><span class="p">],</span> <span class="s1">&#39;stationary&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">init</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_endog_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">truncate</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">as_string</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">truncate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">truncate</span> <span class="o">=</span> <span class="kc">False</span> <span class="k">if</span> <span class="n">as_string</span> <span class="ow">is</span> <span class="kc">False</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">24</span>
        <span class="k">if</span> <span class="n">as_string</span> <span class="ow">is</span> <span class="kc">False</span> <span class="ow">and</span> <span class="n">truncate</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Can only truncate endog names if they&#39;</span>
                             <span class="s1">&#39; are returned as a string.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">as_string</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">as_string</span> <span class="o">=</span> <span class="n">truncate</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span>

        <span class="c1"># The base `endog_names` property is only a list if there are at least</span>
        <span class="c1"># two variables; often, we need it to be a list</span>
        <span class="n">endog_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">endog_names</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">endog_names</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">endog_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">endog_names</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">as_string</span><span class="p">:</span>
            <span class="n">endog_names</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">endog_names</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">truncate</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">truncate</span>
            <span class="n">endog_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">name</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">n</span> <span class="k">else</span> <span class="n">name</span><span class="p">[:</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;...&#39;</span>
                           <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">endog_names</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">endog_names</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_model_name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">model_name</span> <span class="o">=</span> <span class="p">[</span>
            <span class="s1">&#39;Dynamic Factor Model&#39;</span><span class="p">,</span>
            <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">k_factors</span><span class="si">}</span><span class="s1"> factors in </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">k_factor_blocks</span><span class="si">}</span><span class="s1"> blocks&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog_Q</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">model_name</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;Mixed frequency (M/Q)&#39;</span><span class="p">)</span>

        <span class="n">error_type</span> <span class="o">=</span> <span class="s1">&#39;AR(1)&#39;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">idiosyncratic_ar1</span> <span class="k">else</span> <span class="s1">&#39;iid&#39;</span>
        <span class="n">model_name</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">error_type</span><span class="si">}</span><span class="s1"> idiosyncratic&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">model_name</span>

<div class="viewcode-block" id="DynamicFactorMQ.summary">
<a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.dynamic_factor_mq.DynamicFactorMQ.summary.html#statsmodels.tsa.statespace.dynamic_factor_mq.DynamicFactorMQ.summary">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">summary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">truncate_endog_names</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a summary table describing the model.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        truncate_endog_names : int, optional</span>
<span class="sd">            The number of characters to show for names of observed variables.</span>
<span class="sd">            Default is 24 if there is more than one observed variable, or</span>
<span class="sd">            an unlimited number of there is only one.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get endog names</span>
        <span class="n">endog_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_endog_names</span><span class="p">(</span><span class="n">truncate</span><span class="o">=</span><span class="n">truncate_endog_names</span><span class="p">,</span>
                                            <span class="n">as_string</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">title</span> <span class="o">=</span> <span class="s1">&#39;Model Specification: Dynamic Factor Model&#39;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index_dates</span><span class="p">:</span>
            <span class="n">ix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">ix</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">sample</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">d</span><span class="p">]</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">ix</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">sample</span> <span class="o">+=</span> <span class="p">[</span><span class="s1">&#39;- &#39;</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">d</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sample</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="s1">&#39; - &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="p">)]</span>

        <span class="c1"># Standardize the model name as a list of str</span>
        <span class="n">model_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model_name</span>

        <span class="c1"># - Top summary table ------------------------------------------------</span>
        <span class="n">top_left</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">top_left</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s1">&#39;Model:&#39;</span><span class="p">,</span> <span class="p">[</span><span class="n">model_name</span><span class="p">[</span><span class="mi">0</span><span class="p">]]))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">model_name</span><span class="p">)):</span>
            <span class="n">top_left</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;+ &#39;</span> <span class="o">+</span> <span class="n">model_name</span><span class="p">[</span><span class="n">i</span><span class="p">]]))</span>
        <span class="n">top_left</span> <span class="o">+=</span> <span class="p">[</span>
            <span class="p">(</span><span class="s1">&#39;Sample:&#39;</span><span class="p">,</span> <span class="p">[</span><span class="n">sample</span><span class="p">[</span><span class="mi">0</span><span class="p">]]),</span>
            <span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="p">[</span><span class="n">sample</span><span class="p">[</span><span class="mi">1</span><span class="p">]])]</span>

        <span class="n">top_right</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog_Q</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">top_right</span> <span class="o">+=</span> <span class="p">[</span>
                <span class="p">(</span><span class="s1">&#39;# of monthly variables:&#39;</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">k_endog_M</span><span class="p">]),</span>
                <span class="p">(</span><span class="s1">&#39;# of quarterly variables:&#39;</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">k_endog_Q</span><span class="p">])]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">top_right</span> <span class="o">+=</span> <span class="p">[(</span><span class="s1">&#39;# of observed variables:&#39;</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">])]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_factor_blocks</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">top_right</span> <span class="o">+=</span> <span class="p">[(</span><span class="s1">&#39;# of factors:&#39;</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">k_factors</span><span class="p">])]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">top_right</span> <span class="o">+=</span> <span class="p">[(</span><span class="s1">&#39;# of factor blocks:&#39;</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">k_factor_blocks</span><span class="p">])]</span>
        <span class="n">top_right</span> <span class="o">+=</span> <span class="p">[(</span><span class="s1">&#39;Idiosyncratic disturbances:&#39;</span><span class="p">,</span>
                       <span class="p">[</span><span class="s1">&#39;AR(1)&#39;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">idiosyncratic_ar1</span> <span class="k">else</span> <span class="s1">&#39;iid&#39;</span><span class="p">]),</span>
                      <span class="p">(</span><span class="s1">&#39;Standardize variables:&#39;</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">standardize</span><span class="p">])]</span>

        <span class="n">summary</span> <span class="o">=</span> <span class="n">Summary</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="n">summary</span><span class="o">.</span><span class="n">add_table_2cols</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gleft</span><span class="o">=</span><span class="n">top_left</span><span class="p">,</span> <span class="n">gright</span><span class="o">=</span><span class="n">top_right</span><span class="p">,</span>
                                <span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">)</span>
        <span class="n">table_ix</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span>

        <span class="c1"># - Endog / factor map -----------------------------------------------</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">endog_factor_map</span><span class="o">.</span><span class="n">replace</span><span class="p">({</span><span class="kc">True</span><span class="p">:</span> <span class="s1">&#39;X&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">:</span> <span class="s1">&#39;&#39;</span><span class="p">})</span>
        <span class="n">data</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">endog_names</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">items</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="c1"># Remove after pandas 1.5 is minimum</span>
            <span class="n">items</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">iteritems</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">items</span><span class="p">:</span>
            <span class="n">data</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="s1">&#39; &#39;</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">))</span>
        <span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;Dep. variable&#39;</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>

        <span class="n">params_data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">values</span>
        <span class="n">params_header</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="n">params_stubs</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">title</span> <span class="o">=</span> <span class="s1">&#39;Observed variables / factor loadings&#39;</span>
        <span class="n">table</span> <span class="o">=</span> <span class="n">SimpleTable</span><span class="p">(</span>
            <span class="n">params_data</span><span class="p">,</span> <span class="n">params_header</span><span class="p">,</span> <span class="n">params_stubs</span><span class="p">,</span>
            <span class="n">txt_fmt</span><span class="o">=</span><span class="n">fmt_params</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">)</span>

        <span class="n">summary</span><span class="o">.</span><span class="n">tables</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">table_ix</span><span class="p">,</span> <span class="n">table</span><span class="p">)</span>
        <span class="n">table_ix</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># - Factor blocks summary table --------------------------------------</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">factor_block_orders</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
        <span class="n">data</span><span class="p">[</span><span class="s1">&#39;block&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;block&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">factor_names</span><span class="p">:</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">factor_names</span><span class="p">))</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">data</span><span class="p">[[</span><span class="s1">&#39;order&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[[</span><span class="s1">&#39;order&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="n">data</span><span class="p">[[</span><span class="s1">&#39;order&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[[</span><span class="s1">&#39;order&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">applymap</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>

        <span class="n">params_data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">values</span>
        <span class="n">params_header</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="n">params_stubs</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">title</span> <span class="o">=</span> <span class="s1">&#39;Factor blocks:&#39;</span>
        <span class="n">table</span> <span class="o">=</span> <span class="n">SimpleTable</span><span class="p">(</span>
            <span class="n">params_data</span><span class="p">,</span> <span class="n">params_header</span><span class="p">,</span> <span class="n">params_stubs</span><span class="p">,</span>
            <span class="n">txt_fmt</span><span class="o">=</span><span class="n">fmt_params</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">)</span>

        <span class="n">summary</span><span class="o">.</span><span class="n">tables</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">table_ix</span><span class="p">,</span> <span class="n">table</span><span class="p">)</span>
        <span class="n">table_ix</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">summary</span></div>


    <span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Summary tables showing model specification.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">summary</span><span class="p">())</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">state_names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;(list of str) List of human readable names for unobserved states.&quot;&quot;&quot;</span>
        <span class="c1"># Factors</span>
        <span class="n">state_names</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s</span><span class="o">.</span><span class="n">factor_blocks</span><span class="p">:</span>
            <span class="n">state_names</span> <span class="o">+=</span> <span class="p">[</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1">&#39;</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">block</span><span class="o">.</span><span class="n">factor_names</span><span class="p">[:]]</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">block</span><span class="o">.</span><span class="n">_factor_order</span><span class="p">):</span>
                <span class="n">state_names</span> <span class="o">+=</span> <span class="p">[</span><span class="sa">f</span><span class="s1">&#39;L</span><span class="si">{</span><span class="n">s</span><span class="si">}</span><span class="s1">.</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1">&#39;</span>
                                <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">block</span><span class="o">.</span><span class="n">factor_names</span><span class="p">]</span>

        <span class="c1"># Monthly error</span>
        <span class="n">endog_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_endog_names</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">idiosyncratic_ar1</span><span class="p">:</span>
            <span class="n">endog_names_M</span> <span class="o">=</span> <span class="n">endog_names</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_o</span><span class="p">[</span><span class="s1">&#39;M&#39;</span><span class="p">]]</span>
            <span class="n">state_names</span> <span class="o">+=</span> <span class="p">[</span><span class="sa">f</span><span class="s1">&#39;eps_M.</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1">&#39;</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">endog_names_M</span><span class="p">]</span>
        <span class="n">endog_names_Q</span> <span class="o">=</span> <span class="n">endog_names</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_o</span><span class="p">[</span><span class="s1">&#39;Q&#39;</span><span class="p">]]</span>

        <span class="c1"># Quarterly error</span>
        <span class="n">state_names</span> <span class="o">+=</span> <span class="p">[</span><span class="sa">f</span><span class="s1">&#39;eps_Q.</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1">&#39;</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">endog_names_Q</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">):</span>
            <span class="n">state_names</span> <span class="o">+=</span> <span class="p">[</span><span class="sa">f</span><span class="s1">&#39;L</span><span class="si">{</span><span class="n">s</span><span class="si">}</span><span class="s1">.eps_Q.</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1">&#39;</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">endog_names_Q</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">state_names</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">param_names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;(list of str) List of human readable parameter names.&quot;&quot;&quot;</span>
        <span class="n">param_names</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># Loadings</span>
        <span class="c1"># So that Lambda = params[ix].reshape(self.k_endog, self.k_factors)</span>
        <span class="c1"># (where Lambda stacks Lambda_M and Lambda_Q)</span>
        <span class="n">endog_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_endog_names</span><span class="p">(</span><span class="n">as_string</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">endog_name</span> <span class="ow">in</span> <span class="n">endog_names</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s</span><span class="o">.</span><span class="n">factor_blocks</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">factor_name</span> <span class="ow">in</span> <span class="n">block</span><span class="o">.</span><span class="n">factor_names</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">endog_factor_map</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">endog_name</span><span class="p">,</span> <span class="n">factor_name</span><span class="p">]:</span>
                        <span class="n">param_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s1">&#39;loading.</span><span class="si">{</span><span class="n">factor_name</span><span class="si">}</span><span class="s1">-&gt;</span><span class="si">{</span><span class="n">endog_name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="c1"># Factor VAR</span>
        <span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s</span><span class="o">.</span><span class="n">factor_blocks</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">to_factor</span> <span class="ow">in</span> <span class="n">block</span><span class="o">.</span><span class="n">factor_names</span><span class="p">:</span>
                <span class="n">param_names</span> <span class="o">+=</span> <span class="p">[</span><span class="sa">f</span><span class="s1">&#39;L</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">.</span><span class="si">{</span><span class="n">from_factor</span><span class="si">}</span><span class="s1">-&gt;</span><span class="si">{</span><span class="n">to_factor</span><span class="si">}</span><span class="s1">&#39;</span>
                                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">block</span><span class="o">.</span><span class="n">factor_order</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                                <span class="k">for</span> <span class="n">from_factor</span> <span class="ow">in</span> <span class="n">block</span><span class="o">.</span><span class="n">factor_names</span><span class="p">]</span>

        <span class="c1"># Factor covariance</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_s</span><span class="o">.</span><span class="n">factor_blocks</span><span class="p">)):</span>
            <span class="n">block</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s</span><span class="o">.</span><span class="n">factor_blocks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">param_names</span> <span class="o">+=</span> <span class="p">[</span><span class="sa">f</span><span class="s1">&#39;fb(</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">).cov.chol[</span><span class="si">{</span><span class="n">j</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s1">,</span><span class="si">{</span><span class="n">k</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s1">]&#39;</span>
                            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">block</span><span class="o">.</span><span class="n">k_factors</span><span class="p">)</span>
                            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>

        <span class="c1"># Error AR(1)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">idiosyncratic_ar1</span><span class="p">:</span>
            <span class="n">endog_names_M</span> <span class="o">=</span> <span class="n">endog_names</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_o</span><span class="p">[</span><span class="s1">&#39;M&#39;</span><span class="p">]]</span>
            <span class="n">param_names</span> <span class="o">+=</span> <span class="p">[</span><span class="sa">f</span><span class="s1">&#39;L1.eps_M.</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1">&#39;</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">endog_names_M</span><span class="p">]</span>

            <span class="n">endog_names_Q</span> <span class="o">=</span> <span class="n">endog_names</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_o</span><span class="p">[</span><span class="s1">&#39;Q&#39;</span><span class="p">]]</span>
            <span class="n">param_names</span> <span class="o">+=</span> <span class="p">[</span><span class="sa">f</span><span class="s1">&#39;L1.eps_Q.</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1">&#39;</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">endog_names_Q</span><span class="p">]</span>

        <span class="c1"># Error innovation variances</span>
        <span class="n">param_names</span> <span class="o">+=</span> <span class="p">[</span><span class="sa">f</span><span class="s1">&#39;sigma2.</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1">&#39;</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">endog_names</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">param_names</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">start_params</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;(array) Starting parameters for maximum likelihood estimation.&quot;&quot;&quot;</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_params</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

        <span class="c1"># (1) estimate factors one at a time, where the first step uses</span>
        <span class="c1"># PCA on all `endog` variables that load on the first factor, and</span>
        <span class="c1"># subsequent steps use residuals from the previous steps.</span>
        <span class="c1"># TODO: what about factors that only load on quarterly variables?</span>
        <span class="n">endog_factor_map_M</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">endog_factor_map</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">k_endog_M</span><span class="p">]</span>
        <span class="n">factors</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">endog</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">require</span><span class="p">(</span>
            <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endog</span><span class="p">)</span><span class="o">.</span><span class="n">interpolate</span><span class="p">()</span><span class="o">.</span><span class="n">bfill</span><span class="p">(),</span>
            <span class="n">requirements</span><span class="o">=</span><span class="s2">&quot;W&quot;</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">factor_names</span><span class="p">:</span>
            <span class="c1"># Try to retrieve this from monthly variables, which is most</span>
            <span class="c1"># consistent</span>
            <span class="n">endog_ix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">endog_factor_map_M</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">name</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
            <span class="c1"># But fall back to quarterly if necessary</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">endog_ix</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">endog_ix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endog_factor_map</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">name</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">factor_endog</span> <span class="o">=</span> <span class="n">endog</span><span class="p">[:,</span> <span class="n">endog_ix</span><span class="p">]</span>

            <span class="n">res_pca</span> <span class="o">=</span> <span class="n">PCA</span><span class="p">(</span><span class="n">factor_endog</span><span class="p">,</span> <span class="n">ncomp</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;eig&#39;</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">factors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">res_pca</span><span class="o">.</span><span class="n">factors</span><span class="p">)</span>
            <span class="n">endog</span><span class="p">[:,</span> <span class="n">endog_ix</span><span class="p">]</span> <span class="o">-=</span> <span class="n">res_pca</span><span class="o">.</span><span class="n">projection</span>
        <span class="n">factors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">factors</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># (2) Estimate coefficients for each endog, one at a time (OLS for</span>
        <span class="c1"># monthly variables, restricted OLS for quarterly). Also, compute</span>
        <span class="c1"># residuals.</span>
        <span class="n">loadings</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">resid</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_endog_M</span><span class="p">):</span>
            <span class="n">factor_ix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s</span><span class="o">.</span><span class="n">endog_factor_iloc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">factor_exog</span> <span class="o">=</span> <span class="n">factors</span><span class="p">[:,</span> <span class="n">factor_ix</span><span class="p">]</span>
            <span class="n">mod_ols</span> <span class="o">=</span> <span class="n">OLS</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endog</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span> <span class="n">exog</span><span class="o">=</span><span class="n">factor_exog</span><span class="p">,</span> <span class="n">missing</span><span class="o">=</span><span class="s1">&#39;drop&#39;</span><span class="p">)</span>
            <span class="n">res_ols</span> <span class="o">=</span> <span class="n">mod_ols</span><span class="o">.</span><span class="n">fit</span><span class="p">()</span>
            <span class="n">loadings</span> <span class="o">+=</span> <span class="n">res_ols</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="n">resid</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">res_ols</span><span class="o">.</span><span class="n">resid</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_endog_M</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">):</span>
            <span class="n">factor_ix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s</span><span class="o">.</span><span class="n">endog_factor_iloc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">factor_exog</span> <span class="o">=</span> <span class="n">lagmat</span><span class="p">(</span><span class="n">factors</span><span class="p">[:,</span> <span class="n">factor_ix</span><span class="p">],</span> <span class="mi">4</span><span class="p">,</span> <span class="n">original</span><span class="o">=</span><span class="s1">&#39;in&#39;</span><span class="p">)</span>
            <span class="n">mod_glm</span> <span class="o">=</span> <span class="n">GLM</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endog</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span> <span class="n">factor_exog</span><span class="p">,</span> <span class="n">missing</span><span class="o">=</span><span class="s1">&#39;drop&#39;</span><span class="p">)</span>
            <span class="n">res_glm</span> <span class="o">=</span> <span class="n">mod_glm</span><span class="o">.</span><span class="n">fit_constrained</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loading_constraints</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
            <span class="n">loadings</span> <span class="o">+=</span> <span class="n">res_glm</span><span class="o">.</span><span class="n">params</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">factor_ix</span><span class="p">)]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="n">resid</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">res_glm</span><span class="o">.</span><span class="n">resid_response</span><span class="p">)</span>
        <span class="n">params</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_p</span><span class="p">[</span><span class="s1">&#39;loadings&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">loadings</span>

        <span class="c1"># (3) For each factor block, use an AR or VAR model to get coefficients</span>
        <span class="c1"># and covariance estimate</span>
        <span class="c1"># Factor transitions</span>
        <span class="n">stationary</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="n">factor_ar</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">factor_cov</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s</span><span class="o">.</span><span class="n">factor_blocks</span><span class="p">:</span>
            <span class="n">factors_endog</span> <span class="o">=</span> <span class="n">factors</span><span class="p">[:,</span> <span class="n">i</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="n">block</span><span class="o">.</span><span class="n">k_factors</span><span class="p">]</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="n">block</span><span class="o">.</span><span class="n">k_factors</span>

            <span class="k">if</span> <span class="n">block</span><span class="o">.</span><span class="n">factor_order</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="n">block</span><span class="o">.</span><span class="n">k_factors</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">mod_factors</span> <span class="o">=</span> <span class="n">SARIMAX</span><span class="p">(</span><span class="n">factors_endog</span><span class="p">,</span>
                                      <span class="n">order</span><span class="o">=</span><span class="p">(</span><span class="n">block</span><span class="o">.</span><span class="n">factor_order</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
                <span class="n">sp</span> <span class="o">=</span> <span class="n">mod_factors</span><span class="o">.</span><span class="n">start_params</span>
                <span class="n">block_factor_ar</span> <span class="o">=</span> <span class="n">sp</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">block_factor_cov</span> <span class="o">=</span> <span class="n">sp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">:]</span>

                <span class="n">coefficient_matrices</span> <span class="o">=</span> <span class="n">mod_factors</span><span class="o">.</span><span class="n">start_params</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">block</span><span class="o">.</span><span class="n">k_factors</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">mod_factors</span> <span class="o">=</span> <span class="n">VAR</span><span class="p">(</span><span class="n">factors_endog</span><span class="p">)</span>
                <span class="n">res_factors</span> <span class="o">=</span> <span class="n">mod_factors</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span>
                    <span class="n">maxlags</span><span class="o">=</span><span class="n">block</span><span class="o">.</span><span class="n">factor_order</span><span class="p">,</span> <span class="n">ic</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">trend</span><span class="o">=</span><span class="s1">&#39;n&#39;</span><span class="p">)</span>

                <span class="n">block_factor_ar</span> <span class="o">=</span> <span class="n">res_factors</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
                <span class="n">L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">cholesky</span><span class="p">(</span><span class="n">res_factors</span><span class="o">.</span><span class="n">sigma_u</span><span class="p">)</span>
                <span class="n">block_factor_cov</span> <span class="o">=</span> <span class="n">L</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">tril_indices_from</span><span class="p">(</span><span class="n">L</span><span class="p">)]</span>

                <span class="n">coefficient_matrices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">block_factor_ar</span><span class="p">,</span>
                               <span class="p">(</span><span class="n">block</span><span class="o">.</span><span class="n">k_factors</span><span class="p">,</span> <span class="n">block</span><span class="o">.</span><span class="n">k_factors</span><span class="p">,</span>
                                <span class="n">block</span><span class="o">.</span><span class="n">factor_order</span><span class="p">)),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

            <span class="c1"># Test for stationarity</span>
            <span class="n">stationary</span> <span class="o">=</span> <span class="n">is_invertible</span><span class="p">([</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="o">-</span><span class="n">coefficient_matrices</span><span class="p">))</span>

            <span class="c1"># Check for stationarity</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">stationary</span><span class="p">:</span>
                <span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Non-stationary starting factor autoregressive&#39;</span>
                     <span class="s1">&#39; parameters found for factor block&#39;</span>
                     <span class="sa">f</span><span class="s1">&#39; </span><span class="si">{</span><span class="n">block</span><span class="o">.</span><span class="n">factor_names</span><span class="si">}</span><span class="s1">. Using zeros as starting&#39;</span>
                     <span class="s1">&#39; parameters.&#39;</span><span class="p">)</span>
                <span class="n">block_factor_ar</span><span class="p">[:]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">cov_factor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">factors_endog</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
                <span class="n">block_factor_cov</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">cov_factor</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">tril_indices</span><span class="p">(</span><span class="n">block</span><span class="o">.</span><span class="n">k_factors</span><span class="p">)])</span>
            <span class="n">factor_ar</span> <span class="o">+=</span> <span class="n">block_factor_ar</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="n">factor_cov</span> <span class="o">+=</span> <span class="n">block_factor_cov</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="n">params</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_p</span><span class="p">[</span><span class="s1">&#39;factor_ar&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">factor_ar</span>
        <span class="n">params</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_p</span><span class="p">[</span><span class="s1">&#39;factor_cov&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">factor_cov</span>

        <span class="c1"># (4) Use residuals from step (2) to estimate the idiosyncratic</span>
        <span class="c1"># component</span>
        <span class="c1"># Idiosyncratic component</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">idiosyncratic_ar1</span><span class="p">:</span>
            <span class="n">idio_ar1</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">idio_var</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_endog_M</span><span class="p">):</span>
                <span class="n">mod_idio</span> <span class="o">=</span> <span class="n">SARIMAX</span><span class="p">(</span><span class="n">resid</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">order</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">trend</span><span class="o">=</span><span class="s1">&#39;c&#39;</span><span class="p">)</span>
                <span class="n">sp</span> <span class="o">=</span> <span class="n">mod_idio</span><span class="o">.</span><span class="n">start_params</span>
                <span class="n">idio_ar1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">sp</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="mf">0.99</span><span class="p">,</span> <span class="mf">0.99</span><span class="p">))</span>
                <span class="n">idio_var</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">sp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="mf">1e-5</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_endog_M</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">):</span>
                <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">endog</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">y</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">y</span><span class="p">)]</span> <span class="o">=</span> <span class="n">resid</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">mod_idio</span> <span class="o">=</span> <span class="n">QuarterlyAR1</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
                <span class="n">res_idio</span> <span class="o">=</span> <span class="n">mod_idio</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">maxiter</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">return_params</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                        <span class="n">disp</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="n">res_idio</span> <span class="o">=</span> <span class="n">mod_idio</span><span class="o">.</span><span class="n">fit_em</span><span class="p">(</span><span class="n">res_idio</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
                                           <span class="n">return_params</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">idio_ar1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">res_idio</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="mf">0.99</span><span class="p">,</span> <span class="mf">0.99</span><span class="p">))</span>
                <span class="n">idio_var</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">res_idio</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mf">1e-5</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">))</span>
            <span class="n">params</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_p</span><span class="p">[</span><span class="s1">&#39;idiosyncratic_ar1&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">idio_ar1</span>
            <span class="n">params</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_p</span><span class="p">[</span><span class="s1">&#39;idiosyncratic_var&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">idio_var</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">idio_var</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">resid</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_endog_M</span><span class="p">)]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_endog_M</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">):</span>
                <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">endog</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">y</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">y</span><span class="p">)]</span> <span class="o">=</span> <span class="n">resid</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">mod_idio</span> <span class="o">=</span> <span class="n">QuarterlyAR1</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
                <span class="n">res_idio</span> <span class="o">=</span> <span class="n">mod_idio</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">return_params</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">disp</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="n">idio_var</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">res_idio</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mf">1e-5</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">))</span>
            <span class="n">params</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_p</span><span class="p">[</span><span class="s1">&#39;idiosyncratic_var&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">idio_var</span>

        <span class="k">return</span> <span class="n">params</span>

<div class="viewcode-block" id="DynamicFactorMQ.transform_params">
<a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.dynamic_factor_mq.DynamicFactorMQ.transform_params.html#statsmodels.tsa.statespace.dynamic_factor_mq.DynamicFactorMQ.transform_params">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">transform_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unconstrained</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Transform parameters from optimizer space to model space.</span>

<span class="sd">        Transform unconstrained parameters used by the optimizer to constrained</span>
<span class="sd">        parameters used in likelihood evaluation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        unconstrained : array_like</span>
<span class="sd">            Array of unconstrained parameters used by the optimizer, to be</span>
<span class="sd">            transformed.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        constrained : array_like</span>
<span class="sd">            Array of constrained parameters which may be used in likelihood</span>
<span class="sd">            evaluation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">constrained</span> <span class="o">=</span> <span class="n">unconstrained</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># Stationary factor VAR</span>
        <span class="n">unconstrained_factor_ar</span> <span class="o">=</span> <span class="n">unconstrained</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_p</span><span class="p">[</span><span class="s1">&#39;factor_ar&#39;</span><span class="p">]]</span>
        <span class="n">constrained_factor_ar</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s</span><span class="o">.</span><span class="n">factor_blocks</span><span class="p">:</span>
            <span class="n">length</span> <span class="o">=</span> <span class="n">block</span><span class="o">.</span><span class="n">k_factors</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">block</span><span class="o">.</span><span class="n">factor_order</span>
            <span class="n">tmp_coeff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
                <span class="n">unconstrained_factor_ar</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="n">length</span><span class="p">],</span>
                <span class="p">(</span><span class="n">block</span><span class="o">.</span><span class="n">k_factors</span><span class="p">,</span> <span class="n">block</span><span class="o">.</span><span class="n">k_factors</span> <span class="o">*</span> <span class="n">block</span><span class="o">.</span><span class="n">factor_order</span><span class="p">))</span>
            <span class="n">tmp_cov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">block</span><span class="o">.</span><span class="n">k_factors</span><span class="p">)</span>
            <span class="n">tmp_coeff</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">constrain_stationary_multivariate</span><span class="p">(</span><span class="n">tmp_coeff</span><span class="p">,</span>
                                                             <span class="n">tmp_cov</span><span class="p">)</span>
            <span class="n">constrained_factor_ar</span> <span class="o">+=</span> <span class="n">tmp_coeff</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="n">length</span>
        <span class="n">constrained</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_p</span><span class="p">[</span><span class="s1">&#39;factor_ar&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">constrained_factor_ar</span>

        <span class="c1"># Stationary idiosyncratic AR(1)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">idiosyncratic_ar1</span><span class="p">:</span>
            <span class="n">idio_ar1</span> <span class="o">=</span> <span class="n">unconstrained</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_p</span><span class="p">[</span><span class="s1">&#39;idiosyncratic_ar1&#39;</span><span class="p">]]</span>
            <span class="n">constrained</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_p</span><span class="p">[</span><span class="s1">&#39;idiosyncratic_ar1&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">constrain_stationary_univariate</span><span class="p">(</span><span class="n">idio_ar1</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">)]</span>

        <span class="c1"># Positive idiosyncratic variances</span>
        <span class="n">constrained</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_p</span><span class="p">[</span><span class="s1">&#39;idiosyncratic_var&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">constrained</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_p</span><span class="p">[</span><span class="s1">&#39;idiosyncratic_var&#39;</span><span class="p">]]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">constrained</span></div>


<div class="viewcode-block" id="DynamicFactorMQ.untransform_params">
<a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.dynamic_factor_mq.DynamicFactorMQ.untransform_params.html#statsmodels.tsa.statespace.dynamic_factor_mq.DynamicFactorMQ.untransform_params">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">untransform_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">constrained</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Transform parameters from model space to optimizer space.</span>

<span class="sd">        Transform constrained parameters used in likelihood evaluation</span>
<span class="sd">        to unconstrained parameters used by the optimizer.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        constrained : array_like</span>
<span class="sd">            Array of constrained parameters used in likelihood evaluation, to</span>
<span class="sd">            be transformed.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        unconstrained : array_like</span>
<span class="sd">            Array of unconstrained parameters used by the optimizer.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">unconstrained</span> <span class="o">=</span> <span class="n">constrained</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># Stationary factor VAR</span>
        <span class="n">constrained_factor_ar</span> <span class="o">=</span> <span class="n">constrained</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_p</span><span class="p">[</span><span class="s1">&#39;factor_ar&#39;</span><span class="p">]]</span>
        <span class="n">unconstrained_factor_ar</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s</span><span class="o">.</span><span class="n">factor_blocks</span><span class="p">:</span>
            <span class="n">length</span> <span class="o">=</span> <span class="n">block</span><span class="o">.</span><span class="n">k_factors</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">block</span><span class="o">.</span><span class="n">factor_order</span>
            <span class="n">tmp_coeff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
                <span class="n">constrained_factor_ar</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="n">length</span><span class="p">],</span>
                <span class="p">(</span><span class="n">block</span><span class="o">.</span><span class="n">k_factors</span><span class="p">,</span> <span class="n">block</span><span class="o">.</span><span class="n">k_factors</span> <span class="o">*</span> <span class="n">block</span><span class="o">.</span><span class="n">factor_order</span><span class="p">))</span>
            <span class="n">tmp_cov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">block</span><span class="o">.</span><span class="n">k_factors</span><span class="p">)</span>
            <span class="n">tmp_coeff</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">unconstrain_stationary_multivariate</span><span class="p">(</span><span class="n">tmp_coeff</span><span class="p">,</span>
                                                               <span class="n">tmp_cov</span><span class="p">)</span>
            <span class="n">unconstrained_factor_ar</span> <span class="o">+=</span> <span class="n">tmp_coeff</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="n">length</span>
        <span class="n">unconstrained</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_p</span><span class="p">[</span><span class="s1">&#39;factor_ar&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">unconstrained_factor_ar</span>

        <span class="c1"># Stationary idiosyncratic AR(1)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">idiosyncratic_ar1</span><span class="p">:</span>
            <span class="n">idio_ar1</span> <span class="o">=</span> <span class="n">constrained</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_p</span><span class="p">[</span><span class="s1">&#39;idiosyncratic_ar1&#39;</span><span class="p">]]</span>
            <span class="n">unconstrained</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_p</span><span class="p">[</span><span class="s1">&#39;idiosyncratic_ar1&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">unconstrain_stationary_univariate</span><span class="p">(</span><span class="n">idio_ar1</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">)]</span>

        <span class="c1"># Positive idiosyncratic variances</span>
        <span class="n">unconstrained</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_p</span><span class="p">[</span><span class="s1">&#39;idiosyncratic_var&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">unconstrained</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_p</span><span class="p">[</span><span class="s1">&#39;idiosyncratic_var&#39;</span><span class="p">]]</span><span class="o">**</span><span class="mf">0.5</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">unconstrained</span></div>


<div class="viewcode-block" id="DynamicFactorMQ.update">
<a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.dynamic_factor_mq.DynamicFactorMQ.update.html#statsmodels.tsa.statespace.dynamic_factor_mq.DynamicFactorMQ.update">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update the parameters of the model.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array_like</span>
<span class="sd">            Array of new parameters.</span>
<span class="sd">        transformed : bool, optional</span>
<span class="sd">            Whether or not `params` is already transformed. If set to False,</span>
<span class="sd">            `transform_params` is called. Default is True.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">params</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Local copies</span>
        <span class="n">o</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_o</span>
        <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s</span>
        <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_p</span>

        <span class="c1"># Loadings</span>
        <span class="n">loadings</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="n">p</span><span class="p">[</span><span class="s1">&#39;loadings&#39;</span><span class="p">]]</span>
        <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_endog_M</span><span class="p">):</span>
            <span class="n">iloc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s</span><span class="o">.</span><span class="n">endog_factor_iloc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">k_factors</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">iloc</span><span class="p">)</span>
            <span class="n">factor_ix</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="s1">&#39;factors_L1&#39;</span><span class="p">][</span><span class="n">iloc</span><span class="p">]</span>
            <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;design&#39;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">factor_ix</span><span class="p">]</span> <span class="o">=</span> <span class="n">loadings</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">start</span> <span class="o">+</span> <span class="n">k_factors</span><span class="p">]</span>
            <span class="n">start</span> <span class="o">+=</span> <span class="n">k_factors</span>
        <span class="n">multipliers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">])[:,</span> <span class="kc">None</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_endog_M</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">):</span>
            <span class="n">iloc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s</span><span class="o">.</span><span class="n">endog_factor_iloc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">k_factors</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">iloc</span><span class="p">)</span>
            <span class="n">factor_ix</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="s1">&#39;factors_L1_5_ix&#39;</span><span class="p">][:,</span> <span class="n">iloc</span><span class="p">]</span>
            <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;design&#39;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">factor_ix</span><span class="o">.</span><span class="n">ravel</span><span class="p">()]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span>
                <span class="n">loadings</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">start</span> <span class="o">+</span> <span class="n">k_factors</span><span class="p">]</span> <span class="o">*</span> <span class="n">multipliers</span><span class="p">)</span>
            <span class="n">start</span> <span class="o">+=</span> <span class="n">k_factors</span>

        <span class="c1"># Factor VAR</span>
        <span class="n">factor_ar</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="n">p</span><span class="p">[</span><span class="s1">&#39;factor_ar&#39;</span><span class="p">]]</span>
        <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="n">s</span><span class="o">.</span><span class="n">factor_blocks</span><span class="p">:</span>
            <span class="n">k_params</span> <span class="o">=</span> <span class="n">block</span><span class="o">.</span><span class="n">k_factors</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">block</span><span class="o">.</span><span class="n">factor_order</span>
            <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
                <span class="n">factor_ar</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">start</span> <span class="o">+</span> <span class="n">k_params</span><span class="p">],</span>
                <span class="p">(</span><span class="n">block</span><span class="o">.</span><span class="n">k_factors</span><span class="p">,</span> <span class="n">block</span><span class="o">.</span><span class="n">k_factors</span> <span class="o">*</span> <span class="n">block</span><span class="o">.</span><span class="n">factor_order</span><span class="p">))</span>
            <span class="n">start</span> <span class="o">+=</span> <span class="n">k_params</span>
            <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;transition&#39;</span><span class="p">,</span> <span class="n">block</span><span class="p">[</span><span class="s1">&#39;factors_L1&#39;</span><span class="p">],</span> <span class="n">block</span><span class="p">[</span><span class="s1">&#39;factors_ar&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">A</span>

        <span class="c1"># Factor covariance</span>
        <span class="n">factor_cov</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="n">p</span><span class="p">[</span><span class="s1">&#39;factor_cov&#39;</span><span class="p">]]</span>
        <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">ix1</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="n">s</span><span class="o">.</span><span class="n">factor_blocks</span><span class="p">:</span>
            <span class="n">k_params</span> <span class="o">=</span> <span class="n">block</span><span class="o">.</span><span class="n">k_factors</span> <span class="o">*</span> <span class="p">(</span><span class="n">block</span><span class="o">.</span><span class="n">k_factors</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
            <span class="n">L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">block</span><span class="o">.</span><span class="n">k_factors</span><span class="p">,</span> <span class="n">block</span><span class="o">.</span><span class="n">k_factors</span><span class="p">),</span>
                         <span class="n">dtype</span><span class="o">=</span><span class="n">params</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="n">L</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">tril_indices_from</span><span class="p">(</span><span class="n">L</span><span class="p">)]</span> <span class="o">=</span> <span class="n">factor_cov</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">start</span> <span class="o">+</span> <span class="n">k_params</span><span class="p">]</span>
            <span class="n">start</span> <span class="o">+=</span> <span class="n">k_params</span>
            <span class="n">Q</span> <span class="o">=</span> <span class="n">L</span> <span class="o">@</span> <span class="n">L</span><span class="o">.</span><span class="n">T</span>
            <span class="n">ix2</span> <span class="o">=</span> <span class="n">ix1</span> <span class="o">+</span> <span class="n">block</span><span class="o">.</span><span class="n">k_factors</span>
            <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;state_cov&#39;</span><span class="p">,</span> <span class="n">ix1</span><span class="p">:</span><span class="n">ix2</span><span class="p">,</span> <span class="n">ix1</span><span class="p">:</span><span class="n">ix2</span><span class="p">]</span> <span class="o">=</span> <span class="n">Q</span>
            <span class="n">ix1</span> <span class="o">=</span> <span class="n">ix2</span>

        <span class="c1"># Error AR(1)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">idiosyncratic_ar1</span><span class="p">:</span>
            <span class="n">alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="n">p</span><span class="p">[</span><span class="s1">&#39;idiosyncratic_ar1&#39;</span><span class="p">]])</span>
            <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;transition&#39;</span><span class="p">,</span> <span class="n">s</span><span class="p">[</span><span class="s1">&#39;idio_ar_L1&#39;</span><span class="p">],</span> <span class="n">s</span><span class="p">[</span><span class="s1">&#39;idio_ar_L1&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">alpha</span>

        <span class="c1"># Error variances</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">idiosyncratic_ar1</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;state_cov&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_factors</span><span class="p">:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_factors</span><span class="p">:]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="n">p</span><span class="p">[</span><span class="s1">&#39;idiosyncratic_var&#39;</span><span class="p">]]))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">idio_var</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="n">p</span><span class="p">[</span><span class="s1">&#39;idiosyncratic_var&#39;</span><span class="p">]]</span>
            <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;obs_cov&#39;</span><span class="p">,</span> <span class="n">o</span><span class="p">[</span><span class="s1">&#39;M&#39;</span><span class="p">],</span> <span class="n">o</span><span class="p">[</span><span class="s1">&#39;M&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">idio_var</span><span class="p">[</span><span class="n">o</span><span class="p">[</span><span class="s1">&#39;M&#39;</span><span class="p">]])</span>
            <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;state_cov&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_factors</span><span class="p">:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_factors</span><span class="p">:]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">idio_var</span><span class="p">[</span><span class="n">o</span><span class="p">[</span><span class="s1">&#39;Q&#39;</span><span class="p">]]))</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">loglike_constant</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constant term in the joint log-likelihood function.</span>

<span class="sd">        Useful in facilitating comparisons to other packages that exclude the</span>
<span class="sd">        constant from the log-likelihood computation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endog</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>

<div class="viewcode-block" id="DynamicFactorMQ.loading_constraints">
<a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.dynamic_factor_mq.DynamicFactorMQ.loading_constraints.html#statsmodels.tsa.statespace.dynamic_factor_mq.DynamicFactorMQ.loading_constraints">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">loading_constraints</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Matrix formulation of quarterly variables&#39; factor loading constraints.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        i : int</span>
<span class="sd">            Index of the `endog` variable to compute constraints for.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        R : array (k_constraints, k_factors * 5)</span>
<span class="sd">        q : array (k_constraints,)</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        If the factors were known, then the factor loadings for the ith</span>
<span class="sd">        quarterly variable would be computed by a linear regression of the form</span>

<span class="sd">        y_i = A_i&#39; f + B_i&#39; L1.f + C_i&#39; L2.f + D_i&#39; L3.f + E_i&#39; L4.f</span>

<span class="sd">        where:</span>

<span class="sd">        - f is (k_i x 1) and collects all of the factors that load on y_i</span>
<span class="sd">        - L{j}.f is (k_i x 1) and collects the jth lag of each factor</span>
<span class="sd">        - A_i, ..., E_i are (k_i x 1) and collect factor loadings</span>

<span class="sd">        As the observed variable is quarterly while the factors are monthly, we</span>
<span class="sd">        want to restrict the estimated regression coefficients to be:</span>

<span class="sd">        y_i = A_i f + 2 A_i L1.f + 3 A_i L2.f + 2 A_i L3.f + A_i L4.f</span>

<span class="sd">        Stack the unconstrained coefficients: \Lambda_i = [A_i&#39; B_i&#39; ... E_i&#39;]&#39;</span>

<span class="sd">        Then the constraints can be written as follows, for l = 1, ..., k_i</span>

<span class="sd">        - 2 A_{i,l} - B_{i,l} = 0</span>
<span class="sd">        - 3 A_{i,l} - C_{i,l} = 0</span>
<span class="sd">        - 2 A_{i,l} - D_{i,l} = 0</span>
<span class="sd">        - A_{i,l} - E_{i,l} = 0</span>

<span class="sd">        So that k_constraints = 4 * k_i. In matrix form the constraints are:</span>

<span class="sd">        .. math::</span>

<span class="sd">            R \Lambda_i = q</span>

<span class="sd">        where :math:`\Lambda_i` is shaped `(k_i * 5,)`, :math:`R` is shaped</span>
<span class="sd">        `(k_constraints, k_i * 5)`, and :math:`q` is shaped `(k_constraints,)`.</span>


<span class="sd">        For example, for the case that k_i = 2, we can write:</span>

<span class="sd">        |  2 0   -1  0    0  0    0  0    0  0  |   | A_{i,1} |     | 0 |</span>
<span class="sd">        |  0 2    0 -1    0  0    0  0    0  0  |   | A_{i,2} |     | 0 |</span>
<span class="sd">        |  3 0    0  0   -1  0    0  0    0  0  |   | B_{i,1} |     | 0 |</span>
<span class="sd">        |  0 3    0  0    0 -1    0  0    0  0  |   | B_{i,2} |     | 0 |</span>
<span class="sd">        |  2 0    0  0    0  0   -1  0    0  0  |   | C_{i,1} |  =  | 0 |</span>
<span class="sd">        |  0 2    0  0    0  0    0 -1    0  0  |   | C_{i,2} |     | 0 |</span>
<span class="sd">        |  1 0    0  0    0  0    0  0   -1  0  |   | D_{i,1} |     | 0 |</span>
<span class="sd">        |  0 1    0  0    0  0    0  0    0 -1  |   | D_{i,2} |     | 0 |</span>
<span class="sd">                                                    | E_{i,1} |     | 0 |</span>
<span class="sd">                                                    | E_{i,2} |     | 0 |</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog_M</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;No constraints for monthly variables.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_loading_constraints</span><span class="p">:</span>
            <span class="n">k_factors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">endog_factor_map</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

            <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">k_factors</span> <span class="o">*</span> <span class="mi">4</span><span class="p">,</span> <span class="n">k_factors</span> <span class="o">*</span> <span class="mi">5</span><span class="p">))</span>
            <span class="n">q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">R</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

            <span class="c1"># Let R = [R_1 R_2]</span>
            <span class="c1"># Then R_1 is multiples of the identity matrix</span>
            <span class="n">multipliers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
            <span class="n">R</span><span class="p">[:,</span> <span class="p">:</span><span class="n">k_factors</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
                <span class="p">(</span><span class="n">multipliers</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">k_factors</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span> <span class="kc">None</span><span class="p">])</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
                <span class="p">(</span><span class="n">k_factors</span> <span class="o">*</span> <span class="mi">4</span><span class="p">,</span> <span class="n">k_factors</span><span class="p">))</span>

            <span class="c1"># And R_2 is the identity</span>
            <span class="n">R</span><span class="p">[:,</span> <span class="n">k_factors</span><span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">k_factors</span> <span class="o">*</span> <span class="mi">4</span><span class="p">))</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_loading_constraints</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_loading_constraints</span><span class="p">[</span><span class="n">i</span><span class="p">]</span></div>


<div class="viewcode-block" id="DynamicFactorMQ.fit">
<a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.dynamic_factor_mq.DynamicFactorMQ.fit.html#statsmodels.tsa.statespace.dynamic_factor_mq.DynamicFactorMQ.fit">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">includes_fixed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">cov_type</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">,</span> <span class="n">cov_kwds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;em&#39;</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span>
            <span class="n">tolerance</span><span class="o">=</span><span class="mf">1e-6</span><span class="p">,</span> <span class="n">em_initialization</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">mstep_method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">full_output</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">disp</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">return_params</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">optim_score</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">optim_complex_step</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">optim_hessian</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">flags</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">low_memory</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">llf_decrease_action</span><span class="o">=</span><span class="s1">&#39;revert&#39;</span><span class="p">,</span>
            <span class="n">llf_decrease_tolerance</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fits the model by maximum likelihood via Kalman filter.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        start_params : array_like, optional</span>
<span class="sd">            Initial guess of the solution for the loglikelihood maximization.</span>
<span class="sd">            If None, the default is given by Model.start_params.</span>
<span class="sd">        transformed : bool, optional</span>
<span class="sd">            Whether or not `start_params` is already transformed. Default is</span>
<span class="sd">            True.</span>
<span class="sd">        includes_fixed : bool, optional</span>
<span class="sd">            If parameters were previously fixed with the `fix_params` method,</span>
<span class="sd">            this argument describes whether or not `start_params` also includes</span>
<span class="sd">            the fixed parameters, in addition to the free parameters. Default</span>
<span class="sd">            is False.</span>
<span class="sd">        cov_type : str, optional</span>
<span class="sd">            The `cov_type` keyword governs the method for calculating the</span>
<span class="sd">            covariance matrix of parameter estimates. Can be one of:</span>

<span class="sd">            - &#39;opg&#39; for the outer product of gradient estimator</span>
<span class="sd">            - &#39;oim&#39; for the observed information matrix estimator, calculated</span>
<span class="sd">              using the method of Harvey (1989)</span>
<span class="sd">            - &#39;approx&#39; for the observed information matrix estimator,</span>
<span class="sd">              calculated using a numerical approximation of the Hessian matrix.</span>
<span class="sd">            - &#39;robust&#39; for an approximate (quasi-maximum likelihood) covariance</span>
<span class="sd">              matrix that may be valid even in the presence of some</span>
<span class="sd">              misspecifications. Intermediate calculations use the &#39;oim&#39;</span>
<span class="sd">              method.</span>
<span class="sd">            - &#39;robust_approx&#39; is the same as &#39;robust&#39; except that the</span>
<span class="sd">              intermediate calculations use the &#39;approx&#39; method.</span>
<span class="sd">            - &#39;none&#39; for no covariance matrix calculation.</span>

<span class="sd">            Default is &#39;none&#39;, since computing this matrix can be very slow</span>
<span class="sd">            when there are a large number of parameters.</span>
<span class="sd">        cov_kwds : dict or None, optional</span>
<span class="sd">            A dictionary of arguments affecting covariance matrix computation.</span>

<span class="sd">            **opg, oim, approx, robust, robust_approx**</span>

<span class="sd">            - &#39;approx_complex_step&#39; : bool, optional - If True, numerical</span>
<span class="sd">              approximations are computed using complex-step methods. If False,</span>
<span class="sd">              numerical approximations are computed using finite difference</span>
<span class="sd">              methods. Default is True.</span>
<span class="sd">            - &#39;approx_centered&#39; : bool, optional - If True, numerical</span>
<span class="sd">              approximations computed using finite difference methods use a</span>
<span class="sd">              centered approximation. Default is False.</span>
<span class="sd">        method : str, optional</span>
<span class="sd">            The `method` determines which solver from `scipy.optimize`</span>
<span class="sd">            is used, and it can be chosen from among the following strings:</span>

<span class="sd">            - &#39;em&#39; for the EM algorithm</span>
<span class="sd">            - &#39;newton&#39; for Newton-Raphson</span>
<span class="sd">            - &#39;nm&#39; for Nelder-Mead</span>
<span class="sd">            - &#39;bfgs&#39; for Broyden-Fletcher-Goldfarb-Shanno (BFGS)</span>
<span class="sd">            - &#39;lbfgs&#39; for limited-memory BFGS with optional box constraints</span>
<span class="sd">            - &#39;powell&#39; for modified Powell&#39;s method</span>
<span class="sd">            - &#39;cg&#39; for conjugate gradient</span>
<span class="sd">            - &#39;ncg&#39; for Newton-conjugate gradient</span>
<span class="sd">            - &#39;basinhopping&#39; for global basin-hopping solver</span>

<span class="sd">            The explicit arguments in `fit` are passed to the solver,</span>
<span class="sd">            with the exception of the basin-hopping solver. Each</span>
<span class="sd">            solver has several optional arguments that are not the same across</span>
<span class="sd">            solvers. See the notes section below (or scipy.optimize) for the</span>
<span class="sd">            available arguments and for the list of explicit arguments that the</span>
<span class="sd">            basin-hopping solver supports.</span>
<span class="sd">        maxiter : int, optional</span>
<span class="sd">            The maximum number of iterations to perform.</span>
<span class="sd">        tolerance : float, optional</span>
<span class="sd">            Tolerance to use for convergence checking when using the EM</span>
<span class="sd">            algorithm. To set the tolerance for other methods, pass</span>
<span class="sd">            the optimizer-specific keyword argument(s).</span>
<span class="sd">        full_output : bool, optional</span>
<span class="sd">            Set to True to have all available output in the Results object&#39;s</span>
<span class="sd">            mle_retvals attribute. The output is dependent on the solver.</span>
<span class="sd">            See LikelihoodModelResults notes section for more information.</span>
<span class="sd">        disp : bool, optional</span>
<span class="sd">            Set to True to print convergence messages.</span>
<span class="sd">        callback : callable callback(xk), optional</span>
<span class="sd">            Called after each iteration, as callback(xk), where xk is the</span>
<span class="sd">            current parameter vector.</span>
<span class="sd">        return_params : bool, optional</span>
<span class="sd">            Whether or not to return only the array of maximizing parameters.</span>
<span class="sd">            Default is False.</span>
<span class="sd">        optim_score : {&#39;harvey&#39;, &#39;approx&#39;} or None, optional</span>
<span class="sd">            The method by which the score vector is calculated. &#39;harvey&#39; uses</span>
<span class="sd">            the method from Harvey (1989), &#39;approx&#39; uses either finite</span>
<span class="sd">            difference or complex step differentiation depending upon the</span>
<span class="sd">            value of `optim_complex_step`, and None uses the built-in gradient</span>
<span class="sd">            approximation of the optimizer. Default is None. This keyword is</span>
<span class="sd">            only relevant if the optimization method uses the score.</span>
<span class="sd">        optim_complex_step : bool, optional</span>
<span class="sd">            Whether or not to use complex step differentiation when</span>
<span class="sd">            approximating the score; if False, finite difference approximation</span>
<span class="sd">            is used. Default is True. This keyword is only relevant if</span>
<span class="sd">            `optim_score` is set to &#39;harvey&#39; or &#39;approx&#39;.</span>
<span class="sd">        optim_hessian : {&#39;opg&#39;,&#39;oim&#39;,&#39;approx&#39;}, optional</span>
<span class="sd">            The method by which the Hessian is numerically approximated. &#39;opg&#39;</span>
<span class="sd">            uses outer product of gradients, &#39;oim&#39; uses the information</span>
<span class="sd">            matrix formula from Harvey (1989), and &#39;approx&#39; uses numerical</span>
<span class="sd">            approximation. This keyword is only relevant if the</span>
<span class="sd">            optimization method uses the Hessian matrix.</span>
<span class="sd">        low_memory : bool, optional</span>
<span class="sd">            If set to True, techniques are applied to substantially reduce</span>
<span class="sd">            memory usage. If used, some features of the results object will</span>
<span class="sd">            not be available (including smoothed results and in-sample</span>
<span class="sd">            prediction), although out-of-sample forecasting is possible.</span>
<span class="sd">            Note that this option is not available when using the EM algorithm</span>
<span class="sd">            (which is the default for this model). Default is False.</span>
<span class="sd">        llf_decrease_action : {&#39;ignore&#39;, &#39;warn&#39;, &#39;revert&#39;}, optional</span>
<span class="sd">            Action to take if the log-likelihood decreases in an EM iteration.</span>
<span class="sd">            &#39;ignore&#39; continues the iterations, &#39;warn&#39; issues a warning but</span>
<span class="sd">            continues the iterations, while &#39;revert&#39; ends the iterations and</span>
<span class="sd">            returns the result from the last good iteration. Default is &#39;warn&#39;.</span>
<span class="sd">        llf_decrease_tolerance : float, optional</span>
<span class="sd">            Minimum size of the log-likelihood decrease required to trigger a</span>
<span class="sd">            warning or to end the EM iterations. Setting this value slightly</span>
<span class="sd">            larger than zero allows small decreases in the log-likelihood that</span>
<span class="sd">            may be caused by numerical issues. If set to zero, then any</span>
<span class="sd">            decrease will trigger the `llf_decrease_action`. Default is 1e-4.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Additional keyword arguments to pass to the optimizer.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        MLEResults</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        statsmodels.base.model.LikelihoodModel.fit</span>
<span class="sd">        statsmodels.tsa.statespace.mlemodel.MLEResults</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;em&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_em</span><span class="p">(</span>
                <span class="n">start_params</span><span class="o">=</span><span class="n">start_params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="n">transformed</span><span class="p">,</span>
                <span class="n">cov_type</span><span class="o">=</span><span class="n">cov_type</span><span class="p">,</span> <span class="n">cov_kwds</span><span class="o">=</span><span class="n">cov_kwds</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="n">maxiter</span><span class="p">,</span>
                <span class="n">tolerance</span><span class="o">=</span><span class="n">tolerance</span><span class="p">,</span> <span class="n">em_initialization</span><span class="o">=</span><span class="n">em_initialization</span><span class="p">,</span>
                <span class="n">mstep_method</span><span class="o">=</span><span class="n">mstep_method</span><span class="p">,</span> <span class="n">full_output</span><span class="o">=</span><span class="n">full_output</span><span class="p">,</span> <span class="n">disp</span><span class="o">=</span><span class="n">disp</span><span class="p">,</span>
                <span class="n">return_params</span><span class="o">=</span><span class="n">return_params</span><span class="p">,</span> <span class="n">low_memory</span><span class="o">=</span><span class="n">low_memory</span><span class="p">,</span>
                <span class="n">llf_decrease_action</span><span class="o">=</span><span class="n">llf_decrease_action</span><span class="p">,</span>
                <span class="n">llf_decrease_tolerance</span><span class="o">=</span><span class="n">llf_decrease_tolerance</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span>
                <span class="n">start_params</span><span class="o">=</span><span class="n">start_params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="n">transformed</span><span class="p">,</span>
                <span class="n">includes_fixed</span><span class="o">=</span><span class="n">includes_fixed</span><span class="p">,</span> <span class="n">cov_type</span><span class="o">=</span><span class="n">cov_type</span><span class="p">,</span>
                <span class="n">cov_kwds</span><span class="o">=</span><span class="n">cov_kwds</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="n">maxiter</span><span class="p">,</span>
                <span class="n">full_output</span><span class="o">=</span><span class="n">full_output</span><span class="p">,</span> <span class="n">disp</span><span class="o">=</span><span class="n">disp</span><span class="p">,</span>
                <span class="n">callback</span><span class="o">=</span><span class="n">callback</span><span class="p">,</span> <span class="n">return_params</span><span class="o">=</span><span class="n">return_params</span><span class="p">,</span>
                <span class="n">optim_score</span><span class="o">=</span><span class="n">optim_score</span><span class="p">,</span>
                <span class="n">optim_complex_step</span><span class="o">=</span><span class="n">optim_complex_step</span><span class="p">,</span>
                <span class="n">optim_hessian</span><span class="o">=</span><span class="n">optim_hessian</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="n">flags</span><span class="p">,</span>
                <span class="n">low_memory</span><span class="o">=</span><span class="n">low_memory</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="DynamicFactorMQ.fit_em">
<a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.dynamic_factor_mq.DynamicFactorMQ.fit_em.html#statsmodels.tsa.statespace.dynamic_factor_mq.DynamicFactorMQ.fit_em">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">fit_em</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cov_type</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">,</span>
               <span class="n">cov_kwds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mf">1e-6</span><span class="p">,</span> <span class="n">disp</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
               <span class="n">em_initialization</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">mstep_method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">full_output</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
               <span class="n">return_params</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">low_memory</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
               <span class="n">llf_decrease_action</span><span class="o">=</span><span class="s1">&#39;revert&#39;</span><span class="p">,</span> <span class="n">llf_decrease_tolerance</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fits the model by maximum likelihood via the EM algorithm.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        start_params : array_like, optional</span>
<span class="sd">            Initial guess of the solution for the loglikelihood maximization.</span>
<span class="sd">            The default is to use `DynamicFactorMQ.start_params`.</span>
<span class="sd">        transformed : bool, optional</span>
<span class="sd">            Whether or not `start_params` is already transformed. Default is</span>
<span class="sd">            True.</span>
<span class="sd">        cov_type : str, optional</span>
<span class="sd">            The `cov_type` keyword governs the method for calculating the</span>
<span class="sd">            covariance matrix of parameter estimates. Can be one of:</span>

<span class="sd">            - &#39;opg&#39; for the outer product of gradient estimator</span>
<span class="sd">            - &#39;oim&#39; for the observed information matrix estimator, calculated</span>
<span class="sd">              using the method of Harvey (1989)</span>
<span class="sd">            - &#39;approx&#39; for the observed information matrix estimator,</span>
<span class="sd">              calculated using a numerical approximation of the Hessian matrix.</span>
<span class="sd">            - &#39;robust&#39; for an approximate (quasi-maximum likelihood) covariance</span>
<span class="sd">              matrix that may be valid even in the presence of some</span>
<span class="sd">              misspecifications. Intermediate calculations use the &#39;oim&#39;</span>
<span class="sd">              method.</span>
<span class="sd">            - &#39;robust_approx&#39; is the same as &#39;robust&#39; except that the</span>
<span class="sd">              intermediate calculations use the &#39;approx&#39; method.</span>
<span class="sd">            - &#39;none&#39; for no covariance matrix calculation.</span>

<span class="sd">            Default is &#39;none&#39;, since computing this matrix can be very slow</span>
<span class="sd">            when there are a large number of parameters.</span>
<span class="sd">        cov_kwds : dict or None, optional</span>
<span class="sd">            A dictionary of arguments affecting covariance matrix computation.</span>

<span class="sd">            **opg, oim, approx, robust, robust_approx**</span>

<span class="sd">            - &#39;approx_complex_step&#39; : bool, optional - If True, numerical</span>
<span class="sd">              approximations are computed using complex-step methods. If False,</span>
<span class="sd">              numerical approximations are computed using finite difference</span>
<span class="sd">              methods. Default is True.</span>
<span class="sd">            - &#39;approx_centered&#39; : bool, optional - If True, numerical</span>
<span class="sd">              approximations computed using finite difference methods use a</span>
<span class="sd">              centered approximation. Default is False.</span>
<span class="sd">        maxiter : int, optional</span>
<span class="sd">            The maximum number of EM iterations to perform.</span>
<span class="sd">        tolerance : float, optional</span>
<span class="sd">            Parameter governing convergence of the EM algorithm. The</span>
<span class="sd">            `tolerance` is the minimum relative increase in the likelihood</span>
<span class="sd">            for which convergence will be declared. A smaller value for the</span>
<span class="sd">            `tolerance` will typically yield more precise parameter estimates,</span>
<span class="sd">            but will typically require more EM iterations. Default is 1e-6.</span>
<span class="sd">        disp : int or bool, optional</span>
<span class="sd">            Controls printing of EM iteration progress. If an integer, progress</span>
<span class="sd">            is printed at every `disp` iterations. A value of True is</span>
<span class="sd">            interpreted as the value of 1. Default is False (nothing will be</span>
<span class="sd">            printed).</span>
<span class="sd">        em_initialization : bool, optional</span>
<span class="sd">            Whether or not to also update the Kalman filter initialization</span>
<span class="sd">            using the EM algorithm. Default is True.</span>
<span class="sd">        mstep_method : {None, &#39;missing&#39;, &#39;nonmissing&#39;}, optional</span>
<span class="sd">            The EM algorithm maximization step. If there are no NaN values</span>
<span class="sd">            in the dataset, this can be set to &quot;nonmissing&quot; (which is slightly</span>
<span class="sd">            faster) or &quot;missing&quot;, otherwise it must be &quot;missing&quot;. Default is</span>
<span class="sd">            &quot;nonmissing&quot; if there are no NaN values or &quot;missing&quot; if there are.</span>
<span class="sd">        full_output : bool, optional</span>
<span class="sd">            Set to True to have all available output from EM iterations in</span>
<span class="sd">            the Results object&#39;s mle_retvals attribute.</span>
<span class="sd">        return_params : bool, optional</span>
<span class="sd">            Whether or not to return only the array of maximizing parameters.</span>
<span class="sd">            Default is False.</span>
<span class="sd">        low_memory : bool, optional</span>
<span class="sd">            This option cannot be used with the EM algorithm and will raise an</span>
<span class="sd">            error if set to True. Default is False.</span>
<span class="sd">        llf_decrease_action : {&#39;ignore&#39;, &#39;warn&#39;, &#39;revert&#39;}, optional</span>
<span class="sd">            Action to take if the log-likelihood decreases in an EM iteration.</span>
<span class="sd">            &#39;ignore&#39; continues the iterations, &#39;warn&#39; issues a warning but</span>
<span class="sd">            continues the iterations, while &#39;revert&#39; ends the iterations and</span>
<span class="sd">            returns the result from the last good iteration. Default is &#39;warn&#39;.</span>
<span class="sd">        llf_decrease_tolerance : float, optional</span>
<span class="sd">            Minimum size of the log-likelihood decrease required to trigger a</span>
<span class="sd">            warning or to end the EM iterations. Setting this value slightly</span>
<span class="sd">            larger than zero allows small decreases in the log-likelihood that</span>
<span class="sd">            may be caused by numerical issues. If set to zero, then any</span>
<span class="sd">            decrease will trigger the `llf_decrease_action`. Default is 1e-4.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        DynamicFactorMQResults</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        statsmodels.tsa.statespace.mlemodel.MLEModel.fit</span>
<span class="sd">        statsmodels.tsa.statespace.mlemodel.MLEResults</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_fixed_params</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Cannot fit using the EM algorithm while&#39;</span>
                                      <span class="s1">&#39; holding some parameters fixed.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">low_memory</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Cannot fit using the EM algorithm when using&#39;</span>
                             <span class="s1">&#39; low_memory option.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">start_params</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">start_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">start_params</span>
            <span class="n">transformed</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">start_params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">start_params</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">transformed</span><span class="p">:</span>
            <span class="n">start_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_params</span><span class="p">(</span><span class="n">start_params</span><span class="p">)</span>

        <span class="n">llf_decrease_action</span> <span class="o">=</span> <span class="n">string_like</span><span class="p">(</span>
            <span class="n">llf_decrease_action</span><span class="p">,</span> <span class="s1">&#39;llf_decrease_action&#39;</span><span class="p">,</span>
            <span class="n">options</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;ignore&#39;</span><span class="p">,</span> <span class="s1">&#39;warn&#39;</span><span class="p">,</span> <span class="s1">&#39;revert&#39;</span><span class="p">])</span>

        <span class="n">disp</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">disp</span><span class="p">)</span>

        <span class="c1"># Perform expectation-maximization</span>
        <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s</span>
        <span class="n">llf</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">params</span> <span class="o">=</span> <span class="p">[</span><span class="n">start_params</span><span class="p">]</span>
        <span class="n">init</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">inits</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">initialization</span><span class="p">]</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">delta</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">terminate</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1"># init_stationary = None if em_initialization else True</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">maxiter</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">terminate</span> <span class="ow">and</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="p">(</span><span class="n">delta</span> <span class="o">&gt;</span> <span class="n">tolerance</span><span class="p">)):</span>
            <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_em_iteration</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">init</span><span class="o">=</span><span class="n">init</span><span class="p">,</span>
                                     <span class="n">mstep_method</span><span class="o">=</span><span class="n">mstep_method</span><span class="p">)</span>
            <span class="n">new_llf</span> <span class="o">=</span> <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">llf_obs</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

            <span class="c1"># If we are not using EM initialization, then we need to check for</span>
            <span class="c1"># non-stationary parameters</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">em_initialization</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">switch_init</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">T</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;transition&#39;</span><span class="p">]</span>
                <span class="n">init</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">initialization</span>
                <span class="n">iloc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_states</span><span class="p">)</span>

                <span class="c1"># We may only have global initialization if we have no</span>
                <span class="c1"># quarterly variables and idiosyncratic_ar1=False</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog_Q</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">idiosyncratic_ar1</span><span class="p">:</span>
                    <span class="n">block</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">factor_blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">init</span><span class="o">.</span><span class="n">initialization_type</span> <span class="o">==</span> <span class="s1">&#39;stationary&#39;</span><span class="p">:</span>
                        <span class="n">Tb</span> <span class="o">=</span> <span class="n">T</span><span class="p">[</span><span class="n">block</span><span class="p">[</span><span class="s1">&#39;factors&#39;</span><span class="p">],</span> <span class="n">block</span><span class="p">[</span><span class="s1">&#39;factors&#39;</span><span class="p">]]</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigvals</span><span class="p">(</span><span class="n">Tb</span><span class="p">)</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mf">1e-10</span><span class="p">)):</span>
                            <span class="n">init</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">block</span><span class="p">[</span><span class="s1">&#39;factors&#39;</span><span class="p">],</span> <span class="s1">&#39;diffuse&#39;</span><span class="p">)</span>
                            <span class="n">switch_init</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                                <span class="s1">&#39;factor block:&#39;</span>
                                <span class="sa">f</span><span class="s1">&#39; </span><span class="si">{</span><span class="nb">tuple</span><span class="p">(</span><span class="n">block</span><span class="o">.</span><span class="n">factor_names</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Factor blocks</span>
                    <span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="n">s</span><span class="o">.</span><span class="n">factor_blocks</span><span class="p">:</span>
                        <span class="n">b</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">iloc</span><span class="p">[</span><span class="n">block</span><span class="p">[</span><span class="s1">&#39;factors&#39;</span><span class="p">]])</span>
                        <span class="n">init_type</span> <span class="o">=</span> <span class="n">init</span><span class="o">.</span><span class="n">blocks</span><span class="p">[</span><span class="n">b</span><span class="p">]</span><span class="o">.</span><span class="n">initialization_type</span>
                        <span class="k">if</span> <span class="n">init_type</span> <span class="o">==</span> <span class="s1">&#39;stationary&#39;</span><span class="p">:</span>
                            <span class="n">Tb</span> <span class="o">=</span> <span class="n">T</span><span class="p">[</span><span class="n">block</span><span class="p">[</span><span class="s1">&#39;factors&#39;</span><span class="p">],</span> <span class="n">block</span><span class="p">[</span><span class="s1">&#39;factors&#39;</span><span class="p">]]</span>
                            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigvals</span><span class="p">(</span><span class="n">Tb</span><span class="p">)</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mf">1e-10</span><span class="p">)):</span>
                                <span class="n">init</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">block</span><span class="p">[</span><span class="s1">&#39;factors&#39;</span><span class="p">],</span> <span class="s1">&#39;diffuse&#39;</span><span class="p">)</span>
                                <span class="n">switch_init</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                                    <span class="s1">&#39;factor block:&#39;</span>
                                    <span class="sa">f</span><span class="s1">&#39; </span><span class="si">{</span><span class="nb">tuple</span><span class="p">(</span><span class="n">block</span><span class="o">.</span><span class="n">factor_names</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">idiosyncratic_ar1</span><span class="p">:</span>
                    <span class="n">endog_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_endog_names</span><span class="p">(</span><span class="n">as_string</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="c1"># Monthly variables</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="s1">&#39;idio_ar_M&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">s</span><span class="p">[</span><span class="s1">&#39;idio_ar_M&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">stop</span><span class="p">):</span>
                        <span class="n">init_type</span> <span class="o">=</span> <span class="n">init</span><span class="o">.</span><span class="n">blocks</span><span class="p">[(</span><span class="n">j</span><span class="p">,)]</span><span class="o">.</span><span class="n">initialization_type</span>
                        <span class="k">if</span> <span class="n">init_type</span> <span class="o">==</span> <span class="s1">&#39;stationary&#39;</span><span class="p">:</span>
                            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">T</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">j</span><span class="p">])</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mf">1e-10</span><span class="p">):</span>
                                <span class="n">init</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="s1">&#39;diffuse&#39;</span><span class="p">)</span>
                                <span class="n">name</span> <span class="o">=</span> <span class="n">endog_names</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="n">s</span><span class="p">[</span><span class="s1">&#39;idio_ar_M&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">start</span><span class="p">]</span>
                                <span class="n">switch_init</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                                    <span class="s1">&#39;idiosyncratic AR(1) for monthly&#39;</span>
                                    <span class="sa">f</span><span class="s1">&#39; variable: </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

                    <span class="c1"># Quarterly variables</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog_Q</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">b</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">iloc</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="s1">&#39;idio_ar_Q&#39;</span><span class="p">]])</span>
                        <span class="n">init_type</span> <span class="o">=</span> <span class="n">init</span><span class="o">.</span><span class="n">blocks</span><span class="p">[</span><span class="n">b</span><span class="p">]</span><span class="o">.</span><span class="n">initialization_type</span>
                        <span class="k">if</span> <span class="n">init_type</span> <span class="o">==</span> <span class="s1">&#39;stationary&#39;</span><span class="p">:</span>
                            <span class="n">Tb</span> <span class="o">=</span> <span class="n">T</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="s1">&#39;idio_ar_Q&#39;</span><span class="p">],</span> <span class="n">s</span><span class="p">[</span><span class="s1">&#39;idio_ar_Q&#39;</span><span class="p">]]</span>
                            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigvals</span><span class="p">(</span><span class="n">Tb</span><span class="p">)</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mf">1e-10</span><span class="p">)):</span>
                                <span class="n">init</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="s1">&#39;idio_ar_Q&#39;</span><span class="p">],</span> <span class="s1">&#39;diffuse&#39;</span><span class="p">)</span>
                                <span class="n">switch_init</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                                    <span class="s1">&#39;idiosyncratic AR(1) for the&#39;</span>
                                    <span class="s1">&#39; block of quarterly variables&#39;</span><span class="p">)</span>

                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">switch_init</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Non-stationary parameters found at EM iteration&#39;</span>
                         <span class="sa">f</span><span class="s1">&#39; </span><span class="si">{</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s1">, which is not compatible with&#39;</span>
                         <span class="s1">&#39; stationary initialization. Initialization was&#39;</span>
                         <span class="s1">&#39; switched to diffuse for the following: &#39;</span>
                         <span class="sa">f</span><span class="s1">&#39; </span><span class="si">{</span><span class="n">switch_init</span><span class="si">}</span><span class="s1">, and fitting was restarted.&#39;</span><span class="p">)</span>
                    <span class="n">results</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_em</span><span class="p">(</span>
                        <span class="n">start_params</span><span class="o">=</span><span class="n">params</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">transformed</span><span class="o">=</span><span class="n">transformed</span><span class="p">,</span>
                        <span class="n">cov_type</span><span class="o">=</span><span class="n">cov_type</span><span class="p">,</span> <span class="n">cov_kwds</span><span class="o">=</span><span class="n">cov_kwds</span><span class="p">,</span>
                        <span class="n">maxiter</span><span class="o">=</span><span class="n">maxiter</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="n">tolerance</span><span class="p">,</span>
                        <span class="n">em_initialization</span><span class="o">=</span><span class="n">em_initialization</span><span class="p">,</span>
                        <span class="n">mstep_method</span><span class="o">=</span><span class="n">mstep_method</span><span class="p">,</span> <span class="n">full_output</span><span class="o">=</span><span class="n">full_output</span><span class="p">,</span>
                        <span class="n">disp</span><span class="o">=</span><span class="n">disp</span><span class="p">,</span> <span class="n">return_params</span><span class="o">=</span><span class="n">return_params</span><span class="p">,</span>
                        <span class="n">low_memory</span><span class="o">=</span><span class="n">low_memory</span><span class="p">,</span>
                        <span class="n">llf_decrease_action</span><span class="o">=</span><span class="n">llf_decrease_action</span><span class="p">,</span>
                        <span class="n">llf_decrease_tolerance</span><span class="o">=</span><span class="n">llf_decrease_tolerance</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">initialize</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_default_initialization</span><span class="p">())</span>
                    <span class="k">return</span> <span class="n">results</span>

            <span class="c1"># Check for decrease in the log-likelihood</span>
            <span class="c1"># Note: allow a little numerical error before declaring a decrease</span>
            <span class="n">llf_decrease</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="p">(</span><span class="n">new_llf</span> <span class="o">-</span> <span class="n">llf</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">llf_decrease_tolerance</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">llf_decrease_action</span> <span class="o">==</span> <span class="s1">&#39;revert&#39;</span> <span class="ow">and</span> <span class="n">llf_decrease</span><span class="p">:</span>
                <span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Log-likelihood decreased at EM iteration </span><span class="si">{</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s1">.&#39;</span>
                     <span class="sa">f</span><span class="s1">&#39; Reverting to the results from EM iteration </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">&#39;</span>
                     <span class="s1">&#39; (prior to the decrease) and returning the solution.&#39;</span><span class="p">)</span>
                <span class="c1"># Terminated iteration</span>
                <span class="n">i</span> <span class="o">-=</span> <span class="mi">1</span>
                <span class="n">terminate</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">llf_decrease_action</span> <span class="o">==</span> <span class="s1">&#39;warn&#39;</span> <span class="ow">and</span> <span class="n">llf_decrease</span><span class="p">:</span>
                    <span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Log-likelihood decreased at EM iteration </span><span class="si">{</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s1">,&#39;</span>
                         <span class="s1">&#39; which can indicate numerical issues.&#39;</span><span class="p">)</span>
                <span class="n">llf</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_llf</span><span class="p">)</span>
                <span class="n">params</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">em_initialization</span><span class="p">:</span>
                    <span class="n">init</span> <span class="o">=</span> <span class="n">initialization</span><span class="o">.</span><span class="n">Initialization</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">k_states</span><span class="p">,</span> <span class="s1">&#39;known&#39;</span><span class="p">,</span>
                        <span class="n">constant</span><span class="o">=</span><span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">smoothed_state</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                        <span class="n">stationary_cov</span><span class="o">=</span><span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">smoothed_state_cov</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
                    <span class="n">inits</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">init</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">delta</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">llf</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">llf</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span> <span class="o">/</span>
                             <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">llf</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">llf</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">])))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">delta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>

                <span class="c1"># If `disp` is not False, display the first iteration</span>
                <span class="k">if</span> <span class="n">disp</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;EM start iterations, llf=</span><span class="si">{</span><span class="n">llf</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">:</span><span class="s1">.5g</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="c1"># Print output every `disp` observations</span>
                <span class="k">elif</span> <span class="n">disp</span> <span class="ow">and</span> <span class="p">((</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">disp</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;EM iteration </span><span class="si">{</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s1">, llf=</span><span class="si">{</span><span class="n">llf</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">:</span><span class="s1">.5g</span><span class="si">}</span><span class="s1">,&#39;</span>
                          <span class="sa">f</span><span class="s1">&#39; convergence criterion=</span><span class="si">{</span><span class="n">delta</span><span class="si">:</span><span class="s1">.5g</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

            <span class="c1"># Advance the iteration counter</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># Check for convergence</span>
        <span class="n">not_converged</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">maxiter</span> <span class="ow">and</span> <span class="n">delta</span> <span class="o">&gt;</span> <span class="n">tolerance</span><span class="p">)</span>

        <span class="c1"># If no convergence without explicit termination, warn users</span>
        <span class="k">if</span> <span class="n">not_converged</span><span class="p">:</span>
            <span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;EM reached maximum number of iterations (</span><span class="si">{</span><span class="n">maxiter</span><span class="si">}</span><span class="s1">),&#39;</span>
                 <span class="sa">f</span><span class="s1">&#39; without achieving convergence: llf=</span><span class="si">{</span><span class="n">llf</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">:</span><span class="s1">.5g</span><span class="si">}</span><span class="s1">,&#39;</span>
                 <span class="sa">f</span><span class="s1">&#39; convergence criterion=</span><span class="si">{</span><span class="n">delta</span><span class="si">:</span><span class="s1">.5g</span><span class="si">}</span><span class="s1">&#39;</span>
                 <span class="sa">f</span><span class="s1">&#39; (while specified tolerance was </span><span class="si">{</span><span class="n">tolerance</span><span class="si">:</span><span class="s1">.5g</span><span class="si">}</span><span class="s1">)&#39;</span><span class="p">)</span>

        <span class="c1"># If `disp` is not False, display the final iteration</span>
        <span class="k">if</span> <span class="n">disp</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">terminate</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;EM terminated at iteration </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">, llf=</span><span class="si">{</span><span class="n">llf</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">:</span><span class="s1">.5g</span><span class="si">}</span><span class="s1">,&#39;</span>
                      <span class="sa">f</span><span class="s1">&#39; convergence criterion=</span><span class="si">{</span><span class="n">delta</span><span class="si">:</span><span class="s1">.5g</span><span class="si">}</span><span class="s1">&#39;</span>
                      <span class="sa">f</span><span class="s1">&#39; (while specified tolerance was </span><span class="si">{</span><span class="n">tolerance</span><span class="si">:</span><span class="s1">.5g</span><span class="si">}</span><span class="s1">)&#39;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">not_converged</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;EM reached maximum number of iterations (</span><span class="si">{</span><span class="n">maxiter</span><span class="si">}</span><span class="s1">),&#39;</span>
                      <span class="sa">f</span><span class="s1">&#39; without achieving convergence: llf=</span><span class="si">{</span><span class="n">llf</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">:</span><span class="s1">.5g</span><span class="si">}</span><span class="s1">,&#39;</span>
                      <span class="sa">f</span><span class="s1">&#39; convergence criterion=</span><span class="si">{</span><span class="n">delta</span><span class="si">:</span><span class="s1">.5g</span><span class="si">}</span><span class="s1">&#39;</span>
                      <span class="sa">f</span><span class="s1">&#39; (while specified tolerance was </span><span class="si">{</span><span class="n">tolerance</span><span class="si">:</span><span class="s1">.5g</span><span class="si">}</span><span class="s1">)&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;EM converged at iteration </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">, llf=</span><span class="si">{</span><span class="n">llf</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">:</span><span class="s1">.5g</span><span class="si">}</span><span class="s1">,&#39;</span>
                      <span class="sa">f</span><span class="s1">&#39; convergence criterion=</span><span class="si">{</span><span class="n">delta</span><span class="si">:</span><span class="s1">.5g</span><span class="si">}</span><span class="s1">&#39;</span>
                      <span class="sa">f</span><span class="s1">&#39; &lt; tolerance=</span><span class="si">{</span><span class="n">tolerance</span><span class="si">:</span><span class="s1">.5g</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="c1"># Just return the fitted parameters if requested</span>
        <span class="k">if</span> <span class="n">return_params</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># Otherwise construct the results class if desired</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">em_initialization</span><span class="p">:</span>
                <span class="n">base_init</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">initialization</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">initialization</span> <span class="o">=</span> <span class="n">init</span>
            <span class="c1"># Note that because we are using params[-1], we are actually using</span>
            <span class="c1"># the results from one additional iteration compared to the</span>
            <span class="c1"># iteration at which we declared convergence.</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">smooth</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                 <span class="n">cov_type</span><span class="o">=</span><span class="n">cov_type</span><span class="p">,</span> <span class="n">cov_kwds</span><span class="o">=</span><span class="n">cov_kwds</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">em_initialization</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">initialization</span> <span class="o">=</span> <span class="n">base_init</span>

            <span class="c1"># Save the output</span>
            <span class="k">if</span> <span class="n">full_output</span><span class="p">:</span>
                <span class="n">llf</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">llf</span><span class="p">)</span>
                <span class="n">em_retvals</span> <span class="o">=</span> <span class="n">Bunch</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="s1">&#39;params&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">params</span><span class="p">),</span>
                                      <span class="s1">&#39;llf&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">llf</span><span class="p">),</span>
                                      <span class="s1">&#39;iter&#39;</span><span class="p">:</span> <span class="n">i</span><span class="p">,</span>
                                      <span class="s1">&#39;inits&#39;</span><span class="p">:</span> <span class="n">inits</span><span class="p">})</span>
                <span class="n">em_settings</span> <span class="o">=</span> <span class="n">Bunch</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="s1">&#39;method&#39;</span><span class="p">:</span> <span class="s1">&#39;em&#39;</span><span class="p">,</span>
                                       <span class="s1">&#39;tolerance&#39;</span><span class="p">:</span> <span class="n">tolerance</span><span class="p">,</span>
                                       <span class="s1">&#39;maxiter&#39;</span><span class="p">:</span> <span class="n">maxiter</span><span class="p">})</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">em_retvals</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">em_settings</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="n">result</span><span class="o">.</span><span class="n">_results</span><span class="o">.</span><span class="n">mle_retvals</span> <span class="o">=</span> <span class="n">em_retvals</span>
            <span class="n">result</span><span class="o">.</span><span class="n">_results</span><span class="o">.</span><span class="n">mle_settings</span> <span class="o">=</span> <span class="n">em_settings</span>

        <span class="k">return</span> <span class="n">result</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_em_iteration</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params0</span><span class="p">,</span> <span class="n">init</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mstep_method</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;EM iteration.&quot;&quot;&quot;</span>
        <span class="c1"># (E)xpectation step</span>
        <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_em_expectation_step</span><span class="p">(</span><span class="n">params0</span><span class="p">,</span> <span class="n">init</span><span class="o">=</span><span class="n">init</span><span class="p">)</span>

        <span class="c1"># (M)aximization step</span>
        <span class="n">params1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_em_maximization_step</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">params0</span><span class="p">,</span>
                                             <span class="n">mstep_method</span><span class="o">=</span><span class="n">mstep_method</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">res</span><span class="p">,</span> <span class="n">params1</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_em_expectation_step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params0</span><span class="p">,</span> <span class="n">init</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;EM expectation step.&quot;&quot;&quot;</span>
        <span class="c1"># (E)xpectation step</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">params0</span><span class="p">)</span>
        <span class="c1"># Re-initialize state, if new initialization is given</span>
        <span class="k">if</span> <span class="n">init</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">base_init</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">initialization</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">initialization</span> <span class="o">=</span> <span class="n">init</span>
        <span class="c1"># Perform smoothing, only saving what is required</span>
        <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">smooth</span><span class="p">(</span>
            <span class="n">SMOOTHER_STATE</span> <span class="o">|</span> <span class="n">SMOOTHER_STATE_COV</span> <span class="o">|</span> <span class="n">SMOOTHER_STATE_AUTOCOV</span><span class="p">,</span>
            <span class="n">update_filter</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">res</span><span class="o">.</span><span class="n">llf_obs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">_kalman_filter</span><span class="o">.</span><span class="n">loglikelihood</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># Reset initialization</span>
        <span class="k">if</span> <span class="n">init</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">initialization</span> <span class="o">=</span> <span class="n">base_init</span>

        <span class="k">return</span> <span class="n">res</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_em_maximization_step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">params0</span><span class="p">,</span> <span class="n">mstep_method</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;EM maximization step.&quot;&quot;&quot;</span>
        <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s</span>

        <span class="n">a</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">smoothed_state</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>
        <span class="n">cov_a</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">smoothed_state_cov</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">acov_a</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">smoothed_state_autocov</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># E[a_t a_t&#39;], t = 0, ..., T</span>
        <span class="n">Eaa</span> <span class="o">=</span> <span class="n">cov_a</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="c1"># E[a_t a_{t-1}&#39;], t = 1, ..., T</span>
        <span class="n">Eaa1</span> <span class="o">=</span> <span class="n">acov_a</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">a</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

        <span class="c1"># Observation equation</span>
        <span class="n">has_missing</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">nmissing</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mstep_method</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">mstep_method</span> <span class="o">=</span> <span class="s1">&#39;missing&#39;</span> <span class="k">if</span> <span class="n">has_missing</span> <span class="k">else</span> <span class="s1">&#39;nonmissing&#39;</span>
        <span class="n">mstep_method</span> <span class="o">=</span> <span class="n">mstep_method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">mstep_method</span> <span class="o">==</span> <span class="s1">&#39;nonmissing&#39;</span> <span class="ow">and</span> <span class="n">has_missing</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Cannot use EM algorithm option&#39;</span>
                             <span class="s1">&#39; `mstep_method=&quot;nonmissing&quot;` with missing data.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">mstep_method</span> <span class="o">==</span> <span class="s1">&#39;nonmissing&#39;</span><span class="p">:</span>
            <span class="n">func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_em_maximization_obs_nonmissing</span>
        <span class="k">elif</span> <span class="n">mstep_method</span> <span class="o">==</span> <span class="s1">&#39;missing&#39;</span><span class="p">:</span>
            <span class="n">func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_em_maximization_obs_missing</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid maximization step method: &quot;</span><span class="si">%s</span><span class="s1">&quot;.&#39;</span>
                             <span class="o">%</span> <span class="n">mstep_method</span><span class="p">)</span>
        <span class="c1"># TODO: compute H is pretty slow</span>
        <span class="n">Lambda</span><span class="p">,</span> <span class="n">H</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">Eaa</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">compute_H</span><span class="o">=</span><span class="p">(</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">idiosyncratic_ar1</span><span class="p">))</span>

        <span class="c1"># Factor VAR and covariance</span>
        <span class="n">factor_ar</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">factor_cov</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">s</span><span class="o">.</span><span class="n">factor_blocks</span><span class="p">:</span>
            <span class="n">A</span> <span class="o">=</span> <span class="n">Eaa</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="p">[</span><span class="s1">&#39;factors_ar&#39;</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="s1">&#39;factors_ar&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">B</span> <span class="o">=</span> <span class="n">Eaa1</span><span class="p">[:,</span> <span class="n">b</span><span class="p">[</span><span class="s1">&#39;factors_L1&#39;</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="s1">&#39;factors_ar&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">C</span> <span class="o">=</span> <span class="n">Eaa</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="n">b</span><span class="p">[</span><span class="s1">&#39;factors_L1&#39;</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="s1">&#39;factors_L1&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">nobs</span> <span class="o">=</span> <span class="n">Eaa</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>

            <span class="c1"># want: x = B A^{-1}, so solve: x A = B or solve: A&#39; x&#39; = B&#39;</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">f_A</span> <span class="o">=</span> <span class="n">cho_solve</span><span class="p">(</span><span class="n">cho_factor</span><span class="p">(</span><span class="n">A</span><span class="p">),</span> <span class="n">B</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
            <span class="k">except</span> <span class="n">LinAlgError</span><span class="p">:</span>
                <span class="c1"># Fall back to general solver if there are problems with</span>
                <span class="c1"># positive-definiteness</span>
                <span class="n">f_A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

            <span class="n">f_Q</span> <span class="o">=</span> <span class="p">(</span><span class="n">C</span> <span class="o">-</span> <span class="n">f_A</span> <span class="o">@</span> <span class="n">B</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">/</span> <span class="n">nobs</span>
            <span class="n">factor_ar</span> <span class="o">+=</span> <span class="n">f_A</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="n">factor_cov</span> <span class="o">+=</span> <span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">cholesky</span><span class="p">(</span><span class="n">f_Q</span><span class="p">)[</span><span class="n">np</span><span class="o">.</span><span class="n">tril_indices_from</span><span class="p">(</span><span class="n">f_Q</span><span class="p">)]</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>

        <span class="c1"># Idiosyncratic AR(1) and variances</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">idiosyncratic_ar1</span><span class="p">:</span>
            <span class="n">ix</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="s1">&#39;idio_ar_L1&#39;</span><span class="p">]</span>

            <span class="n">Ad</span> <span class="o">=</span> <span class="n">Eaa</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">diagonal</span><span class="p">()</span>
            <span class="n">Bd</span> <span class="o">=</span> <span class="n">Eaa1</span><span class="p">[:,</span> <span class="n">ix</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">diagonal</span><span class="p">()</span>
            <span class="n">Cd</span> <span class="o">=</span> <span class="n">Eaa</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="n">ix</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">diagonal</span><span class="p">()</span>
            <span class="n">nobs</span> <span class="o">=</span> <span class="n">Eaa</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>

            <span class="n">alpha</span> <span class="o">=</span> <span class="n">Bd</span> <span class="o">/</span> <span class="n">Ad</span>
            <span class="n">sigma2</span> <span class="o">=</span> <span class="p">(</span><span class="n">Cd</span> <span class="o">-</span> <span class="n">alpha</span> <span class="o">*</span> <span class="n">Bd</span><span class="p">)</span> <span class="o">/</span> <span class="n">nobs</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ix</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="s1">&#39;idio_ar_L1&#39;</span><span class="p">]</span>
            <span class="n">C</span> <span class="o">=</span> <span class="n">Eaa</span><span class="p">[:,</span> <span class="n">ix</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">sigma2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">H</span><span class="o">.</span><span class="n">diagonal</span><span class="p">()[</span><span class="bp">self</span><span class="o">.</span><span class="n">_o</span><span class="p">[</span><span class="s1">&#39;M&#39;</span><span class="p">]],</span>
                           <span class="n">C</span><span class="o">.</span><span class="n">diagonal</span><span class="p">()</span> <span class="o">/</span> <span class="n">Eaa</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>

        <span class="c1"># Save parameters</span>
        <span class="n">params1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">params0</span><span class="p">)</span>
        <span class="n">loadings</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">):</span>
            <span class="n">iloc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s</span><span class="o">.</span><span class="n">endog_factor_iloc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">factor_ix</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="s1">&#39;factors_L1&#39;</span><span class="p">][</span><span class="n">iloc</span><span class="p">]</span>
            <span class="n">loadings</span> <span class="o">+=</span> <span class="n">Lambda</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">factor_ix</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="n">params1</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_p</span><span class="p">[</span><span class="s1">&#39;loadings&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">loadings</span>
        <span class="n">params1</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_p</span><span class="p">[</span><span class="s1">&#39;factor_ar&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">factor_ar</span>
        <span class="n">params1</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_p</span><span class="p">[</span><span class="s1">&#39;factor_cov&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">factor_cov</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">idiosyncratic_ar1</span><span class="p">:</span>
            <span class="n">params1</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_p</span><span class="p">[</span><span class="s1">&#39;idiosyncratic_ar1&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">alpha</span>
        <span class="n">params1</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_p</span><span class="p">[</span><span class="s1">&#39;idiosyncratic_var&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">sigma2</span>

        <span class="k">return</span> <span class="n">params1</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_em_maximization_obs_nonmissing</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">Eaa</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">compute_H</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;EM maximization step, observation equation without missing data.&quot;&quot;&quot;</span>
        <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">Eaa</span><span class="o">.</span><span class="n">dtype</span>

        <span class="c1"># Observation equation (non-missing)</span>
        <span class="c1"># Note: we only compute loadings for monthly variables because</span>
        <span class="c1"># quarterly variables will always have missing entries, so we would</span>
        <span class="c1"># never choose this method in that case</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">k_states_factors</span>
        <span class="n">Lambda</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">,</span> <span class="n">k</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">):</span>
            <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">endog</span><span class="p">[:,</span> <span class="n">i</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">iloc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s</span><span class="o">.</span><span class="n">endog_factor_iloc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">factor_ix</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="s1">&#39;factors_L1&#39;</span><span class="p">][</span><span class="n">iloc</span><span class="p">]</span>

            <span class="n">ix</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">s_</span><span class="p">[:],)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span><span class="n">factor_ix</span><span class="p">,</span> <span class="n">factor_ix</span><span class="p">)</span>
            <span class="n">A</span> <span class="o">=</span> <span class="n">Eaa</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">B</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">a</span><span class="p">[:,</span> <span class="n">factor_ix</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">idiosyncratic_ar1</span><span class="p">:</span>
                <span class="n">ix1</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">k_states_factors</span> <span class="o">+</span> <span class="n">i</span>
                <span class="n">ix2</span> <span class="o">=</span> <span class="n">ix1</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="n">B</span> <span class="o">-=</span> <span class="n">Eaa</span><span class="p">[:,</span> <span class="n">ix1</span><span class="p">:</span><span class="n">ix2</span><span class="p">,</span> <span class="n">factor_ix</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

            <span class="c1"># want: x = B A^{-1}, so solve: x A = B or solve: A&#39; x&#39; = B&#39;</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">Lambda</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">factor_ix</span><span class="p">]</span> <span class="o">=</span> <span class="n">cho_solve</span><span class="p">(</span><span class="n">cho_factor</span><span class="p">(</span><span class="n">A</span><span class="p">),</span> <span class="n">B</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
            <span class="k">except</span> <span class="n">LinAlgError</span><span class="p">:</span>
                <span class="c1"># Fall back to general solver if there are problems with</span>
                <span class="c1"># positive-definiteness</span>
                <span class="n">Lambda</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">factor_ix</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

        <span class="c1"># Compute new obs cov</span>
        <span class="c1"># Note: this is unnecessary if `idiosyncratic_ar1=True`.</span>
        <span class="c1"># This is written in a slightly more general way than</span>
        <span class="c1"># Banbura and Modugno (2014), equation (7); see instead equation (13)</span>
        <span class="c1"># of Wu et al. (1996)</span>
        <span class="c1"># &quot;An algorithm for estimating parameters of state-space models&quot;</span>
        <span class="k">if</span> <span class="n">compute_H</span><span class="p">:</span>
            <span class="n">Z</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;design&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">Z</span><span class="p">[:,</span> <span class="p">:</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">Lambda</span>
            <span class="n">BL</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">endog</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">a</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">@</span> <span class="n">Z</span><span class="o">.</span><span class="n">T</span>
            <span class="n">C</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">endog</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">endog</span>

            <span class="n">H</span> <span class="o">=</span> <span class="p">(</span><span class="n">C</span> <span class="o">+</span> <span class="o">-</span><span class="n">BL</span> <span class="o">-</span> <span class="n">BL</span><span class="o">.</span><span class="n">T</span> <span class="o">+</span> <span class="n">Z</span> <span class="o">@</span> <span class="n">Eaa</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">@</span> <span class="n">Z</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

        <span class="k">return</span> <span class="n">Lambda</span><span class="p">,</span> <span class="n">H</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_em_maximization_obs_missing</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">Eaa</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">compute_H</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;EM maximization step, observation equation with missing data.&quot;&quot;&quot;</span>
        <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">Eaa</span><span class="o">.</span><span class="n">dtype</span>

        <span class="c1"># Observation equation (missing)</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">k_states_factors</span>
        <span class="n">Lambda</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">,</span> <span class="n">k</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

        <span class="n">W</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">res</span><span class="o">.</span><span class="n">missing</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">W</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>

        <span class="c1"># Compute design for monthly</span>
        <span class="c1"># Note: the relevant A changes for each i</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_endog_M</span><span class="p">):</span>
            <span class="n">iloc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s</span><span class="o">.</span><span class="n">endog_factor_iloc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">factor_ix</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="s1">&#39;factors_L1&#39;</span><span class="p">][</span><span class="n">iloc</span><span class="p">]</span>

            <span class="n">m</span> <span class="o">=</span> <span class="n">mask</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span>
            <span class="n">yt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">endog</span><span class="p">[</span><span class="n">m</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>

            <span class="n">ix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">factor_ix</span><span class="p">,</span> <span class="n">factor_ix</span><span class="p">)</span>
            <span class="n">Ai</span> <span class="o">=</span> <span class="n">Eaa</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">Bi</span> <span class="o">=</span> <span class="n">yt</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">a</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">factor_ix</span><span class="p">)][</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">idiosyncratic_ar1</span><span class="p">:</span>
                <span class="n">ix1</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">k_states_factors</span> <span class="o">+</span> <span class="n">i</span>
                <span class="n">ix2</span> <span class="o">=</span> <span class="n">ix1</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="n">Bi</span> <span class="o">-=</span> <span class="n">Eaa</span><span class="p">[</span><span class="n">m</span><span class="p">,</span> <span class="n">ix1</span><span class="p">:</span><span class="n">ix2</span><span class="p">][</span><span class="o">...</span><span class="p">,</span> <span class="n">factor_ix</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="c1"># want: x = B A^{-1}, so solve: x A = B or solve: A&#39; x&#39; = B&#39;</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">Lambda</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">factor_ix</span><span class="p">]</span> <span class="o">=</span> <span class="n">cho_solve</span><span class="p">(</span><span class="n">cho_factor</span><span class="p">(</span><span class="n">Ai</span><span class="p">),</span> <span class="n">Bi</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
            <span class="k">except</span> <span class="n">LinAlgError</span><span class="p">:</span>
                <span class="c1"># Fall back to general solver if there are problems with</span>
                <span class="c1"># positive-definiteness</span>
                <span class="n">Lambda</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">factor_ix</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">Ai</span><span class="p">,</span> <span class="n">Bi</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

        <span class="c1"># Compute unrestricted design for quarterly</span>
        <span class="c1"># See Banbura at al. (2011), where this is described in Appendix C,</span>
        <span class="c1"># between equations (13) and (14).</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog_Q</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Note: the relevant A changes for each i</span>
            <span class="n">multipliers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">])[:,</span> <span class="kc">None</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_endog_M</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">):</span>
                <span class="n">iloc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s</span><span class="o">.</span><span class="n">endog_factor_iloc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">factor_ix</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="s1">&#39;factors_L1_5_ix&#39;</span><span class="p">][:,</span> <span class="n">iloc</span><span class="p">]</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

                <span class="n">R</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">loading_constraints</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

                <span class="n">iQ</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog_M</span>
                <span class="n">m</span> <span class="o">=</span> <span class="n">mask</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span>
                <span class="n">yt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">endog</span><span class="p">[</span><span class="n">m</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                <span class="n">ix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">factor_ix</span><span class="p">,</span> <span class="n">factor_ix</span><span class="p">)</span>
                <span class="n">Ai</span> <span class="o">=</span> <span class="n">Eaa</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">BiQ</span> <span class="o">=</span> <span class="n">yt</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">a</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">factor_ix</span><span class="p">)][</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">idiosyncratic_ar1</span><span class="p">:</span>
                    <span class="n">ix</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">s_</span><span class="p">[:],)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="s1">&#39;idio_ar_Q_ix&#39;</span><span class="p">][</span><span class="n">iQ</span><span class="p">],</span> <span class="n">factor_ix</span><span class="p">)</span>
                    <span class="n">Eepsf</span> <span class="o">=</span> <span class="n">Eaa</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span>
                    <span class="n">BiQ</span> <span class="o">-=</span> <span class="p">(</span><span class="n">multipliers</span> <span class="o">*</span> <span class="n">Eepsf</span><span class="p">[</span><span class="n">m</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

                <span class="c1"># Note that there was a typo in Banbura et al. (2011) for</span>
                <span class="c1"># the formula applying the restrictions. In their notation,</span>
                <span class="c1"># they show (C D C&#39;)^{-1} while it should be (C D^{-1} C&#39;)^{-1}</span>
                <span class="c1"># Note: in reality, this is:</span>
                <span class="c1"># unrestricted - Aii @ R.T @ RARi @ (R @ unrestricted - q)</span>
                <span class="c1"># where the restrictions are defined as: R @ unrestricted = q</span>
                <span class="c1"># However, here q = 0, so we can simplify.</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">L_and_lower</span> <span class="o">=</span> <span class="n">cho_factor</span><span class="p">(</span><span class="n">Ai</span><span class="p">)</span>
                    <span class="c1"># x = BQ A^{-1}, or x A = BQ, so solve A&#39; x&#39; = (BQ)&#39;</span>
                    <span class="n">unrestricted</span> <span class="o">=</span> <span class="n">cho_solve</span><span class="p">(</span><span class="n">L_and_lower</span><span class="p">,</span> <span class="n">BiQ</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">AiiRT</span> <span class="o">=</span> <span class="n">cho_solve</span><span class="p">(</span><span class="n">L_and_lower</span><span class="p">,</span> <span class="n">R</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

                    <span class="n">L_and_lower</span> <span class="o">=</span> <span class="n">cho_factor</span><span class="p">(</span><span class="n">R</span> <span class="o">@</span> <span class="n">AiiRT</span><span class="p">)</span>
                    <span class="n">RAiiRTiR</span> <span class="o">=</span> <span class="n">cho_solve</span><span class="p">(</span><span class="n">L_and_lower</span><span class="p">,</span> <span class="n">R</span><span class="p">)</span>
                    <span class="n">restricted</span> <span class="o">=</span> <span class="n">unrestricted</span> <span class="o">-</span> <span class="n">AiiRT</span> <span class="o">@</span> <span class="n">RAiiRTiR</span> <span class="o">@</span> <span class="n">unrestricted</span>
                <span class="k">except</span> <span class="n">LinAlgError</span><span class="p">:</span>
                    <span class="c1"># Fall back to slower method if there are problems with</span>
                    <span class="c1"># positive-definiteness</span>
                    <span class="n">Aii</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">Ai</span><span class="p">)</span>
                    <span class="n">unrestricted</span> <span class="o">=</span> <span class="p">(</span><span class="n">BiQ</span> <span class="o">@</span> <span class="n">Aii</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">RARi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">R</span> <span class="o">@</span> <span class="n">Aii</span> <span class="o">@</span> <span class="n">R</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
                    <span class="n">restricted</span> <span class="o">=</span> <span class="p">(</span><span class="n">unrestricted</span> <span class="o">-</span>
                                  <span class="n">Aii</span> <span class="o">@</span> <span class="n">R</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">RARi</span> <span class="o">@</span> <span class="n">R</span> <span class="o">@</span> <span class="n">unrestricted</span><span class="p">)</span>
                <span class="n">Lambda</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">factor_ix</span><span class="p">]</span> <span class="o">=</span> <span class="n">restricted</span>

        <span class="c1"># Compute new obs cov</span>
        <span class="c1"># Note: this is unnecessary if `idiosyncratic_ar1=True`.</span>
        <span class="c1"># See Banbura and Modugno (2014), equation (12)</span>
        <span class="c1"># This does not literally follow their formula, e.g. multiplying by the</span>
        <span class="c1"># W_t selection matrices, because those formulas require loops that are</span>
        <span class="c1"># relatively slow. The formulation here is vectorized.</span>
        <span class="k">if</span> <span class="n">compute_H</span><span class="p">:</span>
            <span class="n">Z</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;design&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">Z</span><span class="p">[:,</span> <span class="p">:</span><span class="n">Lambda</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">Lambda</span>

            <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endog</span><span class="p">)</span>
            <span class="n">C</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">y</span>
            <span class="n">W</span> <span class="o">=</span> <span class="n">W</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>
            <span class="n">IW</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">W</span>

            <span class="n">WL</span> <span class="o">=</span> <span class="n">W</span> <span class="o">*</span> <span class="n">Z</span>
            <span class="n">WLT</span> <span class="o">=</span> <span class="n">WL</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">BL</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">@</span> <span class="n">a</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">@</span> <span class="n">WLT</span>
            <span class="n">A</span> <span class="o">=</span> <span class="n">Eaa</span>

            <span class="n">BLT</span> <span class="o">=</span> <span class="n">BL</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">IWT</span> <span class="o">=</span> <span class="n">IW</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

            <span class="n">H</span> <span class="o">=</span> <span class="p">(</span><span class="n">C</span> <span class="o">+</span> <span class="p">(</span><span class="o">-</span><span class="n">BL</span> <span class="o">-</span> <span class="n">BLT</span> <span class="o">+</span> <span class="n">WL</span> <span class="o">@</span> <span class="n">A</span> <span class="o">@</span> <span class="n">WLT</span> <span class="o">+</span>
                      <span class="n">IW</span> <span class="o">*</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;obs_cov&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">IWT</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

        <span class="k">return</span> <span class="n">Lambda</span><span class="p">,</span> <span class="n">H</span>

<div class="viewcode-block" id="DynamicFactorMQ.smooth">
<a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.dynamic_factor_mq.DynamicFactorMQ.smooth.html#statsmodels.tsa.statespace.dynamic_factor_mq.DynamicFactorMQ.smooth">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">smooth</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">includes_fixed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
               <span class="n">complex_step</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">cov_type</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">,</span> <span class="n">cov_kwds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="n">return_ssm</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">results_class</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="n">results_wrapper_class</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Kalman smoothing.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array_like</span>
<span class="sd">            Array of parameters at which to evaluate the loglikelihood</span>
<span class="sd">            function.</span>
<span class="sd">        transformed : bool, optional</span>
<span class="sd">            Whether or not `params` is already transformed. Default is True.</span>
<span class="sd">        return_ssm : bool,optional</span>
<span class="sd">            Whether or not to return only the state space output or a full</span>
<span class="sd">            results object. Default is to return a full results object.</span>
<span class="sd">        cov_type : str, optional</span>
<span class="sd">            See `MLEResults.fit` for a description of covariance matrix types</span>
<span class="sd">            for results object. Default is None.</span>
<span class="sd">        cov_kwds : dict or None, optional</span>
<span class="sd">            See `MLEResults.get_robustcov_results` for a description required</span>
<span class="sd">            keywords for alternative covariance estimators</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Additional keyword arguments to pass to the Kalman filter. See</span>
<span class="sd">            `KalmanFilter.filter` for more details.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">smooth</span><span class="p">(</span>
            <span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="n">transformed</span><span class="p">,</span> <span class="n">includes_fixed</span><span class="o">=</span><span class="n">includes_fixed</span><span class="p">,</span>
            <span class="n">complex_step</span><span class="o">=</span><span class="n">complex_step</span><span class="p">,</span> <span class="n">cov_type</span><span class="o">=</span><span class="n">cov_type</span><span class="p">,</span> <span class="n">cov_kwds</span><span class="o">=</span><span class="n">cov_kwds</span><span class="p">,</span>
            <span class="n">return_ssm</span><span class="o">=</span><span class="n">return_ssm</span><span class="p">,</span> <span class="n">results_class</span><span class="o">=</span><span class="n">results_class</span><span class="p">,</span>
            <span class="n">results_wrapper_class</span><span class="o">=</span><span class="n">results_wrapper_class</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="DynamicFactorMQ.filter">
<a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.dynamic_factor_mq.DynamicFactorMQ.filter.html#statsmodels.tsa.statespace.dynamic_factor_mq.DynamicFactorMQ.filter">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">includes_fixed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
               <span class="n">complex_step</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">cov_type</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">,</span> <span class="n">cov_kwds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="n">return_ssm</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">results_class</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="n">results_wrapper_class</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">low_memory</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Kalman filtering.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array_like</span>
<span class="sd">            Array of parameters at which to evaluate the loglikelihood</span>
<span class="sd">            function.</span>
<span class="sd">        transformed : bool, optional</span>
<span class="sd">            Whether or not `params` is already transformed. Default is True.</span>
<span class="sd">        return_ssm : bool,optional</span>
<span class="sd">            Whether or not to return only the state space output or a full</span>
<span class="sd">            results object. Default is to return a full results object.</span>
<span class="sd">        cov_type : str, optional</span>
<span class="sd">            See `MLEResults.fit` for a description of covariance matrix types</span>
<span class="sd">            for results object. Default is &#39;none&#39;.</span>
<span class="sd">        cov_kwds : dict or None, optional</span>
<span class="sd">            See `MLEResults.get_robustcov_results` for a description required</span>
<span class="sd">            keywords for alternative covariance estimators</span>
<span class="sd">        low_memory : bool, optional</span>
<span class="sd">            If set to True, techniques are applied to substantially reduce</span>
<span class="sd">            memory usage. If used, some features of the results object will</span>
<span class="sd">            not be available (including in-sample prediction), although</span>
<span class="sd">            out-of-sample forecasting is possible. Default is False.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Additional keyword arguments to pass to the Kalman filter. See</span>
<span class="sd">            `KalmanFilter.filter` for more details.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
            <span class="n">params</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="n">transformed</span><span class="p">,</span> <span class="n">includes_fixed</span><span class="o">=</span><span class="n">includes_fixed</span><span class="p">,</span>
            <span class="n">complex_step</span><span class="o">=</span><span class="n">complex_step</span><span class="p">,</span> <span class="n">cov_type</span><span class="o">=</span><span class="n">cov_type</span><span class="p">,</span> <span class="n">cov_kwds</span><span class="o">=</span><span class="n">cov_kwds</span><span class="p">,</span>
            <span class="n">return_ssm</span><span class="o">=</span><span class="n">return_ssm</span><span class="p">,</span> <span class="n">results_class</span><span class="o">=</span><span class="n">results_class</span><span class="p">,</span>
            <span class="n">results_wrapper_class</span><span class="o">=</span><span class="n">results_wrapper_class</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="DynamicFactorMQ.simulate">
<a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.dynamic_factor_mq.DynamicFactorMQ.simulate.html#statsmodels.tsa.statespace.dynamic_factor_mq.DynamicFactorMQ.simulate">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">simulate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">nsimulations</span><span class="p">,</span> <span class="n">measurement_shocks</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">state_shocks</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">initial_state</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">anchor</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">repetitions</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">exog</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">extend_model</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">extend_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">includes_fixed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">original_scale</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Simulate a new time series following the state space model.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array_like</span>
<span class="sd">            Array of parameters to use in constructing the state space</span>
<span class="sd">            representation to use when simulating.</span>
<span class="sd">        nsimulations : int</span>
<span class="sd">            The number of observations to simulate. If the model is</span>
<span class="sd">            time-invariant this can be any number. If the model is</span>
<span class="sd">            time-varying, then this number must be less than or equal to the</span>
<span class="sd">            number of observations.</span>
<span class="sd">        measurement_shocks : array_like, optional</span>
<span class="sd">            If specified, these are the shocks to the measurement equation,</span>
<span class="sd">            :math:`\varepsilon_t`. If unspecified, these are automatically</span>
<span class="sd">            generated using a pseudo-random number generator. If specified,</span>
<span class="sd">            must be shaped `nsimulations` x `k_endog`, where `k_endog` is the</span>
<span class="sd">            same as in the state space model.</span>
<span class="sd">        state_shocks : array_like, optional</span>
<span class="sd">            If specified, these are the shocks to the state equation,</span>
<span class="sd">            :math:`\eta_t`. If unspecified, these are automatically</span>
<span class="sd">            generated using a pseudo-random number generator. If specified,</span>
<span class="sd">            must be shaped `nsimulations` x `k_posdef` where `k_posdef` is the</span>
<span class="sd">            same as in the state space model.</span>
<span class="sd">        initial_state : array_like, optional</span>
<span class="sd">            If specified, this is the initial state vector to use in</span>
<span class="sd">            simulation, which should be shaped (`k_states` x 1), where</span>
<span class="sd">            `k_states` is the same as in the state space model. If unspecified,</span>
<span class="sd">            but the model has been initialized, then that initialization is</span>
<span class="sd">            used. This must be specified if `anchor` is anything other than</span>
<span class="sd">            &quot;start&quot; or 0 (or else you can use the `simulate` method on a</span>
<span class="sd">            results object rather than on the model object).</span>
<span class="sd">        anchor : int, str, or datetime, optional</span>
<span class="sd">            First period for simulation. The simulation will be conditional on</span>
<span class="sd">            all existing datapoints prior to the `anchor`.  Type depends on the</span>
<span class="sd">            index of the given `endog` in the model. Two special cases are the</span>
<span class="sd">            strings &#39;start&#39; and &#39;end&#39;. `start` refers to beginning the</span>
<span class="sd">            simulation at the first period of the sample, and `end` refers to</span>
<span class="sd">            beginning the simulation at the first period after the sample.</span>
<span class="sd">            Integer values can run from 0 to `nobs`, or can be negative to</span>
<span class="sd">            apply negative indexing. Finally, if a date/time index was provided</span>
<span class="sd">            to the model, then this argument can be a date string to parse or a</span>
<span class="sd">            datetime type. Default is &#39;start&#39;.</span>
<span class="sd">        repetitions : int, optional</span>
<span class="sd">            Number of simulated paths to generate. Default is 1 simulated path.</span>
<span class="sd">        exog : array_like, optional</span>
<span class="sd">            New observations of exogenous regressors, if applicable.</span>
<span class="sd">        transformed : bool, optional</span>
<span class="sd">            Whether or not `params` is already transformed. Default is</span>
<span class="sd">            True.</span>
<span class="sd">        includes_fixed : bool, optional</span>
<span class="sd">            If parameters were previously fixed with the `fix_params` method,</span>
<span class="sd">            this argument describes whether or not `params` also includes</span>
<span class="sd">            the fixed parameters, in addition to the free parameters. Default</span>
<span class="sd">            is False.</span>
<span class="sd">        original_scale : bool, optional</span>
<span class="sd">            If the model specification standardized the data, whether or not</span>
<span class="sd">            to return simulations in the original scale of the data (i.e.</span>
<span class="sd">            before it was standardized by the model). Default is True.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        simulated_obs : ndarray</span>
<span class="sd">            An array of simulated observations. If `repetitions=None`, then it</span>
<span class="sd">            will be shaped (nsimulations x k_endog) or (nsimulations,) if</span>
<span class="sd">            `k_endog=1`. Otherwise it will be shaped</span>
<span class="sd">            (nsimulations x k_endog x repetitions). If the model was given</span>
<span class="sd">            Pandas input then the output will be a Pandas object. If</span>
<span class="sd">            `k_endog &gt; 1` and `repetitions` is not None, then the output will</span>
<span class="sd">            be a Pandas DataFrame that has a MultiIndex for the columns, with</span>
<span class="sd">            the first level containing the names of the `endog` variables and</span>
<span class="sd">            the second level containing the repetition number.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get usual simulations (in the possibly-standardized scale)</span>
        <span class="n">sim</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">simulate</span><span class="p">(</span>
            <span class="n">params</span><span class="p">,</span> <span class="n">nsimulations</span><span class="p">,</span> <span class="n">measurement_shocks</span><span class="o">=</span><span class="n">measurement_shocks</span><span class="p">,</span>
            <span class="n">state_shocks</span><span class="o">=</span><span class="n">state_shocks</span><span class="p">,</span> <span class="n">initial_state</span><span class="o">=</span><span class="n">initial_state</span><span class="p">,</span>
            <span class="n">anchor</span><span class="o">=</span><span class="n">anchor</span><span class="p">,</span> <span class="n">repetitions</span><span class="o">=</span><span class="n">repetitions</span><span class="p">,</span> <span class="n">exog</span><span class="o">=</span><span class="n">exog</span><span class="p">,</span>
            <span class="n">extend_model</span><span class="o">=</span><span class="n">extend_model</span><span class="p">,</span> <span class="n">extend_kwargs</span><span class="o">=</span><span class="n">extend_kwargs</span><span class="p">,</span>
            <span class="n">transformed</span><span class="o">=</span><span class="n">transformed</span><span class="p">,</span> <span class="n">includes_fixed</span><span class="o">=</span><span class="n">includes_fixed</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># If applicable, convert predictions back to original space</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">standardize</span> <span class="ow">and</span> <span class="n">original_scale</span><span class="p">:</span>
            <span class="n">use_pandas</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">PandasData</span><span class="p">)</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">shape</span>

            <span class="k">if</span> <span class="n">use_pandas</span><span class="p">:</span>
                <span class="c1"># pd.Series (k_endog=1, replications=None)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">std</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_endog_std</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">mean</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_endog_mean</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">sim</span> <span class="o">=</span> <span class="n">sim</span> <span class="o">*</span> <span class="n">std</span> <span class="o">+</span> <span class="n">mean</span>
                <span class="c1"># pd.DataFrame (k_endog &gt; 1, replications=None)</span>
                <span class="c1"># [or]</span>
                <span class="c1"># pd.DataFrame with MultiIndex (replications &gt; 0)</span>
                <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">sim</span> <span class="o">=</span> <span class="p">(</span><span class="n">sim</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_endog_std</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                              <span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_endog_mean</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># 1-dim array (k_endog=1, replications=None)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">sim</span> <span class="o">=</span> <span class="n">sim</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_endog_std</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_endog_mean</span>
                <span class="c1"># 2-dim array (k_endog &gt; 1, replications=None)</span>
                <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">sim</span> <span class="o">=</span> <span class="n">sim</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_endog_std</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_endog_mean</span>
                <span class="c1"># 3-dim array with MultiIndex (replications &gt; 0)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Get arrays into the form that can be used for</span>
                    <span class="c1"># broadcasting</span>
                    <span class="n">std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_endog_std</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>
                    <span class="n">mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_endog_mean</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>
                    <span class="n">sim</span> <span class="o">=</span> <span class="n">sim</span> <span class="o">*</span> <span class="n">std</span> <span class="o">+</span> <span class="n">mean</span>

        <span class="k">return</span> <span class="n">sim</span></div>


<div class="viewcode-block" id="DynamicFactorMQ.impulse_responses">
<a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.dynamic_factor_mq.DynamicFactorMQ.impulse_responses.html#statsmodels.tsa.statespace.dynamic_factor_mq.DynamicFactorMQ.impulse_responses">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">impulse_responses</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">steps</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">impulse</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                          <span class="n">orthogonalized</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">cumulative</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">anchor</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                          <span class="n">exog</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">extend_model</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">extend_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                          <span class="n">transformed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">includes_fixed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                          <span class="n">original_scale</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Impulse response function.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array_like</span>
<span class="sd">            Array of model parameters.</span>
<span class="sd">        steps : int, optional</span>
<span class="sd">            The number of steps for which impulse responses are calculated.</span>
<span class="sd">            Default is 1. Note that for time-invariant models, the initial</span>
<span class="sd">            impulse is not counted as a step, so if `steps=1`, the output will</span>
<span class="sd">            have 2 entries.</span>
<span class="sd">        impulse : int or array_like</span>
<span class="sd">            If an integer, the state innovation to pulse; must be between 0</span>
<span class="sd">            and `k_posdef-1`. Alternatively, a custom impulse vector may be</span>
<span class="sd">            provided; must be shaped `k_posdef x 1`.</span>
<span class="sd">        orthogonalized : bool, optional</span>
<span class="sd">            Whether or not to perform impulse using orthogonalized innovations.</span>
<span class="sd">            Note that this will also affect custum `impulse` vectors. Default</span>
<span class="sd">            is False.</span>
<span class="sd">        cumulative : bool, optional</span>
<span class="sd">            Whether or not to return cumulative impulse responses. Default is</span>
<span class="sd">            False.</span>
<span class="sd">        anchor : int, str, or datetime, optional</span>
<span class="sd">            Time point within the sample for the state innovation impulse. Type</span>
<span class="sd">            depends on the index of the given `endog` in the model. Two special</span>
<span class="sd">            cases are the strings &#39;start&#39; and &#39;end&#39;, which refer to setting the</span>
<span class="sd">            impulse at the first and last points of the sample, respectively.</span>
<span class="sd">            Integer values can run from 0 to `nobs - 1`, or can be negative to</span>
<span class="sd">            apply negative indexing. Finally, if a date/time index was provided</span>
<span class="sd">            to the model, then this argument can be a date string to parse or a</span>
<span class="sd">            datetime type. Default is &#39;start&#39;.</span>
<span class="sd">        exog : array_like, optional</span>
<span class="sd">            New observations of exogenous regressors for our-of-sample periods,</span>
<span class="sd">            if applicable.</span>
<span class="sd">        transformed : bool, optional</span>
<span class="sd">            Whether or not `params` is already transformed. Default is</span>
<span class="sd">            True.</span>
<span class="sd">        includes_fixed : bool, optional</span>
<span class="sd">            If parameters were previously fixed with the `fix_params` method,</span>
<span class="sd">            this argument describes whether or not `params` also includes</span>
<span class="sd">            the fixed parameters, in addition to the free parameters. Default</span>
<span class="sd">            is False.</span>
<span class="sd">        original_scale : bool, optional</span>
<span class="sd">            If the model specification standardized the data, whether or not</span>
<span class="sd">            to return impulse responses in the original scale of the data (i.e.</span>
<span class="sd">            before it was standardized by the model). Default is True.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            If the model has time-varying design or transition matrices and the</span>
<span class="sd">            combination of `anchor` and `steps` implies creating impulse</span>
<span class="sd">            responses for the out-of-sample period, then these matrices must</span>
<span class="sd">            have updated values provided for the out-of-sample steps. For</span>
<span class="sd">            example, if `design` is a time-varying component, `nobs` is 10,</span>
<span class="sd">            `anchor=1`, and `steps` is 15, a (`k_endog` x `k_states` x 7)</span>
<span class="sd">            matrix must be provided with the new design matrix values.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        impulse_responses : ndarray</span>
<span class="sd">            Responses for each endogenous variable due to the impulse</span>
<span class="sd">            given by the `impulse` argument. For a time-invariant model, the</span>
<span class="sd">            impulse responses are given for `steps + 1` elements (this gives</span>
<span class="sd">            the &quot;initial impulse&quot; followed by `steps` responses for the</span>
<span class="sd">            important cases of VAR and SARIMAX models), while for time-varying</span>
<span class="sd">            models the impulse responses are only given for `steps` elements</span>
<span class="sd">            (to avoid having to unexpectedly provide updated time-varying</span>
<span class="sd">            matrices).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get usual simulations (in the possibly-standardized scale)</span>
        <span class="n">irfs</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">impulse_responses</span><span class="p">(</span>
            <span class="n">params</span><span class="p">,</span> <span class="n">steps</span><span class="o">=</span><span class="n">steps</span><span class="p">,</span> <span class="n">impulse</span><span class="o">=</span><span class="n">impulse</span><span class="p">,</span>
            <span class="n">orthogonalized</span><span class="o">=</span><span class="n">orthogonalized</span><span class="p">,</span> <span class="n">cumulative</span><span class="o">=</span><span class="n">cumulative</span><span class="p">,</span>
            <span class="n">anchor</span><span class="o">=</span><span class="n">anchor</span><span class="p">,</span> <span class="n">exog</span><span class="o">=</span><span class="n">exog</span><span class="p">,</span> <span class="n">extend_model</span><span class="o">=</span><span class="n">extend_model</span><span class="p">,</span>
            <span class="n">extend_kwargs</span><span class="o">=</span><span class="n">extend_kwargs</span><span class="p">,</span> <span class="n">transformed</span><span class="o">=</span><span class="n">transformed</span><span class="p">,</span>
            <span class="n">includes_fixed</span><span class="o">=</span><span class="n">includes_fixed</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># If applicable, convert predictions back to original space</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">standardize</span> <span class="ow">and</span> <span class="n">original_scale</span><span class="p">:</span>
            <span class="n">use_pandas</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">PandasData</span><span class="p">)</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="n">irfs</span><span class="o">.</span><span class="n">shape</span>

            <span class="k">if</span> <span class="n">use_pandas</span><span class="p">:</span>
                <span class="c1"># pd.Series (k_endog=1, replications=None)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">irfs</span> <span class="o">=</span> <span class="n">irfs</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_endog_std</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="c1"># pd.DataFrame (k_endog &gt; 1)</span>
                <span class="c1"># [or]</span>
                <span class="c1"># pd.DataFrame with MultiIndex (replications &gt; 0)</span>
                <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">irfs</span> <span class="o">=</span> <span class="n">irfs</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_endog_std</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># 1-dim array (k_endog=1)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">irfs</span> <span class="o">=</span> <span class="n">irfs</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_endog_std</span>
                <span class="c1"># 2-dim array (k_endog &gt; 1)</span>
                <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">irfs</span> <span class="o">=</span> <span class="n">irfs</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_endog_std</span>

        <span class="k">return</span> <span class="n">irfs</span></div>
</div>



<div class="viewcode-block" id="DynamicFactorMQResults">
<a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.dynamic_factor_mq.DynamicFactorMQResults.html#statsmodels.tsa.statespace.dynamic_factor_mq.DynamicFactorMQResults">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">DynamicFactorMQResults</span><span class="p">(</span><span class="n">mlemodel</span><span class="o">.</span><span class="n">MLEResults</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Results from fitting a dynamic factor model</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">filter_results</span><span class="p">,</span> <span class="n">cov_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">model</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">filter_results</span><span class="p">,</span> <span class="n">cov_type</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">factors</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Estimates of unobserved factors.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        out : Bunch</span>
<span class="sd">            Has the following attributes shown in Notes.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The output is a bunch of the following format:</span>

<span class="sd">        - `filtered`: a time series array with the filtered estimate of</span>
<span class="sd">          the component</span>
<span class="sd">        - `filtered_cov`: a time series array with the filtered estimate of</span>
<span class="sd">          the variance/covariance of the component</span>
<span class="sd">        - `smoothed`: a time series array with the smoothed estimate of</span>
<span class="sd">          the component</span>
<span class="sd">        - `smoothed_cov`: a time series array with the smoothed estimate of</span>
<span class="sd">          the variance/covariance of the component</span>
<span class="sd">        - `offset`: an integer giving the offset in the state vector where</span>
<span class="sd">          this component begins</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">out</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">k_factors</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">iloc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">_s</span><span class="o">.</span><span class="n">factors_L1</span>
            <span class="n">ix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">state_names</span><span class="p">)[</span><span class="n">iloc</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">Bunch</span><span class="p">(</span>
                <span class="n">filtered</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="o">.</span><span class="n">filtered</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">ix</span><span class="p">],</span>
                <span class="n">filtered_cov</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="o">.</span><span class="n">filtered_cov</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">s_</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="p">:],</span> <span class="n">ix</span><span class="p">],</span>
                <span class="n">smoothed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">smoothed_cov</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">smoothed_state</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">out</span><span class="o">.</span><span class="n">smoothed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="o">.</span><span class="n">smoothed</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">ix</span><span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">smoothed_state_cov</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">out</span><span class="o">.</span><span class="n">smoothed_cov</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="o">.</span><span class="n">smoothed_cov</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">s_</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="p">:],</span> <span class="n">ix</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">out</span>

<div class="viewcode-block" id="DynamicFactorMQResults.get_coefficients_of_determination">
<a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.dynamic_factor_mq.DynamicFactorMQResults.get_coefficients_of_determination.html#statsmodels.tsa.statespace.dynamic_factor_mq.DynamicFactorMQResults.get_coefficients_of_determination">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_coefficients_of_determination</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;individual&#39;</span><span class="p">,</span>
                                          <span class="n">which</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get coefficients of determination (R-squared) for variables / factors.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        method : {&#39;individual&#39;, &#39;joint&#39;, &#39;cumulative&#39;}, optional</span>
<span class="sd">            The type of R-squared values to generate. &quot;individual&quot; plots</span>
<span class="sd">            the R-squared of each variable on each factor; &quot;joint&quot; plots the</span>
<span class="sd">            R-squared of each variable on each factor that it loads on;</span>
<span class="sd">            &quot;cumulative&quot; plots the successive R-squared values as each</span>
<span class="sd">            additional factor is added to the regression, for each variable.</span>
<span class="sd">            Default is &#39;individual&#39;.</span>
<span class="sd">        which: {None, &#39;filtered&#39;, &#39;smoothed&#39;}, optional</span>
<span class="sd">            Whether to compute R-squared values based on filtered or smoothed</span>
<span class="sd">            estimates of the factors. Default is &#39;smoothed&#39; if smoothed results</span>
<span class="sd">            are available and &#39;filtered&#39; otherwise.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        rsquared : pd.DataFrame or pd.Series</span>
<span class="sd">            The R-squared values from regressions of observed variables on</span>
<span class="sd">            one or more of the factors. If method=&#39;individual&#39; or</span>
<span class="sd">            method=&#39;cumulative&#39;, this will be a Pandas DataFrame with observed</span>
<span class="sd">            variables as the index and factors as the columns . If</span>
<span class="sd">            method=&#39;joint&#39;, will be a Pandas Series with observed variables as</span>
<span class="sd">            the index.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        plot_coefficients_of_determination</span>
<span class="sd">        coefficients_of_determination</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">statsmodels.tools</span><span class="w"> </span><span class="kn">import</span> <span class="n">add_constant</span>

        <span class="n">method</span> <span class="o">=</span> <span class="n">string_like</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="s1">&#39;method&#39;</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;individual&#39;</span><span class="p">,</span> <span class="s1">&#39;joint&#39;</span><span class="p">,</span>
                                                        <span class="s1">&#39;cumulative&#39;</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">which</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">which</span> <span class="o">=</span> <span class="s1">&#39;filtered&#39;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">smoothed_state</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="s1">&#39;smoothed&#39;</span>

        <span class="n">k_endog</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">k_endog</span>
        <span class="n">k_factors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">k_factors</span>
        <span class="n">ef_map</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">_s</span><span class="o">.</span><span class="n">endog_factor_map</span>
        <span class="n">endog_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">endog_names</span>
        <span class="n">factor_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">factor_names</span>

        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;individual&#39;</span><span class="p">:</span>
            <span class="n">coefficients</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">k_endog</span><span class="p">,</span> <span class="n">k_factors</span><span class="p">))</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k_factors</span><span class="p">):</span>
                <span class="n">exog</span> <span class="o">=</span> <span class="n">add_constant</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">factors</span><span class="p">[</span><span class="n">which</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="n">i</span><span class="p">])</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k_endog</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">ef_map</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]:</span>
                        <span class="n">endog</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_results</span><span class="o">.</span><span class="n">endog</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                        <span class="n">coefficients</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="n">OLS</span><span class="p">(</span><span class="n">endog</span><span class="p">,</span> <span class="n">exog</span><span class="p">,</span> <span class="n">missing</span><span class="o">=</span><span class="s1">&#39;drop&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">()</span><span class="o">.</span><span class="n">rsquared</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">coefficients</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

            <span class="n">coefficients</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">coefficients</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">endog_names</span><span class="p">,</span>
                                        <span class="n">columns</span><span class="o">=</span><span class="n">factor_names</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;joint&#39;</span><span class="p">:</span>
            <span class="n">coefficients</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">k_endog</span><span class="p">,))</span>
            <span class="n">exog</span> <span class="o">=</span> <span class="n">add_constant</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">factors</span><span class="p">[</span><span class="n">which</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k_endog</span><span class="p">):</span>
                <span class="n">endog</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_results</span><span class="o">.</span><span class="n">endog</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="n">ix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="n">ef_map</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                <span class="n">X</span> <span class="o">=</span> <span class="n">exog</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">ix</span><span class="p">]</span>
                <span class="n">coefficients</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">OLS</span><span class="p">(</span><span class="n">endog</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">missing</span><span class="o">=</span><span class="s1">&#39;drop&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">()</span><span class="o">.</span><span class="n">rsquared</span><span class="p">)</span>
            <span class="n">coefficients</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">coefficients</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">endog_names</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;cumulative&#39;</span><span class="p">:</span>
            <span class="n">coefficients</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">k_endog</span><span class="p">,</span> <span class="n">k_factors</span><span class="p">))</span>
            <span class="n">exog</span> <span class="o">=</span> <span class="n">add_constant</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">factors</span><span class="p">[</span><span class="n">which</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k_endog</span><span class="p">):</span>
                <span class="n">endog</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_results</span><span class="o">.</span><span class="n">endog</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>

                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k_factors</span><span class="p">):</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">_s</span><span class="o">.</span><span class="n">endog_factor_map</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]:</span>
                        <span class="n">ix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="n">ef_map</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span>
                                   <span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">k_factors</span> <span class="o">-</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span>
                        <span class="n">X</span> <span class="o">=</span> <span class="n">exog</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">ix</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()]</span>
                        <span class="n">coefficients</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="n">OLS</span><span class="p">(</span><span class="n">endog</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">missing</span><span class="o">=</span><span class="s1">&#39;drop&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">()</span><span class="o">.</span><span class="n">rsquared</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">coefficients</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">coefficients</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">coefficients</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">endog_names</span><span class="p">,</span>
                                        <span class="n">columns</span><span class="o">=</span><span class="n">factor_names</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">coefficients</span></div>


    <span class="nd">@cache_readonly</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">coefficients_of_determination</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Individual coefficients of determination (:math:`R^2`).</span>

<span class="sd">        Coefficients of determination (:math:`R^2`) from regressions of</span>
<span class="sd">        endogenous variables on individual estimated factors.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        coefficients_of_determination : ndarray</span>
<span class="sd">            A `k_endog` x `k_factors` array, where</span>
<span class="sd">            `coefficients_of_determination[i, j]` represents the :math:`R^2`</span>
<span class="sd">            value from a regression of factor `j` and a constant on endogenous</span>
<span class="sd">            variable `i`.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Although it can be difficult to interpret the estimated factor loadings</span>
<span class="sd">        and factors, it is often helpful to use the coefficients of</span>
<span class="sd">        determination from univariate regressions to assess the importance of</span>
<span class="sd">        each factor in explaining the variation in each endogenous variable.</span>

<span class="sd">        In models with many variables and factors, this can sometimes lend</span>
<span class="sd">        interpretation to the factors (for example sometimes one factor will</span>
<span class="sd">        load primarily on real variables and another on nominal variables).</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        get_coefficients_of_determination</span>
<span class="sd">        plot_coefficients_of_determination</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_coefficients_of_determination</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="s1">&#39;individual&#39;</span><span class="p">)</span>

<div class="viewcode-block" id="DynamicFactorMQResults.plot_coefficients_of_determination">
<a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.dynamic_factor_mq.DynamicFactorMQResults.plot_coefficients_of_determination.html#statsmodels.tsa.statespace.dynamic_factor_mq.DynamicFactorMQResults.plot_coefficients_of_determination">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">plot_coefficients_of_determination</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;individual&#39;</span><span class="p">,</span>
                                           <span class="n">which</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">endog_labels</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                           <span class="n">fig</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot coefficients of determination (R-squared) for variables / factors.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        method : {&#39;individual&#39;, &#39;joint&#39;, &#39;cumulative&#39;}, optional</span>
<span class="sd">            The type of R-squared values to generate. &quot;individual&quot; plots</span>
<span class="sd">            the R-squared of each variable on each factor; &quot;joint&quot; plots the</span>
<span class="sd">            R-squared of each variable on each factor that it loads on;</span>
<span class="sd">            &quot;cumulative&quot; plots the successive R-squared values as each</span>
<span class="sd">            additional factor is added to the regression, for each variable.</span>
<span class="sd">            Default is &#39;individual&#39;.</span>
<span class="sd">        which: {None, &#39;filtered&#39;, &#39;smoothed&#39;}, optional</span>
<span class="sd">            Whether to compute R-squared values based on filtered or smoothed</span>
<span class="sd">            estimates of the factors. Default is &#39;smoothed&#39; if smoothed results</span>
<span class="sd">            are available and &#39;filtered&#39; otherwise.</span>
<span class="sd">        endog_labels : bool, optional</span>
<span class="sd">            Whether or not to label the endogenous variables along the x-axis</span>
<span class="sd">            of the plots. Default is to include labels if there are 5 or fewer</span>
<span class="sd">            endogenous variables.</span>
<span class="sd">        fig : Figure, optional</span>
<span class="sd">            If given, subplots are created in this figure instead of in a new</span>
<span class="sd">            figure. Note that the grid will be created in the provided</span>
<span class="sd">            figure using `fig.add_subplot()`.</span>
<span class="sd">        figsize : tuple, optional</span>
<span class="sd">            If a figure is created, this argument allows specifying a size.</span>
<span class="sd">            The tuple is (width, height).</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The endogenous variables are arranged along the x-axis according to</span>
<span class="sd">        their position in the model&#39;s `endog` array.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        get_coefficients_of_determination</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">statsmodels.graphics.utils</span><span class="w"> </span><span class="kn">import</span> <span class="n">_import_mpl</span><span class="p">,</span> <span class="n">create_mpl_fig</span>
        <span class="n">_import_mpl</span><span class="p">()</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">create_mpl_fig</span><span class="p">(</span><span class="n">fig</span><span class="p">,</span> <span class="n">figsize</span><span class="p">)</span>

        <span class="n">method</span> <span class="o">=</span> <span class="n">string_like</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="s1">&#39;method&#39;</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;individual&#39;</span><span class="p">,</span> <span class="s1">&#39;joint&#39;</span><span class="p">,</span>
                                                        <span class="s1">&#39;cumulative&#39;</span><span class="p">])</span>

        <span class="c1"># Should we label endogenous variables?</span>
        <span class="k">if</span> <span class="n">endog_labels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">endog_labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">k_endog</span> <span class="o">&lt;=</span> <span class="mi">5</span>

        <span class="c1"># Plot the coefficients of determination</span>
        <span class="n">rsquared</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_coefficients_of_determination</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
                                                          <span class="n">which</span><span class="o">=</span><span class="n">which</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">method</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;individual&#39;</span><span class="p">,</span> <span class="s1">&#39;cumulative&#39;</span><span class="p">]:</span>
            <span class="n">plot_idx</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">for</span> <span class="n">factor_name</span><span class="p">,</span> <span class="n">coeffs</span> <span class="ow">in</span> <span class="n">rsquared</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
                <span class="c1"># Create the new axis</span>
                <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">k_factors</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">plot_idx</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">title</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">factor_name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">ylabel</span><span class="o">=</span><span class="sa">r</span><span class="s1">&#39;$R^2$&#39;</span><span class="p">)</span>

                <span class="n">coeffs</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;bar&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">plot_idx</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">rsquared</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">endog_labels</span><span class="p">:</span>
                    <span class="n">ax</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">set_ticklabels</span><span class="p">([])</span>

                <span class="n">plot_idx</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;joint&#39;</span><span class="p">:</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">title</span><span class="o">=</span><span class="sa">r</span><span class="s1">&#39;$R^2$ - regression on all loaded factors&#39;</span><span class="p">,</span>
                   <span class="n">ylabel</span><span class="o">=</span><span class="sa">r</span><span class="s1">&#39;$R^2$&#39;</span><span class="p">)</span>
            <span class="n">rsquared</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;bar&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">endog_labels</span><span class="p">:</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">set_ticklabels</span><span class="p">([])</span>

        <span class="k">return</span> <span class="n">fig</span></div>


<div class="viewcode-block" id="DynamicFactorMQResults.get_prediction">
<a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.dynamic_factor_mq.DynamicFactorMQResults.get_prediction.html#statsmodels.tsa.statespace.dynamic_factor_mq.DynamicFactorMQResults.get_prediction">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_prediction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dynamic</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                       <span class="n">information_set</span><span class="o">=</span><span class="s1">&#39;predicted&#39;</span><span class="p">,</span> <span class="n">signal_only</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                       <span class="n">original_scale</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">exog</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                       <span class="n">extend_model</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">extend_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        In-sample prediction and out-of-sample forecasting.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        start : int, str, or datetime, optional</span>
<span class="sd">            Zero-indexed observation number at which to start forecasting,</span>
<span class="sd">            i.e., the first forecast is start. Can also be a date string to</span>
<span class="sd">            parse or a datetime type. Default is the the zeroth observation.</span>
<span class="sd">        end : int, str, or datetime, optional</span>
<span class="sd">            Zero-indexed observation number at which to end forecasting, i.e.,</span>
<span class="sd">            the last forecast is end. Can also be a date string to</span>
<span class="sd">            parse or a datetime type. However, if the dates index does not</span>
<span class="sd">            have a fixed frequency, end must be an integer index if you</span>
<span class="sd">            want out of sample prediction. Default is the last observation in</span>
<span class="sd">            the sample.</span>
<span class="sd">        dynamic : bool, int, str, or datetime, optional</span>
<span class="sd">            Integer offset relative to `start` at which to begin dynamic</span>
<span class="sd">            prediction. Can also be an absolute date string to parse or a</span>
<span class="sd">            datetime type (these are not interpreted as offsets).</span>
<span class="sd">            Prior to this observation, true endogenous values will be used for</span>
<span class="sd">            prediction; starting with this observation and continuing through</span>
<span class="sd">            the end of prediction, forecasted endogenous values will be used</span>
<span class="sd">            instead.</span>
<span class="sd">        information_set : str, optional</span>
<span class="sd">            The information set to condition each prediction on. Default is</span>
<span class="sd">            &quot;predicted&quot;, which computes predictions of period t values</span>
<span class="sd">            conditional on observed data through period t-1; these are</span>
<span class="sd">            one-step-ahead predictions, and correspond with the typical</span>
<span class="sd">            `fittedvalues` results attribute. Alternatives are &quot;filtered&quot;,</span>
<span class="sd">            which computes predictions of period t values conditional on</span>
<span class="sd">            observed data through period t, and &quot;smoothed&quot;, which computes</span>
<span class="sd">            predictions of period t values conditional on the entire dataset</span>
<span class="sd">            (including also future observations t+1, t+2, ...).</span>
<span class="sd">        signal_only : bool, optional</span>
<span class="sd">            Whether to compute forecasts of only the &quot;signal&quot; component of</span>
<span class="sd">            the observation equation. Default is False. For example, the</span>
<span class="sd">            observation equation of a time-invariant model is</span>
<span class="sd">            :math:`y_t = d + Z \alpha_t + \varepsilon_t`, and the &quot;signal&quot;</span>
<span class="sd">            component is then :math:`Z \alpha_t`. If this argument is set to</span>
<span class="sd">            True, then forecasts of the &quot;signal&quot; :math:`Z \alpha_t` will be</span>
<span class="sd">            returned. Otherwise, the default is for forecasts of :math:`y_t`</span>
<span class="sd">            to be returned.</span>
<span class="sd">        original_scale : bool, optional</span>
<span class="sd">            If the model specification standardized the data, whether or not</span>
<span class="sd">            to return predictions in the original scale of the data (i.e.</span>
<span class="sd">            before it was standardized by the model). Default is True.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Additional arguments may required for forecasting beyond the end</span>
<span class="sd">            of the sample. See `FilterResults.predict` for more details.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        forecast : ndarray</span>
<span class="sd">            Array of out of in-sample predictions and / or out-of-sample</span>
<span class="sd">            forecasts. An (npredict x k_endog) array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get usual predictions (in the possibly-standardized scale)</span>
        <span class="n">res</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get_prediction</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="n">end</span><span class="p">,</span> <span class="n">dynamic</span><span class="o">=</span><span class="n">dynamic</span><span class="p">,</span>
                                     <span class="n">information_set</span><span class="o">=</span><span class="n">information_set</span><span class="p">,</span>
                                     <span class="n">signal_only</span><span class="o">=</span><span class="n">signal_only</span><span class="p">,</span>
                                     <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span> <span class="n">exog</span><span class="o">=</span><span class="n">exog</span><span class="p">,</span>
                                     <span class="n">extend_model</span><span class="o">=</span><span class="n">extend_model</span><span class="p">,</span>
                                     <span class="n">extend_kwargs</span><span class="o">=</span><span class="n">extend_kwargs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># If applicable, convert predictions back to original space</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">standardize</span> <span class="ow">and</span> <span class="n">original_scale</span><span class="p">:</span>
            <span class="n">prediction_results</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">prediction_results</span>
            <span class="n">k_endog</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">prediction_results</span><span class="o">.</span><span class="n">endog</span><span class="o">.</span><span class="n">shape</span>

            <span class="n">mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">_endog_mean</span><span class="p">)</span>
            <span class="n">std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">_endog_std</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">k_endog</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">mean</span> <span class="o">=</span> <span class="n">mean</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>
                <span class="n">std</span> <span class="o">=</span> <span class="n">std</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>

            <span class="n">res</span><span class="o">.</span><span class="n">_results</span><span class="o">.</span><span class="n">_predicted_mean</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">res</span><span class="o">.</span><span class="n">_results</span><span class="o">.</span><span class="n">_predicted_mean</span> <span class="o">*</span> <span class="n">std</span> <span class="o">+</span> <span class="n">mean</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">k_endog</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">res</span><span class="o">.</span><span class="n">_results</span><span class="o">.</span><span class="n">_var_pred_mean</span> <span class="o">*=</span> <span class="n">std</span><span class="o">**</span><span class="mi">2</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">res</span><span class="o">.</span><span class="n">_results</span><span class="o">.</span><span class="n">_var_pred_mean</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">std</span> <span class="o">*</span> <span class="n">res</span><span class="o">.</span><span class="n">_results</span><span class="o">.</span><span class="n">_var_pred_mean</span> <span class="o">*</span> <span class="n">std</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">res</span></div>


<div class="viewcode-block" id="DynamicFactorMQResults.news">
<a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.dynamic_factor_mq.DynamicFactorMQResults.news.html#statsmodels.tsa.statespace.dynamic_factor_mq.DynamicFactorMQResults.news">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">news</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">comparison</span><span class="p">,</span> <span class="n">impact_date</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">impacted_variable</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
             <span class="n">start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">periods</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">exog</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
             <span class="n">comparison_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">revisions_details_start</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
             <span class="n">state_index</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">return_raw</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mf">1e-10</span><span class="p">,</span>
             <span class="n">endog_quarterly</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">original_scale</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute impacts from updated data (news and revisions).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        comparison : array_like or MLEResults</span>
<span class="sd">            An updated dataset with updated and/or revised data from which the</span>
<span class="sd">            news can be computed, or an updated or previous results object</span>
<span class="sd">            to use in computing the news.</span>
<span class="sd">        impact_date : int, str, or datetime, optional</span>
<span class="sd">            A single specific period of impacts from news and revisions to</span>
<span class="sd">            compute. Can also be a date string to parse or a datetime type.</span>
<span class="sd">            This argument cannot be used in combination with `start`, `end`, or</span>
<span class="sd">            `periods`. Default is the first out-of-sample observation.</span>
<span class="sd">        impacted_variable : str, list, array, or slice, optional</span>
<span class="sd">            Observation variable label or slice of labels specifying that only</span>
<span class="sd">            specific impacted variables should be shown in the News output. The</span>
<span class="sd">            impacted variable(s) describe the variables that were *affected* by</span>
<span class="sd">            the news. If you do not know the labels for the variables, check</span>
<span class="sd">            the `endog_names` attribute of the model instance.</span>
<span class="sd">        start : int, str, or datetime, optional</span>
<span class="sd">            The first period of impacts from news and revisions to compute.</span>
<span class="sd">            Can also be a date string to parse or a datetime type. Default is</span>
<span class="sd">            the first out-of-sample observation.</span>
<span class="sd">        end : int, str, or datetime, optional</span>
<span class="sd">            The last period of impacts from news and revisions to compute.</span>
<span class="sd">            Can also be a date string to parse or a datetime type. Default is</span>
<span class="sd">            the first out-of-sample observation.</span>
<span class="sd">        periods : int, optional</span>
<span class="sd">            The number of periods of impacts from news and revisions to</span>
<span class="sd">            compute.</span>
<span class="sd">        exog : array_like, optional</span>
<span class="sd">            Array of exogenous regressors for the out-of-sample period, if</span>
<span class="sd">            applicable.</span>
<span class="sd">        comparison_type : {None, &#39;previous&#39;, &#39;updated&#39;}</span>
<span class="sd">            This denotes whether the `comparison` argument represents a</span>
<span class="sd">            *previous* results object or dataset or an *updated* results object</span>
<span class="sd">            or dataset. If not specified, then an attempt is made to determine</span>
<span class="sd">            the comparison type.</span>
<span class="sd">        state_index : array_like or &quot;common&quot;, optional</span>
<span class="sd">            An optional index specifying a subset of states to use when</span>
<span class="sd">            constructing the impacts of revisions and news. For example, if</span>
<span class="sd">            `state_index=[0, 1]` is passed, then only the impacts to the</span>
<span class="sd">            observed variables arising from the impacts to the first two</span>
<span class="sd">            states will be returned. If the string &quot;common&quot; is passed and the</span>
<span class="sd">            model includes idiosyncratic AR(1) components, news will only be</span>
<span class="sd">            computed based on the common states. Default is to use all states.</span>
<span class="sd">        return_raw : bool, optional</span>
<span class="sd">            Whether or not to return only the specific output or a full</span>
<span class="sd">            results object. Default is to return a full results object.</span>
<span class="sd">        tolerance : float, optional</span>
<span class="sd">            The numerical threshold for determining zero impact. Default is</span>
<span class="sd">            that any impact less than 1e-10 is assumed to be zero.</span>
<span class="sd">        endog_quarterly : array_like, optional</span>
<span class="sd">            New observations of quarterly variables, if `comparison` was</span>
<span class="sd">            provided as an updated monthly dataset. If this argument is</span>
<span class="sd">            provided, it must be a Pandas Series or DataFrame with a</span>
<span class="sd">            DatetimeIndex or PeriodIndex at the quarterly frequency.</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        .. [1] Babura, Marta, and Michele Modugno.</span>
<span class="sd">               &quot;Maximum likelihood estimation of factor models on datasets with</span>
<span class="sd">               arbitrary pattern of missing data.&quot;</span>
<span class="sd">               Journal of Applied Econometrics 29, no. 1 (2014): 133-160.</span>
<span class="sd">        .. [2] Babura, Marta, Domenico Giannone, and Lucrezia Reichlin.</span>
<span class="sd">               &quot;Nowcasting.&quot;</span>
<span class="sd">               The Oxford Handbook of Economic Forecasting. July 8, 2011.</span>
<span class="sd">        .. [3] Babura, Marta, Domenico Giannone, Michele Modugno, and Lucrezia</span>
<span class="sd">               Reichlin.</span>
<span class="sd">               &quot;Now-casting and the real-time data flow.&quot;</span>
<span class="sd">               In Handbook of economic forecasting, vol. 2, pp. 195-237.</span>
<span class="sd">               Elsevier, 2013.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">state_index</span> <span class="o">==</span> <span class="s1">&#39;common&#39;</span><span class="p">:</span>
            <span class="n">state_index</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">k_states</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">k_endog</span><span class="p">))</span>

        <span class="n">news_results</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">news</span><span class="p">(</span>
            <span class="n">comparison</span><span class="p">,</span> <span class="n">impact_date</span><span class="o">=</span><span class="n">impact_date</span><span class="p">,</span>
            <span class="n">impacted_variable</span><span class="o">=</span><span class="n">impacted_variable</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="n">end</span><span class="p">,</span>
            <span class="n">periods</span><span class="o">=</span><span class="n">periods</span><span class="p">,</span> <span class="n">exog</span><span class="o">=</span><span class="n">exog</span><span class="p">,</span> <span class="n">comparison_type</span><span class="o">=</span><span class="n">comparison_type</span><span class="p">,</span>
            <span class="n">revisions_details_start</span><span class="o">=</span><span class="n">revisions_details_start</span><span class="p">,</span>
            <span class="n">state_index</span><span class="o">=</span><span class="n">state_index</span><span class="p">,</span> <span class="n">return_raw</span><span class="o">=</span><span class="n">return_raw</span><span class="p">,</span>
            <span class="n">tolerance</span><span class="o">=</span><span class="n">tolerance</span><span class="p">,</span> <span class="n">endog_quarterly</span><span class="o">=</span><span class="n">endog_quarterly</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># If we have standardized the data, we may want to report the news in</span>
        <span class="c1"># the original scale. If so, we need to modify the data to &quot;undo&quot; the</span>
        <span class="c1"># standardization.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">return_raw</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">standardize</span> <span class="ow">and</span> <span class="n">original_scale</span><span class="p">:</span>
            <span class="n">endog_mean</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">_endog_mean</span>
            <span class="n">endog_std</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">_endog_std</span>

            <span class="c1"># Don&#39;t need to add in the mean for the impacts, since they are</span>
            <span class="c1"># the difference of two forecasts</span>
            <span class="n">news_results</span><span class="o">.</span><span class="n">total_impacts</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">news_results</span><span class="o">.</span><span class="n">total_impacts</span> <span class="o">*</span> <span class="n">endog_std</span><span class="p">)</span>
            <span class="n">news_results</span><span class="o">.</span><span class="n">update_impacts</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">news_results</span><span class="o">.</span><span class="n">update_impacts</span> <span class="o">*</span> <span class="n">endog_std</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">news_results</span><span class="o">.</span><span class="n">revision_impacts</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">news_results</span><span class="o">.</span><span class="n">revision_impacts</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">news_results</span><span class="o">.</span><span class="n">revision_impacts</span> <span class="o">*</span> <span class="n">endog_std</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">news_results</span><span class="o">.</span><span class="n">revision_detailed_impacts</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">news_results</span><span class="o">.</span><span class="n">revision_detailed_impacts</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">news_results</span><span class="o">.</span><span class="n">revision_detailed_impacts</span> <span class="o">*</span> <span class="n">endog_std</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">news_results</span><span class="o">.</span><span class="n">revision_grouped_impacts</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">news_results</span><span class="o">.</span><span class="n">revision_grouped_impacts</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">news_results</span><span class="o">.</span><span class="n">revision_grouped_impacts</span> <span class="o">*</span> <span class="n">endog_std</span><span class="p">)</span>

            <span class="c1"># Update forecasts</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;prev_impacted_forecasts&#39;</span><span class="p">,</span> <span class="s1">&#39;news&#39;</span><span class="p">,</span> <span class="s1">&#39;revisions&#39;</span><span class="p">,</span>
                         <span class="s1">&#39;update_realized&#39;</span><span class="p">,</span> <span class="s1">&#39;update_forecasts&#39;</span><span class="p">,</span>
                         <span class="s1">&#39;revised&#39;</span><span class="p">,</span> <span class="s1">&#39;revised_prev&#39;</span><span class="p">,</span> <span class="s1">&#39;post_impacted_forecasts&#39;</span><span class="p">,</span>
                         <span class="s1">&#39;revisions_all&#39;</span><span class="p">,</span> <span class="s1">&#39;revised_all&#39;</span><span class="p">,</span> <span class="s1">&#39;revised_prev_all&#39;</span><span class="p">]:</span>
                <span class="n">dta</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">news_results</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

                <span class="c1"># for pd.Series, dta.multiply(...) and (sometimes) dta.add(...)</span>
                <span class="c1"># remove the name attribute; save it now so that we can add it</span>
                <span class="c1"># back in</span>
                <span class="n">orig_name</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">dta</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span><span class="p">):</span>
                    <span class="n">orig_name</span> <span class="o">=</span> <span class="n">dta</span><span class="o">.</span><span class="n">name</span>

                <span class="n">dta</span> <span class="o">=</span> <span class="n">dta</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">endog_std</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;news&#39;</span><span class="p">,</span> <span class="s1">&#39;revisions&#39;</span><span class="p">]:</span>
                    <span class="n">dta</span> <span class="o">=</span> <span class="n">dta</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">endog_mean</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

                <span class="c1"># add back in the name attribute if it was removed</span>
                <span class="k">if</span> <span class="n">orig_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">dta</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">orig_name</span>

                <span class="nb">setattr</span><span class="p">(</span><span class="n">news_results</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">dta</span><span class="p">)</span>

            <span class="c1"># For the weights: rows correspond to update (date, variable) and</span>
            <span class="c1"># columns correspond to the impacted variable.</span>
            <span class="c1"># 1. Because we have modified the updates (realized, forecasts, and</span>
            <span class="c1">#    forecast errors) to be in the scale of the original updated</span>
            <span class="c1">#    variable, we need to essentially reverse that change for each</span>
            <span class="c1">#    row of the weights by dividing by the standard deviation of</span>
            <span class="c1">#    that row&#39;s updated variable</span>
            <span class="c1"># 2. Because we want the impacts to be in the scale of the original</span>
            <span class="c1">#    impacted variable, we need to multiply each column by the</span>
            <span class="c1">#    standard deviation of that column&#39;s impacted variable</span>
            <span class="n">news_results</span><span class="o">.</span><span class="n">weights</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">news_results</span><span class="o">.</span><span class="n">weights</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">endog_std</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                                    <span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">endog_std</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
            <span class="n">news_results</span><span class="o">.</span><span class="n">revision_weights</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">news_results</span><span class="o">.</span><span class="n">revision_weights</span>
                            <span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">endog_std</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                            <span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">endog_std</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">news_results</span></div>


<div class="viewcode-block" id="DynamicFactorMQResults.get_smoothed_decomposition">
<a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.dynamic_factor_mq.DynamicFactorMQResults.get_smoothed_decomposition.html#statsmodels.tsa.statespace.dynamic_factor_mq.DynamicFactorMQResults.get_smoothed_decomposition">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_smoothed_decomposition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">decomposition_of</span><span class="o">=</span><span class="s1">&#39;smoothed_state&#39;</span><span class="p">,</span>
                                   <span class="n">state_index</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">original_scale</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Decompose smoothed output into contributions from observations</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        decomposition_of : {&quot;smoothed_state&quot;, &quot;smoothed_signal&quot;}</span>
<span class="sd">            The object to perform a decomposition of. If it is set to</span>
<span class="sd">            &quot;smoothed_state&quot;, then the elements of the smoothed state vector</span>
<span class="sd">            are decomposed into the contributions of each observation. If it</span>
<span class="sd">            is set to &quot;smoothed_signal&quot;, then the predictions of the</span>
<span class="sd">            observation vector based on the smoothed state vector are</span>
<span class="sd">            decomposed. Default is &quot;smoothed_state&quot;.</span>
<span class="sd">        state_index : array_like, optional</span>
<span class="sd">            An optional index specifying a subset of states to use when</span>
<span class="sd">            constructing the decomposition of the &quot;smoothed_signal&quot;. For</span>
<span class="sd">            example, if `state_index=[0, 1]` is passed, then only the</span>
<span class="sd">            contributions of observed variables to the smoothed signal arising</span>
<span class="sd">            from the first two states will be returned. Note that if not all</span>
<span class="sd">            states are used, the contributions will not sum to the smoothed</span>
<span class="sd">            signal. Default is to use all states.</span>
<span class="sd">        original_scale : bool, optional</span>
<span class="sd">            If the model specification standardized the data, whether or not</span>
<span class="sd">            to return simulations in the original scale of the data (i.e.</span>
<span class="sd">            before it was standardized by the model). Default is True.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        data_contributions : pd.DataFrame</span>
<span class="sd">            Contributions of observations to the decomposed object. If the</span>
<span class="sd">            smoothed state is being decomposed, then `data_contributions` is</span>
<span class="sd">            shaped `(k_states x nobs, k_endog x nobs)` with a `pd.MultiIndex`</span>
<span class="sd">            index corresponding to `state_to x date_to` and `pd.MultiIndex`</span>
<span class="sd">            columns corresponding to `variable_from x date_from`. If the</span>
<span class="sd">            smoothed signal is being decomposed, then `data_contributions` is</span>
<span class="sd">            shaped `(k_endog x nobs, k_endog x nobs)` with `pd.MultiIndex`-es</span>
<span class="sd">            corresponding to `variable_to x date_to` and</span>
<span class="sd">            `variable_from x date_from`.</span>
<span class="sd">        obs_intercept_contributions : pd.DataFrame</span>
<span class="sd">            Contributions of the observation intercept to the decomposed</span>
<span class="sd">            object. If the smoothed state is being decomposed, then</span>
<span class="sd">            `obs_intercept_contributions` is</span>
<span class="sd">            shaped `(k_states x nobs, k_endog x nobs)` with a `pd.MultiIndex`</span>
<span class="sd">            index corresponding to `state_to x date_to` and `pd.MultiIndex`</span>
<span class="sd">            columns corresponding to `obs_intercept_from x date_from`. If the</span>
<span class="sd">            smoothed signal is being decomposed, then</span>
<span class="sd">            `obs_intercept_contributions` is shaped</span>
<span class="sd">            `(k_endog x nobs, k_endog x nobs)` with `pd.MultiIndex`-es</span>
<span class="sd">            corresponding to `variable_to x date_to` and</span>
<span class="sd">            `obs_intercept_from x date_from`.</span>
<span class="sd">        state_intercept_contributions : pd.DataFrame</span>
<span class="sd">            Contributions of the state intercept to the decomposed</span>
<span class="sd">            object. If the smoothed state is being decomposed, then</span>
<span class="sd">            `state_intercept_contributions` is</span>
<span class="sd">            shaped `(k_states x nobs, k_states x nobs)` with a `pd.MultiIndex`</span>
<span class="sd">            index corresponding to `state_to x date_to` and `pd.MultiIndex`</span>
<span class="sd">            columns corresponding to `state_intercept_from x date_from`. If the</span>
<span class="sd">            smoothed signal is being decomposed, then</span>
<span class="sd">            `state_intercept_contributions` is shaped</span>
<span class="sd">            `(k_endog x nobs, k_states x nobs)` with `pd.MultiIndex`-es</span>
<span class="sd">            corresponding to `variable_to x date_to` and</span>
<span class="sd">            `state_intercept_from x date_from`.</span>
<span class="sd">        prior_contributions : pd.DataFrame</span>
<span class="sd">            Contributions of the prior to the decomposed object. If the</span>
<span class="sd">            smoothed state is being decomposed, then `prior_contributions` is</span>
<span class="sd">            shaped `(nobs x k_states, k_states)`, with a `pd.MultiIndex`</span>
<span class="sd">            index corresponding to `state_to x date_to` and columns</span>
<span class="sd">            corresponding to elements of the prior mean (aka &quot;initial state&quot;).</span>
<span class="sd">            If the smoothed signal is being decomposed, then</span>
<span class="sd">            `prior_contributions` is shaped `(nobs x k_endog, k_states)`,</span>
<span class="sd">            with a `pd.MultiIndex` index corresponding to</span>
<span class="sd">            `variable_to x date_to` and columns corresponding to elements of</span>
<span class="sd">            the prior mean.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Denote the smoothed state at time :math:`t` by :math:`\alpha_t`. Then</span>
<span class="sd">        the smoothed signal is :math:`Z_t \alpha_t`, where :math:`Z_t` is the</span>
<span class="sd">        design matrix operative at time :math:`t`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># De-meaning the data is like putting the mean into the observation</span>
        <span class="c1"># intercept. To compute the decomposition correctly in the original</span>
        <span class="c1"># scale, we need to account for this, so we fill in the observation</span>
        <span class="c1"># intercept temporarily</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">standardize</span> <span class="ow">and</span> <span class="n">original_scale</span><span class="p">:</span>
            <span class="n">cache_obs_intercept</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">[</span><span class="s1">&#39;obs_intercept&#39;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">[</span><span class="s1">&#39;obs_intercept&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">_endog_mean</span>

        <span class="c1"># Compute the contributions</span>
        <span class="p">(</span><span class="n">data_contributions</span><span class="p">,</span> <span class="n">obs_intercept_contributions</span><span class="p">,</span>
         <span class="n">state_intercept_contributions</span><span class="p">,</span> <span class="n">prior_contributions</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span>
            <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get_smoothed_decomposition</span><span class="p">(</span>
                <span class="n">decomposition_of</span><span class="o">=</span><span class="n">decomposition_of</span><span class="p">,</span> <span class="n">state_index</span><span class="o">=</span><span class="n">state_index</span><span class="p">))</span>

        <span class="c1"># Replace the original observation intercept</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">standardize</span> <span class="ow">and</span> <span class="n">original_scale</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">[</span><span class="s1">&#39;obs_intercept&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cache_obs_intercept</span>

        <span class="c1"># Reverse the effect of dividing by the standard deviation</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">decomposition_of</span> <span class="o">==</span> <span class="s1">&#39;smoothed_signal&#39;</span>
                <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">standardize</span> <span class="ow">and</span> <span class="n">original_scale</span><span class="p">):</span>
            <span class="n">endog_std</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">_endog_std</span>

            <span class="n">data_contributions</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">data_contributions</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">endog_std</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
            <span class="n">obs_intercept_contributions</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">obs_intercept_contributions</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span>
                    <span class="n">endog_std</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
            <span class="n">state_intercept_contributions</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">state_intercept_contributions</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span>
                    <span class="n">endog_std</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
            <span class="n">prior_contributions</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">prior_contributions</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">endog_std</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">data_contributions</span><span class="p">,</span> <span class="n">obs_intercept_contributions</span><span class="p">,</span>
                <span class="n">state_intercept_contributions</span><span class="p">,</span> <span class="n">prior_contributions</span><span class="p">)</span></div>


<div class="viewcode-block" id="DynamicFactorMQResults.append">
<a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.dynamic_factor_mq.DynamicFactorMQResults.append.html#statsmodels.tsa.statespace.dynamic_factor_mq.DynamicFactorMQResults.append">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">endog</span><span class="p">,</span> <span class="n">endog_quarterly</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">refit</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fit_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="n">copy_initialization</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">retain_standardization</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
               <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Recreate the results object with new data appended to original data.</span>

<span class="sd">        Creates a new result object applied to a dataset that is created by</span>
<span class="sd">        appending new data to the end of the model&#39;s original data. The new</span>
<span class="sd">        results can then be used for analysis or forecasting.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        endog : array_like</span>
<span class="sd">            New observations from the modeled time-series process.</span>
<span class="sd">        endog_quarterly : array_like, optional</span>
<span class="sd">            New observations of quarterly variables. If provided, must be a</span>
<span class="sd">            Pandas Series or DataFrame with a DatetimeIndex or PeriodIndex at</span>
<span class="sd">            the quarterly frequency.</span>
<span class="sd">        refit : bool, optional</span>
<span class="sd">            Whether to re-fit the parameters, based on the combined dataset.</span>
<span class="sd">            Default is False (so parameters from the current results object</span>
<span class="sd">            are used to create the new results object).</span>
<span class="sd">        fit_kwargs : dict, optional</span>
<span class="sd">            Keyword arguments to pass to `fit` (if `refit=True`) or `filter` /</span>
<span class="sd">            `smooth`.</span>
<span class="sd">        copy_initialization : bool, optional</span>
<span class="sd">            Whether or not to copy the initialization from the current results</span>
<span class="sd">            set to the new model. Default is True.</span>
<span class="sd">        retain_standardization : bool, optional</span>
<span class="sd">            Whether or not to use the mean and standard deviations that were</span>
<span class="sd">            used to standardize the data in the current model in the new model.</span>
<span class="sd">            Default is True.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Keyword arguments may be used to modify model specification</span>
<span class="sd">            arguments when created the new model object.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        results</span>
<span class="sd">            Updated Results object, that includes results from both the</span>
<span class="sd">            original dataset and the new dataset.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The `endog` and `exog` arguments to this method must be formatted in</span>
<span class="sd">        the same way (e.g. Pandas Series versus Numpy array) as were the</span>
<span class="sd">        `endog` and `exog` arrays passed to the original model.</span>

<span class="sd">        The `endog` (and, if applicable, `endog_quarterly`) arguments to this</span>
<span class="sd">        method should consist of new observations that occurred directly after</span>
<span class="sd">        the last element of `endog`. For any other kind of dataset, see the</span>
<span class="sd">        `apply` method.</span>

<span class="sd">        This method will apply filtering to all of the original data as well</span>
<span class="sd">        as to the new data. To apply filtering only to the new data (which</span>
<span class="sd">        can be much faster if the original dataset is large), see the `extend`</span>
<span class="sd">        method.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        extend</span>
<span class="sd">        apply</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Construct the combined dataset, if necessary</span>
        <span class="n">endog</span><span class="p">,</span> <span class="n">k_endog_monthly</span> <span class="o">=</span> <span class="n">DynamicFactorMQ</span><span class="o">.</span><span class="n">construct_endog</span><span class="p">(</span>
            <span class="n">endog</span><span class="p">,</span> <span class="n">endog_quarterly</span><span class="p">)</span>

        <span class="c1"># Check for compatible dimensions</span>
        <span class="n">k_endog</span> <span class="o">=</span> <span class="n">endog</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">endog</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="k">else</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">k_endog_monthly</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">k_endog_M</span> <span class="ow">or</span>
                <span class="n">k_endog</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">k_endog</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Cannot append data of a different dimension to&#39;</span>
                             <span class="s1">&#39; a model.&#39;</span><span class="p">)</span>

        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;k_endog_monthly&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">k_endog_monthly</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="n">endog</span><span class="p">,</span> <span class="n">refit</span><span class="o">=</span><span class="n">refit</span><span class="p">,</span> <span class="n">fit_kwargs</span><span class="o">=</span><span class="n">fit_kwargs</span><span class="p">,</span>
            <span class="n">copy_initialization</span><span class="o">=</span><span class="n">copy_initialization</span><span class="p">,</span>
            <span class="n">retain_standardization</span><span class="o">=</span><span class="n">retain_standardization</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="DynamicFactorMQResults.extend">
<a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.dynamic_factor_mq.DynamicFactorMQResults.extend.html#statsmodels.tsa.statespace.dynamic_factor_mq.DynamicFactorMQResults.extend">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">extend</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">endog</span><span class="p">,</span> <span class="n">endog_quarterly</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fit_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="n">retain_standardization</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Recreate the results object for new data that extends original data.</span>

<span class="sd">        Creates a new result object applied to a new dataset that is assumed to</span>
<span class="sd">        follow directly from the end of the model&#39;s original data. The new</span>
<span class="sd">        results can then be used for analysis or forecasting.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        endog : array_like</span>
<span class="sd">            New observations from the modeled time-series process.</span>
<span class="sd">        endog_quarterly : array_like, optional</span>
<span class="sd">            New observations of quarterly variables. If provided, must be a</span>
<span class="sd">            Pandas Series or DataFrame with a DatetimeIndex or PeriodIndex at</span>
<span class="sd">            the quarterly frequency.</span>
<span class="sd">        fit_kwargs : dict, optional</span>
<span class="sd">            Keyword arguments to pass to `filter` or `smooth`.</span>
<span class="sd">        retain_standardization : bool, optional</span>
<span class="sd">            Whether or not to use the mean and standard deviations that were</span>
<span class="sd">            used to standardize the data in the current model in the new model.</span>
<span class="sd">            Default is True.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Keyword arguments may be used to modify model specification</span>
<span class="sd">            arguments when created the new model object.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        results</span>
<span class="sd">            Updated Results object, that includes results only for the new</span>
<span class="sd">            dataset.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        append</span>
<span class="sd">        apply</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The `endog` argument to this method should consist of new observations</span>
<span class="sd">        that occurred directly after the last element of the model&#39;s original</span>
<span class="sd">        `endog` array. For any other kind of dataset, see the `apply` method.</span>

<span class="sd">        This method will apply filtering only to the new data provided by the</span>
<span class="sd">        `endog` argument, which can be much faster than re-filtering the entire</span>
<span class="sd">        dataset. However, the returned results object will only have results</span>
<span class="sd">        for the new data. To retrieve results for both the new data and the</span>
<span class="sd">        original data, see the `append` method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Construct the combined dataset, if necessary</span>
        <span class="n">endog</span><span class="p">,</span> <span class="n">k_endog_monthly</span> <span class="o">=</span> <span class="n">DynamicFactorMQ</span><span class="o">.</span><span class="n">construct_endog</span><span class="p">(</span>
            <span class="n">endog</span><span class="p">,</span> <span class="n">endog_quarterly</span><span class="p">)</span>

        <span class="c1"># Check for compatible dimensions</span>
        <span class="n">k_endog</span> <span class="o">=</span> <span class="n">endog</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">endog</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="k">else</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">k_endog_monthly</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">k_endog_M</span> <span class="ow">or</span>
                <span class="n">k_endog</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">k_endog</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Cannot append data of a different dimension to&#39;</span>
                             <span class="s1">&#39; a model.&#39;</span><span class="p">)</span>

        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;k_endog_monthly&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">k_endog_monthly</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
            <span class="n">endog</span><span class="p">,</span> <span class="n">fit_kwargs</span><span class="o">=</span><span class="n">fit_kwargs</span><span class="p">,</span>
            <span class="n">retain_standardization</span><span class="o">=</span><span class="n">retain_standardization</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="DynamicFactorMQResults.apply">
<a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.dynamic_factor_mq.DynamicFactorMQResults.apply.html#statsmodels.tsa.statespace.dynamic_factor_mq.DynamicFactorMQResults.apply">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">endog</span><span class="p">,</span> <span class="n">k_endog_monthly</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">endog_quarterly</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
              <span class="n">refit</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fit_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">copy_initialization</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
              <span class="n">retain_standardization</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply the fitted parameters to new data unrelated to the original data.</span>

<span class="sd">        Creates a new result object using the current fitted parameters,</span>
<span class="sd">        applied to a completely new dataset that is assumed to be unrelated to</span>
<span class="sd">        the model&#39;s original data. The new results can then be used for</span>
<span class="sd">        analysis or forecasting.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        endog : array_like</span>
<span class="sd">            New observations from the modeled time-series process.</span>
<span class="sd">        k_endog_monthly : int, optional</span>
<span class="sd">            If specifying a monthly/quarterly mixed frequency model in which</span>
<span class="sd">            the provided `endog` dataset contains both the monthly and</span>
<span class="sd">            quarterly data, this variable should be used to indicate how many</span>
<span class="sd">            of the variables are monthly.</span>
<span class="sd">        endog_quarterly : array_like, optional</span>
<span class="sd">            New observations of quarterly variables. If provided, must be a</span>
<span class="sd">            Pandas Series or DataFrame with a DatetimeIndex or PeriodIndex at</span>
<span class="sd">            the quarterly frequency.</span>
<span class="sd">        refit : bool, optional</span>
<span class="sd">            Whether to re-fit the parameters, using the new dataset.</span>
<span class="sd">            Default is False (so parameters from the current results object</span>
<span class="sd">            are used to create the new results object).</span>
<span class="sd">        fit_kwargs : dict, optional</span>
<span class="sd">            Keyword arguments to pass to `fit` (if `refit=True`) or `filter` /</span>
<span class="sd">            `smooth`.</span>
<span class="sd">        copy_initialization : bool, optional</span>
<span class="sd">            Whether or not to copy the initialization from the current results</span>
<span class="sd">            set to the new model. Default is False.</span>
<span class="sd">        retain_standardization : bool, optional</span>
<span class="sd">            Whether or not to use the mean and standard deviations that were</span>
<span class="sd">            used to standardize the data in the current model in the new model.</span>
<span class="sd">            Default is True.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Keyword arguments may be used to modify model specification</span>
<span class="sd">            arguments when created the new model object.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        results</span>
<span class="sd">            Updated Results object, that includes results only for the new</span>
<span class="sd">            dataset.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        statsmodels.tsa.statespace.mlemodel.MLEResults.append</span>
<span class="sd">        statsmodels.tsa.statespace.mlemodel.MLEResults.apply</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The `endog` argument to this method should consist of new observations</span>
<span class="sd">        that are not necessarily related to the original model&#39;s `endog`</span>
<span class="sd">        dataset. For observations that continue that original dataset by follow</span>
<span class="sd">        directly after its last element, see the `append` and `extend` methods.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mod</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">endog</span><span class="p">,</span> <span class="n">k_endog_monthly</span><span class="o">=</span><span class="n">k_endog_monthly</span><span class="p">,</span>
                               <span class="n">endog_quarterly</span><span class="o">=</span><span class="n">endog_quarterly</span><span class="p">,</span>
                               <span class="n">retain_standardization</span><span class="o">=</span><span class="n">retain_standardization</span><span class="p">,</span>
                               <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">copy_initialization</span><span class="p">:</span>
            <span class="n">init</span> <span class="o">=</span> <span class="n">initialization</span><span class="o">.</span><span class="n">Initialization</span><span class="o">.</span><span class="n">from_results</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">filter_results</span><span class="p">)</span>
            <span class="n">mod</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">initialization</span> <span class="o">=</span> <span class="n">init</span>

        <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">refit</span><span class="o">=</span><span class="n">refit</span><span class="p">,</span> <span class="n">fit_kwargs</span><span class="o">=</span><span class="n">fit_kwargs</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">res</span></div>


<div class="viewcode-block" id="DynamicFactorMQResults.summary">
<a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.dynamic_factor_mq.DynamicFactorMQResults.summary.html#statsmodels.tsa.statespace.dynamic_factor_mq.DynamicFactorMQResults.summary">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">summary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">.05</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">model_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">display_params</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">display_diagnostics</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">display_params_as_list</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">truncate_endog_names</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">display_max_endog</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Summarize the Model.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        alpha : float, optional</span>
<span class="sd">            Significance level for the confidence intervals. Default is 0.05.</span>
<span class="sd">        start : int, optional</span>
<span class="sd">            Integer of the start observation. Default is 0.</span>
<span class="sd">        title : str, optional</span>
<span class="sd">            The title used for the summary table.</span>
<span class="sd">        model_name : str, optional</span>
<span class="sd">            The name of the model used. Default is to use model class name.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        summary : Summary instance</span>
<span class="sd">            This holds the summary table and text, which can be printed or</span>
<span class="sd">            converted to various output formats.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        statsmodels.iolib.summary.Summary</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mod</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span>

        <span class="c1"># Default title / model name</span>
        <span class="k">if</span> <span class="n">title</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">title</span> <span class="o">=</span> <span class="s1">&#39;Dynamic Factor Results&#39;</span>
        <span class="k">if</span> <span class="n">model_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">model_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">_model_name</span>

        <span class="c1"># Get endog names</span>
        <span class="n">endog_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">_get_endog_names</span><span class="p">(</span>
            <span class="n">truncate</span><span class="o">=</span><span class="n">truncate_endog_names</span><span class="p">)</span>

        <span class="c1"># Get extra elements for top summary table</span>
        <span class="n">extra_top_left</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">extra_top_right</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">mle_retvals</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;mle_retvals&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">mle_settings</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;mle_settings&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mle_settings</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">mle_settings</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;em&#39;</span><span class="p">:</span>
            <span class="n">extra_top_right</span> <span class="o">+=</span> <span class="p">[(</span><span class="s1">&#39;EM Iterations&#39;</span><span class="p">,</span> <span class="p">[</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">mle_retvals</span><span class="o">.</span><span class="n">iter</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">])]</span>

        <span class="c1"># Get the basic summary tables</span>
        <span class="n">summary</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">summary</span><span class="p">(</span>
            <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="n">start</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">,</span> <span class="n">model_name</span><span class="o">=</span><span class="n">model_name</span><span class="p">,</span>
            <span class="n">display_params</span><span class="o">=</span><span class="p">(</span><span class="n">display_params</span> <span class="ow">and</span> <span class="n">display_params_as_list</span><span class="p">),</span>
            <span class="n">display_diagnostics</span><span class="o">=</span><span class="n">display_diagnostics</span><span class="p">,</span>
            <span class="n">truncate_endog_names</span><span class="o">=</span><span class="n">truncate_endog_names</span><span class="p">,</span>
            <span class="n">display_max_endog</span><span class="o">=</span><span class="n">display_max_endog</span><span class="p">,</span>
            <span class="n">extra_top_left</span><span class="o">=</span><span class="n">extra_top_left</span><span class="p">,</span> <span class="n">extra_top_right</span><span class="o">=</span><span class="n">extra_top_right</span><span class="p">)</span>

        <span class="c1"># Get tables of parameters</span>
        <span class="n">table_ix</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">display_params_as_list</span><span class="p">:</span>

            <span class="c1"># Observation equation table</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">filter_results</span><span class="o">.</span><span class="n">design</span><span class="p">[:,</span> <span class="n">mod</span><span class="o">.</span><span class="n">_s</span><span class="p">[</span><span class="s1">&#39;factors_L1&#39;</span><span class="p">],</span> <span class="mi">0</span><span class="p">],</span>
                <span class="n">index</span><span class="o">=</span><span class="n">endog_names</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">mod</span><span class="o">.</span><span class="n">factor_names</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">s</span><span class="p">:</span> <span class="s1">&#39;</span><span class="si">%.2f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">s</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">applymap</span><span class="p">(</span><span class="k">lambda</span> <span class="n">s</span><span class="p">:</span> <span class="s1">&#39;</span><span class="si">%.2f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">s</span><span class="p">)</span>

            <span class="c1"># Idiosyncratic terms</span>
            <span class="c1"># data[&#39;   &#39;] = &#39;   &#39;</span>
            <span class="n">k_idio</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">mod</span><span class="o">.</span><span class="n">idiosyncratic_ar1</span><span class="p">:</span>
                <span class="n">data</span><span class="p">[</span><span class="s1">&#39;   idiosyncratic: AR(1)&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="n">mod</span><span class="o">.</span><span class="n">_p</span><span class="p">[</span><span class="s1">&#39;idiosyncratic_ar1&#39;</span><span class="p">]])</span>
                <span class="n">k_idio</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">data</span><span class="p">[</span><span class="s1">&#39;var.&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="n">mod</span><span class="o">.</span><span class="n">_p</span><span class="p">[</span><span class="s1">&#39;idiosyncratic_var&#39;</span><span class="p">]]</span>
            <span class="c1"># Ensure object dtype for string assignment</span>
            <span class="n">cols_to_cast</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="o">-</span><span class="n">k_idio</span><span class="p">:]</span>
            <span class="n">data</span><span class="p">[</span><span class="n">cols_to_cast</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">cols_to_cast</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">object</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">data</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="o">-</span><span class="n">k_idio</span><span class="p">:]</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="o">-</span><span class="n">k_idio</span><span class="p">:]</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
                    <span class="k">lambda</span> <span class="n">s</span><span class="p">:</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">s</span><span class="si">:</span><span class="s1">.2f</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="n">data</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="o">-</span><span class="n">k_idio</span><span class="p">:]</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="o">-</span><span class="n">k_idio</span><span class="p">:]</span><span class="o">.</span><span class="n">applymap</span><span class="p">(</span>
                    <span class="k">lambda</span> <span class="n">s</span><span class="p">:</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">s</span><span class="si">:</span><span class="s1">.2f</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

            <span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;Factor loadings:&#39;</span>

            <span class="c1"># Clear entries for non-loading factors</span>
            <span class="n">base_iloc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">mod</span><span class="o">.</span><span class="n">k_factors</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">mod</span><span class="o">.</span><span class="n">k_endog</span><span class="p">):</span>
                <span class="n">iloc</span> <span class="o">=</span> <span class="p">[</span><span class="n">j</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">base_iloc</span>
                        <span class="k">if</span> <span class="n">j</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">mod</span><span class="o">.</span><span class="n">_s</span><span class="o">.</span><span class="n">endog_factor_iloc</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
                <span class="n">data</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">iloc</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;.&#39;</span>

            <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>

            <span class="c1"># Build the table</span>
            <span class="n">params_data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">values</span>
            <span class="n">params_header</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="n">params_stubs</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="n">title</span> <span class="o">=</span> <span class="s1">&#39;Observation equation:&#39;</span>
            <span class="n">table</span> <span class="o">=</span> <span class="n">SimpleTable</span><span class="p">(</span>
                <span class="n">params_data</span><span class="p">,</span> <span class="n">params_header</span><span class="p">,</span> <span class="n">params_stubs</span><span class="p">,</span>
                <span class="n">txt_fmt</span><span class="o">=</span><span class="n">fmt_params</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">)</span>
            <span class="n">summary</span><span class="o">.</span><span class="n">tables</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">table_ix</span><span class="p">,</span> <span class="n">table</span><span class="p">)</span>
            <span class="n">table_ix</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="c1"># Factor transitions</span>
            <span class="n">ix1</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">ix2</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mod</span><span class="o">.</span><span class="n">_s</span><span class="o">.</span><span class="n">factor_blocks</span><span class="p">)):</span>
                <span class="n">block</span> <span class="o">=</span> <span class="n">mod</span><span class="o">.</span><span class="n">_s</span><span class="o">.</span><span class="n">factor_blocks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">ix2</span> <span class="o">+=</span> <span class="n">block</span><span class="o">.</span><span class="n">k_factors</span>

                <span class="n">T</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_results</span><span class="o">.</span><span class="n">transition</span>
                <span class="n">lag_names</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">block</span><span class="o">.</span><span class="n">factor_order</span><span class="p">):</span>
                    <span class="n">lag_names</span> <span class="o">+=</span> <span class="p">[</span><span class="sa">f</span><span class="s1">&#39;L</span><span class="si">{</span><span class="n">j</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s1">.</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1">&#39;</span>
                                  <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">block</span><span class="o">.</span><span class="n">factor_names</span><span class="p">]</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">T</span><span class="p">[</span><span class="n">block</span><span class="o">.</span><span class="n">factors_L1</span><span class="p">,</span> <span class="n">block</span><span class="o">.</span><span class="n">factors_ar</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                                    <span class="n">index</span><span class="o">=</span><span class="n">block</span><span class="o">.</span><span class="n">factor_names</span><span class="p">,</span>
                                    <span class="n">columns</span><span class="o">=</span><span class="n">lag_names</span><span class="p">)</span>
                <span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">s</span><span class="p">:</span> <span class="s1">&#39;</span><span class="si">%.2f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">s</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">applymap</span><span class="p">(</span><span class="k">lambda</span> <span class="n">s</span><span class="p">:</span> <span class="s1">&#39;</span><span class="si">%.2f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">s</span><span class="p">)</span>

                <span class="n">Q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_results</span><span class="o">.</span><span class="n">state_cov</span>
                <span class="c1"># data[&#39; &#39;] = &#39;&#39;</span>
                <span class="k">if</span> <span class="n">block</span><span class="o">.</span><span class="n">k_factors</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">data</span><span class="p">[</span><span class="s1">&#39;   error variance&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">Q</span><span class="p">[</span><span class="n">ix1</span><span class="p">,</span> <span class="n">ix1</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">data</span><span class="p">[</span><span class="s1">&#39;   error covariance&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">block</span><span class="o">.</span><span class="n">factor_names</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">block</span><span class="o">.</span><span class="n">k_factors</span><span class="p">):</span>
                        <span class="n">data</span><span class="p">[</span><span class="n">block</span><span class="o">.</span><span class="n">factor_names</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="o">=</span> <span class="n">Q</span><span class="p">[</span><span class="n">ix1</span><span class="p">:</span><span class="n">ix2</span><span class="p">,</span> <span class="n">ix1</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span>
                <span class="n">cols_to_cast</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="o">-</span><span class="n">block</span><span class="o">.</span><span class="n">k_factors</span><span class="p">:]</span>
                <span class="n">data</span><span class="p">[</span><span class="n">cols_to_cast</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">cols_to_cast</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">object</span><span class="p">)</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">formatted_vals</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="o">-</span><span class="n">block</span><span class="o">.</span><span class="n">k_factors</span><span class="p">:]</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
                        <span class="k">lambda</span> <span class="n">s</span><span class="p">:</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">s</span><span class="si">:</span><span class="s1">.2f</span><span class="si">}</span><span class="s1">&#39;</span>
                    <span class="p">)</span>
                <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                    <span class="n">formatted_vals</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="o">-</span><span class="n">block</span><span class="o">.</span><span class="n">k_factors</span><span class="p">:]</span><span class="o">.</span><span class="n">applymap</span><span class="p">(</span>
                        <span class="k">lambda</span> <span class="n">s</span><span class="p">:</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">s</span><span class="si">:</span><span class="s1">.2f</span><span class="si">}</span><span class="s1">&#39;</span>
                    <span class="p">)</span>
                <span class="n">data</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="o">-</span><span class="n">block</span><span class="o">.</span><span class="n">k_factors</span><span class="p">:]</span> <span class="o">=</span> <span class="n">formatted_vals</span>

                <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>

                <span class="n">params_data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">values</span>
                <span class="n">params_header</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                <span class="n">params_stubs</span> <span class="o">=</span> <span class="kc">None</span>

                <span class="n">title</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;Transition: Factor block </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">&#39;</span>
                <span class="n">table</span> <span class="o">=</span> <span class="n">SimpleTable</span><span class="p">(</span>
                    <span class="n">params_data</span><span class="p">,</span> <span class="n">params_header</span><span class="p">,</span> <span class="n">params_stubs</span><span class="p">,</span>
                    <span class="n">txt_fmt</span><span class="o">=</span><span class="n">fmt_params</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">)</span>
                <span class="n">summary</span><span class="o">.</span><span class="n">tables</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">table_ix</span><span class="p">,</span> <span class="n">table</span><span class="p">)</span>
                <span class="n">table_ix</span> <span class="o">+=</span> <span class="mi">1</span>

                <span class="n">ix1</span> <span class="o">=</span> <span class="n">ix2</span>

        <span class="k">return</span> <span class="n">summary</span></div>
</div>

</code></pre></div>







  
    
  
  


  <aside class="md-source-file">
    
      
  <span class="md-source-file__fact">
    <span class="md-icon" title="Last update">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M21 13.1c-.1 0-.3.1-.4.2l-1 1 2.1 2.1 1-1c.2-.2.2-.6 0-.8l-1.3-1.3c-.1-.1-.2-.2-.4-.2m-1.9 1.8-6.1 6V23h2.1l6.1-6.1zM12.5 7v5.2l4 2.4-1 1L11 13V7zM11 21.9c-5.1-.5-9-4.8-9-9.9C2 6.5 6.5 2 12 2c5.3 0 9.6 4.1 10 9.3-.3-.1-.6-.2-1-.2s-.7.1-1 .2C19.6 7.2 16.2 4 12 4c-4.4 0-8 3.6-8 8 0 4.1 3.1 7.5 7.1 7.9l-.1.2z"/></svg>
    </span>
    Mar 27, 2025
  </span>

    
    
    
    
  </aside>





                
              </article>
            </div>
          
          
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  
  
  <div class="md-footer-meta md-typeset">
    
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
    <div class="md-footer-copyright__highlight">
        &#169; Copyright 2009-2025, Josef Perktold, Skipper Seabold, Jonathan Taylor, statsmodels-developers.
        
    </div>
  
    Created using
    <a href="https://www.sphinx-doc.org/" target="_blank" rel="noopener">Sphinx</a>
    7.3.7.
     and
    <a href="https://github.com/jbms/sphinx-immaterial/" target="_blank" rel="noopener">Sphinx-Immaterial</a>
  
</div>
      
        <div class="md-social">
  
    
    
    
    
    <a href="https://github.com/statsmodels/statsmodels/" target="_blank" rel="noopener" title="Source on github.com" class="md-social__link">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6m-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3m44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9M244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8M97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1m-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7m32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1m-11.4-14.7c-1.6 1-1.6 3.6 0 5.9s4.3 3.3 5.6 2.3c1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2"/></svg>
    </a>
  
    
    
    
    
      
      
    
    <a href="https://pypi.org/project/statsmodels/" target="_blank" rel="noopener" title="pypi.org" class="md-social__link">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.8 200.5c-7.7-30.9-22.3-54.2-53.4-54.2h-40.1v47.4c0 36.8-31.2 67.8-66.8 67.8H172.7c-29.2 0-53.4 25-53.4 54.3v101.8c0 29 25.2 46 53.4 54.3 33.8 9.9 66.3 11.7 106.8 0 26.9-7.8 53.4-23.5 53.4-54.3v-40.7H226.2v-13.6h160.2c31.1 0 42.6-21.7 53.4-54.2 11.2-33.5 10.7-65.7 0-108.6M286.2 404c11.1 0 20.1 9.1 20.1 20.3 0 11.3-9 20.4-20.1 20.4-11 0-20.1-9.2-20.1-20.4.1-11.3 9.1-20.3 20.1-20.3M167.8 248.1h106.8c29.7 0 53.4-24.5 53.4-54.3V91.9c0-29-24.4-50.7-53.4-55.6-35.8-5.9-74.7-5.6-106.8.1-45.2 8-53.4 24.7-53.4 55.6v40.7h106.9v13.6h-147c-31.1 0-58.3 18.7-66.8 54.2-9.8 40.7-10.2 66.1 0 108.6 7.6 31.6 25.7 54.2 56.8 54.2H101v-48.8c0-35.3 30.5-66.4 66.8-66.4m-6.7-142.6c-11.1 0-20.1-9.1-20.1-20.3.1-11.3 9-20.4 20.1-20.4 11 0 20.1 9.2 20.1 20.4s-9 20.3-20.1 20.3"/></svg>
    </a>
  
    
    
    
    
      
      
    
    <a href="https://doi.org/10.5281/zenodo.593847" target="_blank" rel="noopener" title="doi.org" class="md-social__link">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M0 216C0 149.7 53.7 96 120 96h8c17.7 0 32 14.3 32 32s-14.3 32-32 32h-8c-30.9 0-56 25.1-56 56v8h64c35.3 0 64 28.7 64 64v64c0 35.3-28.7 64-64 64H64c-35.3 0-64-28.7-64-64V216m256 0c0-66.3 53.7-120 120-120h8c17.7 0 32 14.3 32 32s-14.3 32-32 32h-8c-30.9 0-56 25.1-56 56v8h64c35.3 0 64 28.7 64 64v64c0 35.3-28.7 64-64 64h-64c-35.3 0-64-28.7-64-64V216"/></svg>
    </a>
  
</div>
      
    </div>
    
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "../../../..", "features": [], "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}, "version": {"provider": "mike", "staticVersions": null, "versionPath": "../versions-v3.json"}}</script>
    
      
        <script src="../../../../_static/sphinx_immaterial_theme.32136f45f91ae6956.min.js?v=a7a9472a"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    
  </body>
</html>