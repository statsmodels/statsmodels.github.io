


<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      <link rel="icon" href="../../../../_static/favicon.ico">
    
    
  
      
        <title>statsmodels.tsa.statespace.tools - statsmodels 0.15.0 (+518)</title>
      
    
  <link rel="icon" type="image/png" sizes="32x32" href="../../../../_static/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="../../../../_static/icons/favicon-16x16.png">
  <link rel="manifest" href="../../../../_static/icons/site.webmanifest">
  <link rel="mask-icon" href="../../../../_static/icons/safari-pinned-tab.svg" color="#919191">
  <meta name="msapplication-TileColor" content="#2b5797">
  <meta name="msapplication-config" content="../../../../_static/icons/browserconfig.xml">
  <link rel="stylesheet" href="../../../../_static/stylesheets/examples.css">
  <link rel="stylesheet" href="../../../../_static/stylesheets/deprecation.css">
    
      
        
        
          
          
          <meta name="theme-color" content="#4051b5">
        
      
      

    
    
    
      
        
        
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
        <link rel="stylesheet" type="text/css" href="../../../../_static/sphinx_immaterial_theme.4b4a8c74e2ff2ab5b.min.css?v=afa97f93" />
        <link rel="stylesheet" type="text/css" href="../../../../_static/graphviz.css?v=fd3f3429" />
        <link rel="stylesheet" type="text/css" href="../../../../_static/plot_directive.css" />
    <script>__md_scope=new URL("../../../..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="" data-md-color-primary="indigo" data-md-color-accent="blue">
  
    
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
      <div data-md-component="outdated" hidden>
        
      </div>
    
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../../../../index.html" title="statsmodels 0.15.0 (+518)" class="md-header__button md-logo" aria-label="statsmodels 0.15.0 (+518)" data-md-component="logo">
      <img src="../../../../_static/statsmodels-logo-v2-bw.svg" alt="logo">
    </a>
    <label class="md-header__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            statsmodels 0.15.0 (+518)
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              statsmodels.tsa.statespace.tools
            
          </span>
        </div>
      </div>
    </div>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header__source">
        <a href="https://github.com/statsmodels/statsmodels/" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc.--><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg>
  </div>
  <div class="md-source__repository">
    statsmodels
  </div>
</a>
      </div>
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../../../../index.html" title="statsmodels 0.15.0 (+518)" class="md-nav__button md-logo" aria-label="statsmodels 0.15.0 (+518)" data-md-component="logo">
      <img src="../../../../_static/statsmodels-logo-v2-bw.svg" alt="logo">
    </a>
    statsmodels 0.15.0 (+518)
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/statsmodels/statsmodels/" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc.--><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg>
  </div>
  <div class="md-source__repository">
    statsmodels
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      

  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../install.html" class="md-nav__link">
        <span title="/install.rst (reference label)" class="md-ellipsis">Installing statsmodels</span>
      </a>
    </li>
  

    
      
      
      

  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../gettingstarted.html" class="md-nav__link">
        <span title="/gettingstarted.rst (reference label)" class="md-ellipsis">Getting started</span>
      </a>
    </li>
  

    
      
      
      

  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../user-guide.html" class="md-nav__link">
        <span title="/user-guide.rst (reference label)" class="md-ellipsis">User Guide</span>
      </a>
    </li>
  

    
      
      
      

  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../examples/index.html" class="md-nav__link">
        <span title="/examples/index.rst (reference label)" class="md-ellipsis">Examples</span>
      </a>
    </li>
  

    
      
      
      

  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../api.html" class="md-nav__link">
        <span title="/api.rst (reference label)" class="md-ellipsis">API Reference</span>
      </a>
    </li>
  

    
      
      
      

  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../about.html" class="md-nav__link">
        <span title="/about.rst (reference label)" class="md-ellipsis">About statsmodels</span>
      </a>
    </li>
  

    
      
      
      

  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../dev/index.html" class="md-nav__link">
        <span title="/dev/index.rst (reference label)" class="md-ellipsis">Developer Page</span>
      </a>
    </li>
  

    
      
      
      

  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../release/index.html" class="md-nav__link">
        <span title="/release/index.rst (reference label)" class="md-ellipsis">Release Notes</span>
      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

  

<nav class="md-nav md-nav--secondary">
  
  
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset" role="main">
                  


<h1>Source code for statsmodels.tsa.statespace.tools</h1><div class="highlight"><pre>
<span></span><code><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Statespace Tools</span>

<span class="sd">Author: Chad Fulton</span>
<span class="sd">License: Simplified-BSD</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">solve_sylvester</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>

<span class="kn">from</span> <span class="nn">statsmodels.compat.pandas</span> <span class="kn">import</span> <span class="n">Appender</span>
<span class="kn">from</span> <span class="nn">statsmodels.tools.data</span> <span class="kn">import</span> <span class="n">_is_using_pandas</span>
<span class="kn">from</span> <span class="nn">scipy.linalg.blas</span> <span class="kn">import</span> <span class="n">find_best_blas_type</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="p">(</span><span class="n">_initialization</span><span class="p">,</span> <span class="n">_representation</span><span class="p">,</span> <span class="n">_kalman_filter</span><span class="p">,</span>
               <span class="n">_kalman_smoother</span><span class="p">,</span> <span class="n">_simulation_smoother</span><span class="p">,</span>
               <span class="n">_cfa_simulation_smoother</span><span class="p">,</span> <span class="n">_tools</span><span class="p">)</span>


<span class="n">compatibility_mode</span> <span class="o">=</span> <span class="kc">False</span>
<span class="n">has_trmm</span> <span class="o">=</span> <span class="kc">True</span>
<span class="n">prefix_dtype_map</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;s&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">complex64</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">complex128</span>
<span class="p">}</span>
<span class="n">prefix_initialization_map</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;s&#39;</span><span class="p">:</span> <span class="n">_initialization</span><span class="o">.</span><span class="n">sInitialization</span><span class="p">,</span>
    <span class="s1">&#39;d&#39;</span><span class="p">:</span> <span class="n">_initialization</span><span class="o">.</span><span class="n">dInitialization</span><span class="p">,</span>
    <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="n">_initialization</span><span class="o">.</span><span class="n">cInitialization</span><span class="p">,</span>
    <span class="s1">&#39;z&#39;</span><span class="p">:</span> <span class="n">_initialization</span><span class="o">.</span><span class="n">zInitialization</span>
<span class="p">}</span>
<span class="n">prefix_statespace_map</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;s&#39;</span><span class="p">:</span> <span class="n">_representation</span><span class="o">.</span><span class="n">sStatespace</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">:</span> <span class="n">_representation</span><span class="o">.</span><span class="n">dStatespace</span><span class="p">,</span>
    <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="n">_representation</span><span class="o">.</span><span class="n">cStatespace</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">:</span> <span class="n">_representation</span><span class="o">.</span><span class="n">zStatespace</span>
<span class="p">}</span>
<span class="n">prefix_kalman_filter_map</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;s&#39;</span><span class="p">:</span> <span class="n">_kalman_filter</span><span class="o">.</span><span class="n">sKalmanFilter</span><span class="p">,</span>
    <span class="s1">&#39;d&#39;</span><span class="p">:</span> <span class="n">_kalman_filter</span><span class="o">.</span><span class="n">dKalmanFilter</span><span class="p">,</span>
    <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="n">_kalman_filter</span><span class="o">.</span><span class="n">cKalmanFilter</span><span class="p">,</span>
    <span class="s1">&#39;z&#39;</span><span class="p">:</span> <span class="n">_kalman_filter</span><span class="o">.</span><span class="n">zKalmanFilter</span>
<span class="p">}</span>
<span class="n">prefix_kalman_smoother_map</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;s&#39;</span><span class="p">:</span> <span class="n">_kalman_smoother</span><span class="o">.</span><span class="n">sKalmanSmoother</span><span class="p">,</span>
    <span class="s1">&#39;d&#39;</span><span class="p">:</span> <span class="n">_kalman_smoother</span><span class="o">.</span><span class="n">dKalmanSmoother</span><span class="p">,</span>
    <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="n">_kalman_smoother</span><span class="o">.</span><span class="n">cKalmanSmoother</span><span class="p">,</span>
    <span class="s1">&#39;z&#39;</span><span class="p">:</span> <span class="n">_kalman_smoother</span><span class="o">.</span><span class="n">zKalmanSmoother</span>
<span class="p">}</span>
<span class="n">prefix_simulation_smoother_map</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;s&#39;</span><span class="p">:</span> <span class="n">_simulation_smoother</span><span class="o">.</span><span class="n">sSimulationSmoother</span><span class="p">,</span>
    <span class="s1">&#39;d&#39;</span><span class="p">:</span> <span class="n">_simulation_smoother</span><span class="o">.</span><span class="n">dSimulationSmoother</span><span class="p">,</span>
    <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="n">_simulation_smoother</span><span class="o">.</span><span class="n">cSimulationSmoother</span><span class="p">,</span>
    <span class="s1">&#39;z&#39;</span><span class="p">:</span> <span class="n">_simulation_smoother</span><span class="o">.</span><span class="n">zSimulationSmoother</span>
<span class="p">}</span>
<span class="n">prefix_cfa_simulation_smoother_map</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;s&#39;</span><span class="p">:</span> <span class="n">_cfa_simulation_smoother</span><span class="o">.</span><span class="n">sCFASimulationSmoother</span><span class="p">,</span>
    <span class="s1">&#39;d&#39;</span><span class="p">:</span> <span class="n">_cfa_simulation_smoother</span><span class="o">.</span><span class="n">dCFASimulationSmoother</span><span class="p">,</span>
    <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="n">_cfa_simulation_smoother</span><span class="o">.</span><span class="n">cCFASimulationSmoother</span><span class="p">,</span>
    <span class="s1">&#39;z&#39;</span><span class="p">:</span> <span class="n">_cfa_simulation_smoother</span><span class="o">.</span><span class="n">zCFASimulationSmoother</span>
<span class="p">}</span>
<span class="n">prefix_pacf_map</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;s&#39;</span><span class="p">:</span> <span class="n">_tools</span><span class="o">.</span><span class="n">_scompute_coefficients_from_multivariate_pacf</span><span class="p">,</span>
    <span class="s1">&#39;d&#39;</span><span class="p">:</span> <span class="n">_tools</span><span class="o">.</span><span class="n">_dcompute_coefficients_from_multivariate_pacf</span><span class="p">,</span>
    <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="n">_tools</span><span class="o">.</span><span class="n">_ccompute_coefficients_from_multivariate_pacf</span><span class="p">,</span>
    <span class="s1">&#39;z&#39;</span><span class="p">:</span> <span class="n">_tools</span><span class="o">.</span><span class="n">_zcompute_coefficients_from_multivariate_pacf</span>
<span class="p">}</span>
<span class="n">prefix_sv_map</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;s&#39;</span><span class="p">:</span> <span class="n">_tools</span><span class="o">.</span><span class="n">_sconstrain_sv_less_than_one</span><span class="p">,</span>
    <span class="s1">&#39;d&#39;</span><span class="p">:</span> <span class="n">_tools</span><span class="o">.</span><span class="n">_dconstrain_sv_less_than_one</span><span class="p">,</span>
    <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="n">_tools</span><span class="o">.</span><span class="n">_cconstrain_sv_less_than_one</span><span class="p">,</span>
    <span class="s1">&#39;z&#39;</span><span class="p">:</span> <span class="n">_tools</span><span class="o">.</span><span class="n">_zconstrain_sv_less_than_one</span>
<span class="p">}</span>
<span class="n">prefix_reorder_missing_matrix_map</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;s&#39;</span><span class="p">:</span> <span class="n">_tools</span><span class="o">.</span><span class="n">sreorder_missing_matrix</span><span class="p">,</span>
    <span class="s1">&#39;d&#39;</span><span class="p">:</span> <span class="n">_tools</span><span class="o">.</span><span class="n">dreorder_missing_matrix</span><span class="p">,</span>
    <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="n">_tools</span><span class="o">.</span><span class="n">creorder_missing_matrix</span><span class="p">,</span>
    <span class="s1">&#39;z&#39;</span><span class="p">:</span> <span class="n">_tools</span><span class="o">.</span><span class="n">zreorder_missing_matrix</span>
<span class="p">}</span>
<span class="n">prefix_reorder_missing_vector_map</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;s&#39;</span><span class="p">:</span> <span class="n">_tools</span><span class="o">.</span><span class="n">sreorder_missing_vector</span><span class="p">,</span>
    <span class="s1">&#39;d&#39;</span><span class="p">:</span> <span class="n">_tools</span><span class="o">.</span><span class="n">dreorder_missing_vector</span><span class="p">,</span>
    <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="n">_tools</span><span class="o">.</span><span class="n">creorder_missing_vector</span><span class="p">,</span>
    <span class="s1">&#39;z&#39;</span><span class="p">:</span> <span class="n">_tools</span><span class="o">.</span><span class="n">zreorder_missing_vector</span>
<span class="p">}</span>
<span class="n">prefix_copy_missing_matrix_map</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;s&#39;</span><span class="p">:</span> <span class="n">_tools</span><span class="o">.</span><span class="n">scopy_missing_matrix</span><span class="p">,</span>
    <span class="s1">&#39;d&#39;</span><span class="p">:</span> <span class="n">_tools</span><span class="o">.</span><span class="n">dcopy_missing_matrix</span><span class="p">,</span>
    <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="n">_tools</span><span class="o">.</span><span class="n">ccopy_missing_matrix</span><span class="p">,</span>
    <span class="s1">&#39;z&#39;</span><span class="p">:</span> <span class="n">_tools</span><span class="o">.</span><span class="n">zcopy_missing_matrix</span>
<span class="p">}</span>
<span class="n">prefix_copy_missing_vector_map</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;s&#39;</span><span class="p">:</span> <span class="n">_tools</span><span class="o">.</span><span class="n">scopy_missing_vector</span><span class="p">,</span>
    <span class="s1">&#39;d&#39;</span><span class="p">:</span> <span class="n">_tools</span><span class="o">.</span><span class="n">dcopy_missing_vector</span><span class="p">,</span>
    <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="n">_tools</span><span class="o">.</span><span class="n">ccopy_missing_vector</span><span class="p">,</span>
    <span class="s1">&#39;z&#39;</span><span class="p">:</span> <span class="n">_tools</span><span class="o">.</span><span class="n">zcopy_missing_vector</span>
<span class="p">}</span>
<span class="n">prefix_copy_index_matrix_map</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;s&#39;</span><span class="p">:</span> <span class="n">_tools</span><span class="o">.</span><span class="n">scopy_index_matrix</span><span class="p">,</span>
    <span class="s1">&#39;d&#39;</span><span class="p">:</span> <span class="n">_tools</span><span class="o">.</span><span class="n">dcopy_index_matrix</span><span class="p">,</span>
    <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="n">_tools</span><span class="o">.</span><span class="n">ccopy_index_matrix</span><span class="p">,</span>
    <span class="s1">&#39;z&#39;</span><span class="p">:</span> <span class="n">_tools</span><span class="o">.</span><span class="n">zcopy_index_matrix</span>
<span class="p">}</span>
<span class="n">prefix_copy_index_vector_map</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;s&#39;</span><span class="p">:</span> <span class="n">_tools</span><span class="o">.</span><span class="n">scopy_index_vector</span><span class="p">,</span>
    <span class="s1">&#39;d&#39;</span><span class="p">:</span> <span class="n">_tools</span><span class="o">.</span><span class="n">dcopy_index_vector</span><span class="p">,</span>
    <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="n">_tools</span><span class="o">.</span><span class="n">ccopy_index_vector</span><span class="p">,</span>
    <span class="s1">&#39;z&#39;</span><span class="p">:</span> <span class="n">_tools</span><span class="o">.</span><span class="n">zcopy_index_vector</span>
<span class="p">}</span>
<span class="n">prefix_compute_smoothed_state_weights_map</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;s&#39;</span><span class="p">:</span> <span class="n">_tools</span><span class="o">.</span><span class="n">_scompute_smoothed_state_weights</span><span class="p">,</span>
    <span class="s1">&#39;d&#39;</span><span class="p">:</span> <span class="n">_tools</span><span class="o">.</span><span class="n">_dcompute_smoothed_state_weights</span><span class="p">,</span>
    <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="n">_tools</span><span class="o">.</span><span class="n">_ccompute_smoothed_state_weights</span><span class="p">,</span>
    <span class="s1">&#39;z&#39;</span><span class="p">:</span> <span class="n">_tools</span><span class="o">.</span><span class="n">_zcompute_smoothed_state_weights</span>
<span class="p">}</span>


<span class="k">def</span> <span class="nf">set_mode</span><span class="p">(</span><span class="n">compatibility</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">compatibility</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Compatibility mode is only available in&#39;</span>
                                  <span class="s1">&#39; statsmodels &lt;= 0.9&#39;</span><span class="p">)</span>


<div class="viewcode-block" id="companion_matrix">
<a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.tools.companion_matrix.html#statsmodels.tsa.statespace.tools.companion_matrix">[docs]</a>
<span class="k">def</span> <span class="nf">companion_matrix</span><span class="p">(</span><span class="n">polynomial</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a companion matrix</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    polynomial : array_like or list</span>
<span class="sd">        If an iterable, interpreted as the coefficients of the polynomial from</span>
<span class="sd">        which to form the companion matrix. Polynomial coefficients are in</span>
<span class="sd">        order of increasing degree, and may be either scalars (as in an AR(p)</span>
<span class="sd">        model) or coefficient matrices (as in a VAR(p) model). If an integer,</span>
<span class="sd">        it is interpreted as the size of a companion matrix of a scalar</span>
<span class="sd">        polynomial, where the polynomial coefficients are initialized to zeros.</span>
<span class="sd">        If a matrix polynomial is passed, :math:`C_0` may be set to the scalar</span>
<span class="sd">        value 1 to indicate an identity matrix (doing so will improve the speed</span>
<span class="sd">        of the companion matrix creation).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    companion_matrix : ndarray</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Given coefficients of a lag polynomial of the form:</span>

<span class="sd">    .. math::</span>

<span class="sd">        c(L) = c_0 + c_1 L + \dots + c_p L^p</span>

<span class="sd">    returns a matrix of the form</span>

<span class="sd">    .. math::</span>
<span class="sd">        \begin{bmatrix}</span>
<span class="sd">            \phi_1 &amp; 1      &amp; 0 &amp; \cdots &amp; 0 \\</span>
<span class="sd">            \phi_2 &amp; 0      &amp; 1 &amp;        &amp; 0 \\</span>
<span class="sd">            \vdots &amp;        &amp;   &amp; \ddots &amp; 0 \\</span>
<span class="sd">                   &amp;        &amp;   &amp;        &amp; 1 \\</span>
<span class="sd">            \phi_n &amp; 0      &amp; 0 &amp; \cdots &amp; 0 \\</span>
<span class="sd">        \end{bmatrix}</span>

<span class="sd">    where some or all of the :math:`\phi_i` may be non-zero (if `polynomial` is</span>
<span class="sd">    None, then all are equal to zero).</span>

<span class="sd">    If the coefficients provided are scalars :math:`(c_0, c_1, \dots, c_p)`,</span>
<span class="sd">    then the companion matrix is an :math:`n \times n` matrix formed with the</span>
<span class="sd">    elements in the first column defined as</span>
<span class="sd">    :math:`\phi_i = -\frac{c_i}{c_0}, i \in 1, \dots, p`.</span>

<span class="sd">    If the coefficients provided are matrices :math:`(C_0, C_1, \dots, C_p)`,</span>
<span class="sd">    each of shape :math:`(m, m)`, then the companion matrix is an</span>
<span class="sd">    :math:`nm \times nm` matrix formed with the elements in the first column</span>
<span class="sd">    defined as :math:`\phi_i = -C_0^{-1} C_i&#39;, i \in 1, \dots, p`.</span>

<span class="sd">    It is important to understand the expected signs of the coefficients. A</span>
<span class="sd">    typical AR(p) model is written as:</span>

<span class="sd">    .. math::</span>
<span class="sd">        y_t = a_1 y_{t-1} + \dots + a_p y_{t-p} + \varepsilon_t</span>

<span class="sd">    This can be rewritten as:</span>

<span class="sd">    .. math::</span>
<span class="sd">        (1 - a_1 L - \dots - a_p L^p )y_t = \varepsilon_t \\</span>
<span class="sd">        (1 + c_1 L + \dots + c_p L^p )y_t = \varepsilon_t \\</span>
<span class="sd">        c(L) y_t = \varepsilon_t</span>

<span class="sd">    The coefficients from this form are defined to be :math:`c_i = - a_i`, and</span>
<span class="sd">    it is the :math:`c_i` coefficients that this function expects to be</span>
<span class="sd">    provided.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">identity_matrix</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">polynomial</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)):</span>
        <span class="c1"># GH 5570, allow numpy integer types, but coerce to python int</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">polynomial</span><span class="p">)</span>
        <span class="n">m</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">polynomial</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">polynomial</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Companion matrix polynomials must include at&quot;</span>
                             <span class="s2">&quot; least two terms.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">polynomial</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># Note: cannot use polynomial[0] because of the special</span>
                <span class="c1"># behavior associated with matrix polynomials and the constant</span>
                <span class="c1"># 1, see below.</span>
                <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">polynomial</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="n">m</span> <span class="o">=</span> <span class="mi">1</span>

            <span class="c1"># Check if we just have a scalar polynomial</span>
            <span class="k">if</span> <span class="n">m</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">polynomial</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">polynomial</span><span class="p">)</span>
            <span class="c1"># Check if 1 was passed as the first argument (indicating an</span>
            <span class="c1"># identity matrix)</span>
            <span class="k">elif</span> <span class="n">polynomial</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">polynomial</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
                <span class="n">identity_matrix</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">m</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">polynomial</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">polynomial</span><span class="p">)</span>

    <span class="n">matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span> <span class="o">*</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">*</span> <span class="n">m</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">polynomial</span><span class="p">)</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag_indices</span><span class="p">((</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">m</span><span class="p">)</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">idx</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">m</span><span class="p">)</span>
    <span class="n">matrix</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">polynomial</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">m</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">matrix</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">polynomial</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">/</span> <span class="n">polynomial</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">identity_matrix</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="n">matrix</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="n">m</span><span class="p">:(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">m</span><span class="p">,</span> <span class="p">:</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">polynomial</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">inv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">polynomial</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="n">matrix</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="n">m</span><span class="p">:(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">m</span><span class="p">,</span> <span class="p">:</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">inv</span><span class="p">,</span> <span class="n">polynomial</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
    <span class="k">return</span> <span class="n">matrix</span></div>



<div class="viewcode-block" id="diff">
<a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.tools.diff.html#statsmodels.tsa.statespace.tools.diff">[docs]</a>
<span class="k">def</span> <span class="nf">diff</span><span class="p">(</span><span class="n">series</span><span class="p">,</span> <span class="n">k_diff</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">k_seasonal_diff</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">seasonal_periods</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Difference a series simply and/or seasonally along the zero-th axis.</span>

<span class="sd">    Given a series (denoted :math:`y_t`), performs the differencing operation</span>

<span class="sd">    .. math::</span>

<span class="sd">        \Delta^d \Delta_s^D y_t</span>

<span class="sd">    where :math:`d =` `diff`, :math:`s =` `seasonal_periods`,</span>
<span class="sd">    :math:`D =` `seasonal\_diff`, and :math:`\Delta` is the difference</span>
<span class="sd">    operator.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    series : array_like</span>
<span class="sd">        The series to be differenced.</span>
<span class="sd">    k_diff : int, optional</span>
<span class="sd">        The number of simple differences to perform. Default is 1.</span>
<span class="sd">    k_seasonal_diff : int or None, optional</span>
<span class="sd">        The number of seasonal differences to perform. Default is no seasonal</span>
<span class="sd">        differencing.</span>
<span class="sd">    seasonal_periods : int, optional</span>
<span class="sd">        The seasonal lag. Default is 1. Unused if there is no seasonal</span>
<span class="sd">        differencing.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    differenced : ndarray</span>
<span class="sd">        The differenced array.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">pandas</span> <span class="o">=</span> <span class="n">_is_using_pandas</span><span class="p">(</span><span class="n">series</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="n">differenced</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">series</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">pandas</span> <span class="k">else</span> <span class="n">series</span>

    <span class="c1"># Seasonal differencing</span>
    <span class="k">if</span> <span class="n">k_seasonal_diff</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">while</span> <span class="n">k_seasonal_diff</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">pandas</span><span class="p">:</span>
                <span class="n">differenced</span> <span class="o">=</span> <span class="p">(</span><span class="n">differenced</span><span class="p">[</span><span class="n">seasonal_periods</span><span class="p">:]</span> <span class="o">-</span>
                               <span class="n">differenced</span><span class="p">[:</span><span class="o">-</span><span class="n">seasonal_periods</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">sdiffed</span> <span class="o">=</span> <span class="n">differenced</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">seasonal_periods</span><span class="p">)</span>
                <span class="n">differenced</span> <span class="o">=</span> <span class="n">sdiffed</span><span class="p">[</span><span class="n">seasonal_periods</span><span class="p">:]</span>
            <span class="n">k_seasonal_diff</span> <span class="o">-=</span> <span class="mi">1</span>

    <span class="c1"># Simple differencing</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">pandas</span><span class="p">:</span>
        <span class="n">differenced</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">differenced</span><span class="p">,</span> <span class="n">k_diff</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">while</span> <span class="n">k_diff</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">differenced</span> <span class="o">=</span> <span class="n">differenced</span><span class="o">.</span><span class="n">diff</span><span class="p">()[</span><span class="mi">1</span><span class="p">:]</span>
            <span class="n">k_diff</span> <span class="o">-=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">differenced</span></div>



<span class="k">def</span> <span class="nf">concat</span><span class="p">(</span><span class="n">series</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">allow_mix</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Concatenate a set of series.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    series : iterable</span>
<span class="sd">        An iterable of series to be concatenated</span>
<span class="sd">    axis : int, optional</span>
<span class="sd">        The axis along which to concatenate. Default is 1 (columns).</span>
<span class="sd">    allow_mix : bool</span>
<span class="sd">        Whether or not to allow a mix of pandas and non-pandas objects. Default</span>
<span class="sd">        is False. If true, the returned object is an ndarray, and additional</span>
<span class="sd">        pandas metadata (e.g. column names, indices, etc) is lost.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    concatenated : array or pd.DataFrame</span>
<span class="sd">        The concatenated array. Will be a DataFrame if series are pandas</span>
<span class="sd">        objects.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">is_pandas</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[[</span><span class="n">_is_using_pandas</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">series</span><span class="p">]]</span>
    <span class="n">ndim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[[</span><span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">series</span><span class="p">]]</span>
    <span class="n">max_ndim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">ndim</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">max_ndim</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;`tools.concat` does not support arrays with 3 or&#39;</span>
                         <span class="s1">&#39; more dimensions.&#39;</span><span class="p">)</span>

    <span class="c1"># Make sure the iterable is mutable</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">series</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
        <span class="n">series</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">series</span><span class="p">)</span>

    <span class="c1"># Standardize ndim</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">series</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">ndim</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">max_ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">series</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">series</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">ndim</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">max_ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">series</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">series</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">ndim</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">max_ndim</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">is_pandas</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">series</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">name</span>
            <span class="n">series</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">series</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">to_frame</span><span class="p">()</span>
            <span class="n">series</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">ndim</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">max_ndim</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">is_pandas</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="n">series</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">series</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">is_pandas</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">series</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
            <span class="n">base_columns</span> <span class="o">=</span> <span class="n">series</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">columns</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">base_columns</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">([</span><span class="n">series</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">name</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">series</span><span class="p">)):</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">series</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
                <span class="c1"># Handle case where we were passed a dataframe and a series</span>
                <span class="c1"># to concatenate, and the series did not have a name.</span>
                <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">([</span><span class="kc">None</span><span class="p">])):</span>
                    <span class="n">s</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="n">base_columns</span><span class="p">[:</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">s_columns</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">columns</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">s_columns</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">([</span><span class="n">s</span><span class="o">.</span><span class="n">name</span><span class="p">])</span>

            <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">base_columns</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">s_columns</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Columns must match to concatenate along&#39;</span>
                                 <span class="s1">&#39; rows.&#39;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">series</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">index</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Index must match to concatenate along&#39;</span>
                                 <span class="s1">&#39; columns.&#39;</span><span class="p">)</span>
        <span class="n">concatenated</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">series</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="o">~</span><span class="n">is_pandas</span><span class="p">)</span> <span class="ow">or</span> <span class="n">allow_mix</span><span class="p">:</span>
        <span class="n">concatenated</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">series</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Attempted to concatenate Pandas objects with&#39;</span>
                         <span class="s1">&#39; non-Pandas objects with `allow_mix=False`.&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">concatenated</span>


<div class="viewcode-block" id="is_invertible">
<a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.tools.is_invertible.html#statsmodels.tsa.statespace.tools.is_invertible">[docs]</a>
<span class="k">def</span> <span class="nf">is_invertible</span><span class="p">(</span><span class="n">polynomial</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mi">1</span> <span class="o">-</span> <span class="mf">1e-10</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Determine if a polynomial is invertible.</span>

<span class="sd">    Requires all roots of the polynomial lie inside the unit circle.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    polynomial : array_like or tuple, list</span>
<span class="sd">        Coefficients of a polynomial, in order of increasing degree.</span>
<span class="sd">        For example, `polynomial=[1, -0.5]` corresponds to the polynomial</span>
<span class="sd">        :math:`1 - 0.5x` which has root :math:`2`. If it is a matrix</span>
<span class="sd">        polynomial (in which case the coefficients are coefficient matrices),</span>
<span class="sd">        a tuple or list of matrices should be passed.</span>
<span class="sd">    threshold : number</span>
<span class="sd">        Allowed threshold for `is_invertible` to return True. Default is 1.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    companion_matrix</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>

<span class="sd">    If the coefficients provided are scalars :math:`(c_0, c_1, \dots, c_n)`,</span>
<span class="sd">    then the corresponding polynomial is :math:`c_0 + c_1 L + \dots + c_n L^n`.</span>


<span class="sd">    If the coefficients provided are matrices :math:`(C_0, C_1, \dots, C_n)`,</span>
<span class="sd">    then the corresponding polynomial is :math:`C_0 + C_1 L + \dots + C_n L^n`.</span>

<span class="sd">    There are three equivalent methods of determining if the polynomial</span>
<span class="sd">    represented by the coefficients is invertible:</span>

<span class="sd">    The first method factorizes the polynomial into:</span>

<span class="sd">    .. math::</span>

<span class="sd">        C(L) &amp; = c_0 + c_1 L + \dots + c_n L^n \\</span>
<span class="sd">             &amp; = constant (1 - \lambda_1 L)</span>
<span class="sd">                 (1 - \lambda_2 L) \dots (1 - \lambda_n L)</span>

<span class="sd">    In order for :math:`C(L)` to be invertible, it must be that each factor</span>
<span class="sd">    :math:`(1 - \lambda_i L)` is invertible; the condition is then that</span>
<span class="sd">    :math:`|\lambda_i| &lt; 1`, where :math:`\lambda_i` is a root of the</span>
<span class="sd">    polynomial.</span>

<span class="sd">    The second method factorizes the polynomial into:</span>

<span class="sd">    .. math::</span>

<span class="sd">        C(L) &amp; = c_0 + c_1 L + \dots + c_n L^n \\</span>
<span class="sd">             &amp; = constant (L - \zeta_1) (L - \zeta_2) \dots (L - \zeta_3)</span>

<span class="sd">    The condition is now :math:`|\zeta_i| &gt; 1`, where :math:`\zeta_i` is a root</span>
<span class="sd">    of the polynomial with reversed coefficients and</span>
<span class="sd">    :math:`\lambda_i = \frac{1}{\zeta_i}`.</span>

<span class="sd">    Finally, a companion matrix can be formed using the coefficients of the</span>
<span class="sd">    polynomial. Then the eigenvalues of that matrix give the roots of the</span>
<span class="sd">    polynomial. This last method is the one actually used.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># First method:</span>
    <span class="c1"># np.all(np.abs(np.roots(np.r_[1, params])) &lt; 1)</span>
    <span class="c1"># Second method:</span>
    <span class="c1"># np.all(np.abs(np.roots(np.r_[1, params][::-1])) &gt; 1)</span>
    <span class="c1"># Final method:</span>
    <span class="n">eigvals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigvals</span><span class="p">(</span><span class="n">companion_matrix</span><span class="p">(</span><span class="n">polynomial</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">eigvals</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">threshold</span><span class="p">)</span></div>



<span class="k">def</span> <span class="nf">solve_discrete_lyapunov</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">complex_step</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Solves the discrete Lyapunov equation using a bilinear transformation.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This is a modification of the version in Scipy (see</span>
<span class="sd">    https://github.com/scipy/scipy/blob/master/scipy/linalg/_solvers.py)</span>
<span class="sd">    which allows passing through the complex numbers in the matrix a</span>
<span class="sd">    (usually the transition matrix) in order to allow complex step</span>
<span class="sd">    differentiation.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">eye</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">complex_step</span><span class="p">:</span>
        <span class="n">aH</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
        <span class="n">aHI_inv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">aH</span> <span class="o">+</span> <span class="n">eye</span><span class="p">)</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">aH</span> <span class="o">-</span> <span class="n">eye</span><span class="p">,</span> <span class="n">aHI_inv</span><span class="p">)</span>
        <span class="n">c</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">eye</span><span class="p">),</span> <span class="n">q</span><span class="p">),</span> <span class="n">aHI_inv</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">solve_sylvester</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">(),</span> <span class="n">b</span><span class="p">,</span> <span class="o">-</span><span class="n">c</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">aH</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
        <span class="n">aHI_inv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">aH</span> <span class="o">+</span> <span class="n">eye</span><span class="p">)</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">aH</span> <span class="o">-</span> <span class="n">eye</span><span class="p">,</span> <span class="n">aHI_inv</span><span class="p">)</span>
        <span class="n">c</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">eye</span><span class="p">),</span> <span class="n">q</span><span class="p">),</span> <span class="n">aHI_inv</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">solve_sylvester</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">transpose</span><span class="p">(),</span> <span class="n">b</span><span class="p">,</span> <span class="o">-</span><span class="n">c</span><span class="p">)</span>


<div class="viewcode-block" id="constrain_stationary_univariate">
<a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.tools.constrain_stationary_univariate.html#statsmodels.tsa.statespace.tools.constrain_stationary_univariate">[docs]</a>
<span class="k">def</span> <span class="nf">constrain_stationary_univariate</span><span class="p">(</span><span class="n">unconstrained</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Transform unconstrained parameters used by the optimizer to constrained</span>
<span class="sd">    parameters used in likelihood evaluation</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    unconstrained : ndarray</span>
<span class="sd">        Unconstrained parameters used by the optimizer, to be transformed to</span>
<span class="sd">        stationary coefficients of, e.g., an autoregressive or moving average</span>
<span class="sd">        component.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    constrained : ndarray</span>
<span class="sd">        Constrained parameters of, e.g., an autoregressive or moving average</span>
<span class="sd">        component, to be transformed to arbitrary parameters used by the</span>
<span class="sd">        optimizer.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [*] Monahan, John F. 1984.</span>
<span class="sd">       &quot;A Note on Enforcing Stationarity in</span>
<span class="sd">       Autoregressive-moving Average Models.&quot;</span>
<span class="sd">       Biometrika 71 (2) (August 1): 403-404.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">n</span> <span class="o">=</span> <span class="n">unconstrained</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">unconstrained</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">unconstrained</span><span class="o">/</span><span class="p">((</span><span class="mi">1</span> <span class="o">+</span> <span class="n">unconstrained</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
            <span class="n">y</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">r</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">y</span><span class="p">[</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">k</span> <span class="o">-</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">y</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
    <span class="k">return</span> <span class="o">-</span><span class="n">y</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:]</span></div>



<div class="viewcode-block" id="unconstrain_stationary_univariate">
<a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.tools.unconstrain_stationary_univariate.html#statsmodels.tsa.statespace.tools.unconstrain_stationary_univariate">[docs]</a>
<span class="k">def</span> <span class="nf">unconstrain_stationary_univariate</span><span class="p">(</span><span class="n">constrained</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Transform constrained parameters used in likelihood evaluation</span>
<span class="sd">    to unconstrained parameters used by the optimizer</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    constrained : ndarray</span>
<span class="sd">        Constrained parameters of, e.g., an autoregressive or moving average</span>
<span class="sd">        component, to be transformed to arbitrary parameters used by the</span>
<span class="sd">        optimizer.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    unconstrained : ndarray</span>
<span class="sd">        Unconstrained parameters used by the optimizer, to be transformed to</span>
<span class="sd">        stationary coefficients of, e.g., an autoregressive or moving average</span>
<span class="sd">        component.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [*] Monahan, John F. 1984.</span>
<span class="sd">       &quot;A Note on Enforcing Stationarity in</span>
<span class="sd">       Autoregressive-moving Average Models.&quot;</span>
<span class="sd">       Biometrika 71 (2) (August 1): 403-404.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">constrained</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">constrained</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">y</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="o">-</span><span class="n">constrained</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
            <span class="n">y</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">y</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span><span class="o">*</span><span class="n">y</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="o">-</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">y</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">diagonal</span><span class="p">()</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">r</span> <span class="o">/</span> <span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="n">r</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">x</span></div>



<span class="k">def</span> <span class="nf">_constrain_sv_less_than_one_python</span><span class="p">(</span><span class="n">unconstrained</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                       <span class="n">k_endog</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Transform arbitrary matrices to matrices with singular values less than</span>
<span class="sd">    one.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    unconstrained : list</span>
<span class="sd">        Arbitrary matrices. Should be a list of length `order`, where each</span>
<span class="sd">        element is an array sized `k_endog` x `k_endog`.</span>
<span class="sd">    order : int, optional</span>
<span class="sd">        The order of the autoregression.</span>
<span class="sd">    k_endog : int, optional</span>
<span class="sd">        The dimension of the data vector.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    constrained : list</span>
<span class="sd">        Partial autocorrelation matrices. Should be a list of length</span>
<span class="sd">        `order`, where each element is an array sized `k_endog` x `k_endog`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    constrain_stationary_multivariate</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Corresponds to Lemma 2.2 in Ansley and Kohn (1986). See</span>
<span class="sd">    `constrain_stationary_multivariate` for more details.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">linalg</span>

    <span class="n">constrained</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># P_s,  s = 1, ..., p</span>
    <span class="k">if</span> <span class="n">order</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">order</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">unconstrained</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">k_endog</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">k_endog</span> <span class="o">=</span> <span class="n">unconstrained</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">eye</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">k_endog</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">order</span><span class="p">):</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">unconstrained</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">B</span><span class="p">,</span> <span class="n">lower</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">cho_factor</span><span class="p">(</span><span class="n">eye</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">A</span><span class="o">.</span><span class="n">T</span><span class="p">),</span> <span class="n">lower</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">constrained</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve_triangular</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">lower</span><span class="o">=</span><span class="n">lower</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">constrained</span>


<span class="k">def</span> <span class="nf">_compute_coefficients_from_multivariate_pacf_python</span><span class="p">(</span>
        <span class="n">partial_autocorrelations</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">transform_variance</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">k_endog</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Transform matrices with singular values less than one to matrices</span>
<span class="sd">    corresponding to a stationary (or invertible) process.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    partial_autocorrelations : list</span>
<span class="sd">        Partial autocorrelation matrices. Should be a list of length `order`,</span>
<span class="sd">        where each element is an array sized `k_endog` x `k_endog`.</span>
<span class="sd">    error_variance : ndarray</span>
<span class="sd">        The variance / covariance matrix of the error term. Should be sized</span>
<span class="sd">        `k_endog` x `k_endog`. This is used as input in the algorithm even if</span>
<span class="sd">        is not transformed by it (when `transform_variance` is False). The</span>
<span class="sd">        error term variance is required input when transformation is used</span>
<span class="sd">        either to force an autoregressive component to be stationary or to</span>
<span class="sd">        force a moving average component to be invertible.</span>
<span class="sd">    transform_variance : bool, optional</span>
<span class="sd">        Whether or not to transform the error variance term. This option is</span>
<span class="sd">        not typically used, and the default is False.</span>
<span class="sd">    order : int, optional</span>
<span class="sd">        The order of the autoregression.</span>
<span class="sd">    k_endog : int, optional</span>
<span class="sd">        The dimension of the data vector.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    coefficient_matrices : list</span>
<span class="sd">        Transformed coefficient matrices leading to a stationary VAR</span>
<span class="sd">        representation.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    constrain_stationary_multivariate</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Corresponds to Lemma 2.1 in Ansley and Kohn (1986). See</span>
<span class="sd">    `constrain_stationary_multivariate` for more details.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">linalg</span>

    <span class="k">if</span> <span class="n">order</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">order</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">partial_autocorrelations</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">k_endog</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">k_endog</span> <span class="o">=</span> <span class="n">partial_autocorrelations</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># If we want to keep the provided variance but with the constrained</span>
    <span class="c1"># coefficient matrices, we need to make a copy here, and then after the</span>
    <span class="c1"># main loop we will transform the coefficients to match the passed variance</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">transform_variance</span><span class="p">:</span>
        <span class="n">initial_variance</span> <span class="o">=</span> <span class="n">error_variance</span>
        <span class="c1"># Need to make the input variance large enough that the recursions</span>
        <span class="c1"># do not lead to zero-matrices due to roundoff error, which would case</span>
        <span class="c1"># exceptions from the Cholesky decompositions.</span>
        <span class="c1"># Note that this will still not always ensure positive definiteness,</span>
        <span class="c1"># and for k_endog, order large enough an exception may still be raised</span>
        <span class="n">error_variance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">k_endog</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">order</span> <span class="o">+</span> <span class="n">k_endog</span><span class="p">)</span><span class="o">**</span><span class="mi">10</span>

    <span class="n">forward_variances</span> <span class="o">=</span> <span class="p">[</span><span class="n">error_variance</span><span class="p">]</span>   <span class="c1"># \Sigma_s</span>
    <span class="n">backward_variances</span> <span class="o">=</span> <span class="p">[</span><span class="n">error_variance</span><span class="p">]</span>  <span class="c1"># \Sigma_s^*,  s = 0, ..., p</span>
    <span class="n">autocovariances</span> <span class="o">=</span> <span class="p">[</span><span class="n">error_variance</span><span class="p">]</span>     <span class="c1"># \Gamma_s</span>
    <span class="c1"># \phi_{s,k}, s = 1, ..., p</span>
    <span class="c1">#             k = 1, ..., s+1</span>
    <span class="n">forwards</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># \phi_{s,k}^*</span>
    <span class="n">backwards</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">error_variance_factor</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">cholesky</span><span class="p">(</span><span class="n">error_variance</span><span class="p">,</span> <span class="n">lower</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">forward_factors</span> <span class="o">=</span> <span class="p">[</span><span class="n">error_variance_factor</span><span class="p">]</span>
    <span class="n">backward_factors</span> <span class="o">=</span> <span class="p">[</span><span class="n">error_variance_factor</span><span class="p">]</span>

    <span class="c1"># We fill in the entries as follows:</span>
    <span class="c1"># [1,1]</span>
    <span class="c1"># [2,2], [2,1]</span>
    <span class="c1"># [3,3], [3,1], [3,2]</span>
    <span class="c1"># ...</span>
    <span class="c1"># [p,p], [p,1], ..., [p,p-1]</span>
    <span class="c1"># the last row, correctly ordered, is then used as the coefficients</span>
    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">order</span><span class="p">):</span>  <span class="c1"># s = 0, ..., p-1</span>
        <span class="n">prev_forwards</span> <span class="o">=</span> <span class="n">forwards</span>
        <span class="n">prev_backwards</span> <span class="o">=</span> <span class="n">backwards</span>
        <span class="n">forwards</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">backwards</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Create the &quot;last&quot; (k = s+1) matrix</span>
        <span class="c1"># Note: this is for k = s+1. However, below we then have to fill</span>
        <span class="c1"># in for k = 1, ..., s in order.</span>
        <span class="c1"># P L*^{-1} = x</span>
        <span class="c1"># x L* = P</span>
        <span class="c1"># L*&#39; x&#39; = P&#39;</span>
        <span class="n">forwards</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="n">linalg</span><span class="o">.</span><span class="n">solve_triangular</span><span class="p">(</span>
                <span class="n">backward_factors</span><span class="p">[</span><span class="n">s</span><span class="p">],</span> <span class="n">partial_autocorrelations</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
                <span class="n">lower</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">trans</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">))</span>
        <span class="n">forwards</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">forward_factors</span><span class="p">[</span><span class="n">s</span><span class="p">],</span> <span class="n">forwards</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

        <span class="c1"># P&#39; L^{-1} = x</span>
        <span class="c1"># x L = P&#39;</span>
        <span class="c1"># L&#39; x&#39; = P</span>
        <span class="n">backwards</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="n">linalg</span><span class="o">.</span><span class="n">solve_triangular</span><span class="p">(</span>
                <span class="n">forward_factors</span><span class="p">[</span><span class="n">s</span><span class="p">],</span> <span class="n">partial_autocorrelations</span><span class="p">[</span><span class="n">s</span><span class="p">],</span>
                <span class="n">lower</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">trans</span><span class="o">=</span><span class="s1">&#39;T&#39;</span><span class="p">))</span>
        <span class="n">backwards</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">backward_factors</span><span class="p">[</span><span class="n">s</span><span class="p">],</span> <span class="n">backwards</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

        <span class="c1"># Update the variance</span>
        <span class="c1"># Note: if s &gt;= 1, this will be further updated in the for loop</span>
        <span class="c1"># below</span>
        <span class="c1"># Also, this calculation will be re-used in the forward variance</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">forwards</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">backward_variances</span><span class="p">[</span><span class="n">s</span><span class="p">])</span>
        <span class="n">autocovariances</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tmp</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

        <span class="c1"># Create the remaining k = 1, ..., s matrices,</span>
        <span class="c1"># only has an effect if s &gt;= 1</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
            <span class="n">forwards</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">prev_forwards</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
                <span class="n">forwards</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">prev_backwards</span><span class="p">[</span><span class="n">s</span><span class="o">-</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)]))</span>

            <span class="n">backwards</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">prev_backwards</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
                <span class="n">backwards</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">prev_forwards</span><span class="p">[</span><span class="n">s</span><span class="o">-</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)]))</span>

            <span class="n">autocovariances</span><span class="p">[</span><span class="n">s</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">autocovariances</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span>
                                           <span class="n">prev_forwards</span><span class="p">[</span><span class="n">s</span><span class="o">-</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

        <span class="c1"># Create forward and backwards variances</span>
        <span class="n">forward_variances</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="n">forward_variances</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">forwards</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">backward_variances</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="n">backward_variances</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">-</span>
            <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">backwards</span><span class="p">[</span><span class="n">s</span><span class="p">],</span> <span class="n">forward_variances</span><span class="p">[</span><span class="n">s</span><span class="p">]),</span>
                <span class="n">backwards</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>
            <span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># Cholesky factors</span>
        <span class="n">forward_factors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="n">linalg</span><span class="o">.</span><span class="n">cholesky</span><span class="p">(</span><span class="n">forward_variances</span><span class="p">[</span><span class="n">s</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">lower</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">backward_factors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="n">linalg</span><span class="o">.</span><span class="n">cholesky</span><span class="p">(</span><span class="n">backward_variances</span><span class="p">[</span><span class="n">s</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">lower</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="c1"># If we do not want to use the transformed variance, we need to</span>
    <span class="c1"># adjust the constrained matrices, as presented in Lemma 2.3, see above</span>
    <span class="n">variance</span> <span class="o">=</span> <span class="n">forward_variances</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">transform_variance</span><span class="p">:</span>
        <span class="c1"># Here, we need to construct T such that:</span>
        <span class="c1"># variance = T * initial_variance * T&#39;</span>
        <span class="c1"># To do that, consider the Cholesky of variance (L) and</span>
        <span class="c1"># input_variance (M) to get:</span>
        <span class="c1"># L L&#39; = T M M&#39; T&#39; = (TM) (TM)&#39;</span>
        <span class="c1"># =&gt; L = T M</span>
        <span class="c1"># =&gt; L M^{-1} = T</span>
        <span class="n">initial_variance_factor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">cholesky</span><span class="p">(</span><span class="n">initial_variance</span><span class="p">)</span>
        <span class="n">transformed_variance_factor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">cholesky</span><span class="p">(</span><span class="n">variance</span><span class="p">)</span>
        <span class="n">transform</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">initial_variance_factor</span><span class="p">,</span>
                           <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">transformed_variance_factor</span><span class="p">))</span>
        <span class="n">inv_transform</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">transform</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">order</span><span class="p">):</span>
            <span class="n">forwards</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">transform</span><span class="p">,</span> <span class="n">forwards</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="n">inv_transform</span><span class="p">)</span>
            <span class="p">)</span>

    <span class="k">return</span> <span class="n">forwards</span><span class="p">,</span> <span class="n">variance</span>


<span class="k">def</span> <span class="nf">constrain_stationary_multivariate_python</span><span class="p">(</span><span class="n">unconstrained</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span>
                                             <span class="n">transform_variance</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                             <span class="n">prefix</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Transform unconstrained parameters used by the optimizer to constrained</span>
<span class="sd">    parameters used in likelihood evaluation for a vector autoregression.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    unconstrained : array or list</span>
<span class="sd">        Arbitrary matrices to be transformed to stationary coefficient matrices</span>
<span class="sd">        of the VAR. If a list, should be a list of length `order`, where each</span>
<span class="sd">        element is an array sized `k_endog` x `k_endog`. If an array, should be</span>
<span class="sd">        the matrices horizontally concatenated and sized</span>
<span class="sd">        `k_endog` x `k_endog * order`.</span>
<span class="sd">    error_variance : ndarray</span>
<span class="sd">        The variance / covariance matrix of the error term. Should be sized</span>
<span class="sd">        `k_endog` x `k_endog`. This is used as input in the algorithm even if</span>
<span class="sd">        is not transformed by it (when `transform_variance` is False). The</span>
<span class="sd">        error term variance is required input when transformation is used</span>
<span class="sd">        either to force an autoregressive component to be stationary or to</span>
<span class="sd">        force a moving average component to be invertible.</span>
<span class="sd">    transform_variance : bool, optional</span>
<span class="sd">        Whether or not to transform the error variance term. This option is</span>
<span class="sd">        not typically used, and the default is False.</span>
<span class="sd">    prefix : {&#39;s&#39;,&#39;d&#39;,&#39;c&#39;,&#39;z&#39;}, optional</span>
<span class="sd">        The appropriate BLAS prefix to use for the passed datatypes. Only</span>
<span class="sd">        use if absolutely sure that the prefix is correct or an error will</span>
<span class="sd">        result.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    constrained : array or list</span>
<span class="sd">        Transformed coefficient matrices leading to a stationary VAR</span>
<span class="sd">        representation. Will match the type of the passed `unconstrained`</span>
<span class="sd">        variable (so if a list was passed, a list will be returned).</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    In the notation of [1]_, the arguments `(variance, unconstrained)` are</span>
<span class="sd">    written as :math:`(\Sigma, A_1, \dots, A_p)`, where :math:`p` is the order</span>
<span class="sd">    of the vector autoregression, and is here determined by the length of</span>
<span class="sd">    the `unconstrained` argument.</span>

<span class="sd">    There are two steps in the constraining algorithm.</span>

<span class="sd">    First, :math:`(A_1, \dots, A_p)` are transformed into</span>
<span class="sd">    :math:`(P_1, \dots, P_p)` via Lemma 2.2 of [1]_.</span>

<span class="sd">    Second, :math:`(\Sigma, P_1, \dots, P_p)` are transformed into</span>
<span class="sd">    :math:`(\Sigma, \phi_1, \dots, \phi_p)` via Lemmas 2.1 and 2.3 of [1]_.</span>

<span class="sd">    If `transform_variance=True`, then only Lemma 2.1 is applied in the second</span>
<span class="sd">    step.</span>

<span class="sd">    While this function can be used even in the univariate case, it is much</span>
<span class="sd">    slower, so in that case `constrain_stationary_univariate` is preferred.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Ansley, Craig F., and Robert Kohn. 1986.</span>
<span class="sd">       &quot;A Note on Reparameterizing a Vector Autoregressive Moving Average Model</span>
<span class="sd">       to Enforce Stationarity.&quot;</span>
<span class="sd">       Journal of Statistical Computation and Simulation 24 (2): 99-106.</span>
<span class="sd">    .. [*] Ansley, Craig F, and Paul Newbold. 1979.</span>
<span class="sd">       &quot;Multivariate Partial Autocorrelations.&quot;</span>
<span class="sd">       In Proceedings of the Business and Economic Statistics Section, 349-53.</span>
<span class="sd">       American Statistical Association</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">use_list</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">unconstrained</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">use_list</span><span class="p">:</span>
        <span class="n">k_endog</span><span class="p">,</span> <span class="n">order</span> <span class="o">=</span> <span class="n">unconstrained</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">order</span> <span class="o">//=</span> <span class="n">k_endog</span>

        <span class="n">unconstrained</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">unconstrained</span><span class="p">[:</span><span class="n">k_endog</span><span class="p">,</span> <span class="n">i</span><span class="o">*</span><span class="n">k_endog</span><span class="p">:(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">k_endog</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">order</span><span class="p">)</span>
        <span class="p">]</span>

    <span class="n">order</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">unconstrained</span><span class="p">)</span>
    <span class="n">k_endog</span> <span class="o">=</span> <span class="n">unconstrained</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># Step 1: convert from arbitrary matrices to those with singular values</span>
    <span class="c1"># less than one.</span>
    <span class="n">sv_constrained</span> <span class="o">=</span> <span class="n">_constrain_sv_less_than_one_python</span><span class="p">(</span>
        <span class="n">unconstrained</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">k_endog</span><span class="p">)</span>

    <span class="c1"># Step 2: convert matrices from our &quot;partial autocorrelation matrix&quot; space</span>
    <span class="c1"># (matrices with singular values less than one) to the space of stationary</span>
    <span class="c1"># coefficient matrices</span>
    <span class="n">constrained</span><span class="p">,</span> <span class="n">var</span> <span class="o">=</span> <span class="n">_compute_coefficients_from_multivariate_pacf_python</span><span class="p">(</span>
        <span class="n">sv_constrained</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">transform_variance</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">k_endog</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">use_list</span><span class="p">:</span>
        <span class="n">constrained</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">constrained</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
            <span class="n">k_endog</span><span class="p">,</span> <span class="n">k_endog</span> <span class="o">*</span> <span class="n">order</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">constrained</span><span class="p">,</span> <span class="n">var</span>


<div class="viewcode-block" id="constrain_stationary_multivariate">
<a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.tools.constrain_stationary_multivariate.html#statsmodels.tsa.statespace.tools.constrain_stationary_multivariate">[docs]</a>
<span class="nd">@Appender</span><span class="p">(</span><span class="n">constrain_stationary_multivariate_python</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">constrain_stationary_multivariate</span><span class="p">(</span><span class="n">unconstrained</span><span class="p">,</span> <span class="n">variance</span><span class="p">,</span>
                                      <span class="n">transform_variance</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                      <span class="n">prefix</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

    <span class="n">use_list</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">unconstrained</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span>
    <span class="k">if</span> <span class="n">use_list</span><span class="p">:</span>
        <span class="n">unconstrained</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">unconstrained</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">k_endog</span><span class="p">,</span> <span class="n">order</span> <span class="o">=</span> <span class="n">unconstrained</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">order</span> <span class="o">//=</span> <span class="n">k_endog</span>

    <span class="k">if</span> <span class="n">order</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Must have order at least 1&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">k_endog</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Must have at least 1 endogenous variable&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">prefix</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">prefix</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">find_best_blas_type</span><span class="p">(</span>
            <span class="p">[</span><span class="n">unconstrained</span><span class="p">,</span> <span class="n">variance</span><span class="p">])</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="n">prefix_dtype_map</span><span class="p">[</span><span class="n">prefix</span><span class="p">]</span>

    <span class="n">unconstrained</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asfortranarray</span><span class="p">(</span><span class="n">unconstrained</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">variance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asfortranarray</span><span class="p">(</span><span class="n">variance</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

    <span class="c1"># Step 1: convert from arbitrary matrices to those with singular values</span>
    <span class="c1"># less than one.</span>
    <span class="c1"># sv_constrained = _constrain_sv_less_than_one(unconstrained, order,</span>
    <span class="c1">#                                              k_endog, prefix)</span>
    <span class="n">sv_constrained</span> <span class="o">=</span> <span class="n">prefix_sv_map</span><span class="p">[</span><span class="n">prefix</span><span class="p">](</span><span class="n">unconstrained</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">k_endog</span><span class="p">)</span>

    <span class="c1"># Step 2: convert matrices from our &quot;partial autocorrelation matrix&quot;</span>
    <span class="c1"># space (matrices with singular values less than one) to the space of</span>
    <span class="c1"># stationary coefficient matrices</span>
    <span class="n">constrained</span><span class="p">,</span> <span class="n">variance</span> <span class="o">=</span> <span class="n">prefix_pacf_map</span><span class="p">[</span><span class="n">prefix</span><span class="p">](</span>
        <span class="n">sv_constrained</span><span class="p">,</span> <span class="n">variance</span><span class="p">,</span> <span class="n">transform_variance</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">k_endog</span><span class="p">)</span>

    <span class="n">constrained</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">constrained</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">variance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">variance</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">use_list</span><span class="p">:</span>
        <span class="n">constrained</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">constrained</span><span class="p">[:</span><span class="n">k_endog</span><span class="p">,</span> <span class="n">i</span><span class="o">*</span><span class="n">k_endog</span><span class="p">:(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">k_endog</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">order</span><span class="p">)</span>
        <span class="p">]</span>

    <span class="k">return</span> <span class="n">constrained</span><span class="p">,</span> <span class="n">variance</span></div>



<span class="k">def</span> <span class="nf">_unconstrain_sv_less_than_one</span><span class="p">(</span><span class="n">constrained</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">k_endog</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Transform matrices with singular values less than one to arbitrary</span>
<span class="sd">    matrices.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    constrained : list</span>
<span class="sd">        The partial autocorrelation matrices. Should be a list of length</span>
<span class="sd">        `order`, where each element is an array sized `k_endog` x `k_endog`.</span>
<span class="sd">    order : int, optional</span>
<span class="sd">        The order of the autoregression.</span>
<span class="sd">    k_endog : int, optional</span>
<span class="sd">        The dimension of the data vector.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    unconstrained : list</span>
<span class="sd">        Unconstrained matrices. A list of length `order`, where each element is</span>
<span class="sd">        an array sized `k_endog` x `k_endog`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    unconstrain_stationary_multivariate</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Corresponds to the inverse of Lemma 2.2 in Ansley and Kohn (1986). See</span>
<span class="sd">    `unconstrain_stationary_multivariate` for more details.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">linalg</span>

    <span class="n">unconstrained</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># A_s,  s = 1, ..., p</span>
    <span class="k">if</span> <span class="n">order</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">order</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">constrained</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">k_endog</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">k_endog</span> <span class="o">=</span> <span class="n">constrained</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">eye</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">k_endog</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">order</span><span class="p">):</span>
        <span class="n">P</span> <span class="o">=</span> <span class="n">constrained</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="c1"># B^{-1} B^{-1}&#39; = I - P P&#39;</span>
        <span class="n">B_inv</span><span class="p">,</span> <span class="n">lower</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">cho_factor</span><span class="p">(</span><span class="n">eye</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">P</span><span class="o">.</span><span class="n">T</span><span class="p">),</span> <span class="n">lower</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># A = BP</span>
        <span class="c1"># B^{-1} A = P</span>
        <span class="n">unconstrained</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve_triangular</span><span class="p">(</span><span class="n">B_inv</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">lower</span><span class="o">=</span><span class="n">lower</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">unconstrained</span>


<span class="k">def</span> <span class="nf">_compute_multivariate_sample_acovf</span><span class="p">(</span><span class="n">endog</span><span class="p">,</span> <span class="n">maxlag</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computer multivariate sample autocovariances</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    endog : array_like</span>
<span class="sd">        Sample data on which to compute sample autocovariances. Shaped</span>
<span class="sd">        `nobs` x `k_endog`.</span>
<span class="sd">    maxlag : int</span>
<span class="sd">        Maximum lag to use when computing the sample autocovariances.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    sample_autocovariances : list</span>
<span class="sd">        A list of the first `maxlag` sample autocovariance matrices. Each</span>
<span class="sd">        matrix is shaped `k_endog` x `k_endog`.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This function computes the forward sample autocovariances:</span>

<span class="sd">    .. math::</span>

<span class="sd">        \hat \Gamma(s) = \frac{1}{n} \sum_{t=1}^{n-s}</span>
<span class="sd">        (Z_t - \bar Z) (Z_{t+s} - \bar Z)&#39;</span>

<span class="sd">    See page 353 of Wei (1990). This function is primarily implemented for</span>
<span class="sd">    checking the partial autocorrelation functions below, and so is quite slow.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [*] Wei, William. 1990.</span>
<span class="sd">       Time Series Analysis : Univariate and Multivariate Methods. Boston:</span>
<span class="sd">       Pearson.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Get the (demeaned) data as an array</span>
    <span class="n">endog</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">endog</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">endog</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">endog</span> <span class="o">=</span> <span class="n">endog</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
    <span class="n">endog</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">endog</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1"># Dimensions</span>
    <span class="n">nobs</span><span class="p">,</span> <span class="n">k_endog</span> <span class="o">=</span> <span class="n">endog</span><span class="o">.</span><span class="n">shape</span>

    <span class="n">sample_autocovariances</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">maxlag</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">sample_autocovariances</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">k_endog</span><span class="p">,</span> <span class="n">k_endog</span><span class="p">)))</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nobs</span> <span class="o">-</span> <span class="n">s</span><span class="p">):</span>
            <span class="n">sample_autocovariances</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">endog</span><span class="p">[</span><span class="n">t</span><span class="p">],</span> <span class="n">endog</span><span class="p">[</span><span class="n">t</span><span class="o">+</span><span class="n">s</span><span class="p">])</span>
        <span class="n">sample_autocovariances</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">/=</span> <span class="n">nobs</span>

    <span class="k">return</span> <span class="n">sample_autocovariances</span>


<span class="k">def</span> <span class="nf">_compute_multivariate_acovf_from_coefficients</span><span class="p">(</span>
        <span class="n">coefficients</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">maxlag</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">forward_autocovariances</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute multivariate autocovariances from vector autoregression coefficient</span>
<span class="sd">    matrices</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    coefficients : array or list</span>
<span class="sd">        The coefficients matrices. If a list, should be a list of length</span>
<span class="sd">        `order`, where each element is an array sized `k_endog` x `k_endog`. If</span>
<span class="sd">        an array, should be the coefficient matrices horizontally concatenated</span>
<span class="sd">        and sized `k_endog` x `k_endog * order`.</span>
<span class="sd">    error_variance : ndarray</span>
<span class="sd">        The variance / covariance matrix of the error term. Should be sized</span>
<span class="sd">        `k_endog` x `k_endog`.</span>
<span class="sd">    maxlag : int, optional</span>
<span class="sd">        The maximum autocovariance to compute. Default is `order`-1. Can be</span>
<span class="sd">        zero, in which case it returns the variance.</span>
<span class="sd">    forward_autocovariances : bool, optional</span>
<span class="sd">        Whether or not to compute forward autocovariances</span>
<span class="sd">        :math:`E(y_t y_{t+j}&#39;)`. Default is False, so that backward</span>
<span class="sd">        autocovariances :math:`E(y_t y_{t-j}&#39;)` are returned.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    autocovariances : list</span>
<span class="sd">        A list of the first `maxlag` autocovariance matrices. Each matrix is</span>
<span class="sd">        shaped `k_endog` x `k_endog`.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Computes</span>

<span class="sd">    .. math::</span>

<span class="sd">        \Gamma(j) = E(y_t y_{t-j}&#39;)</span>

<span class="sd">    for j = 1, ..., `maxlag`, unless `forward_autocovariances` is specified,</span>
<span class="sd">    in which case it computes:</span>

<span class="sd">    .. math::</span>

<span class="sd">        E(y_t y_{t+j}&#39;) = \Gamma(j)&#39;</span>

<span class="sd">    Coefficients are assumed to be provided from the VAR model:</span>

<span class="sd">    .. math::</span>
<span class="sd">        y_t = A_1 y_{t-1} + \dots + A_p y_{t-p} + \varepsilon_t</span>

<span class="sd">    Autocovariances are calculated by solving the associated discrete Lyapunov</span>
<span class="sd">    equation of the state space representation of the VAR process.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">linalg</span>

    <span class="c1"># Convert coefficients to a list of matrices, for use in</span>
    <span class="c1"># `companion_matrix`; get dimensions</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">coefficients</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span><span class="p">:</span>
        <span class="n">order</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">coefficients</span><span class="p">)</span>
        <span class="n">k_endog</span> <span class="o">=</span> <span class="n">coefficients</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">k_endog</span><span class="p">,</span> <span class="n">order</span> <span class="o">=</span> <span class="n">coefficients</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">order</span> <span class="o">//=</span> <span class="n">k_endog</span>

        <span class="n">coefficients</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">coefficients</span><span class="p">[:</span><span class="n">k_endog</span><span class="p">,</span> <span class="n">i</span><span class="o">*</span><span class="n">k_endog</span><span class="p">:(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">k_endog</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">order</span><span class="p">)</span>
        <span class="p">]</span>

    <span class="k">if</span> <span class="n">maxlag</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">maxlag</span> <span class="o">=</span> <span class="n">order</span><span class="o">-</span><span class="mi">1</span>

    <span class="c1"># Start with VAR(p): w_{t+1} = phi_1 w_t + ... + phi_p w_{t-p+1} + u_{t+1}</span>
    <span class="c1"># Then stack the VAR(p) into a VAR(1) in companion matrix form:</span>
    <span class="c1"># z_{t+1} = F z_t + v_t</span>
    <span class="n">companion</span> <span class="o">=</span> <span class="n">companion_matrix</span><span class="p">(</span>
        <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">coefficients</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">order</span><span class="p">)]</span>
    <span class="p">)</span><span class="o">.</span><span class="n">T</span>

    <span class="c1"># Compute the error variance matrix for the stacked form: E v_t v_t&#39;</span>
    <span class="n">selected_variance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">companion</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">selected_variance</span><span class="p">[:</span><span class="n">k_endog</span><span class="p">,</span> <span class="p">:</span><span class="n">k_endog</span><span class="p">]</span> <span class="o">=</span> <span class="n">error_variance</span>

    <span class="c1"># Compute the unconditional variance of z_t: E z_t z_t&#39;</span>
    <span class="n">stacked_cov</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">solve_discrete_lyapunov</span><span class="p">(</span><span class="n">companion</span><span class="p">,</span> <span class="n">selected_variance</span><span class="p">)</span>

    <span class="c1"># The first (block) row of the variance of z_t gives the first p-1</span>
    <span class="c1"># autocovariances of w_t: \Gamma_i = E w_t w_t+i with \Gamma_0 = Var(w_t)</span>
    <span class="c1"># Note: these are okay, checked against ArmaProcess</span>
    <span class="n">autocovariances</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">stacked_cov</span><span class="p">[:</span><span class="n">k_endog</span><span class="p">,</span> <span class="n">i</span><span class="o">*</span><span class="n">k_endog</span><span class="p">:(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">k_endog</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">order</span><span class="p">,</span> <span class="n">maxlag</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
    <span class="p">]</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">maxlag</span> <span class="o">-</span> <span class="p">(</span><span class="n">order</span><span class="o">-</span><span class="mi">1</span><span class="p">)):</span>
        <span class="n">stacked_cov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">companion</span><span class="p">,</span> <span class="n">stacked_cov</span><span class="p">)</span>
        <span class="n">autocovariances</span> <span class="o">+=</span> <span class="p">[</span>
            <span class="n">stacked_cov</span><span class="p">[:</span><span class="n">k_endog</span><span class="p">,</span> <span class="o">-</span><span class="n">k_endog</span><span class="p">:]</span>
        <span class="p">]</span>

    <span class="k">if</span> <span class="n">forward_autocovariances</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">autocovariances</span><span class="p">)):</span>
            <span class="n">autocovariances</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">autocovariances</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>

    <span class="k">return</span> <span class="n">autocovariances</span>


<span class="k">def</span> <span class="nf">_compute_multivariate_sample_pacf</span><span class="p">(</span><span class="n">endog</span><span class="p">,</span> <span class="n">maxlag</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computer multivariate sample partial autocorrelations</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    endog : array_like</span>
<span class="sd">        Sample data on which to compute sample autocovariances. Shaped</span>
<span class="sd">        `nobs` x `k_endog`.</span>
<span class="sd">    maxlag : int</span>
<span class="sd">        Maximum lag for which to calculate sample partial autocorrelations.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    sample_pacf : list</span>
<span class="sd">        A list of the first `maxlag` sample partial autocorrelation matrices.</span>
<span class="sd">        Each matrix is shaped `k_endog` x `k_endog`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sample_autocovariances</span> <span class="o">=</span> <span class="n">_compute_multivariate_sample_acovf</span><span class="p">(</span><span class="n">endog</span><span class="p">,</span> <span class="n">maxlag</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">_compute_multivariate_pacf_from_autocovariances</span><span class="p">(</span>
        <span class="n">sample_autocovariances</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_compute_multivariate_pacf_from_autocovariances</span><span class="p">(</span><span class="n">autocovariances</span><span class="p">,</span>
                                                    <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">k_endog</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute multivariate partial autocorrelations from autocovariances.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    autocovariances : list</span>
<span class="sd">        Autocorrelations matrices. Should be a list of length `order` + 1,</span>
<span class="sd">        where each element is an array sized `k_endog` x `k_endog`.</span>
<span class="sd">    order : int, optional</span>
<span class="sd">        The order of the autoregression.</span>
<span class="sd">    k_endog : int, optional</span>
<span class="sd">        The dimension of the data vector.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    pacf : list</span>
<span class="sd">        List of first `order` multivariate partial autocorrelations.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    unconstrain_stationary_multivariate</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Note that this computes multivariate partial autocorrelations.</span>

<span class="sd">    Corresponds to the inverse of Lemma 2.1 in Ansley and Kohn (1986). See</span>
<span class="sd">    `unconstrain_stationary_multivariate` for more details.</span>

<span class="sd">    Computes sample partial autocorrelations if sample autocovariances are</span>
<span class="sd">    given.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">linalg</span>

    <span class="k">if</span> <span class="n">order</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">order</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">autocovariances</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
    <span class="k">if</span> <span class="n">k_endog</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">k_endog</span> <span class="o">=</span> <span class="n">autocovariances</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># Now apply the Ansley and Kohn (1986) algorithm, except that instead of</span>
    <span class="c1"># calculating phi_{s+1, s+1} = L_s P_{s+1} {L_s^*}^{-1} (which requires</span>
    <span class="c1"># the partial autocorrelation P_{s+1} which is what we&#39;re trying to</span>
    <span class="c1"># calculate here), we calculate it as in Ansley and Newbold (1979), using</span>
    <span class="c1"># the autocovariances \Gamma_s and the forwards and backwards residual</span>
    <span class="c1"># variances \Sigma_s, \Sigma_s^*:</span>
    <span class="c1"># phi_{s+1, s+1} = [ \Gamma_{s+1}&#39; - \phi_{s,1} \Gamma_s&#39; - ... -</span>
    <span class="c1">#                    \phi_{s,s} \Gamma_1&#39; ] {\Sigma_s^*}^{-1}</span>

    <span class="c1"># Forward and backward variances</span>
    <span class="n">forward_variances</span> <span class="o">=</span> <span class="p">[]</span>   <span class="c1"># \Sigma_s</span>
    <span class="n">backward_variances</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># \Sigma_s^*,  s = 0, ..., p</span>
    <span class="c1"># \phi_{s,k}, s = 1, ..., p</span>
    <span class="c1">#             k = 1, ..., s+1</span>
    <span class="n">forwards</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># \phi_{s,k}^*</span>
    <span class="n">backwards</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">forward_factors</span> <span class="o">=</span> <span class="p">[]</span>   <span class="c1"># L_s</span>
    <span class="n">backward_factors</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># L_s^*,  s = 0, ..., p</span>

    <span class="c1"># Ultimately we want to construct the partial autocorrelation matrices</span>
    <span class="c1"># Note that this is &quot;1-indexed&quot; in the sense that it stores P_1, ... P_p</span>
    <span class="c1"># rather than starting with P_0.</span>
    <span class="n">partial_autocorrelations</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># We fill in the entries of phi_{s,k} as follows:</span>
    <span class="c1"># [1,1]</span>
    <span class="c1"># [2,2], [2,1]</span>
    <span class="c1"># [3,3], [3,1], [3,2]</span>
    <span class="c1"># ...</span>
    <span class="c1"># [p,p], [p,1], ..., [p,p-1]</span>
    <span class="c1"># the last row, correctly ordered, should be the same as the coefficient</span>
    <span class="c1"># matrices provided in the argument `constrained`</span>
    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">order</span><span class="p">):</span>  <span class="c1"># s = 0, ..., p-1</span>
        <span class="n">prev_forwards</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">forwards</span><span class="p">)</span>
        <span class="n">prev_backwards</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">backwards</span><span class="p">)</span>
        <span class="n">forwards</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">backwards</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Create forward and backwards variances Sigma_s, Sigma*_s</span>
        <span class="n">forward_variance</span> <span class="o">=</span> <span class="n">autocovariances</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">backward_variance</span> <span class="o">=</span> <span class="n">autocovariances</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
            <span class="n">forward_variance</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">prev_forwards</span><span class="p">[</span><span class="n">k</span><span class="p">],</span>
                                       <span class="n">autocovariances</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">backward_variance</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">prev_backwards</span><span class="p">[</span><span class="n">k</span><span class="p">],</span>
                                        <span class="n">autocovariances</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

        <span class="n">forward_variances</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">forward_variance</span><span class="p">)</span>
        <span class="n">backward_variances</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">backward_variance</span><span class="p">)</span>

        <span class="c1"># Cholesky factors</span>
        <span class="n">forward_factors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="n">linalg</span><span class="o">.</span><span class="n">cholesky</span><span class="p">(</span><span class="n">forward_variances</span><span class="p">[</span><span class="n">s</span><span class="p">],</span> <span class="n">lower</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">backward_factors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="n">linalg</span><span class="o">.</span><span class="n">cholesky</span><span class="p">(</span><span class="n">backward_variances</span><span class="p">[</span><span class="n">s</span><span class="p">],</span> <span class="n">lower</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># Create the intermediate sum term</span>
        <span class="k">if</span> <span class="n">s</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># phi_11 = \Gamma_1&#39; \Gamma_0^{-1}</span>
            <span class="c1"># phi_11 \Gamma_0 = \Gamma_1&#39;</span>
            <span class="c1"># \Gamma_0 phi_11&#39; = \Gamma_1</span>
            <span class="n">forwards</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">linalg</span><span class="o">.</span><span class="n">cho_solve</span><span class="p">(</span>
                <span class="p">(</span><span class="n">forward_factors</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="kc">True</span><span class="p">),</span> <span class="n">autocovariances</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
            <span class="c1"># backwards.append(forwards[-1])</span>
            <span class="c1"># phi_11_star = \Gamma_1 \Gamma_0^{-1}</span>
            <span class="c1"># phi_11_star \Gamma_0 = \Gamma_1</span>
            <span class="c1"># \Gamma_0 phi_11_star&#39; = \Gamma_1&#39;</span>
            <span class="n">backwards</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">linalg</span><span class="o">.</span><span class="n">cho_solve</span><span class="p">(</span>
                <span class="p">(</span><span class="n">backward_factors</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="kc">True</span><span class="p">),</span> <span class="n">autocovariances</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># G := \Gamma_{s+1}&#39; -</span>
            <span class="c1">#      \phi_{s,1} \Gamma_s&#39; - .. - \phi_{s,s} \Gamma_1&#39;</span>
            <span class="n">tmp_sum</span> <span class="o">=</span> <span class="n">autocovariances</span><span class="p">[</span><span class="n">s</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
                <span class="n">tmp_sum</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">prev_forwards</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">autocovariances</span><span class="p">[</span><span class="n">s</span><span class="o">-</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

            <span class="c1"># Create the &quot;last&quot; (k = s+1) matrix</span>
            <span class="c1"># Note: this is for k = s+1. However, below we then have to</span>
            <span class="c1"># fill in for k = 1, ..., s in order.</span>
            <span class="c1"># phi = G Sigma*^{-1}</span>
            <span class="c1"># phi Sigma* = G</span>
            <span class="c1"># Sigma*&#39; phi&#39; = G&#39;</span>
            <span class="c1"># Sigma* phi&#39; = G&#39;</span>
            <span class="c1"># (because Sigma* is symmetric)</span>
            <span class="n">forwards</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">linalg</span><span class="o">.</span><span class="n">cho_solve</span><span class="p">(</span>
                <span class="p">(</span><span class="n">backward_factors</span><span class="p">[</span><span class="n">s</span><span class="p">],</span> <span class="kc">True</span><span class="p">),</span> <span class="n">tmp_sum</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

            <span class="c1"># phi = G&#39; Sigma^{-1}</span>
            <span class="c1"># phi Sigma = G&#39;</span>
            <span class="c1"># Sigma&#39; phi&#39; = G</span>
            <span class="c1"># Sigma phi&#39; = G</span>
            <span class="c1"># (because Sigma is symmetric)</span>
            <span class="n">backwards</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">linalg</span><span class="o">.</span><span class="n">cho_solve</span><span class="p">(</span>
                <span class="p">(</span><span class="n">forward_factors</span><span class="p">[</span><span class="n">s</span><span class="p">],</span> <span class="kc">True</span><span class="p">),</span> <span class="n">tmp_sum</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

        <span class="c1"># Create the remaining k = 1, ..., s matrices,</span>
        <span class="c1"># only has an effect if s &gt;= 1</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
            <span class="n">forwards</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">prev_forwards</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
                <span class="n">forwards</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">prev_backwards</span><span class="p">[</span><span class="n">s</span><span class="o">-</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)]))</span>
            <span class="n">backwards</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">prev_backwards</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
                <span class="n">backwards</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">prev_forwards</span><span class="p">[</span><span class="n">s</span><span class="o">-</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)]))</span>

        <span class="c1"># Partial autocorrelation matrix: P_{s+1}</span>
        <span class="c1"># P = L^{-1} phi L*</span>
        <span class="c1"># L P = (phi L*)</span>
        <span class="n">partial_autocorrelations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve_triangular</span><span class="p">(</span>
            <span class="n">forward_factors</span><span class="p">[</span><span class="n">s</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">forwards</span><span class="p">[</span><span class="n">s</span><span class="p">],</span> <span class="n">backward_factors</span><span class="p">[</span><span class="n">s</span><span class="p">]),</span>
            <span class="n">lower</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">partial_autocorrelations</span>


<span class="k">def</span> <span class="nf">_compute_multivariate_pacf_from_coefficients</span><span class="p">(</span><span class="n">constrained</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span>
                                                 <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">k_endog</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Transform matrices corresponding to a stationary (or invertible) process</span>
<span class="sd">    to matrices with singular values less than one.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    constrained : array or list</span>
<span class="sd">        The coefficients matrices. If a list, should be a list of length</span>
<span class="sd">        `order`, where each element is an array sized `k_endog` x `k_endog`. If</span>
<span class="sd">        an array, should be the coefficient matrices horizontally concatenated</span>
<span class="sd">        and sized `k_endog` x `k_endog * order`.</span>
<span class="sd">    error_variance : ndarray</span>
<span class="sd">        The variance / covariance matrix of the error term. Should be sized</span>
<span class="sd">        `k_endog` x `k_endog`.</span>
<span class="sd">    order : int, optional</span>
<span class="sd">        The order of the autoregression.</span>
<span class="sd">    k_endog : int, optional</span>
<span class="sd">        The dimension of the data vector.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    pacf : list</span>
<span class="sd">        List of first `order` multivariate partial autocorrelations.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    unconstrain_stationary_multivariate</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Note that this computes multivariate partial autocorrelations.</span>

<span class="sd">    Corresponds to the inverse of Lemma 2.1 in Ansley and Kohn (1986). See</span>
<span class="sd">    `unconstrain_stationary_multivariate` for more details.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Coefficients are assumed to be provided from the VAR model:</span>

<span class="sd">    .. math::</span>
<span class="sd">        y_t = A_1 y_{t-1} + \dots + A_p y_{t-p} + \varepsilon_t</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">constrained</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span><span class="p">:</span>
        <span class="n">order</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">constrained</span><span class="p">)</span>
        <span class="n">k_endog</span> <span class="o">=</span> <span class="n">constrained</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">k_endog</span><span class="p">,</span> <span class="n">order</span> <span class="o">=</span> <span class="n">constrained</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">order</span> <span class="o">//=</span> <span class="n">k_endog</span>

    <span class="c1"># Get autocovariances for the process; these are defined to be</span>
    <span class="c1"># E z_t z_{t-j}&#39;</span>
    <span class="c1"># However, we want E z_t z_{t+j}&#39; = (E z_t z_{t-j}&#39;)&#39;</span>
    <span class="n">_acovf</span> <span class="o">=</span> <span class="n">_compute_multivariate_acovf_from_coefficients</span>

    <span class="n">autocovariances</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">autocovariance</span><span class="o">.</span><span class="n">T</span> <span class="k">for</span> <span class="n">autocovariance</span> <span class="ow">in</span>
        <span class="n">_acovf</span><span class="p">(</span><span class="n">constrained</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">maxlag</span><span class="o">=</span><span class="n">order</span><span class="p">)]</span>

    <span class="k">return</span> <span class="n">_compute_multivariate_pacf_from_autocovariances</span><span class="p">(</span><span class="n">autocovariances</span><span class="p">)</span>


<div class="viewcode-block" id="unconstrain_stationary_multivariate">
<a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.tools.unconstrain_stationary_multivariate.html#statsmodels.tsa.statespace.tools.unconstrain_stationary_multivariate">[docs]</a>
<span class="k">def</span> <span class="nf">unconstrain_stationary_multivariate</span><span class="p">(</span><span class="n">constrained</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Transform constrained parameters used in likelihood evaluation</span>
<span class="sd">    to unconstrained parameters used by the optimizer</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    constrained : array or list</span>
<span class="sd">        Constrained parameters of, e.g., an autoregressive or moving average</span>
<span class="sd">        component, to be transformed to arbitrary parameters used by the</span>
<span class="sd">        optimizer. If a list, should be a list of length `order`, where each</span>
<span class="sd">        element is an array sized `k_endog` x `k_endog`. If an array, should be</span>
<span class="sd">        the coefficient matrices horizontally concatenated and sized</span>
<span class="sd">        `k_endog` x `k_endog * order`.</span>
<span class="sd">    error_variance : ndarray</span>
<span class="sd">        The variance / covariance matrix of the error term. Should be sized</span>
<span class="sd">        `k_endog` x `k_endog`. This is used as input in the algorithm even if</span>
<span class="sd">        is not transformed by it (when `transform_variance` is False).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    unconstrained : ndarray</span>
<span class="sd">        Unconstrained parameters used by the optimizer, to be transformed to</span>
<span class="sd">        stationary coefficients of, e.g., an autoregressive or moving average</span>
<span class="sd">        component. Will match the type of the passed `constrained`</span>
<span class="sd">        variable (so if a list was passed, a list will be returned).</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Uses the list representation internally, even if an array is passed.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [*] Ansley, Craig F., and Robert Kohn. 1986.</span>
<span class="sd">       &quot;A Note on Reparameterizing a Vector Autoregressive Moving Average Model</span>
<span class="sd">       to Enforce Stationarity.&quot;</span>
<span class="sd">       Journal of Statistical Computation and Simulation 24 (2): 99-106.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">use_list</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">constrained</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">use_list</span><span class="p">:</span>
        <span class="n">k_endog</span><span class="p">,</span> <span class="n">order</span> <span class="o">=</span> <span class="n">constrained</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">order</span> <span class="o">//=</span> <span class="n">k_endog</span>

        <span class="n">constrained</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">constrained</span><span class="p">[:</span><span class="n">k_endog</span><span class="p">,</span> <span class="n">i</span><span class="o">*</span><span class="n">k_endog</span><span class="p">:(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">k_endog</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">order</span><span class="p">)</span>
        <span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">order</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">constrained</span><span class="p">)</span>
        <span class="n">k_endog</span> <span class="o">=</span> <span class="n">constrained</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># Step 1: convert matrices from the space of stationary</span>
    <span class="c1"># coefficient matrices to our &quot;partial autocorrelation matrix&quot; space</span>
    <span class="c1"># (matrices with singular values less than one)</span>
    <span class="n">partial_autocorrelations</span> <span class="o">=</span> <span class="n">_compute_multivariate_pacf_from_coefficients</span><span class="p">(</span>
        <span class="n">constrained</span><span class="p">,</span> <span class="n">error_variance</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">k_endog</span><span class="p">)</span>

    <span class="c1"># Step 2: convert from arbitrary matrices to those with singular values</span>
    <span class="c1"># less than one.</span>
    <span class="n">unconstrained</span> <span class="o">=</span> <span class="n">_unconstrain_sv_less_than_one</span><span class="p">(</span>
        <span class="n">partial_autocorrelations</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">k_endog</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">use_list</span><span class="p">:</span>
        <span class="n">unconstrained</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">unconstrained</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">unconstrained</span><span class="p">,</span> <span class="n">error_variance</span></div>



<div class="viewcode-block" id="validate_matrix_shape">
<a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.tools.validate_matrix_shape.html#statsmodels.tsa.statespace.tools.validate_matrix_shape">[docs]</a>
<span class="k">def</span> <span class="nf">validate_matrix_shape</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">nrows</span><span class="p">,</span> <span class="n">ncols</span><span class="p">,</span> <span class="n">nobs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Validate the shape of a possibly time-varying matrix, or raise an exception</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    name : str</span>
<span class="sd">        The name of the matrix being validated (used in exception messages)</span>
<span class="sd">    shape : array_like</span>
<span class="sd">        The shape of the matrix to be validated. May be of size 2 or (if</span>
<span class="sd">        the matrix is time-varying) 3.</span>
<span class="sd">    nrows : int</span>
<span class="sd">        The expected number of rows.</span>
<span class="sd">    ncols : int</span>
<span class="sd">        The expected number of columns.</span>
<span class="sd">    nobs : int</span>
<span class="sd">        The number of observations (used to validate the last dimension of a</span>
<span class="sd">        time-varying matrix)</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If the matrix is not of the desired shape.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ndim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>

    <span class="c1"># Enforce dimension</span>
    <span class="k">if</span> <span class="n">ndim</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid value for </span><span class="si">%s</span><span class="s1"> matrix. Requires a&#39;</span>
                         <span class="s1">&#39; 2- or 3-dimensional array, got </span><span class="si">%d</span><span class="s1"> dimensions&#39;</span> <span class="o">%</span>
                         <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">ndim</span><span class="p">))</span>
    <span class="c1"># Enforce the shape of the matrix</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">nrows</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid dimensions for </span><span class="si">%s</span><span class="s1"> matrix: requires </span><span class="si">%d</span><span class="s1">&#39;</span>
                         <span class="s1">&#39; rows, got </span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">nrows</span><span class="p">,</span> <span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">ncols</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid dimensions for </span><span class="si">%s</span><span class="s1"> matrix: requires </span><span class="si">%d</span><span class="s1">&#39;</span>
                         <span class="s1">&#39; columns, got </span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">ncols</span><span class="p">,</span> <span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

    <span class="c1"># If we do not yet know `nobs`, do not allow time-varying arrays</span>
    <span class="k">if</span> <span class="n">nobs</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">or</span> <span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid dimensions for </span><span class="si">%s</span><span class="s1"> matrix: time-varying&#39;</span>
                         <span class="s1">&#39; matrices cannot be given unless `nobs` is specified&#39;</span>
                         <span class="s1">&#39; (implicitly when a dataset is bound or else set&#39;</span>
                         <span class="s1">&#39; explicity)&#39;</span> <span class="o">%</span> <span class="n">name</span><span class="p">)</span>

    <span class="c1"># Enforce time-varying array size</span>
    <span class="k">if</span> <span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">and</span> <span class="n">nobs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">nobs</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid dimensions for time-varying </span><span class="si">%s</span><span class="s1">&#39;</span>
                         <span class="s1">&#39; matrix. Requires shape (*,*,</span><span class="si">%d</span><span class="s1">), got </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span>
                         <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">nobs</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">shape</span><span class="p">)))</span></div>



<div class="viewcode-block" id="validate_vector_shape">
<a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.tools.validate_vector_shape.html#statsmodels.tsa.statespace.tools.validate_vector_shape">[docs]</a>
<span class="k">def</span> <span class="nf">validate_vector_shape</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">nrows</span><span class="p">,</span> <span class="n">nobs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Validate the shape of a possibly time-varying vector, or raise an exception</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    name : str</span>
<span class="sd">        The name of the vector being validated (used in exception messages)</span>
<span class="sd">    shape : array_like</span>
<span class="sd">        The shape of the vector to be validated. May be of size 1 or (if</span>
<span class="sd">        the vector is time-varying) 2.</span>
<span class="sd">    nrows : int</span>
<span class="sd">        The expected number of rows (elements of the vector).</span>
<span class="sd">    nobs : int</span>
<span class="sd">        The number of observations (used to validate the last dimension of a</span>
<span class="sd">        time-varying vector)</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If the vector is not of the desired shape.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ndim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
    <span class="c1"># Enforce dimension</span>
    <span class="k">if</span> <span class="n">ndim</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid value for </span><span class="si">%s</span><span class="s1"> vector. Requires a&#39;</span>
                         <span class="s1">&#39; 1- or 2-dimensional array, got </span><span class="si">%d</span><span class="s1"> dimensions&#39;</span> <span class="o">%</span>
                         <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">ndim</span><span class="p">))</span>
    <span class="c1"># Enforce the shape of the vector</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">nrows</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid dimensions for </span><span class="si">%s</span><span class="s1"> vector: requires </span><span class="si">%d</span><span class="s1">&#39;</span>
                         <span class="s1">&#39; rows, got </span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">nrows</span><span class="p">,</span> <span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

    <span class="c1"># If we do not yet know `nobs`, do not allow time-varying arrays</span>
    <span class="k">if</span> <span class="n">nobs</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid dimensions for </span><span class="si">%s</span><span class="s1"> vector: time-varying&#39;</span>
                         <span class="s1">&#39; vectors cannot be given unless `nobs` is specified&#39;</span>
                         <span class="s1">&#39; (implicitly when a dataset is bound or else set&#39;</span>
                         <span class="s1">&#39; explicity)&#39;</span> <span class="o">%</span> <span class="n">name</span><span class="p">)</span>

    <span class="c1"># Enforce time-varying array size</span>
    <span class="k">if</span> <span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">nobs</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid dimensions for time-varying </span><span class="si">%s</span><span class="s1">&#39;</span>
                         <span class="s1">&#39; vector. Requires shape (*,</span><span class="si">%d</span><span class="s1">), got </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span>
                         <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">nobs</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">shape</span><span class="p">)))</span></div>



<span class="k">def</span> <span class="nf">reorder_missing_matrix</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">missing</span><span class="p">,</span> <span class="n">reorder_rows</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                           <span class="n">reorder_cols</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">is_diagonal</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                           <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Reorder the rows or columns of a time-varying matrix where all non-missing</span>
<span class="sd">    values are in the upper left corner of the matrix.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    matrix : array_like</span>
<span class="sd">        The matrix to be reordered. Must have shape (n, m, nobs).</span>
<span class="sd">    missing : array_like of bool</span>
<span class="sd">        The vector of missing indices. Must have shape (k, nobs) where `k = n`</span>
<span class="sd">        if `reorder_rows is True` and `k = m` if `reorder_cols is True`.</span>
<span class="sd">    reorder_rows : bool, optional</span>
<span class="sd">        Whether or not the rows of the matrix should be re-ordered. Default</span>
<span class="sd">        is False.</span>
<span class="sd">    reorder_cols : bool, optional</span>
<span class="sd">        Whether or not the columns of the matrix should be re-ordered. Default</span>
<span class="sd">        is False.</span>
<span class="sd">    is_diagonal : bool, optional</span>
<span class="sd">        Whether or not the matrix is diagonal. If this is True, must also have</span>
<span class="sd">        `n = m`. Default is False.</span>
<span class="sd">    inplace : bool, optional</span>
<span class="sd">        Whether or not to reorder the matrix in-place.</span>
<span class="sd">    prefix : {&#39;s&#39;, &#39;d&#39;, &#39;c&#39;, &#39;z&#39;}, optional</span>
<span class="sd">        The Fortran prefix of the vector. Default is to automatically detect</span>
<span class="sd">        the dtype. This parameter should only be used with caution.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    reordered_matrix : array_like</span>
<span class="sd">        The reordered matrix.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">prefix</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">prefix</span> <span class="o">=</span> <span class="n">find_best_blas_type</span><span class="p">((</span><span class="n">matrix</span><span class="p">,))[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">reorder</span> <span class="o">=</span> <span class="n">prefix_reorder_missing_matrix_map</span><span class="p">[</span><span class="n">prefix</span><span class="p">]</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">inplace</span><span class="p">:</span>
        <span class="n">matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>

    <span class="n">reorder</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">asfortranarray</span><span class="p">(</span><span class="n">missing</span><span class="p">),</span> <span class="n">reorder_rows</span><span class="p">,</span> <span class="n">reorder_cols</span><span class="p">,</span>
            <span class="n">is_diagonal</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">matrix</span>


<span class="k">def</span> <span class="nf">reorder_missing_vector</span><span class="p">(</span><span class="n">vector</span><span class="p">,</span> <span class="n">missing</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Reorder the elements of a time-varying vector where all non-missing</span>
<span class="sd">    values are in the first elements of the vector.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    vector : array_like</span>
<span class="sd">        The vector to be reordered. Must have shape (n, nobs).</span>
<span class="sd">    missing : array_like of bool</span>
<span class="sd">        The vector of missing indices. Must have shape (n, nobs).</span>
<span class="sd">    inplace : bool, optional</span>
<span class="sd">        Whether or not to reorder the matrix in-place. Default is False.</span>
<span class="sd">    prefix : {&#39;s&#39;, &#39;d&#39;, &#39;c&#39;, &#39;z&#39;}, optional</span>
<span class="sd">        The Fortran prefix of the vector. Default is to automatically detect</span>
<span class="sd">        the dtype. This parameter should only be used with caution.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    reordered_vector : array_like</span>
<span class="sd">        The reordered vector.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">prefix</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">prefix</span> <span class="o">=</span> <span class="n">find_best_blas_type</span><span class="p">((</span><span class="n">vector</span><span class="p">,))[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">reorder</span> <span class="o">=</span> <span class="n">prefix_reorder_missing_vector_map</span><span class="p">[</span><span class="n">prefix</span><span class="p">]</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">inplace</span><span class="p">:</span>
        <span class="n">vector</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">vector</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>

    <span class="n">reorder</span><span class="p">(</span><span class="n">vector</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">asfortranarray</span><span class="p">(</span><span class="n">missing</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">vector</span>


<span class="k">def</span> <span class="nf">copy_missing_matrix</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">missing</span><span class="p">,</span> <span class="n">missing_rows</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">missing_cols</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                        <span class="n">is_diagonal</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Copy the rows or columns of a time-varying matrix where all non-missing</span>
<span class="sd">    values are in the upper left corner of the matrix.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    A : array_like</span>
<span class="sd">        The matrix from which to copy. Must have shape (n, m, nobs) or</span>
<span class="sd">        (n, m, 1).</span>
<span class="sd">    B : array_like</span>
<span class="sd">        The matrix to copy to. Must have shape (n, m, nobs).</span>
<span class="sd">    missing : array_like of bool</span>
<span class="sd">        The vector of missing indices. Must have shape (k, nobs) where `k = n`</span>
<span class="sd">        if `reorder_rows is True` and `k = m` if `reorder_cols is True`.</span>
<span class="sd">    missing_rows : bool, optional</span>
<span class="sd">        Whether or not the rows of the matrix are a missing dimension. Default</span>
<span class="sd">        is False.</span>
<span class="sd">    missing_cols : bool, optional</span>
<span class="sd">        Whether or not the columns of the matrix are a missing dimension.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    is_diagonal : bool, optional</span>
<span class="sd">        Whether or not the matrix is diagonal. If this is True, must also have</span>
<span class="sd">        `n = m`. Default is False.</span>
<span class="sd">    inplace : bool, optional</span>
<span class="sd">        Whether or not to copy to B in-place. Default is False.</span>
<span class="sd">    prefix : {&#39;s&#39;, &#39;d&#39;, &#39;c&#39;, &#39;z&#39;}, optional</span>
<span class="sd">        The Fortran prefix of the vector. Default is to automatically detect</span>
<span class="sd">        the dtype. This parameter should only be used with caution.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    copied_matrix : array_like</span>
<span class="sd">        The matrix B with the non-missing submatrix of A copied onto it.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">prefix</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">prefix</span> <span class="o">=</span> <span class="n">find_best_blas_type</span><span class="p">((</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">copy</span> <span class="o">=</span> <span class="n">prefix_copy_missing_matrix_map</span><span class="p">[</span><span class="n">prefix</span><span class="p">]</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">inplace</span><span class="p">:</span>
        <span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>

    <span class="c1"># We may have been given an F-contiguous memoryview; in that case, we do</span>
    <span class="c1"># not want to alter it or convert it to a numpy array</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">A</span><span class="o">.</span><span class="n">is_f_contig</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">()</span>
    <span class="k">except</span> <span class="p">(</span><span class="ne">AttributeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">):</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asfortranarray</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>

    <span class="n">copy</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">asfortranarray</span><span class="p">(</span><span class="n">missing</span><span class="p">),</span> <span class="n">missing_rows</span><span class="p">,</span> <span class="n">missing_cols</span><span class="p">,</span>
         <span class="n">is_diagonal</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">B</span>


<span class="k">def</span> <span class="nf">copy_missing_vector</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">missing</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Reorder the elements of a time-varying vector where all non-missing</span>
<span class="sd">    values are in the first elements of the vector.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        The vector from which to copy. Must have shape (n, nobs) or (n, 1).</span>
<span class="sd">    b : array_like</span>
<span class="sd">        The vector to copy to. Must have shape (n, nobs).</span>
<span class="sd">    missing : array_like of bool</span>
<span class="sd">        The vector of missing indices. Must have shape (n, nobs).</span>
<span class="sd">    inplace : bool, optional</span>
<span class="sd">        Whether or not to copy to b in-place. Default is False.</span>
<span class="sd">    prefix : {&#39;s&#39;, &#39;d&#39;, &#39;c&#39;, &#39;z&#39;}, optional</span>
<span class="sd">        The Fortran prefix of the vector. Default is to automatically detect</span>
<span class="sd">        the dtype. This parameter should only be used with caution.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    copied_vector : array_like</span>
<span class="sd">        The vector b with the non-missing subvector of b copied onto it.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">prefix</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">prefix</span> <span class="o">=</span> <span class="n">find_best_blas_type</span><span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">copy</span> <span class="o">=</span> <span class="n">prefix_copy_missing_vector_map</span><span class="p">[</span><span class="n">prefix</span><span class="p">]</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">inplace</span><span class="p">:</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>

    <span class="c1"># We may have been given an F-contiguous memoryview; in that case, we do</span>
    <span class="c1"># not want to alter it or convert it to a numpy array</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">a</span><span class="o">.</span><span class="n">is_f_contig</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">()</span>
    <span class="k">except</span> <span class="p">(</span><span class="ne">AttributeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">):</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asfortranarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

    <span class="n">copy</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">asfortranarray</span><span class="p">(</span><span class="n">missing</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">b</span>


<span class="k">def</span> <span class="nf">copy_index_matrix</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">index_rows</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">index_cols</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                      <span class="n">is_diagonal</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Copy the rows or columns of a time-varying matrix where all non-index</span>
<span class="sd">    values are in the upper left corner of the matrix.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    A : array_like</span>
<span class="sd">        The matrix from which to copy. Must have shape (n, m, nobs) or</span>
<span class="sd">        (n, m, 1).</span>
<span class="sd">    B : array_like</span>
<span class="sd">        The matrix to copy to. Must have shape (n, m, nobs).</span>
<span class="sd">    index : array_like of bool</span>
<span class="sd">        The vector of index indices. Must have shape (k, nobs) where `k = n`</span>
<span class="sd">        if `reorder_rows is True` and `k = m` if `reorder_cols is True`.</span>
<span class="sd">    index_rows : bool, optional</span>
<span class="sd">        Whether or not the rows of the matrix are a index dimension. Default</span>
<span class="sd">        is False.</span>
<span class="sd">    index_cols : bool, optional</span>
<span class="sd">        Whether or not the columns of the matrix are a index dimension.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    is_diagonal : bool, optional</span>
<span class="sd">        Whether or not the matrix is diagonal. If this is True, must also have</span>
<span class="sd">        `n = m`. Default is False.</span>
<span class="sd">    inplace : bool, optional</span>
<span class="sd">        Whether or not to copy to B in-place. Default is False.</span>
<span class="sd">    prefix : {&#39;s&#39;, &#39;d&#39;, &#39;c&#39;, &#39;z&#39;}, optional</span>
<span class="sd">        The Fortran prefix of the vector. Default is to automatically detect</span>
<span class="sd">        the dtype. This parameter should only be used with caution.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    copied_matrix : array_like</span>
<span class="sd">        The matrix B with the non-index submatrix of A copied onto it.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">prefix</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">prefix</span> <span class="o">=</span> <span class="n">find_best_blas_type</span><span class="p">((</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">copy</span> <span class="o">=</span> <span class="n">prefix_copy_index_matrix_map</span><span class="p">[</span><span class="n">prefix</span><span class="p">]</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">inplace</span><span class="p">:</span>
        <span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>

    <span class="c1"># We may have been given an F-contiguous memoryview; in that case, we do</span>
    <span class="c1"># not want to alter it or convert it to a numpy array</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">A</span><span class="o">.</span><span class="n">is_f_contig</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">()</span>
    <span class="k">except</span> <span class="p">(</span><span class="ne">AttributeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">):</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asfortranarray</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>

    <span class="n">copy</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">asfortranarray</span><span class="p">(</span><span class="n">index</span><span class="p">),</span> <span class="n">index_rows</span><span class="p">,</span> <span class="n">index_cols</span><span class="p">,</span>
         <span class="n">is_diagonal</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">B</span>


<span class="k">def</span> <span class="nf">copy_index_vector</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Reorder the elements of a time-varying vector where all non-index</span>
<span class="sd">    values are in the first elements of the vector.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        The vector from which to copy. Must have shape (n, nobs) or (n, 1).</span>
<span class="sd">    b : array_like</span>
<span class="sd">        The vector to copy to. Must have shape (n, nobs).</span>
<span class="sd">    index : array_like of bool</span>
<span class="sd">        The vector of index indices. Must have shape (n, nobs).</span>
<span class="sd">    inplace : bool, optional</span>
<span class="sd">        Whether or not to copy to b in-place. Default is False.</span>
<span class="sd">    prefix : {&#39;s&#39;, &#39;d&#39;, &#39;c&#39;, &#39;z&#39;}, optional</span>
<span class="sd">        The Fortran prefix of the vector. Default is to automatically detect</span>
<span class="sd">        the dtype. This parameter should only be used with caution.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    copied_vector : array_like</span>
<span class="sd">        The vector b with the non-index subvector of b copied onto it.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">prefix</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">prefix</span> <span class="o">=</span> <span class="n">find_best_blas_type</span><span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">copy</span> <span class="o">=</span> <span class="n">prefix_copy_index_vector_map</span><span class="p">[</span><span class="n">prefix</span><span class="p">]</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">inplace</span><span class="p">:</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>

    <span class="c1"># We may have been given an F-contiguous memoryview; in that case, we do</span>
    <span class="c1"># not want to alter it or convert it to a numpy array</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">a</span><span class="o">.</span><span class="n">is_f_contig</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">()</span>
    <span class="k">except</span> <span class="p">(</span><span class="ne">AttributeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">):</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asfortranarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

    <span class="n">copy</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">asfortranarray</span><span class="p">(</span><span class="n">index</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">b</span>


<span class="k">def</span> <span class="nf">prepare_exog</span><span class="p">(</span><span class="n">exog</span><span class="p">):</span>
    <span class="n">k_exog</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">exog</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">exog_is_using_pandas</span> <span class="o">=</span> <span class="n">_is_using_pandas</span><span class="p">(</span><span class="n">exog</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">exog_is_using_pandas</span><span class="p">:</span>
            <span class="n">exog</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">exog</span><span class="p">)</span>

        <span class="c1"># Make sure we have 2-dimensional array</span>
        <span class="k">if</span> <span class="n">exog</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">exog_is_using_pandas</span><span class="p">:</span>
                <span class="n">exog</span> <span class="o">=</span> <span class="n">exog</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">exog</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">exog</span><span class="p">)</span>

        <span class="n">k_exog</span> <span class="o">=</span> <span class="n">exog</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">k_exog</span><span class="p">,</span> <span class="n">exog</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">prepare_trend_spec</span><span class="p">(</span><span class="n">trend</span><span class="p">):</span>
    <span class="c1"># Trend</span>
    <span class="k">if</span> <span class="n">trend</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">trend</span> <span class="o">==</span> <span class="s1">&#39;n&#39;</span><span class="p">:</span>
        <span class="n">polynomial_trend</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">trend</span> <span class="o">==</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span>
        <span class="n">polynomial_trend</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">elif</span> <span class="n">trend</span> <span class="o">==</span> <span class="s1">&#39;t&#39;</span><span class="p">:</span>
        <span class="n">polynomial_trend</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="k">elif</span> <span class="n">trend</span> <span class="o">==</span> <span class="s1">&#39;ct&#39;</span><span class="p">:</span>
        <span class="n">polynomial_trend</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="k">elif</span> <span class="n">trend</span> <span class="o">==</span> <span class="s1">&#39;ctt&#39;</span><span class="p">:</span>
        <span class="c1"># TODO deprecate ctt?</span>
        <span class="n">polynomial_trend</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">trend</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">trend</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">trend</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">polynomial_trend</span> <span class="o">=</span> <span class="p">(</span><span class="n">trend</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Valid trend inputs are &#39;c&#39; (constant), &#39;t&#39; (linear trend in &quot;</span>
                <span class="s2">&quot;time), &#39;ct&#39; (both), &#39;ctt&#39; (both with trend squared) or an &quot;</span>
                <span class="s2">&quot;interable defining a polynomial, e.g., [1, 1, 0, 1] is `a + &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;b*t + ct**3`. Received </span><span class="si">{</span><span class="n">trend</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

    <span class="c1"># Note: k_trend is not the degree of the trend polynomial, because e.g.</span>
    <span class="c1"># k_trend = 1 corresponds to the degree zero polynomial (with only a</span>
    <span class="c1"># constant term).</span>
    <span class="n">k_trend</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">polynomial_trend</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">polynomial_trend</span><span class="p">,</span> <span class="n">k_trend</span>


<span class="k">def</span> <span class="nf">prepare_trend_data</span><span class="p">(</span><span class="n">polynomial_trend</span><span class="p">,</span> <span class="n">k_trend</span><span class="p">,</span> <span class="n">nobs</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="c1"># Cache the arrays for calculating the intercept from the trend</span>
    <span class="c1"># components</span>
    <span class="n">time_trend</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="n">nobs</span> <span class="o">+</span> <span class="n">offset</span><span class="p">)</span>
    <span class="n">trend_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nobs</span><span class="p">,</span> <span class="n">k_trend</span><span class="p">))</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">polynomial_trend</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">trend_data</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">nobs</span><span class="p">,)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">trend_data</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">time_trend</span><span class="o">**</span><span class="n">k</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">trend_data</span>


<span class="k">def</span> <span class="nf">_safe_cond</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute condition while protecting from LinAlgError&quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">cond</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">except</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">LinAlgError</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">a</span><span class="p">)):</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>


<span class="k">def</span> <span class="nf">_compute_smoothed_state_weights</span><span class="p">(</span><span class="n">ssm</span><span class="p">,</span> <span class="n">compute_t</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">compute_j</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                    <span class="n">compute_prior_weights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
    <span class="c1"># Get references to the Cython objects</span>
    <span class="n">_model</span> <span class="o">=</span> <span class="n">ssm</span><span class="o">.</span><span class="n">_statespace</span>
    <span class="n">_kfilter</span> <span class="o">=</span> <span class="n">ssm</span><span class="o">.</span><span class="n">_kalman_filter</span>
    <span class="n">_smoother</span> <span class="o">=</span> <span class="n">ssm</span><span class="o">.</span><span class="n">_kalman_smoother</span>

    <span class="c1"># Determine the appropriate function for the dtype</span>
    <span class="n">func</span> <span class="o">=</span> <span class="n">prefix_compute_smoothed_state_weights_map</span><span class="p">[</span><span class="n">ssm</span><span class="o">.</span><span class="n">prefix</span><span class="p">]</span>

    <span class="c1"># Handle compute_t and compute_j indexes</span>
    <span class="k">if</span> <span class="n">compute_t</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">compute_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">ssm</span><span class="o">.</span><span class="n">nobs</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">compute_j</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">compute_j</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">ssm</span><span class="o">.</span><span class="n">nobs</span><span class="p">)</span>
    <span class="n">compute_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">compute_t</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">))</span>
    <span class="n">compute_t</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
    <span class="n">compute_j</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">compute_j</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">))</span>
    <span class="n">compute_j</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>

    <span class="c1"># Default setting for computing the prior weights</span>
    <span class="k">if</span> <span class="n">compute_prior_weights</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">compute_prior_weights</span> <span class="o">=</span> <span class="n">compute_j</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span>
    <span class="c1"># Validate that compute_prior_weights is valid</span>
    <span class="k">if</span> <span class="n">compute_prior_weights</span> <span class="ow">and</span> <span class="n">compute_j</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;If `compute_prior_weights` is set to True, then&#39;</span>
                         <span class="s1">&#39; `compute_j` must include the time period 0.&#39;</span><span class="p">)</span>

    <span class="c1"># Compute the weights</span>
    <span class="n">weights</span><span class="p">,</span> <span class="n">state_intercept_weights</span><span class="p">,</span> <span class="n">prior_weights</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span>
        <span class="n">_smoother</span><span class="p">,</span> <span class="n">_kfilter</span><span class="p">,</span> <span class="n">_model</span><span class="p">,</span> <span class="n">compute_t</span><span class="p">,</span> <span class="n">compute_j</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span>
        <span class="nb">bool</span><span class="p">(</span><span class="n">compute_prior_weights</span><span class="p">))</span>

    <span class="c1"># Re-order missing entries correctly and transpose to the appropriate</span>
    <span class="c1"># shape</span>
    <span class="n">t0</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">compute_t</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">compute_j</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">missing</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">ssm</span><span class="o">.</span><span class="n">endog</span><span class="p">[:,</span> <span class="n">t0</span><span class="p">:])</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">missing</span><span class="p">):</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="n">weights</span><span class="o">.</span><span class="n">shape</span>
        <span class="c1"># Transpose m, p, t, j, -&gt; t, m, p, j so that we can use the</span>
        <span class="c1"># `reorder_missing_matrix` function</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asfortranarray</span><span class="p">(</span><span class="n">weights</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
            <span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">shape</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">))</span>
        <span class="n">missing</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asfortranarray</span><span class="p">(</span><span class="n">missing</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">))</span>
        <span class="n">reorder_missing_matrix</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">missing</span><span class="p">,</span> <span class="n">reorder_cols</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                               <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># Transpose t, m, p, j -&gt; t, j, m, p,</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="p">(</span><span class="n">weights</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">shape</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
                          <span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Transpose m, p, t, j -&gt; t, j, m, p</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="n">weights</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Transpose m, l, t, j -&gt; t, j, m, l</span>
    <span class="n">state_intercept_weights</span> <span class="o">=</span> <span class="n">state_intercept_weights</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Transpose m, l, t -&gt; t, m, l</span>
    <span class="n">prior_weights</span> <span class="o">=</span> <span class="n">prior_weights</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Subset to the actual computed t, j elements</span>
    <span class="n">ix_tj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span><span class="n">compute_t</span> <span class="o">-</span> <span class="n">t0</span><span class="p">,</span> <span class="n">compute_j</span> <span class="o">-</span> <span class="n">t0</span><span class="p">)</span>
    <span class="n">weights</span> <span class="o">=</span> <span class="n">weights</span><span class="p">[</span><span class="n">ix_tj</span><span class="p">]</span>
    <span class="n">state_intercept_weights</span> <span class="o">=</span> <span class="n">state_intercept_weights</span><span class="p">[</span><span class="n">ix_tj</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">compute_prior_weights</span><span class="p">:</span>
        <span class="n">prior_weights</span> <span class="o">=</span> <span class="n">prior_weights</span><span class="p">[</span><span class="n">compute_t</span> <span class="o">-</span> <span class="n">t0</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">weights</span><span class="p">,</span> <span class="n">state_intercept_weights</span><span class="p">,</span> <span class="n">prior_weights</span>


<span class="k">def</span> <span class="nf">compute_smoothed_state_weights</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="n">compute_t</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">compute_j</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                   <span class="n">compute_prior_weights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">resmooth</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Construct the weights of observations and the prior on the smoothed state</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    results : MLEResults object</span>
<span class="sd">        Results object from fitting a state space model.</span>
<span class="sd">    compute_t : array_like, optional</span>
<span class="sd">        An explicit list of periods `t` of the smoothed state vector to compute</span>
<span class="sd">        weights for (see the Returns section for more details about the</span>
<span class="sd">        dimension `t`). Default is to compute weights for all periods `t`.</span>
<span class="sd">        However, if weights for only a few time points are desired, then</span>
<span class="sd">        performance can be improved by specifying this argument.</span>
<span class="sd">    compute_j : array_like, optional</span>
<span class="sd">        An explicit list of periods `j` of observations to compute</span>
<span class="sd">        weights for (see the Returns section for more details about the</span>
<span class="sd">        dimension `j`). Default is to compute weights for all periods `j`.</span>
<span class="sd">        However, if weights for only a few time points are desired, then</span>
<span class="sd">        performance can be improved by specifying this argument.</span>
<span class="sd">    compute_prior_weights : bool, optional</span>
<span class="sd">        Whether or not to compute the weight matrices associated with the prior</span>
<span class="sd">        mean (also called the &quot;initial state&quot;). Note that doing so requires</span>
<span class="sd">        that period 0 is in the periods defined in `compute_j`. Default is True</span>
<span class="sd">        if 0 is in `compute_j` (or if the `compute_j` argument is not passed)</span>
<span class="sd">        and False otherwise.</span>
<span class="sd">    resmooth : bool, optional</span>
<span class="sd">        Whether or not to re-perform filtering and smoothing prior to</span>
<span class="sd">        constructing the weights. Default is to resmooth if the smoothed_state</span>
<span class="sd">        vector is different between the given results object and the</span>
<span class="sd">        underlying smoother. Caution is adviced when changing this setting.</span>
<span class="sd">        See the Notes section below for more details.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    weights : array_like</span>
<span class="sd">        Weight matrices that can be used to construct the smoothed state from</span>
<span class="sd">        the observations. The returned matrix is always shaped</span>
<span class="sd">        `(nobs, nobs, k_states, k_endog)`, and entries that are not computed</span>
<span class="sd">        are set to NaNs. (Entries will not be computed if they are not</span>
<span class="sd">        included in `compute_t` and `compute_j`, or if they correspond to</span>
<span class="sd">        missing observations, or if they are for periods in which the exact</span>
<span class="sd">        diffuse Kalman filter is operative). The `(t, j, m, p)`-th element of</span>
<span class="sd">        this matrix contains the weight of the `p`-th element of the</span>
<span class="sd">        observation vector at time `j` in constructing the `m`-th element of</span>
<span class="sd">        the smoothed state vector at time `t`.</span>
<span class="sd">    prior_weights : array_like</span>
<span class="sd">        Weight matrices that describe the impact of the prior (also called the</span>
<span class="sd">        initialization) on the smoothed state vector. The returned matrix is</span>
<span class="sd">        always shaped `(nobs, k_states, k_states)`. If prior weights are not</span>
<span class="sd">        computed, then all entries will be set to NaNs. The `(t, m, l)`-th</span>
<span class="sd">        element of this matrix contains the weight of the `l`-th element of the</span>
<span class="sd">        prior mean (also called the &quot;initial state&quot;) in constructing the</span>
<span class="sd">        `m`-th element of the smoothed state vector at time `t`.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    In [1]_, Chapter 4.8, it is shown how the smoothed state vector can be</span>
<span class="sd">    written as a weighted vector sum of observations:</span>

<span class="sd">    .. math::</span>

<span class="sd">        \hat \alpha_t = \sum_{j=1}^n \omega_{jt}^{\hat \alpha} y_j</span>

<span class="sd">    One output of this function is the weights</span>
<span class="sd">    :math:`\omega_{jt}^{\hat \alpha}`. Note that the description in [1]_</span>
<span class="sd">    assumes that the prior mean (or &quot;initial state&quot;) is fixed to be zero. More</span>
<span class="sd">    generally, the smoothed state vector will also depend partly on the prior.</span>
<span class="sd">    The second output of this function are the weights of the prior mean.</span>

<span class="sd">    There are two important technical notes about the computations used here:</span>

<span class="sd">    1. In the univariate approach to multivariate filtering (see e.g.</span>
<span class="sd">       Chapter 6.4 of [1]_), all observations are introduced one at a time,</span>
<span class="sd">       including those from the same time period. As a result, the weight of</span>
<span class="sd">       each observation can be different than when all observations from the</span>
<span class="sd">       same time point are introduced together, as in the typical multivariate</span>
<span class="sd">       filtering approach. Here, we always compute weights as in the</span>
<span class="sd">       multivariate filtering approach, and we handle singular forecast error</span>
<span class="sd">       covariance matrices by using a pseudo-inverse.</span>
<span class="sd">    2. Constructing observation weights for periods in which the exact diffuse</span>
<span class="sd">       filter (see e.g. Chapter 5 of [1]_) is operative is not done here, and</span>
<span class="sd">       so the corresponding entries in the returned weight matrices will always</span>
<span class="sd">       be set equal to zeros. While handling these periods may be implemented</span>
<span class="sd">       in the future, one option for constructing these weights is to use an</span>
<span class="sd">       approximate (instead of exact) diffuse initialization for this purpose.</span>

<span class="sd">    Finally, one note about implementation: to compute the weights, we use</span>
<span class="sd">    attributes of the underlying filtering and smoothing Cython objects</span>
<span class="sd">    directly. However, these objects are not frozen with the result</span>
<span class="sd">    computation, and we cannot guarantee that their attributes have not</span>
<span class="sd">    changed since `res` was created. As a result, by default we re-run the</span>
<span class="sd">    filter and smoother to ensure that the attributes there actually correspond</span>
<span class="sd">    to the `res` object. This can be overridden by the user for a small</span>
<span class="sd">    performance boost if they are sure that the attributes have not changed;</span>
<span class="sd">    see the `resmooth` argument.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Durbin, James, and Siem Jan Koopman. 2012.</span>
<span class="sd">            Time Series Analysis by State Space Methods: Second Edition.</span>
<span class="sd">            Oxford University Press.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Get the python model object</span>
    <span class="n">mod</span> <span class="o">=</span> <span class="n">results</span><span class="o">.</span><span class="n">model</span>
    <span class="c1"># Always update the parameters to be consistent with `res`</span>
    <span class="n">mod</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">results</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>
    <span class="c1"># By default, resmooth if it appears the results have changed; check is</span>
    <span class="c1"># based on the smoothed state vector</span>
    <span class="k">if</span> <span class="n">resmooth</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">resmooth</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">results</span><span class="o">.</span><span class="n">smoothed_state</span> <span class="o">!=</span>
                          <span class="n">mod</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">_kalman_smoother</span><span class="o">.</span><span class="n">smoothed_state</span><span class="p">)</span>
    <span class="c1"># Resmooth if necessary, otherwise at least update the Cython model</span>
    <span class="k">if</span> <span class="n">resmooth</span><span class="p">:</span>
        <span class="n">mod</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">smooth</span><span class="p">(</span><span class="n">conserve_memory</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">update_representation</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                       <span class="n">update_filter</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">update_smoother</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">mod</span><span class="o">.</span><span class="n">ssm</span><span class="o">.</span><span class="n">_initialize_representation</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">_compute_smoothed_state_weights</span><span class="p">(</span>
        <span class="n">mod</span><span class="o">.</span><span class="n">ssm</span><span class="p">,</span> <span class="n">compute_t</span><span class="o">=</span><span class="n">compute_t</span><span class="p">,</span> <span class="n">compute_j</span><span class="o">=</span><span class="n">compute_j</span><span class="p">,</span>
        <span class="n">compute_prior_weights</span><span class="o">=</span><span class="n">compute_prior_weights</span><span class="p">,</span>
        <span class="n">scale</span><span class="o">=</span><span class="n">results</span><span class="o">.</span><span class="n">filter_results</span><span class="o">.</span><span class="n">scale</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">get_impact_dates</span><span class="p">(</span><span class="n">previous_model</span><span class="p">,</span> <span class="n">updated_model</span><span class="p">,</span> <span class="n">impact_date</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">periods</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute start/end periods and an index, often for impacts of data updates</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    previous_model : MLEModel</span>
<span class="sd">        Model used to compute default start/end periods if None are given.</span>
<span class="sd">        In the case of computing impacts of data updates, this would be the</span>
<span class="sd">        model estimated with the previous dataset. Otherwise, can be the same</span>
<span class="sd">        as `updated_model`.</span>
<span class="sd">    updated_model : MLEModel</span>
<span class="sd">        Model used to compute the index. In the case of computing impacts of</span>
<span class="sd">        data updates, this would be the model estimated with the updated</span>
<span class="sd">        dataset. Otherwise, can be the same as `previous_model`.</span>
<span class="sd">    impact_date : {int, str, datetime}, optional</span>
<span class="sd">        Specific individual impact date. Cannot be used in combination with</span>
<span class="sd">        `start`, `end`, or `periods`.</span>
<span class="sd">    start : {int, str, datetime}, optional</span>
<span class="sd">        Starting point of the impact dates. If given, one of `end` or `periods`</span>
<span class="sd">        must also be given. If a negative integer, will be computed relative to</span>
<span class="sd">        the dates in the `updated_model` index. Cannot be used in combination</span>
<span class="sd">        with `impact_date`.</span>
<span class="sd">    end : {int, str, datetime}, optional</span>
<span class="sd">        Ending point of the impact dates. If given, one of `start` or `periods`</span>
<span class="sd">        must also be given. If a negative integer, will be computed relative to</span>
<span class="sd">        the dates in the `updated_model` index. Cannot be used in combination</span>
<span class="sd">        with `impact_date`.</span>
<span class="sd">    periods : int, optional</span>
<span class="sd">        Number of impact date periods. If given, one of `start` or `end`</span>
<span class="sd">        must also be given. Cannot be used in combination with `impact_date`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    start : int</span>
<span class="sd">        Integer location of the first included impact dates.</span>
<span class="sd">    end : int</span>
<span class="sd">        Integer location of the last included impact dates (i.e. this integer</span>
<span class="sd">        location is included in the returned `index`).</span>
<span class="sd">    index : pd.Index</span>
<span class="sd">        Index associated with `start` and `end`, as computed from the</span>
<span class="sd">        `updated_model`&#39;s index.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This function is typically used as a helper for standardizing start and</span>
<span class="sd">    end periods for a date range where the most sensible default values are</span>
<span class="sd">    based on some initial dataset (here contained in the `previous_model`),</span>
<span class="sd">    while index-related operations (especially relative start/end dates given</span>
<span class="sd">    via negative integers) are most sensibly computed from an updated dataset</span>
<span class="sd">    (here contained in the `updated_model`).</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># There doesn&#39;t seem to be any universal default that both (a) make</span>
    <span class="c1"># sense for all data update combinations, and (b) work with both</span>
    <span class="c1"># time-invariant and time-varying models. So we require that the user</span>
    <span class="c1"># specify exactly two of start, end, periods.</span>
    <span class="k">if</span> <span class="n">impact_date</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">start</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">end</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">periods</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Cannot use the `impact_date` argument in&#39;</span>
                             <span class="s1">&#39; combination with `start`, `end`, or&#39;</span>
                             <span class="s1">&#39; `periods`.&#39;</span><span class="p">)</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">impact_date</span>
        <span class="n">periods</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">end</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">periods</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">previous_model</span><span class="o">.</span><span class="n">nobs</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">end</span> <span class="o">=</span> <span class="n">previous_model</span><span class="o">.</span><span class="n">nobs</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="n">start</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="n">end</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="n">periods</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Of the three parameters: start, end, and&#39;</span>
                         <span class="s1">&#39; periods, exactly two must be specified&#39;</span><span class="p">)</span>
    <span class="c1"># If we have the `periods` object, we need to convert `start`/`end` to</span>
    <span class="c1"># integers so that we can compute the other one. That&#39;s because</span>
    <span class="c1"># _get_prediction_index doesn&#39;t support a `periods` argument</span>
    <span class="k">elif</span> <span class="n">start</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">periods</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">start</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">updated_model</span><span class="o">.</span><span class="n">_get_prediction_index</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">start</span><span class="p">)</span>
        <span class="n">end</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="p">(</span><span class="n">periods</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">end</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">periods</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">updated_model</span><span class="o">.</span><span class="n">_get_prediction_index</span><span class="p">(</span><span class="n">end</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">end</span> <span class="o">-</span> <span class="p">(</span><span class="n">periods</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">start</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">end</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">pass</span>

    <span class="c1"># Get the integer-based start, end and the prediction index</span>
    <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">out_of_sample</span><span class="p">,</span> <span class="n">prediction_index</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">updated_model</span><span class="o">.</span><span class="n">_get_prediction_index</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">))</span>
    <span class="n">end</span> <span class="o">=</span> <span class="n">end</span> <span class="o">+</span> <span class="n">out_of_sample</span>

    <span class="k">return</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">prediction_index</span>


<span class="k">def</span> <span class="nf">_atleast_1d</span><span class="p">(</span><span class="o">*</span><span class="n">arys</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Version of `np.atleast_1d`, copied from</span>
<span class="sd">    https://github.com/numpy/numpy/blob/master/numpy/core/shape_base.py,</span>
<span class="sd">    with the following modifications:</span>

<span class="sd">    1. It allows for `None` arguments, and passes them directly through</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">ary</span> <span class="ow">in</span> <span class="n">arys</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">ary</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ary</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">ary</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ary</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">ary</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">ary</span>
        <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">res</span>


<span class="k">def</span> <span class="nf">_atleast_2d</span><span class="p">(</span><span class="o">*</span><span class="n">arys</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Version of `np.atleast_2d`, copied from</span>
<span class="sd">    https://github.com/numpy/numpy/blob/master/numpy/core/shape_base.py,</span>
<span class="sd">    with the following modifications:</span>

<span class="sd">    1. It allows for `None` arguments, and passes them directly through</span>
<span class="sd">    2. Instead of creating new axis at the beginning, it creates it at the end</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">ary</span> <span class="ow">in</span> <span class="n">arys</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">ary</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ary</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">ary</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ary</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">ary</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">ary</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">ary</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">ary</span>
        <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">res</span>
</code></pre></div>

  <hr>
<div class="md-source-file">
  <small>
    
      Last update:
      Oct 29, 2024
    
  </small>
</div>





                
              </article>
            </div>
          
          
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  
  
  <div class="md-footer-meta md-typeset">
    
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
    <div class="md-footer-copyright__highlight">
        &#169; Copyright 2009-2023, Josef Perktold, Skipper Seabold, Jonathan Taylor, statsmodels-developers.
        
    </div>
  
    Created using
    <a href="https://www.sphinx-doc.org/" target="_blank" rel="noopener">Sphinx</a>
    7.3.7.
     and
    <a href="https://github.com/jbms/sphinx-immaterial/" target="_blank" rel="noopener">Sphinx-Immaterial</a>
  
</div>
      
        <div class="md-social">
  
    
    
    <a href="https://github.com/statsmodels/statsmodels/" target="_blank" rel="noopener" title="Source on github.com" class="md-social__link">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc.--><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg>
    </a>
  
    
    
      
      
    
    <a href="https://pypi.org/project/statsmodels/" target="_blank" rel="noopener" title="pypi.org" class="md-social__link">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc.--><path d="M439.8 200.5c-7.7-30.9-22.3-54.2-53.4-54.2h-40.1v47.4c0 36.8-31.2 67.8-66.8 67.8H172.7c-29.2 0-53.4 25-53.4 54.3v101.8c0 29 25.2 46 53.4 54.3 33.8 9.9 66.3 11.7 106.8 0 26.9-7.8 53.4-23.5 53.4-54.3v-40.7H226.2v-13.6h160.2c31.1 0 42.6-21.7 53.4-54.2 11.2-33.5 10.7-65.7 0-108.6zM286.2 404c11.1 0 20.1 9.1 20.1 20.3 0 11.3-9 20.4-20.1 20.4-11 0-20.1-9.2-20.1-20.4.1-11.3 9.1-20.3 20.1-20.3zM167.8 248.1h106.8c29.7 0 53.4-24.5 53.4-54.3V91.9c0-29-24.4-50.7-53.4-55.6-35.8-5.9-74.7-5.6-106.8.1-45.2 8-53.4 24.7-53.4 55.6v40.7h106.9v13.6h-147c-31.1 0-58.3 18.7-66.8 54.2-9.8 40.7-10.2 66.1 0 108.6 7.6 31.6 25.7 54.2 56.8 54.2H101v-48.8c0-35.3 30.5-66.4 66.8-66.4zm-6.7-142.6c-11.1 0-20.1-9.1-20.1-20.3.1-11.3 9-20.4 20.1-20.4 11 0 20.1 9.2 20.1 20.4s-9 20.3-20.1 20.3z"/></svg>
    </a>
  
    
    
      
      
    
    <a href="https://doi.org/10.5281/zenodo.593847" target="_blank" rel="noopener" title="doi.org" class="md-social__link">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc.--><path d="M0 216C0 149.7 53.7 96 120 96h8c17.7 0 32 14.3 32 32s-14.3 32-32 32h-8c-30.9 0-56 25.1-56 56v8h64c35.3 0 64 28.7 64 64v64c0 35.3-28.7 64-64 64H64c-35.3 0-64-28.7-64-64V216zm256 0c0-66.3 53.7-120 120-120h8c17.7 0 32 14.3 32 32s-14.3 32-32 32h-8c-30.9 0-56 25.1-56 56v8h64c35.3 0 64 28.7 64 64v64c0 35.3-28.7 64-64 64h-64c-35.3 0-64-28.7-64-64V216z"/></svg>
    </a>
  
</div>
      
    </div>
    
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    <script id="__config" type="application/json">{"base": "../../../..", "features": [], "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.config.lang": "en", "search.config.pipeline": "trimmer, stopWordFilter", "search.config.separator": "[\\s\\-]+", "search.placeholder": "Search", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version.title": "Select version"}, "version": {"provider": "mike", "staticVersions": null, "versionPath": "../versions-v3.json"}}</script>
    
      
        <script src="../../../../_static/sphinx_immaterial_theme.f9d9eeeb247ace16c.min.js?v=8ec58cb5"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    
  </body>
</html>