


<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      <link rel="icon" href="../../../../_static/favicon.ico">
    
    
  
      
        <title>statsmodels.tsa.statespace.kalman_filter - statsmodels 0.15.0 (+57)</title>
      
    
  <link rel="icon" type="image/png" sizes="32x32" href="../../../../_static/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="../../../../_static/icons/favicon-16x16.png">
  <link rel="manifest" href="../../../../_static/icons/site.webmanifest">
  <link rel="mask-icon" href="../../../../_static/icons/safari-pinned-tab.svg" color="#919191">
  <meta name="msapplication-TileColor" content="#2b5797">
  <meta name="msapplication-config" content="../../../../_static/icons/browserconfig.xml">
  <link rel="stylesheet" href="../../../../_static/stylesheets/examples.css">
  <link rel="stylesheet" href="../../../../_static/stylesheets/deprecation.css">
    
      
        
        
          
          
          <meta name="theme-color" content="#4051b5">
        
      
      

    
    
    
      
        
        
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
        <link rel="stylesheet" type="text/css" href="../../../../_static/sphinx_immaterial_theme.a60204c58f5e4ff66.min.css?v=63f51f50" />
        <link rel="stylesheet" type="text/css" href="../../../../_static/graphviz.css?v=eafc0fe6" />
        <link rel="stylesheet" type="text/css" href="../../../../_static/plot_directive.css" />
    <script>__md_scope=new URL("../../../..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="" data-md-color-primary="indigo" data-md-color-accent="blue">
  
    
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
      <div data-md-component="outdated" hidden>
        
      </div>
    
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../../../../index.html" title="statsmodels 0.15.0 (+57)" class="md-header__button md-logo" aria-label="statsmodels 0.15.0 (+57)" data-md-component="logo">
      <img src="../../../../_static/statsmodels-logo-v2-bw.svg" alt="logo">
    </a>
    <label class="md-header__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            statsmodels 0.15.0 (+57)
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              statsmodels.tsa.statespace.kalman_filter
            
          </span>
        </div>
      </div>
    </div>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header__source">
        <a href="https://github.com/statsmodels/statsmodels/" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc.--><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg>
  </div>
  <div class="md-source__repository">
    statsmodels
  </div>
</a>
      </div>
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../../../../index.html" title="statsmodels 0.15.0 (+57)" class="md-nav__button md-logo" aria-label="statsmodels 0.15.0 (+57)" data-md-component="logo">
      <img src="../../../../_static/statsmodels-logo-v2-bw.svg" alt="logo">
    </a>
    statsmodels 0.15.0 (+57)
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/statsmodels/statsmodels/" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc.--><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg>
  </div>
  <div class="md-source__repository">
    statsmodels
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      

  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../install.html" class="md-nav__link">
        <span title="/install.rst (reference label)" class="md-ellipsis">Installing statsmodels</span>
      </a>
    </li>
  

    
      
      
      

  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../gettingstarted.html" class="md-nav__link">
        <span title="/gettingstarted.rst (reference label)" class="md-ellipsis">Getting started</span>
      </a>
    </li>
  

    
      
      
      

  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../user-guide.html" class="md-nav__link">
        <span title="/user-guide.rst (reference label)" class="md-ellipsis">User Guide</span>
      </a>
    </li>
  

    
      
      
      

  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../examples/index.html" class="md-nav__link">
        <span title="/examples/index.rst (reference label)" class="md-ellipsis">Examples</span>
      </a>
    </li>
  

    
      
      
      

  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../api.html" class="md-nav__link">
        <span title="/api.rst (reference label)" class="md-ellipsis">API Reference</span>
      </a>
    </li>
  

    
      
      
      

  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../about.html" class="md-nav__link">
        <span title="/about.rst (reference label)" class="md-ellipsis">About statsmodels</span>
      </a>
    </li>
  

    
      
      
      

  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../dev/index.html" class="md-nav__link">
        <span title="/dev/index.rst (reference label)" class="md-ellipsis">Developer Page</span>
      </a>
    </li>
  

    
      
      
      

  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../release/index.html" class="md-nav__link">
        <span title="/release/index.rst (reference label)" class="md-ellipsis">Release Notes</span>
      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

  

<nav class="md-nav md-nav--secondary">
  
  
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset" role="main">
                  


<h1>Source code for statsmodels.tsa.statespace.kalman_filter</h1><div class="highlight"><pre>
<span></span><code><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">State Space Representation and Kalman Filter</span>

<span class="sd">Author: Chad Fulton</span>
<span class="sd">License: Simplified-BSD</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">contextlib</span>
<span class="kn">from</span> <span class="nn">warnings</span> <span class="kn">import</span> <span class="n">warn</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">.representation</span> <span class="kn">import</span> <span class="n">OptionWrapper</span><span class="p">,</span> <span class="n">Representation</span><span class="p">,</span> <span class="n">FrozenRepresentation</span>
<span class="kn">from</span> <span class="nn">.tools</span> <span class="kn">import</span> <span class="n">reorder_missing_matrix</span><span class="p">,</span> <span class="n">reorder_missing_vector</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">tools</span>
<span class="kn">from</span> <span class="nn">statsmodels.tools.sm_exceptions</span> <span class="kn">import</span> <span class="n">ValueWarning</span>

<span class="c1"># Define constants</span>
<span class="n">FILTER_CONVENTIONAL</span> <span class="o">=</span> <span class="mh">0x01</span>     <span class="c1"># Durbin and Koopman (2012), Chapter 4</span>
<span class="n">FILTER_EXACT_INITIAL</span> <span class="o">=</span> <span class="mh">0x02</span>    <span class="c1"># ibid., Chapter 5.6</span>
<span class="n">FILTER_AUGMENTED</span> <span class="o">=</span> <span class="mh">0x04</span>        <span class="c1"># ibid., Chapter 5.7</span>
<span class="n">FILTER_SQUARE_ROOT</span> <span class="o">=</span> <span class="mh">0x08</span>      <span class="c1"># ibid., Chapter 6.3</span>
<span class="n">FILTER_UNIVARIATE</span> <span class="o">=</span> <span class="mh">0x10</span>       <span class="c1"># ibid., Chapter 6.4</span>
<span class="n">FILTER_COLLAPSED</span> <span class="o">=</span> <span class="mh">0x20</span>        <span class="c1"># ibid., Chapter 6.5</span>
<span class="n">FILTER_EXTENDED</span> <span class="o">=</span> <span class="mh">0x40</span>         <span class="c1"># ibid., Chapter 10.2</span>
<span class="n">FILTER_UNSCENTED</span> <span class="o">=</span> <span class="mh">0x80</span>        <span class="c1"># ibid., Chapter 10.3</span>
<span class="n">FILTER_CONCENTRATED</span> <span class="o">=</span> <span class="mh">0x100</span>    <span class="c1"># Harvey (1989), Chapter 3.4</span>
<span class="n">FILTER_CHANDRASEKHAR</span> <span class="o">=</span> <span class="mh">0x200</span>   <span class="c1"># Herbst (2015)</span>

<span class="n">INVERT_UNIVARIATE</span> <span class="o">=</span> <span class="mh">0x01</span>
<span class="n">SOLVE_LU</span> <span class="o">=</span> <span class="mh">0x02</span>
<span class="n">INVERT_LU</span> <span class="o">=</span> <span class="mh">0x04</span>
<span class="n">SOLVE_CHOLESKY</span> <span class="o">=</span> <span class="mh">0x08</span>
<span class="n">INVERT_CHOLESKY</span> <span class="o">=</span> <span class="mh">0x10</span>

<span class="n">STABILITY_FORCE_SYMMETRY</span> <span class="o">=</span> <span class="mh">0x01</span>

<span class="n">MEMORY_STORE_ALL</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">MEMORY_NO_FORECAST_MEAN</span> <span class="o">=</span> <span class="mh">0x01</span>
<span class="n">MEMORY_NO_FORECAST_COV</span> <span class="o">=</span> <span class="mh">0x02</span>
<span class="n">MEMORY_NO_FORECAST</span> <span class="o">=</span> <span class="n">MEMORY_NO_FORECAST_MEAN</span> <span class="o">|</span> <span class="n">MEMORY_NO_FORECAST_COV</span>
<span class="n">MEMORY_NO_PREDICTED_MEAN</span> <span class="o">=</span> <span class="mh">0x04</span>
<span class="n">MEMORY_NO_PREDICTED_COV</span> <span class="o">=</span> <span class="mh">0x08</span>
<span class="n">MEMORY_NO_PREDICTED</span> <span class="o">=</span> <span class="n">MEMORY_NO_PREDICTED_MEAN</span> <span class="o">|</span> <span class="n">MEMORY_NO_PREDICTED_COV</span>
<span class="n">MEMORY_NO_FILTERED_MEAN</span> <span class="o">=</span> <span class="mh">0x10</span>
<span class="n">MEMORY_NO_FILTERED_COV</span> <span class="o">=</span> <span class="mh">0x20</span>
<span class="n">MEMORY_NO_FILTERED</span> <span class="o">=</span> <span class="n">MEMORY_NO_FILTERED_MEAN</span> <span class="o">|</span> <span class="n">MEMORY_NO_FILTERED_COV</span>
<span class="n">MEMORY_NO_LIKELIHOOD</span> <span class="o">=</span> <span class="mh">0x40</span>
<span class="n">MEMORY_NO_GAIN</span> <span class="o">=</span> <span class="mh">0x80</span>
<span class="n">MEMORY_NO_SMOOTHING</span> <span class="o">=</span> <span class="mh">0x100</span>
<span class="n">MEMORY_NO_STD_FORECAST</span> <span class="o">=</span> <span class="mh">0x200</span>
<span class="n">MEMORY_CONSERVE</span> <span class="o">=</span> <span class="p">(</span>
    <span class="n">MEMORY_NO_FORECAST_COV</span> <span class="o">|</span> <span class="n">MEMORY_NO_PREDICTED</span> <span class="o">|</span> <span class="n">MEMORY_NO_FILTERED</span> <span class="o">|</span>
    <span class="n">MEMORY_NO_LIKELIHOOD</span> <span class="o">|</span> <span class="n">MEMORY_NO_GAIN</span> <span class="o">|</span> <span class="n">MEMORY_NO_SMOOTHING</span>
<span class="p">)</span>

<span class="n">TIMING_INIT_PREDICTED</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">TIMING_INIT_FILTERED</span> <span class="o">=</span> <span class="mi">1</span>


<div class="viewcode-block" id="KalmanFilter">
<a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.kalman_filter.KalmanFilter.html#statsmodels.tsa.statespace.kalman_filter.KalmanFilter">[docs]</a>
<span class="k">class</span> <span class="nc">KalmanFilter</span><span class="p">(</span><span class="n">Representation</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    State space representation of a time series process, with Kalman filter</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    k_endog : {array_like, int}</span>
<span class="sd">        The observed time-series process :math:`y` if array like or the</span>
<span class="sd">        number of variables in the process if an integer.</span>
<span class="sd">    k_states : int</span>
<span class="sd">        The dimension of the unobserved state process.</span>
<span class="sd">    k_posdef : int, optional</span>
<span class="sd">        The dimension of a guaranteed positive definite covariance matrix</span>
<span class="sd">        describing the shocks in the transition equation. Must be less than</span>
<span class="sd">        or equal to `k_states`. Default is `k_states`.</span>
<span class="sd">    loglikelihood_burn : int, optional</span>
<span class="sd">        The number of initial periods during which the loglikelihood is not</span>
<span class="sd">        recorded. Default is 0.</span>
<span class="sd">    tolerance : float, optional</span>
<span class="sd">        The tolerance at which the Kalman filter determines convergence to</span>
<span class="sd">        steady-state. Default is 1e-19.</span>
<span class="sd">    results_class : class, optional</span>
<span class="sd">        Default results class to use to save filtering output. Default is</span>
<span class="sd">        `FilterResults`. If specified, class must extend from `FilterResults`.</span>
<span class="sd">    **kwargs</span>
<span class="sd">        Keyword arguments may be used to provide values for the filter,</span>
<span class="sd">        inversion, and stability methods. See `set_filter_method`,</span>
<span class="sd">        `set_inversion_method`, and `set_stability_method`.</span>
<span class="sd">        Keyword arguments may be used to provide default values for state space</span>
<span class="sd">        matrices. See `Representation` for more details.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    FilterResults</span>
<span class="sd">    statsmodels.tsa.statespace.representation.Representation</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    There are several types of options available for controlling the Kalman</span>
<span class="sd">    filter operation. All options are internally held as bitmasks, but can be</span>
<span class="sd">    manipulated by setting class attributes, which act like boolean flags. For</span>
<span class="sd">    more information, see the `set_*` class method documentation. The options</span>
<span class="sd">    are:</span>

<span class="sd">    filter_method</span>
<span class="sd">        The filtering method controls aspects of which</span>
<span class="sd">        Kalman filtering approach will be used.</span>
<span class="sd">    inversion_method</span>
<span class="sd">        The Kalman filter may contain one matrix inversion: that of the</span>
<span class="sd">        forecast error covariance matrix. The inversion method controls how and</span>
<span class="sd">        if that inverse is performed.</span>
<span class="sd">    stability_method</span>
<span class="sd">        The Kalman filter is a recursive algorithm that may in some cases</span>
<span class="sd">        suffer issues with numerical stability. The stability method controls</span>
<span class="sd">        what, if any, measures are taken to promote stability.</span>
<span class="sd">    conserve_memory</span>
<span class="sd">        By default, the Kalman filter computes a number of intermediate</span>
<span class="sd">        matrices at each iteration. The memory conservation options control</span>
<span class="sd">        which of those matrices are stored.</span>
<span class="sd">    filter_timing</span>
<span class="sd">        By default, the Kalman filter follows Durbin and Koopman, 2012, in</span>
<span class="sd">        initializing the filter with predicted values. Kim and Nelson, 1999,</span>
<span class="sd">        instead initialize the filter with filtered values, which is</span>
<span class="sd">        essentially just a different timing convention.</span>

<span class="sd">    The `filter_method` and `inversion_method` options intentionally allow</span>
<span class="sd">    the possibility that multiple methods will be indicated. In the case that</span>
<span class="sd">    multiple methods are selected, the underlying Kalman filter will attempt to</span>
<span class="sd">    select the optional method given the input data.</span>

<span class="sd">    For example, it may be that INVERT_UNIVARIATE and SOLVE_CHOLESKY are</span>
<span class="sd">    indicated (this is in fact the default case). In this case, if the</span>
<span class="sd">    endogenous vector is 1-dimensional (`k_endog` = 1), then INVERT_UNIVARIATE</span>
<span class="sd">    is used and inversion reduces to simple division, and if it has a larger</span>
<span class="sd">    dimension, the Cholesky decomposition along with linear solving (rather</span>
<span class="sd">    than explicit matrix inversion) is used. If only SOLVE_CHOLESKY had been</span>
<span class="sd">    set, then the Cholesky decomposition method would *always* be used, even in</span>
<span class="sd">    the case of 1-dimensional data.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">filter_methods</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s1">&#39;filter_conventional&#39;</span><span class="p">,</span> <span class="s1">&#39;filter_exact_initial&#39;</span><span class="p">,</span> <span class="s1">&#39;filter_augmented&#39;</span><span class="p">,</span>
        <span class="s1">&#39;filter_square_root&#39;</span><span class="p">,</span> <span class="s1">&#39;filter_univariate&#39;</span><span class="p">,</span> <span class="s1">&#39;filter_collapsed&#39;</span><span class="p">,</span>
        <span class="s1">&#39;filter_extended&#39;</span><span class="p">,</span> <span class="s1">&#39;filter_unscented&#39;</span><span class="p">,</span> <span class="s1">&#39;filter_concentrated&#39;</span><span class="p">,</span>
        <span class="s1">&#39;filter_chandrasekhar&#39;</span>
    <span class="p">]</span>

    <span class="n">filter_conventional</span> <span class="o">=</span> <span class="n">OptionWrapper</span><span class="p">(</span><span class="s1">&#39;filter_method&#39;</span><span class="p">,</span> <span class="n">FILTER_CONVENTIONAL</span><span class="p">)</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    (bool) Flag for conventional Kalman filtering.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">filter_exact_initial</span> <span class="o">=</span> <span class="n">OptionWrapper</span><span class="p">(</span><span class="s1">&#39;filter_method&#39;</span><span class="p">,</span> <span class="n">FILTER_EXACT_INITIAL</span><span class="p">)</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    (bool) Flag for exact initial Kalman filtering. Not implemented.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">filter_augmented</span> <span class="o">=</span> <span class="n">OptionWrapper</span><span class="p">(</span><span class="s1">&#39;filter_method&#39;</span><span class="p">,</span> <span class="n">FILTER_AUGMENTED</span><span class="p">)</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    (bool) Flag for augmented Kalman filtering. Not implemented.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">filter_square_root</span> <span class="o">=</span> <span class="n">OptionWrapper</span><span class="p">(</span><span class="s1">&#39;filter_method&#39;</span><span class="p">,</span> <span class="n">FILTER_SQUARE_ROOT</span><span class="p">)</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    (bool) Flag for square-root Kalman filtering. Not implemented.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">filter_univariate</span> <span class="o">=</span> <span class="n">OptionWrapper</span><span class="p">(</span><span class="s1">&#39;filter_method&#39;</span><span class="p">,</span> <span class="n">FILTER_UNIVARIATE</span><span class="p">)</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    (bool) Flag for univariate filtering of multivariate observation vector.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">filter_collapsed</span> <span class="o">=</span> <span class="n">OptionWrapper</span><span class="p">(</span><span class="s1">&#39;filter_method&#39;</span><span class="p">,</span> <span class="n">FILTER_COLLAPSED</span><span class="p">)</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    (bool) Flag for Kalman filtering with collapsed observation vector.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">filter_extended</span> <span class="o">=</span> <span class="n">OptionWrapper</span><span class="p">(</span><span class="s1">&#39;filter_method&#39;</span><span class="p">,</span> <span class="n">FILTER_EXTENDED</span><span class="p">)</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    (bool) Flag for extended Kalman filtering. Not implemented.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">filter_unscented</span> <span class="o">=</span> <span class="n">OptionWrapper</span><span class="p">(</span><span class="s1">&#39;filter_method&#39;</span><span class="p">,</span> <span class="n">FILTER_UNSCENTED</span><span class="p">)</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    (bool) Flag for unscented Kalman filtering. Not implemented.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">filter_concentrated</span> <span class="o">=</span> <span class="n">OptionWrapper</span><span class="p">(</span><span class="s1">&#39;filter_method&#39;</span><span class="p">,</span> <span class="n">FILTER_CONCENTRATED</span><span class="p">)</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    (bool) Flag for Kalman filtering with concentrated log-likelihood.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">filter_chandrasekhar</span> <span class="o">=</span> <span class="n">OptionWrapper</span><span class="p">(</span><span class="s1">&#39;filter_method&#39;</span><span class="p">,</span> <span class="n">FILTER_CHANDRASEKHAR</span><span class="p">)</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    (bool) Flag for filtering with Chandrasekhar recursions.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">inversion_methods</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s1">&#39;invert_univariate&#39;</span><span class="p">,</span> <span class="s1">&#39;solve_lu&#39;</span><span class="p">,</span> <span class="s1">&#39;invert_lu&#39;</span><span class="p">,</span> <span class="s1">&#39;solve_cholesky&#39;</span><span class="p">,</span>
        <span class="s1">&#39;invert_cholesky&#39;</span>
    <span class="p">]</span>

    <span class="n">invert_univariate</span> <span class="o">=</span> <span class="n">OptionWrapper</span><span class="p">(</span><span class="s1">&#39;inversion_method&#39;</span><span class="p">,</span> <span class="n">INVERT_UNIVARIATE</span><span class="p">)</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    (bool) Flag for univariate inversion method (recommended).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">solve_lu</span> <span class="o">=</span> <span class="n">OptionWrapper</span><span class="p">(</span><span class="s1">&#39;inversion_method&#39;</span><span class="p">,</span> <span class="n">SOLVE_LU</span><span class="p">)</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    (bool) Flag for LU and linear solver inversion method.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">invert_lu</span> <span class="o">=</span> <span class="n">OptionWrapper</span><span class="p">(</span><span class="s1">&#39;inversion_method&#39;</span><span class="p">,</span> <span class="n">INVERT_LU</span><span class="p">)</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    (bool) Flag for LU inversion method.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">solve_cholesky</span> <span class="o">=</span> <span class="n">OptionWrapper</span><span class="p">(</span><span class="s1">&#39;inversion_method&#39;</span><span class="p">,</span> <span class="n">SOLVE_CHOLESKY</span><span class="p">)</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    (bool) Flag for Cholesky and linear solver inversion method (recommended).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">invert_cholesky</span> <span class="o">=</span> <span class="n">OptionWrapper</span><span class="p">(</span><span class="s1">&#39;inversion_method&#39;</span><span class="p">,</span> <span class="n">INVERT_CHOLESKY</span><span class="p">)</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    (bool) Flag for Cholesky inversion method.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">stability_methods</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;stability_force_symmetry&#39;</span><span class="p">]</span>

    <span class="n">stability_force_symmetry</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">OptionWrapper</span><span class="p">(</span><span class="s1">&#39;stability_method&#39;</span><span class="p">,</span> <span class="n">STABILITY_FORCE_SYMMETRY</span><span class="p">)</span>
    <span class="p">)</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    (bool) Flag for enforcing covariance matrix symmetry</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">memory_options</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s1">&#39;memory_store_all&#39;</span><span class="p">,</span> <span class="s1">&#39;memory_no_forecast_mean&#39;</span><span class="p">,</span>
        <span class="s1">&#39;memory_no_forecast_cov&#39;</span><span class="p">,</span> <span class="s1">&#39;memory_no_forecast&#39;</span><span class="p">,</span>
        <span class="s1">&#39;memory_no_predicted_mean&#39;</span><span class="p">,</span> <span class="s1">&#39;memory_no_predicted_cov&#39;</span><span class="p">,</span>
        <span class="s1">&#39;memory_no_predicted&#39;</span><span class="p">,</span> <span class="s1">&#39;memory_no_filtered_mean&#39;</span><span class="p">,</span>
        <span class="s1">&#39;memory_no_filtered_cov&#39;</span><span class="p">,</span> <span class="s1">&#39;memory_no_filtered&#39;</span><span class="p">,</span>
        <span class="s1">&#39;memory_no_likelihood&#39;</span><span class="p">,</span> <span class="s1">&#39;memory_no_gain&#39;</span><span class="p">,</span>
        <span class="s1">&#39;memory_no_smoothing&#39;</span><span class="p">,</span> <span class="s1">&#39;memory_no_std_forecast&#39;</span><span class="p">,</span> <span class="s1">&#39;memory_conserve&#39;</span>
    <span class="p">]</span>

    <span class="n">memory_store_all</span> <span class="o">=</span> <span class="n">OptionWrapper</span><span class="p">(</span><span class="s1">&#39;conserve_memory&#39;</span><span class="p">,</span> <span class="n">MEMORY_STORE_ALL</span><span class="p">)</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    (bool) Flag for storing all intermediate results in memory (default).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">memory_no_forecast_mean</span> <span class="o">=</span> <span class="n">OptionWrapper</span><span class="p">(</span>
        <span class="s1">&#39;conserve_memory&#39;</span><span class="p">,</span> <span class="n">MEMORY_NO_FORECAST_MEAN</span><span class="p">)</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    (bool) Flag to prevent storing forecasts and forecast errors.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">memory_no_forecast_cov</span> <span class="o">=</span> <span class="n">OptionWrapper</span><span class="p">(</span>
        <span class="s1">&#39;conserve_memory&#39;</span><span class="p">,</span> <span class="n">MEMORY_NO_FORECAST_COV</span><span class="p">)</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    (bool) Flag to prevent storing forecast error covariance matrices.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">memory_no_forecast</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        (bool) Flag to prevent storing all forecast-related output.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">memory_no_forecast_mean</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">memory_no_forecast_cov</span>

    <span class="nd">@memory_no_forecast</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">memory_no_forecast</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">bool</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">memory_no_forecast_mean</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">memory_no_forecast_cov</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">memory_no_forecast_mean</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">memory_no_forecast_cov</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="n">memory_no_predicted_mean</span> <span class="o">=</span> <span class="n">OptionWrapper</span><span class="p">(</span>
        <span class="s1">&#39;conserve_memory&#39;</span><span class="p">,</span> <span class="n">MEMORY_NO_PREDICTED_MEAN</span><span class="p">)</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    (bool) Flag to prevent storing predicted states.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">memory_no_predicted_cov</span> <span class="o">=</span> <span class="n">OptionWrapper</span><span class="p">(</span>
        <span class="s1">&#39;conserve_memory&#39;</span><span class="p">,</span> <span class="n">MEMORY_NO_PREDICTED_COV</span><span class="p">)</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    (bool) Flag to prevent storing predicted state covariance matrices.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">memory_no_predicted</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        (bool) Flag to prevent storing predicted state and covariance matrices.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">memory_no_predicted_mean</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">memory_no_predicted_cov</span>

    <span class="nd">@memory_no_predicted</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">memory_no_predicted</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">bool</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">memory_no_predicted_mean</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">memory_no_predicted_cov</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">memory_no_predicted_mean</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">memory_no_predicted_cov</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="n">memory_no_filtered_mean</span> <span class="o">=</span> <span class="n">OptionWrapper</span><span class="p">(</span>
        <span class="s1">&#39;conserve_memory&#39;</span><span class="p">,</span> <span class="n">MEMORY_NO_FILTERED_MEAN</span><span class="p">)</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    (bool) Flag to prevent storing filtered states.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">memory_no_filtered_cov</span> <span class="o">=</span> <span class="n">OptionWrapper</span><span class="p">(</span>
        <span class="s1">&#39;conserve_memory&#39;</span><span class="p">,</span> <span class="n">MEMORY_NO_FILTERED_COV</span><span class="p">)</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    (bool) Flag to prevent storing filtered state covariance matrices.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">memory_no_filtered</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        (bool) Flag to prevent storing filtered state and covariance matrices.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">memory_no_filtered_mean</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">memory_no_filtered_cov</span>

    <span class="nd">@memory_no_filtered</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">memory_no_filtered</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">bool</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">memory_no_filtered_mean</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">memory_no_filtered_cov</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">memory_no_filtered_mean</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">memory_no_filtered_cov</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="n">memory_no_likelihood</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">OptionWrapper</span><span class="p">(</span><span class="s1">&#39;conserve_memory&#39;</span><span class="p">,</span> <span class="n">MEMORY_NO_LIKELIHOOD</span><span class="p">)</span>
    <span class="p">)</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    (bool) Flag to prevent storing likelihood values for each observation.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">memory_no_gain</span> <span class="o">=</span> <span class="n">OptionWrapper</span><span class="p">(</span><span class="s1">&#39;conserve_memory&#39;</span><span class="p">,</span> <span class="n">MEMORY_NO_GAIN</span><span class="p">)</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    (bool) Flag to prevent storing the Kalman gain matrices.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">memory_no_smoothing</span> <span class="o">=</span> <span class="n">OptionWrapper</span><span class="p">(</span><span class="s1">&#39;conserve_memory&#39;</span><span class="p">,</span> <span class="n">MEMORY_NO_SMOOTHING</span><span class="p">)</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    (bool) Flag to prevent storing likelihood values for each observation.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">memory_no_std_forecast</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">OptionWrapper</span><span class="p">(</span><span class="s1">&#39;conserve_memory&#39;</span><span class="p">,</span> <span class="n">MEMORY_NO_STD_FORECAST</span><span class="p">))</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    (bool) Flag to prevent storing standardized forecast errors.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">memory_conserve</span> <span class="o">=</span> <span class="n">OptionWrapper</span><span class="p">(</span><span class="s1">&#39;conserve_memory&#39;</span><span class="p">,</span> <span class="n">MEMORY_CONSERVE</span><span class="p">)</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    (bool) Flag to conserve the maximum amount of memory.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">timing_options</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s1">&#39;timing_init_predicted&#39;</span><span class="p">,</span> <span class="s1">&#39;timing_init_filtered&#39;</span>
    <span class="p">]</span>
    <span class="n">timing_init_predicted</span> <span class="o">=</span> <span class="n">OptionWrapper</span><span class="p">(</span><span class="s1">&#39;filter_timing&#39;</span><span class="p">,</span>
                                          <span class="n">TIMING_INIT_PREDICTED</span><span class="p">)</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    (bool) Flag for the default timing convention (Durbin and Koopman, 2012).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">timing_init_filtered</span> <span class="o">=</span> <span class="n">OptionWrapper</span><span class="p">(</span><span class="s1">&#39;filter_timing&#39;</span><span class="p">,</span> <span class="n">TIMING_INIT_FILTERED</span><span class="p">)</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    (bool) Flag for the alternate timing convention (Kim and Nelson, 2012).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Default filter options</span>
    <span class="n">filter_method</span> <span class="o">=</span> <span class="n">FILTER_CONVENTIONAL</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    (int) Filtering method bitmask.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">inversion_method</span> <span class="o">=</span> <span class="n">INVERT_UNIVARIATE</span> <span class="o">|</span> <span class="n">SOLVE_CHOLESKY</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    (int) Inversion method bitmask.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">stability_method</span> <span class="o">=</span> <span class="n">STABILITY_FORCE_SYMMETRY</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    (int) Stability method bitmask.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">conserve_memory</span> <span class="o">=</span> <span class="n">MEMORY_STORE_ALL</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    (int) Memory conservation bitmask.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">filter_timing</span> <span class="o">=</span> <span class="n">TIMING_INIT_PREDICTED</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    (int) Filter timing.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k_endog</span><span class="p">,</span> <span class="n">k_states</span><span class="p">,</span> <span class="n">k_posdef</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">loglikelihood_burn</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mf">1e-19</span><span class="p">,</span> <span class="n">results_class</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">kalman_filter_classes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># Extract keyword arguments to-be-used later</span>
        <span class="n">keys</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;filter_method&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">KalmanFilter</span><span class="o">.</span><span class="n">filter_methods</span>
        <span class="n">filter_method_kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">keys</span>
                                <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">}</span>
        <span class="n">keys</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;inversion_method&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">KalmanFilter</span><span class="o">.</span><span class="n">inversion_methods</span>
        <span class="n">inversion_method_kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">keys</span>
                                   <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">}</span>
        <span class="n">keys</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;stability_method&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">KalmanFilter</span><span class="o">.</span><span class="n">stability_methods</span>
        <span class="n">stability_method_kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">keys</span>
                                   <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">}</span>
        <span class="n">keys</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;conserve_memory&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">KalmanFilter</span><span class="o">.</span><span class="n">memory_options</span>
        <span class="n">conserve_memory_kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">keys</span>
                                  <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">}</span>
        <span class="n">keys</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;alternate_timing&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">KalmanFilter</span><span class="o">.</span><span class="n">timing_options</span>
        <span class="n">filter_timing_kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">keys</span>
                                <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">}</span>

        <span class="c1"># Initialize the base class</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">KalmanFilter</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">k_endog</span><span class="p">,</span> <span class="n">k_states</span><span class="p">,</span> <span class="n">k_posdef</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>

        <span class="c1"># Setup the underlying Kalman filter storage</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_kalman_filters</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># Filter options</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loglikelihood_burn</span> <span class="o">=</span> <span class="n">loglikelihood_burn</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">results_class</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">results_class</span> <span class="k">if</span> <span class="n">results_class</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">FilterResults</span>
        <span class="p">)</span>
        <span class="c1"># Options</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prefix_kalman_filter_map</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">kalman_filter_classes</span>
            <span class="k">if</span> <span class="n">kalman_filter_classes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="k">else</span> <span class="n">tools</span><span class="o">.</span><span class="n">prefix_kalman_filter_map</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">set_filter_method</span><span class="p">(</span><span class="o">**</span><span class="n">filter_method_kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_inversion_method</span><span class="p">(</span><span class="o">**</span><span class="n">inversion_method_kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_stability_method</span><span class="p">(</span><span class="o">**</span><span class="n">stability_method_kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_conserve_memory</span><span class="p">(</span><span class="o">**</span><span class="n">conserve_memory_kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_filter_timing</span><span class="p">(</span><span class="o">**</span><span class="n">filter_timing_kwargs</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">tolerance</span> <span class="o">=</span> <span class="n">tolerance</span>

        <span class="c1"># Internal flags</span>
        <span class="c1"># The _scale internal flag is used because we may want to</span>
        <span class="c1"># use a fixed scale, in which case we want the flag to the Cython</span>
        <span class="c1"># Kalman filter to indicate that the scale should not be concentrated</span>
        <span class="c1"># out, so that self.filter_concentrated = False, but we still want to</span>
        <span class="c1"># alert the results object that we are viewing the model as one in</span>
        <span class="c1"># which the scale had been concentrated out for e.g. degree of freedom</span>
        <span class="c1"># computations.</span>
        <span class="c1"># This value should always be None, except within the fixed_scale</span>
        <span class="c1"># context, and should not be modified by users or anywhere else.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_scale</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_clone_kwargs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">endog</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># See Representation._clone_kwargs for docstring</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">KalmanFilter</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_clone_kwargs</span><span class="p">(</span><span class="n">endog</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Get defaults for options</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;filter_method&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_method</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;inversion_method&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">inversion_method</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;stability_method&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">stability_method</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;conserve_memory&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">conserve_memory</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;alternate_timing&#39;</span><span class="p">,</span> <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filter_timing</span><span class="p">))</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;tolerance&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tolerance</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;loglikelihood_burn&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">loglikelihood_burn</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">kwargs</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_kalman_filter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">prefix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prefix</span>
        <span class="k">if</span> <span class="n">prefix</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kalman_filters</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kalman_filters</span><span class="p">[</span><span class="n">prefix</span><span class="p">]</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_initialize_filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filter_method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">inversion_method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                           <span class="n">stability_method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">conserve_memory</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                           <span class="n">tolerance</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">filter_timing</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                           <span class="n">loglikelihood_burn</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">filter_method</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">filter_method</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_method</span>
        <span class="k">if</span> <span class="n">inversion_method</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">inversion_method</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inversion_method</span>
        <span class="k">if</span> <span class="n">stability_method</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">stability_method</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stability_method</span>
        <span class="k">if</span> <span class="n">conserve_memory</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">conserve_memory</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">conserve_memory</span>
        <span class="k">if</span> <span class="n">loglikelihood_burn</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">loglikelihood_burn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">loglikelihood_burn</span>
        <span class="k">if</span> <span class="n">filter_timing</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">filter_timing</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_timing</span>
        <span class="k">if</span> <span class="n">tolerance</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tolerance</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tolerance</span>

        <span class="c1"># Make sure we have endog</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">endog</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Must bind a dataset to the model before&#39;</span>
                               <span class="s1">&#39; filtering or smoothing.&#39;</span><span class="p">)</span>

        <span class="c1"># Initialize the representation matrices</span>
        <span class="n">prefix</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">create_statespace</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_representation</span><span class="p">()</span>

        <span class="c1"># Determine if we need to (re-)create the filter</span>
        <span class="c1"># (definitely need to recreate if we recreated the _statespace object)</span>
        <span class="n">create_filter</span> <span class="o">=</span> <span class="n">create_statespace</span> <span class="ow">or</span> <span class="n">prefix</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kalman_filters</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">create_filter</span><span class="p">:</span>
            <span class="n">kalman_filter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kalman_filters</span><span class="p">[</span><span class="n">prefix</span><span class="p">]</span>

            <span class="n">create_filter</span> <span class="o">=</span> <span class="p">(</span>
                <span class="ow">not</span> <span class="n">kalman_filter</span><span class="o">.</span><span class="n">conserve_memory</span> <span class="o">==</span> <span class="n">conserve_memory</span> <span class="ow">or</span>
                <span class="ow">not</span> <span class="n">kalman_filter</span><span class="o">.</span><span class="n">loglikelihood_burn</span> <span class="o">==</span> <span class="n">loglikelihood_burn</span>
            <span class="p">)</span>

        <span class="c1"># If the dtype-specific _kalman_filter does not exist (or if we need</span>
        <span class="c1"># to re-create it), create it</span>
        <span class="k">if</span> <span class="n">create_filter</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">prefix</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kalman_filters</span><span class="p">:</span>
                <span class="c1"># Delete the old filter</span>
                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kalman_filters</span><span class="p">[</span><span class="n">prefix</span><span class="p">]</span>
            <span class="c1"># Setup the filter</span>
            <span class="bp">cls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prefix_kalman_filter_map</span><span class="p">[</span><span class="n">prefix</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_kalman_filters</span><span class="p">[</span><span class="n">prefix</span><span class="p">]</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_statespaces</span><span class="p">[</span><span class="n">prefix</span><span class="p">],</span> <span class="n">filter_method</span><span class="p">,</span> <span class="n">inversion_method</span><span class="p">,</span>
                <span class="n">stability_method</span><span class="p">,</span> <span class="n">conserve_memory</span><span class="p">,</span> <span class="n">filter_timing</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">,</span>
                <span class="n">loglikelihood_burn</span>
            <span class="p">)</span>
        <span class="c1"># Otherwise, update the filter parameters</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">kalman_filter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kalman_filters</span><span class="p">[</span><span class="n">prefix</span><span class="p">]</span>
            <span class="n">kalman_filter</span><span class="o">.</span><span class="n">set_filter_method</span><span class="p">(</span><span class="n">filter_method</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
            <span class="n">kalman_filter</span><span class="o">.</span><span class="n">inversion_method</span> <span class="o">=</span> <span class="n">inversion_method</span>
            <span class="n">kalman_filter</span><span class="o">.</span><span class="n">stability_method</span> <span class="o">=</span> <span class="n">stability_method</span>
            <span class="n">kalman_filter</span><span class="o">.</span><span class="n">filter_timing</span> <span class="o">=</span> <span class="n">filter_timing</span>
            <span class="n">kalman_filter</span><span class="o">.</span><span class="n">tolerance</span> <span class="o">=</span> <span class="n">tolerance</span>
            <span class="c1"># conserve_memory and loglikelihood_burn changes always lead to</span>
            <span class="c1"># re-created filters</span>

        <span class="k">return</span> <span class="n">prefix</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">create_filter</span><span class="p">,</span> <span class="n">create_statespace</span>

<div class="viewcode-block" id="KalmanFilter.set_filter_method">
<a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.kalman_filter.KalmanFilter.set_filter_method.html#statsmodels.tsa.statespace.kalman_filter.KalmanFilter.set_filter_method">[docs]</a>
    <span class="k">def</span> <span class="nf">set_filter_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filter_method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the filtering method</span>

<span class="sd">        The filtering method controls aspects of which Kalman filtering</span>
<span class="sd">        approach will be used.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filter_method : int, optional</span>
<span class="sd">            Bitmask value to set the filter method to. See notes for details.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Keyword arguments may be used to influence the filter method by</span>
<span class="sd">            setting individual boolean flags. See notes for details.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The filtering method is defined by a collection of boolean flags, and</span>
<span class="sd">        is internally stored as a bitmask. The methods available are:</span>

<span class="sd">        FILTER_CONVENTIONAL</span>
<span class="sd">            Conventional Kalman filter.</span>
<span class="sd">        FILTER_UNIVARIATE</span>
<span class="sd">            Univariate approach to Kalman filtering. Overrides conventional</span>
<span class="sd">            method if both are specified.</span>
<span class="sd">        FILTER_COLLAPSED</span>
<span class="sd">            Collapsed approach to Kalman filtering. Will be used *in addition*</span>
<span class="sd">            to conventional or univariate filtering.</span>
<span class="sd">        FILTER_CONCENTRATED</span>
<span class="sd">            Use the concentrated log-likelihood function. Will be used</span>
<span class="sd">            *in addition* to the other options.</span>

<span class="sd">        Note that only the first method is available if using a Scipy version</span>
<span class="sd">        older than 0.16.</span>

<span class="sd">        If the bitmask is set directly via the `filter_method` argument, then</span>
<span class="sd">        the full method must be provided.</span>

<span class="sd">        If keyword arguments are used to set individual boolean flags, then</span>
<span class="sd">        the lowercase of the method must be used as an argument name, and the</span>
<span class="sd">        value is the desired value of the boolean flag (True or False).</span>

<span class="sd">        Note that the filter method may also be specified by directly modifying</span>
<span class="sd">        the class attributes which are defined similarly to the keyword</span>
<span class="sd">        arguments.</span>

<span class="sd">        The default filtering method is FILTER_CONVENTIONAL.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; mod = sm.tsa.statespace.SARIMAX(range(10))</span>
<span class="sd">        &gt;&gt;&gt; mod.ssm.filter_method</span>
<span class="sd">        1</span>
<span class="sd">        &gt;&gt;&gt; mod.ssm.filter_conventional</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; mod.ssm.filter_univariate = True</span>
<span class="sd">        &gt;&gt;&gt; mod.ssm.filter_method</span>
<span class="sd">        17</span>
<span class="sd">        &gt;&gt;&gt; mod.ssm.set_filter_method(filter_univariate=False,</span>
<span class="sd">        ...                           filter_collapsed=True)</span>
<span class="sd">        &gt;&gt;&gt; mod.ssm.filter_method</span>
<span class="sd">        33</span>
<span class="sd">        &gt;&gt;&gt; mod.ssm.set_filter_method(filter_method=1)</span>
<span class="sd">        &gt;&gt;&gt; mod.ssm.filter_conventional</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; mod.ssm.filter_univariate</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; mod.ssm.filter_collapsed</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; mod.ssm.filter_univariate = True</span>
<span class="sd">        &gt;&gt;&gt; mod.ssm.filter_method</span>
<span class="sd">        17</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">filter_method</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">filter_method</span> <span class="o">=</span> <span class="n">filter_method</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">KalmanFilter</span><span class="o">.</span><span class="n">filter_methods</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">name</span><span class="p">])</span></div>


<div class="viewcode-block" id="KalmanFilter.set_inversion_method">
<a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.kalman_filter.KalmanFilter.set_inversion_method.html#statsmodels.tsa.statespace.kalman_filter.KalmanFilter.set_inversion_method">[docs]</a>
    <span class="k">def</span> <span class="nf">set_inversion_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inversion_method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the inversion method</span>

<span class="sd">        The Kalman filter may contain one matrix inversion: that of the</span>
<span class="sd">        forecast error covariance matrix. The inversion method controls how and</span>
<span class="sd">        if that inverse is performed.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        inversion_method : int, optional</span>
<span class="sd">            Bitmask value to set the inversion method to. See notes for</span>
<span class="sd">            details.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Keyword arguments may be used to influence the inversion method by</span>
<span class="sd">            setting individual boolean flags. See notes for details.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The inversion method is defined by a collection of boolean flags, and</span>
<span class="sd">        is internally stored as a bitmask. The methods available are:</span>

<span class="sd">        INVERT_UNIVARIATE</span>
<span class="sd">            If the endogenous time series is univariate, then inversion can be</span>
<span class="sd">            performed by simple division. If this flag is set and the time</span>
<span class="sd">            series is univariate, then division will always be used even if</span>
<span class="sd">            other flags are also set.</span>
<span class="sd">        SOLVE_LU</span>
<span class="sd">            Use an LU decomposition along with a linear solver (rather than</span>
<span class="sd">            ever actually inverting the matrix).</span>
<span class="sd">        INVERT_LU</span>
<span class="sd">            Use an LU decomposition along with typical matrix inversion.</span>
<span class="sd">        SOLVE_CHOLESKY</span>
<span class="sd">            Use a Cholesky decomposition along with a linear solver.</span>
<span class="sd">        INVERT_CHOLESKY</span>
<span class="sd">            Use an Cholesky decomposition along with typical matrix inversion.</span>

<span class="sd">        If the bitmask is set directly via the `inversion_method` argument,</span>
<span class="sd">        then the full method must be provided.</span>

<span class="sd">        If keyword arguments are used to set individual boolean flags, then</span>
<span class="sd">        the lowercase of the method must be used as an argument name, and the</span>
<span class="sd">        value is the desired value of the boolean flag (True or False).</span>

<span class="sd">        Note that the inversion method may also be specified by directly</span>
<span class="sd">        modifying the class attributes which are defined similarly to the</span>
<span class="sd">        keyword arguments.</span>

<span class="sd">        The default inversion method is `INVERT_UNIVARIATE | SOLVE_CHOLESKY`</span>

<span class="sd">        Several things to keep in mind are:</span>

<span class="sd">        - If the filtering method is specified to be univariate, then simple</span>
<span class="sd">          division is always used regardless of the dimension of the endogenous</span>
<span class="sd">          time series.</span>
<span class="sd">        - Cholesky decomposition is about twice as fast as LU decomposition,</span>
<span class="sd">          but it requires that the matrix be positive definite. While this</span>
<span class="sd">          should generally be true, it may not be in every case.</span>
<span class="sd">        - Using a linear solver rather than true matrix inversion is generally</span>
<span class="sd">          faster and is numerically more stable.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; mod = sm.tsa.statespace.SARIMAX(range(10))</span>
<span class="sd">        &gt;&gt;&gt; mod.ssm.inversion_method</span>
<span class="sd">        1</span>
<span class="sd">        &gt;&gt;&gt; mod.ssm.solve_cholesky</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; mod.ssm.invert_univariate</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; mod.ssm.invert_lu</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; mod.ssm.invert_univariate = False</span>
<span class="sd">        &gt;&gt;&gt; mod.ssm.inversion_method</span>
<span class="sd">        8</span>
<span class="sd">        &gt;&gt;&gt; mod.ssm.set_inversion_method(solve_cholesky=False,</span>
<span class="sd">        ...                              invert_cholesky=True)</span>
<span class="sd">        &gt;&gt;&gt; mod.ssm.inversion_method</span>
<span class="sd">        16</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">inversion_method</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">inversion_method</span> <span class="o">=</span> <span class="n">inversion_method</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">KalmanFilter</span><span class="o">.</span><span class="n">inversion_methods</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">name</span><span class="p">])</span></div>


<div class="viewcode-block" id="KalmanFilter.set_stability_method">
<a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.kalman_filter.KalmanFilter.set_stability_method.html#statsmodels.tsa.statespace.kalman_filter.KalmanFilter.set_stability_method">[docs]</a>
    <span class="k">def</span> <span class="nf">set_stability_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stability_method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the numerical stability method</span>

<span class="sd">        The Kalman filter is a recursive algorithm that may in some cases</span>
<span class="sd">        suffer issues with numerical stability. The stability method controls</span>
<span class="sd">        what, if any, measures are taken to promote stability.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        stability_method : int, optional</span>
<span class="sd">            Bitmask value to set the stability method to. See notes for</span>
<span class="sd">            details.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Keyword arguments may be used to influence the stability method by</span>
<span class="sd">            setting individual boolean flags. See notes for details.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The stability method is defined by a collection of boolean flags, and</span>
<span class="sd">        is internally stored as a bitmask. The methods available are:</span>

<span class="sd">        STABILITY_FORCE_SYMMETRY = 0x01</span>
<span class="sd">            If this flag is set, symmetry of the predicted state covariance</span>
<span class="sd">            matrix is enforced at each iteration of the filter, where each</span>
<span class="sd">            element is set to the average of the corresponding elements in the</span>
<span class="sd">            upper and lower triangle.</span>

<span class="sd">        If the bitmask is set directly via the `stability_method` argument,</span>
<span class="sd">        then the full method must be provided.</span>

<span class="sd">        If keyword arguments are used to set individual boolean flags, then</span>
<span class="sd">        the lowercase of the method must be used as an argument name, and the</span>
<span class="sd">        value is the desired value of the boolean flag (True or False).</span>

<span class="sd">        Note that the stability method may also be specified by directly</span>
<span class="sd">        modifying the class attributes which are defined similarly to the</span>
<span class="sd">        keyword arguments.</span>

<span class="sd">        The default stability method is `STABILITY_FORCE_SYMMETRY`</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; mod = sm.tsa.statespace.SARIMAX(range(10))</span>
<span class="sd">        &gt;&gt;&gt; mod.ssm.stability_method</span>
<span class="sd">        1</span>
<span class="sd">        &gt;&gt;&gt; mod.ssm.stability_force_symmetry</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; mod.ssm.stability_force_symmetry = False</span>
<span class="sd">        &gt;&gt;&gt; mod.ssm.stability_method</span>
<span class="sd">        0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">stability_method</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stability_method</span> <span class="o">=</span> <span class="n">stability_method</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">KalmanFilter</span><span class="o">.</span><span class="n">stability_methods</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">name</span><span class="p">])</span></div>


<div class="viewcode-block" id="KalmanFilter.set_conserve_memory">
<a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.kalman_filter.KalmanFilter.set_conserve_memory.html#statsmodels.tsa.statespace.kalman_filter.KalmanFilter.set_conserve_memory">[docs]</a>
    <span class="k">def</span> <span class="nf">set_conserve_memory</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">conserve_memory</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the memory conservation method</span>

<span class="sd">        By default, the Kalman filter computes a number of intermediate</span>
<span class="sd">        matrices at each iteration. The memory conservation options control</span>
<span class="sd">        which of those matrices are stored.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        conserve_memory : int, optional</span>
<span class="sd">            Bitmask value to set the memory conservation method to. See notes</span>
<span class="sd">            for details.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Keyword arguments may be used to influence the memory conservation</span>
<span class="sd">            method by setting individual boolean flags. See notes for details.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The memory conservation method is defined by a collection of boolean</span>
<span class="sd">        flags, and is internally stored as a bitmask. The methods available</span>
<span class="sd">        are:</span>

<span class="sd">        MEMORY_STORE_ALL</span>
<span class="sd">            Store all intermediate matrices. This is the default value.</span>
<span class="sd">        MEMORY_NO_FORECAST_MEAN</span>
<span class="sd">            Do not store the forecast or forecast errors. If this option is</span>
<span class="sd">            used, the `predict` method from the results class is unavailable.</span>
<span class="sd">        MEMORY_NO_FORECAST_COV</span>
<span class="sd">            Do not store the forecast error covariance matrices.</span>
<span class="sd">        MEMORY_NO_FORECAST</span>
<span class="sd">            Do not store the forecast, forecast error, or forecast error</span>
<span class="sd">            covariance matrices. If this option is used, the `predict` method</span>
<span class="sd">            from the results class is unavailable.</span>
<span class="sd">        MEMORY_NO_PREDICTED_MEAN</span>
<span class="sd">            Do not store the predicted state.</span>
<span class="sd">        MEMORY_NO_PREDICTED_COV</span>
<span class="sd">            Do not store the predicted state covariance</span>
<span class="sd">            matrices.</span>
<span class="sd">        MEMORY_NO_PREDICTED</span>
<span class="sd">            Do not store the predicted state or predicted state covariance</span>
<span class="sd">            matrices.</span>
<span class="sd">        MEMORY_NO_FILTERED_MEAN</span>
<span class="sd">            Do not store the filtered state.</span>
<span class="sd">        MEMORY_NO_FILTERED_COV</span>
<span class="sd">            Do not store the filtered state covariance</span>
<span class="sd">            matrices.</span>
<span class="sd">        MEMORY_NO_FILTERED</span>
<span class="sd">            Do not store the filtered state or filtered state covariance</span>
<span class="sd">            matrices.</span>
<span class="sd">        MEMORY_NO_LIKELIHOOD</span>
<span class="sd">            Do not store the vector of loglikelihood values for each</span>
<span class="sd">            observation. Only the sum of the loglikelihood values is stored.</span>
<span class="sd">        MEMORY_NO_GAIN</span>
<span class="sd">            Do not store the Kalman gain matrices.</span>
<span class="sd">        MEMORY_NO_SMOOTHING</span>
<span class="sd">            Do not store temporary variables related to Kalman smoothing. If</span>
<span class="sd">            this option is used, smoothing is unavailable.</span>
<span class="sd">        MEMORY_NO_STD_FORECAST</span>
<span class="sd">            Do not store standardized forecast errors.</span>
<span class="sd">        MEMORY_CONSERVE</span>
<span class="sd">            Do not store any intermediate matrices.</span>

<span class="sd">        If the bitmask is set directly via the `conserve_memory` argument,</span>
<span class="sd">        then the full method must be provided.</span>

<span class="sd">        If keyword arguments are used to set individual boolean flags, then</span>
<span class="sd">        the lowercase of the method must be used as an argument name, and the</span>
<span class="sd">        value is the desired value of the boolean flag (True or False).</span>

<span class="sd">        Note that the memory conservation method may also be specified by</span>
<span class="sd">        directly modifying the class attributes which are defined similarly to</span>
<span class="sd">        the keyword arguments.</span>

<span class="sd">        The default memory conservation method is `MEMORY_STORE_ALL`, so that</span>
<span class="sd">        all intermediate matrices are stored.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; mod = sm.tsa.statespace.SARIMAX(range(10))</span>
<span class="sd">        &gt;&gt;&gt; mod.ssm..conserve_memory</span>
<span class="sd">        0</span>
<span class="sd">        &gt;&gt;&gt; mod.ssm.memory_no_predicted</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; mod.ssm.memory_no_predicted = True</span>
<span class="sd">        &gt;&gt;&gt; mod.ssm.conserve_memory</span>
<span class="sd">        2</span>
<span class="sd">        &gt;&gt;&gt; mod.ssm.set_conserve_memory(memory_no_filtered=True,</span>
<span class="sd">        ...                             memory_no_forecast=True)</span>
<span class="sd">        &gt;&gt;&gt; mod.ssm.conserve_memory</span>
<span class="sd">        7</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">conserve_memory</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">conserve_memory</span> <span class="o">=</span> <span class="n">conserve_memory</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">KalmanFilter</span><span class="o">.</span><span class="n">memory_options</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">name</span><span class="p">])</span></div>


<div class="viewcode-block" id="KalmanFilter.set_filter_timing">
<a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.kalman_filter.KalmanFilter.set_filter_timing.html#statsmodels.tsa.statespace.kalman_filter.KalmanFilter.set_filter_timing">[docs]</a>
    <span class="k">def</span> <span class="nf">set_filter_timing</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alternate_timing</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the filter timing convention</span>

<span class="sd">        By default, the Kalman filter follows Durbin and Koopman, 2012, in</span>
<span class="sd">        initializing the filter with predicted values. Kim and Nelson, 1999,</span>
<span class="sd">        instead initialize the filter with filtered values, which is</span>
<span class="sd">        essentially just a different timing convention.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        alternate_timing : int, optional</span>
<span class="sd">            Whether or not to use the alternate timing convention. Default is</span>
<span class="sd">            unspecified.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Keyword arguments may be used to influence the memory conservation</span>
<span class="sd">            method by setting individual boolean flags. See notes for details.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">alternate_timing</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">filter_timing</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">alternate_timing</span><span class="p">)</span>
        <span class="k">if</span> <span class="s1">&#39;timing_init_predicted&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">filter_timing</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="ow">not</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;timing_init_predicted&#39;</span><span class="p">])</span>
        <span class="k">if</span> <span class="s1">&#39;timing_init_filtered&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">filter_timing</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;timing_init_filtered&#39;</span><span class="p">])</span></div>


<div class="viewcode-block" id="KalmanFilter.fixed_scale">
<a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.kalman_filter.KalmanFilter.fixed_scale.html#statsmodels.tsa.statespace.kalman_filter.KalmanFilter.fixed_scale">[docs]</a>
    <span class="nd">@contextlib</span><span class="o">.</span><span class="n">contextmanager</span>
    <span class="k">def</span> <span class="nf">fixed_scale</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scale</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        fixed_scale(scale)</span>

<span class="sd">        Context manager for fixing the scale when FILTER_CONCENTRATED is set</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        scale : numeric</span>
<span class="sd">            Scale of the model.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This a no-op if scale is None.</span>

<span class="sd">        This context manager is most useful in models which are explicitly</span>
<span class="sd">        concentrating out the scale, so that the set of parameters they are</span>
<span class="sd">        estimating does not include the scale.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If a scale was provided, use it and do not concentrate it out of the</span>
        <span class="c1"># loglikelihood</span>
        <span class="k">if</span> <span class="n">scale</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">scale</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_concentrated</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Cannot provide scale if filter method does&#39;</span>
                                 <span class="s1">&#39; not include FILTER_CONCENTRATED.&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">filter_concentrated</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_scale</span> <span class="o">=</span> <span class="n">scale</span>
            <span class="n">obs_cov</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;obs_cov&#39;</span><span class="p">]</span>
            <span class="n">state_cov</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;state_cov&#39;</span><span class="p">]</span>
            <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;obs_cov&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">scale</span> <span class="o">*</span> <span class="n">obs_cov</span>
            <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;state_cov&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">scale</span> <span class="o">*</span> <span class="n">state_cov</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">yield</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="c1"># If a scale was provided, reset the model</span>
            <span class="k">if</span> <span class="n">scale</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">scale</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;state_cov&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">state_cov</span>
                <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;obs_cov&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">obs_cov</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">filter_concentrated</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_scale</span> <span class="o">=</span> <span class="kc">None</span></div>


    <span class="k">def</span> <span class="nf">_filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filter_method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">inversion_method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">stability_method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">conserve_memory</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">filter_timing</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">loglikelihood_burn</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">complex_step</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="c1"># Initialize the filter</span>
        <span class="n">prefix</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">create_filter</span><span class="p">,</span> <span class="n">create_statespace</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_filter</span><span class="p">(</span>
                <span class="n">filter_method</span><span class="p">,</span> <span class="n">inversion_method</span><span class="p">,</span> <span class="n">stability_method</span><span class="p">,</span>
                <span class="n">conserve_memory</span><span class="p">,</span> <span class="n">filter_timing</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">,</span> <span class="n">loglikelihood_burn</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="n">kfilter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kalman_filters</span><span class="p">[</span><span class="n">prefix</span><span class="p">]</span>

        <span class="c1"># Initialize the state</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_state</span><span class="p">(</span><span class="n">prefix</span><span class="o">=</span><span class="n">prefix</span><span class="p">,</span> <span class="n">complex_step</span><span class="o">=</span><span class="n">complex_step</span><span class="p">)</span>

        <span class="c1"># Run the filter</span>
        <span class="n">kfilter</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">kfilter</span>

<div class="viewcode-block" id="KalmanFilter.filter">
<a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.kalman_filter.KalmanFilter.filter.html#statsmodels.tsa.statespace.kalman_filter.KalmanFilter.filter">[docs]</a>
    <span class="k">def</span> <span class="nf">filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filter_method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">inversion_method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="n">stability_method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">conserve_memory</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">filter_timing</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="n">tolerance</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">loglikelihood_burn</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">complex_step</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply the Kalman filter to the statespace model.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filter_method : int, optional</span>
<span class="sd">            Determines which Kalman filter to use. Default is conventional.</span>
<span class="sd">        inversion_method : int, optional</span>
<span class="sd">            Determines which inversion technique to use. Default is by Cholesky</span>
<span class="sd">            decomposition.</span>
<span class="sd">        stability_method : int, optional</span>
<span class="sd">            Determines which numerical stability techniques to use. Default is</span>
<span class="sd">            to enforce symmetry of the predicted state covariance matrix.</span>
<span class="sd">        conserve_memory : int, optional</span>
<span class="sd">            Determines what output from the filter to store. Default is to</span>
<span class="sd">            store everything.</span>
<span class="sd">        filter_timing : int, optional</span>
<span class="sd">            Determines the timing convention of the filter. Default is that</span>
<span class="sd">            from Durbin and Koopman (2012), in which the filter is initialized</span>
<span class="sd">            with predicted values.</span>
<span class="sd">        tolerance : float, optional</span>
<span class="sd">            The tolerance at which the Kalman filter determines convergence to</span>
<span class="sd">            steady-state. Default is 1e-19.</span>
<span class="sd">        loglikelihood_burn : int, optional</span>
<span class="sd">            The number of initial periods during which the loglikelihood is not</span>
<span class="sd">            recorded. Default is 0.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This function by default does not compute variables required for</span>
<span class="sd">        smoothing.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Handle memory conservation</span>
        <span class="k">if</span> <span class="n">conserve_memory</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">conserve_memory</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">conserve_memory</span> <span class="o">|</span> <span class="n">MEMORY_NO_SMOOTHING</span>
        <span class="n">conserve_memory_cache</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">conserve_memory</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_conserve_memory</span><span class="p">(</span><span class="n">conserve_memory</span><span class="p">)</span>

        <span class="c1"># Run the filter</span>
        <span class="n">kfilter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filter</span><span class="p">(</span>
            <span class="n">filter_method</span><span class="p">,</span> <span class="n">inversion_method</span><span class="p">,</span> <span class="n">stability_method</span><span class="p">,</span> <span class="n">conserve_memory</span><span class="p">,</span>
            <span class="n">filter_timing</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">,</span> <span class="n">loglikelihood_burn</span><span class="p">,</span> <span class="n">complex_step</span><span class="p">)</span>

        <span class="c1"># Create the results object</span>
        <span class="n">results</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">results_class</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">results</span><span class="o">.</span><span class="n">update_representation</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">results</span><span class="o">.</span><span class="n">update_filter</span><span class="p">(</span><span class="n">kfilter</span><span class="p">)</span>

        <span class="c1"># Resent memory conservation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_conserve_memory</span><span class="p">(</span><span class="n">conserve_memory_cache</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">results</span></div>


<div class="viewcode-block" id="KalmanFilter.loglike">
<a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.kalman_filter.KalmanFilter.loglike.html#statsmodels.tsa.statespace.kalman_filter.KalmanFilter.loglike">[docs]</a>
    <span class="k">def</span> <span class="nf">loglike</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the loglikelihood associated with the statespace model.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Additional keyword arguments to pass to the Kalman filter. See</span>
<span class="sd">            `KalmanFilter.filter` for more details.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        loglike : float</span>
<span class="sd">            The joint loglikelihood.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;conserve_memory&#39;</span><span class="p">,</span>
                          <span class="n">MEMORY_CONSERVE</span> <span class="o">^</span> <span class="n">MEMORY_NO_LIKELIHOOD</span><span class="p">)</span>
        <span class="n">kfilter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filter</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">loglikelihood_burn</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;loglikelihood_burn&#39;</span><span class="p">,</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">loglikelihood_burn</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;conserve_memory&#39;</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">MEMORY_NO_LIKELIHOOD</span><span class="p">):</span>
            <span class="n">loglike</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">kfilter</span><span class="o">.</span><span class="n">loglikelihood</span><span class="p">[</span><span class="n">loglikelihood_burn</span><span class="p">:])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">loglike</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">kfilter</span><span class="o">.</span><span class="n">loglikelihood</span><span class="p">)</span>

        <span class="c1"># Need to modify the computed log-likelihood to incorporate the</span>
        <span class="c1"># MLE scale.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_method</span> <span class="o">&amp;</span> <span class="n">FILTER_CONCENTRATED</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">loglikelihood_burn</span><span class="p">,</span> <span class="n">kfilter</span><span class="o">.</span><span class="n">nobs_diffuse</span><span class="p">)</span>
            <span class="n">nobs_k_endog</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span> <span class="o">-</span>
                <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_statespace</span><span class="o">.</span><span class="n">nmissing</span><span class="p">)[</span><span class="n">d</span><span class="p">:])</span>

            <span class="c1"># In the univariate case, we need to subtract observations</span>
            <span class="c1"># associated with a singular forecast error covariance matrix</span>
            <span class="n">nobs_k_endog</span> <span class="o">-=</span> <span class="n">kfilter</span><span class="o">.</span><span class="n">nobs_kendog_univariate_singular</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;conserve_memory&#39;</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">MEMORY_NO_LIKELIHOOD</span><span class="p">):</span>
                <span class="n">scale</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">kfilter</span><span class="o">.</span><span class="n">scale</span><span class="p">[</span><span class="n">d</span><span class="p">:])</span> <span class="o">/</span> <span class="n">nobs_k_endog</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">scale</span> <span class="o">=</span> <span class="n">kfilter</span><span class="o">.</span><span class="n">scale</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">nobs_k_endog</span>

            <span class="n">loglike</span> <span class="o">+=</span> <span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">nobs_k_endog</span>

            <span class="c1"># Now need to modify this for diffuse initialization, since for</span>
            <span class="c1"># diffuse periods we only need to add in the scale value part if</span>
            <span class="c1"># the diffuse forecast error covariance matrix element was singular</span>
            <span class="k">if</span> <span class="n">kfilter</span><span class="o">.</span><span class="n">nobs_diffuse</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">nobs_k_endog</span> <span class="o">-=</span> <span class="n">kfilter</span><span class="o">.</span><span class="n">nobs_kendog_diffuse_nonsingular</span>

            <span class="n">loglike</span> <span class="o">+=</span> <span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">nobs_k_endog</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">scale</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">loglike</span></div>


<div class="viewcode-block" id="KalmanFilter.loglikeobs">
<a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.kalman_filter.KalmanFilter.loglikeobs.html#statsmodels.tsa.statespace.kalman_filter.KalmanFilter.loglikeobs">[docs]</a>
    <span class="k">def</span> <span class="nf">loglikeobs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the loglikelihood for each observation associated with the</span>
<span class="sd">        statespace model.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Additional keyword arguments to pass to the Kalman filter. See</span>
<span class="sd">            `KalmanFilter.filter` for more details.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        If `loglikelihood_burn` is positive, then the entries in the returned</span>
<span class="sd">        loglikelihood vector are set to be zero for those initial time periods.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        loglike : array of float</span>
<span class="sd">            Array of loglikelihood values for each observation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">memory_no_likelihood</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Cannot compute loglikelihood if&#39;</span>
                               <span class="s1">&#39; MEMORY_NO_LIKELIHOOD option is selected.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_method</span> <span class="o">&amp;</span> <span class="n">FILTER_CONCENTRATED</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;conserve_memory&#39;</span><span class="p">,</span>
                              <span class="n">MEMORY_CONSERVE</span> <span class="o">^</span> <span class="n">MEMORY_NO_LIKELIHOOD</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span>
                <span class="s1">&#39;conserve_memory&#39;</span><span class="p">,</span>
                <span class="n">MEMORY_CONSERVE</span> <span class="o">^</span> <span class="p">(</span><span class="n">MEMORY_NO_FORECAST</span> <span class="o">|</span> <span class="n">MEMORY_NO_LIKELIHOOD</span><span class="p">))</span>
        <span class="n">kfilter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filter</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">llf_obs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">kfilter</span><span class="o">.</span><span class="n">loglikelihood</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">loglikelihood_burn</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;loglikelihood_burn&#39;</span><span class="p">,</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">loglikelihood_burn</span><span class="p">)</span>

        <span class="c1"># If the scale was concentrated out of the log-likelihood function,</span>
        <span class="c1"># then the llf_obs above is:</span>
        <span class="c1"># -0.5 * k_endog * log 2 * pi - 0.5 * log |F_t|</span>
        <span class="c1"># and we need to add in the effect of the scale:</span>
        <span class="c1"># -0.5 * k_endog * log scale - 0.5 v&#39; F_t^{-1} v / scale</span>
        <span class="c1"># and note that v&#39; F_t^{-1} is in the _kalman_filter.scale array</span>
        <span class="c1"># Also note that we need to adjust the nobs and k_endog in both the</span>
        <span class="c1"># denominator of the scale computation and in the llf_obs adjustment</span>
        <span class="c1"># to take into account missing values.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_method</span> <span class="o">&amp;</span> <span class="n">FILTER_CONCENTRATED</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">loglikelihood_burn</span><span class="p">,</span> <span class="n">kfilter</span><span class="o">.</span><span class="n">nobs_diffuse</span><span class="p">)</span>
            <span class="n">nmissing</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_statespace</span><span class="o">.</span><span class="n">nmissing</span><span class="p">)</span>
            <span class="n">nobs_k_endog</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span> <span class="o">-</span> <span class="n">nmissing</span><span class="p">[</span><span class="n">d</span><span class="p">:])</span>

            <span class="c1"># In the univariate case, we need to subtract observations</span>
            <span class="c1"># associated with a singular forecast error covariance matrix</span>
            <span class="n">nobs_k_endog</span> <span class="o">-=</span> <span class="n">kfilter</span><span class="o">.</span><span class="n">nobs_kendog_univariate_singular</span>

            <span class="n">scale</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">kfilter</span><span class="o">.</span><span class="n">scale</span><span class="p">[</span><span class="n">d</span><span class="p">:])</span> <span class="o">/</span> <span class="n">nobs_k_endog</span>

            <span class="c1"># Need to modify this for diffuse initialization, since for</span>
            <span class="c1"># diffuse periods we only need to add in the scale value if the</span>
            <span class="c1"># diffuse forecast error covariance matrix element was singular</span>
            <span class="n">nsingular</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="n">kfilter</span><span class="o">.</span><span class="n">nobs_diffuse</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">kfilter</span><span class="o">.</span><span class="n">nobs_diffuse</span>
                <span class="n">Finf</span> <span class="o">=</span> <span class="n">kfilter</span><span class="o">.</span><span class="n">forecast_error_diffuse_cov</span>
                <span class="n">singular</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diagonal</span><span class="p">(</span><span class="n">Finf</span><span class="p">)</span><span class="o">.</span><span class="n">real</span> <span class="o">&lt;=</span> <span class="n">kfilter</span><span class="o">.</span><span class="n">tolerance_diffuse</span>
                <span class="n">nsingular</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">~</span><span class="n">singular</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

            <span class="n">scale_obs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">kfilter</span><span class="o">.</span><span class="n">scale</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">llf_obs</span> <span class="o">+=</span> <span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span>
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span> <span class="o">-</span> <span class="n">nmissing</span> <span class="o">-</span> <span class="n">nsingular</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">scale</span><span class="p">)</span> <span class="o">+</span>
                <span class="n">scale_obs</span> <span class="o">/</span> <span class="n">scale</span><span class="p">)</span>

        <span class="c1"># Set any burned observations to have zero likelihood</span>
        <span class="n">llf_obs</span><span class="p">[:</span><span class="n">loglikelihood_burn</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">return</span> <span class="n">llf_obs</span></div>


<div class="viewcode-block" id="KalmanFilter.simulate">
<a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.kalman_filter.KalmanFilter.simulate.html#statsmodels.tsa.statespace.kalman_filter.KalmanFilter.simulate">[docs]</a>
    <span class="k">def</span> <span class="nf">simulate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nsimulations</span><span class="p">,</span> <span class="n">measurement_shocks</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">state_shocks</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">initial_state</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">pretransformed_measurement_shocks</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">pretransformed_state_shocks</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">pretransformed_initial_state</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">simulator</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">return_simulator</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Simulate a new time series following the state space model</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nsimulations : int</span>
<span class="sd">            The number of observations to simulate. If the model is</span>
<span class="sd">            time-invariant this can be any number. If the model is</span>
<span class="sd">            time-varying, then this number must be less than or equal to the</span>
<span class="sd">            number</span>
<span class="sd">        measurement_shocks : array_like, optional</span>
<span class="sd">            If specified, these are the shocks to the measurement equation,</span>
<span class="sd">            :math:`\varepsilon_t`. If unspecified, these are automatically</span>
<span class="sd">            generated using a pseudo-random number generator. If specified,</span>
<span class="sd">            must be shaped `nsimulations` x `k_endog`, where `k_endog` is the</span>
<span class="sd">            same as in the state space model.</span>
<span class="sd">        state_shocks : array_like, optional</span>
<span class="sd">            If specified, these are the shocks to the state equation,</span>
<span class="sd">            :math:`\eta_t`. If unspecified, these are automatically</span>
<span class="sd">            generated using a pseudo-random number generator. If specified,</span>
<span class="sd">            must be shaped `nsimulations` x `k_posdef` where `k_posdef` is the</span>
<span class="sd">            same as in the state space model.</span>
<span class="sd">        initial_state : array_like, optional</span>
<span class="sd">            If specified, this is the state vector at time zero, which should</span>
<span class="sd">            be shaped (`k_states` x 1), where `k_states` is the same as in the</span>
<span class="sd">            state space model. If unspecified, but the model has been</span>
<span class="sd">            initialized, then that initialization is used. If unspecified and</span>
<span class="sd">            the model has not been initialized, then a vector of zeros is used.</span>
<span class="sd">            Note that this is not included in the returned `simulated_states`</span>
<span class="sd">            array.</span>
<span class="sd">        pretransformed_measurement_shocks : bool, optional</span>
<span class="sd">            If `measurement_shocks` is provided, this flag indicates whether it</span>
<span class="sd">            should be directly used as the shocks. If False, then it is assumed</span>
<span class="sd">            to contain draws from the standard Normal distribution that must be</span>
<span class="sd">            transformed using the `obs_cov` covariance matrix. Default is True.</span>
<span class="sd">        pretransformed_state_shocks : bool, optional</span>
<span class="sd">            If `state_shocks` is provided, this flag indicates whether it</span>
<span class="sd">            should be directly used as the shocks. If False, then it is assumed</span>
<span class="sd">            to contain draws from the standard Normal distribution that must be</span>
<span class="sd">            transformed using the `state_cov` covariance matrix. Default is</span>
<span class="sd">            True.</span>
<span class="sd">        pretransformed_initial_state : bool, optional</span>
<span class="sd">            If `initial_state` is provided, this flag indicates whether it</span>
<span class="sd">            should be directly used as the initial_state. If False, then it is</span>
<span class="sd">            assumed to contain draws from the standard Normal distribution that</span>
<span class="sd">            must be transformed using the `initial_state_cov` covariance</span>
<span class="sd">            matrix. Default is True.</span>
<span class="sd">        return_simulator : bool, optional</span>
<span class="sd">            Whether or not to return the simulator object. Typically used to</span>
<span class="sd">            improve performance when performing repeated sampling. Default is</span>
<span class="sd">            False.</span>
<span class="sd">        random_state : {None, int, Generator, RandomState}, optionall</span>
<span class="sd">            If `seed` is None (or `np.random`), the `numpy.random.RandomState`</span>
<span class="sd">            singleton is used.</span>
<span class="sd">            If `seed` is an int, a new ``RandomState`` instance is used,</span>
<span class="sd">            seeded with `seed`.</span>
<span class="sd">            If `seed` is already a ``Generator`` or ``RandomState`` instance</span>
<span class="sd">            then that instance is used.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        simulated_obs : ndarray</span>
<span class="sd">            An (nsimulations x k_endog) array of simulated observations.</span>
<span class="sd">        simulated_states : ndarray</span>
<span class="sd">            An (nsimulations x k_states) array of simulated states.</span>
<span class="sd">        simulator : SimulationSmoothResults</span>
<span class="sd">            If `return_simulator=True`, then an instance of a simulator is</span>
<span class="sd">            returned, which can be reused for additional simulations of the</span>
<span class="sd">            same size.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">time_invariant</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_invariant</span>
        <span class="c1"># Check for valid number of simulations</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">time_invariant</span> <span class="ow">and</span> <span class="n">nsimulations</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;In a time-varying model, cannot create more&#39;</span>
                             <span class="s1">&#39; simulations than there are observations.&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_simulate</span><span class="p">(</span>
            <span class="n">nsimulations</span><span class="p">,</span>
            <span class="n">measurement_disturbance_variates</span><span class="o">=</span><span class="n">measurement_shocks</span><span class="p">,</span>
            <span class="n">state_disturbance_variates</span><span class="o">=</span><span class="n">state_shocks</span><span class="p">,</span>
            <span class="n">initial_state_variates</span><span class="o">=</span><span class="n">initial_state</span><span class="p">,</span>
            <span class="n">pretransformed_measurement_disturbance_variates</span><span class="o">=</span><span class="p">(</span>
                <span class="n">pretransformed_measurement_shocks</span><span class="p">),</span>
            <span class="n">pretransformed_state_disturbance_variates</span><span class="o">=</span><span class="p">(</span>
                <span class="n">pretransformed_state_shocks</span><span class="p">),</span>
            <span class="n">pretransformed_initial_state_variates</span><span class="o">=</span><span class="p">(</span>
                <span class="n">pretransformed_initial_state</span><span class="p">),</span>
            <span class="n">simulator</span><span class="o">=</span><span class="n">simulator</span><span class="p">,</span> <span class="n">return_simulator</span><span class="o">=</span><span class="n">return_simulator</span><span class="p">,</span>
            <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">_simulate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nsimulations</span><span class="p">,</span> <span class="n">simulator</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                  <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Simulation only available through&#39;</span>
                                  <span class="s1">&#39; the simulation smoother.&#39;</span><span class="p">)</span>

<div class="viewcode-block" id="KalmanFilter.impulse_responses">
<a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.kalman_filter.KalmanFilter.impulse_responses.html#statsmodels.tsa.statespace.kalman_filter.KalmanFilter.impulse_responses">[docs]</a>
    <span class="k">def</span> <span class="nf">impulse_responses</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">steps</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">impulse</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">orthogonalized</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                          <span class="n">cumulative</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">direct</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Impulse response function</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        steps : int, optional</span>
<span class="sd">            The number of steps for which impulse responses are calculated.</span>
<span class="sd">            Default is 10. Note that the initial impulse is not counted as a</span>
<span class="sd">            step, so if `steps=1`, the output will have 2 entries.</span>
<span class="sd">        impulse : int or array_like</span>
<span class="sd">            If an integer, the state innovation to pulse; must be between 0</span>
<span class="sd">            and `k_posdef-1` where `k_posdef` is the same as in the state</span>
<span class="sd">            space model. Alternatively, a custom impulse vector may be</span>
<span class="sd">            provided; must be a column vector with shape `(k_posdef, 1)`.</span>
<span class="sd">        orthogonalized : bool, optional</span>
<span class="sd">            Whether or not to perform impulse using orthogonalized innovations.</span>
<span class="sd">            Note that this will also affect custum `impulse` vectors. Default</span>
<span class="sd">            is False.</span>
<span class="sd">        cumulative : bool, optional</span>
<span class="sd">            Whether or not to return cumulative impulse responses. Default is</span>
<span class="sd">            False.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        impulse_responses : ndarray</span>
<span class="sd">            Responses for each endogenous variable due to the impulse</span>
<span class="sd">            given by the `impulse` argument. A (steps + 1 x k_endog) array.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Intercepts in the measurement and state equation are ignored when</span>
<span class="sd">        calculating impulse responses.</span>

<span class="sd">        TODO: add note about how for time-varying systems this is - perhaps</span>
<span class="sd">        counter-intuitively - returning the impulse response within the given</span>
<span class="sd">        model (i.e. starting at period 0 defined by the model) and it is *not*</span>
<span class="sd">        doing impulse responses after the end of the model. To compute impulse</span>
<span class="sd">        responses from arbitrary time points, it is necessary to clone a new</span>
<span class="sd">        model with the appropriate system matrices.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># We need to add an additional step, since the first simulated value</span>
        <span class="c1"># will always be zeros (note that we take this value out at the end).</span>
        <span class="n">steps</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># For time-invariant models, add an additional `step`. This is the</span>
        <span class="c1"># default for time-invariant models based on the expected behavior for</span>
        <span class="c1"># ARIMA and VAR models: we want to record the initial impulse and also</span>
        <span class="c1"># `steps` values of the responses afterwards.</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_design</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transition</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_selection</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">steps</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># Check for what kind of impulse we want</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">impulse</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">impulse</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_posdef</span> <span class="ow">or</span> <span class="n">impulse</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid value for `impulse`. Must be the&#39;</span>
                                 <span class="s1">&#39; index of one of the state innovations.&#39;</span><span class="p">)</span>

            <span class="c1"># Create the (non-orthogonalized) impulse vector</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">impulse</span>
            <span class="n">impulse</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_posdef</span><span class="p">)</span>
            <span class="n">impulse</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">impulse</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">impulse</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">impulse</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">impulse</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">impulse</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">impulse</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_posdef</span><span class="p">,):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid impulse vector. Must be shaped&#39;</span>
                                 <span class="s1">&#39; (</span><span class="si">%d</span><span class="s1">,)&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_posdef</span><span class="p">)</span>

        <span class="c1"># Orthogonalize the impulses, if requested, using Cholesky on the</span>
        <span class="c1"># first state covariance matrix</span>
        <span class="k">if</span> <span class="n">orthogonalized</span><span class="p">:</span>
            <span class="n">state_chol</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">cholesky</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state_cov</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">])</span>
            <span class="n">impulse</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">state_chol</span><span class="p">,</span> <span class="n">impulse</span><span class="p">)</span>

        <span class="c1"># If we have time-varying design, transition, or selection matrices,</span>
        <span class="c1"># then we can&#39;t produce more IRFs than we have time points</span>
        <span class="n">time_invariant_irf</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_design</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transition</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_selection</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Note: to generate impulse responses following the end of a</span>
        <span class="c1"># time-varying model, one should `clone` the state space model with the</span>
        <span class="c1"># new time-varying model, and then compute the IRFs using the cloned</span>
        <span class="c1"># model</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">time_invariant_irf</span> <span class="ow">and</span> <span class="n">steps</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;In a time-varying model, cannot create more&#39;</span>
                             <span class="s1">&#39; impulse responses than there are&#39;</span>
                             <span class="s1">&#39; observations&#39;</span><span class="p">)</span>

        <span class="c1"># Impulse responses only depend on the design, transition, and</span>
        <span class="c1"># selection matrices. We set the others to zeros because they must be</span>
        <span class="c1"># set in the call to `clone`.</span>
        <span class="c1"># Note: we don&#39;t even need selection after the first point, because</span>
        <span class="c1"># the state shocks will be zeros in every period except the first.</span>
        <span class="n">sim_model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span>
            <span class="n">endog</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">steps</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">),</span>
            <span class="n">obs_intercept</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">),</span>
            <span class="n">design</span><span class="o">=</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;design&#39;</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="p">:</span><span class="n">steps</span><span class="p">],</span>
            <span class="n">obs_cov</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">)),</span>
            <span class="n">state_intercept</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_states</span><span class="p">),</span>
            <span class="n">transition</span><span class="o">=</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;transition&#39;</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="p">:</span><span class="n">steps</span><span class="p">],</span>
            <span class="n">selection</span><span class="o">=</span><span class="bp">self</span><span class="p">[</span><span class="s1">&#39;selection&#39;</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="p">:</span><span class="n">steps</span><span class="p">],</span>
            <span class="n">state_cov</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">k_posdef</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_posdef</span><span class="p">)))</span>

        <span class="c1"># Get the impulse response function via simulation of the state</span>
        <span class="c1"># space model, but with other shocks set to zero</span>
        <span class="n">measurement_shocks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">steps</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">))</span>
        <span class="n">state_shocks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">steps</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_posdef</span><span class="p">))</span>
        <span class="n">state_shocks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">impulse</span>
        <span class="n">initial_state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">k_states</span><span class="p">,))</span>
        <span class="n">irf</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">sim_model</span><span class="o">.</span><span class="n">simulate</span><span class="p">(</span>
            <span class="n">steps</span><span class="p">,</span> <span class="n">measurement_shocks</span><span class="o">=</span><span class="n">measurement_shocks</span><span class="p">,</span>
            <span class="n">state_shocks</span><span class="o">=</span><span class="n">state_shocks</span><span class="p">,</span> <span class="n">initial_state</span><span class="o">=</span><span class="n">initial_state</span><span class="p">)</span>

        <span class="c1"># Get the cumulative response if requested</span>
        <span class="k">if</span> <span class="n">cumulative</span><span class="p">:</span>
            <span class="n">irf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">irf</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Here we ignore the first value, because it is always zeros (we added</span>
        <span class="c1"># an additional `step` at the top to account for this).</span>
        <span class="k">return</span> <span class="n">irf</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span></div>
</div>



<div class="viewcode-block" id="FilterResults">
<a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.kalman_filter.FilterResults.html#statsmodels.tsa.statespace.kalman_filter.FilterResults">[docs]</a>
<span class="k">class</span> <span class="nc">FilterResults</span><span class="p">(</span><span class="n">FrozenRepresentation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Results from applying the Kalman filter to a state space model.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    model : Representation</span>
<span class="sd">        A Statespace representation</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    nobs : int</span>
<span class="sd">        Number of observations.</span>
<span class="sd">    nobs_diffuse : int</span>
<span class="sd">        Number of observations under the diffuse Kalman filter.</span>
<span class="sd">    k_endog : int</span>
<span class="sd">        The dimension of the observation series.</span>
<span class="sd">    k_states : int</span>
<span class="sd">        The dimension of the unobserved state process.</span>
<span class="sd">    k_posdef : int</span>
<span class="sd">        The dimension of a guaranteed positive definite</span>
<span class="sd">        covariance matrix describing the shocks in the</span>
<span class="sd">        measurement equation.</span>
<span class="sd">    dtype : dtype</span>
<span class="sd">        Datatype of representation matrices</span>
<span class="sd">    prefix : str</span>
<span class="sd">        BLAS prefix of representation matrices</span>
<span class="sd">    shapes : dictionary of name,tuple</span>
<span class="sd">        A dictionary recording the shapes of each of the</span>
<span class="sd">        representation matrices as tuples.</span>
<span class="sd">    endog : ndarray</span>
<span class="sd">        The observation vector.</span>
<span class="sd">    design : ndarray</span>
<span class="sd">        The design matrix, :math:`Z`.</span>
<span class="sd">    obs_intercept : ndarray</span>
<span class="sd">        The intercept for the observation equation, :math:`d`.</span>
<span class="sd">    obs_cov : ndarray</span>
<span class="sd">        The covariance matrix for the observation equation :math:`H`.</span>
<span class="sd">    transition : ndarray</span>
<span class="sd">        The transition matrix, :math:`T`.</span>
<span class="sd">    state_intercept : ndarray</span>
<span class="sd">        The intercept for the transition equation, :math:`c`.</span>
<span class="sd">    selection : ndarray</span>
<span class="sd">        The selection matrix, :math:`R`.</span>
<span class="sd">    state_cov : ndarray</span>
<span class="sd">        The covariance matrix for the state equation :math:`Q`.</span>
<span class="sd">    missing : array of bool</span>
<span class="sd">        An array of the same size as `endog`, filled</span>
<span class="sd">        with boolean values that are True if the</span>
<span class="sd">        corresponding entry in `endog` is NaN and False</span>
<span class="sd">        otherwise.</span>
<span class="sd">    nmissing : array of int</span>
<span class="sd">        An array of size `nobs`, where the ith entry</span>
<span class="sd">        is the number (between 0 and `k_endog`) of NaNs in</span>
<span class="sd">        the ith row of the `endog` array.</span>
<span class="sd">    time_invariant : bool</span>
<span class="sd">        Whether or not the representation matrices are time-invariant</span>
<span class="sd">    initialization : str</span>
<span class="sd">        Kalman filter initialization method.</span>
<span class="sd">    initial_state : array_like</span>
<span class="sd">        The state vector used to initialize the Kalamn filter.</span>
<span class="sd">    initial_state_cov : array_like</span>
<span class="sd">        The state covariance matrix used to initialize the Kalamn filter.</span>
<span class="sd">    initial_diffuse_state_cov : array_like</span>
<span class="sd">        Diffuse state covariance matrix used to initialize the Kalamn filter.</span>
<span class="sd">    filter_method : int</span>
<span class="sd">        Bitmask representing the Kalman filtering method</span>
<span class="sd">    inversion_method : int</span>
<span class="sd">        Bitmask representing the method used to</span>
<span class="sd">        invert the forecast error covariance matrix.</span>
<span class="sd">    stability_method : int</span>
<span class="sd">        Bitmask representing the methods used to promote</span>
<span class="sd">        numerical stability in the Kalman filter</span>
<span class="sd">        recursions.</span>
<span class="sd">    conserve_memory : int</span>
<span class="sd">        Bitmask representing the selected memory conservation method.</span>
<span class="sd">    filter_timing : int</span>
<span class="sd">        Whether or not to use the alternate timing convention.</span>
<span class="sd">    tolerance : float</span>
<span class="sd">        The tolerance at which the Kalman filter</span>
<span class="sd">        determines convergence to steady-state.</span>
<span class="sd">    loglikelihood_burn : int</span>
<span class="sd">        The number of initial periods during which</span>
<span class="sd">        the loglikelihood is not recorded.</span>
<span class="sd">    converged : bool</span>
<span class="sd">        Whether or not the Kalman filter converged.</span>
<span class="sd">    period_converged : int</span>
<span class="sd">        The time period in which the Kalman filter converged.</span>
<span class="sd">    filtered_state : ndarray</span>
<span class="sd">        The filtered state vector at each time period.</span>
<span class="sd">    filtered_state_cov : ndarray</span>
<span class="sd">        The filtered state covariance matrix at each time period.</span>
<span class="sd">    predicted_state : ndarray</span>
<span class="sd">        The predicted state vector at each time period.</span>
<span class="sd">    predicted_state_cov : ndarray</span>
<span class="sd">        The predicted state covariance matrix at each time period.</span>
<span class="sd">    forecast_error_diffuse_cov : ndarray</span>
<span class="sd">        Diffuse forecast error covariance matrix at each time period.</span>
<span class="sd">    predicted_diffuse_state_cov : ndarray</span>
<span class="sd">        The predicted diffuse state covariance matrix at each time period.</span>
<span class="sd">    kalman_gain : ndarray</span>
<span class="sd">        The Kalman gain at each time period.</span>
<span class="sd">    forecasts : ndarray</span>
<span class="sd">        The one-step-ahead forecasts of observations at each time period.</span>
<span class="sd">    forecasts_error : ndarray</span>
<span class="sd">        The forecast errors at each time period.</span>
<span class="sd">    forecasts_error_cov : ndarray</span>
<span class="sd">        The forecast error covariance matrices at each time period.</span>
<span class="sd">    llf_obs : ndarray</span>
<span class="sd">        The loglikelihood values at each time period.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_filter_attributes</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s1">&#39;filter_method&#39;</span><span class="p">,</span> <span class="s1">&#39;inversion_method&#39;</span><span class="p">,</span> <span class="s1">&#39;stability_method&#39;</span><span class="p">,</span>
        <span class="s1">&#39;conserve_memory&#39;</span><span class="p">,</span> <span class="s1">&#39;filter_timing&#39;</span><span class="p">,</span> <span class="s1">&#39;tolerance&#39;</span><span class="p">,</span> <span class="s1">&#39;loglikelihood_burn&#39;</span><span class="p">,</span>
        <span class="s1">&#39;converged&#39;</span><span class="p">,</span> <span class="s1">&#39;period_converged&#39;</span><span class="p">,</span> <span class="s1">&#39;filtered_state&#39;</span><span class="p">,</span>
        <span class="s1">&#39;filtered_state_cov&#39;</span><span class="p">,</span> <span class="s1">&#39;predicted_state&#39;</span><span class="p">,</span> <span class="s1">&#39;predicted_state_cov&#39;</span><span class="p">,</span>
        <span class="s1">&#39;forecasts_error_diffuse_cov&#39;</span><span class="p">,</span> <span class="s1">&#39;predicted_diffuse_state_cov&#39;</span><span class="p">,</span>
        <span class="s1">&#39;tmp1&#39;</span><span class="p">,</span> <span class="s1">&#39;tmp2&#39;</span><span class="p">,</span> <span class="s1">&#39;tmp3&#39;</span><span class="p">,</span> <span class="s1">&#39;tmp4&#39;</span><span class="p">,</span> <span class="s1">&#39;forecasts&#39;</span><span class="p">,</span>
        <span class="s1">&#39;forecasts_error&#39;</span><span class="p">,</span> <span class="s1">&#39;forecasts_error_cov&#39;</span><span class="p">,</span> <span class="s1">&#39;llf&#39;</span><span class="p">,</span> <span class="s1">&#39;llf_obs&#39;</span><span class="p">,</span>
        <span class="s1">&#39;collapsed_forecasts&#39;</span><span class="p">,</span> <span class="s1">&#39;collapsed_forecasts_error&#39;</span><span class="p">,</span>
        <span class="s1">&#39;collapsed_forecasts_error_cov&#39;</span><span class="p">,</span> <span class="s1">&#39;scale&#39;</span>
    <span class="p">]</span>

    <span class="n">_filter_options</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">KalmanFilter</span><span class="o">.</span><span class="n">filter_methods</span> <span class="o">+</span> <span class="n">KalmanFilter</span><span class="o">.</span><span class="n">stability_methods</span> <span class="o">+</span>
        <span class="n">KalmanFilter</span><span class="o">.</span><span class="n">inversion_methods</span> <span class="o">+</span> <span class="n">KalmanFilter</span><span class="o">.</span><span class="n">memory_options</span>
    <span class="p">)</span>

    <span class="n">_attributes</span> <span class="o">=</span> <span class="n">FrozenRepresentation</span><span class="o">.</span><span class="n">_model_attributes</span> <span class="o">+</span> <span class="n">_filter_attributes</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">FilterResults</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>

        <span class="c1"># Setup caches for uninitialized objects</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_kalman_gain</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_standardized_forecasts_error</span> <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="FilterResults.update_representation">
<a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.kalman_filter.FilterResults.update_representation.html#statsmodels.tsa.statespace.kalman_filter.FilterResults.update_representation">[docs]</a>
    <span class="k">def</span> <span class="nf">update_representation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">only_options</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update the results to match a given model</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        model : Representation</span>
<span class="sd">            The model object from which to take the updated values.</span>
<span class="sd">        only_options : bool, optional</span>
<span class="sd">            If set to true, only the filter options are updated, and the state</span>
<span class="sd">            space representation is not updated. Default is False.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method is rarely required except for internal usage.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">only_options</span><span class="p">:</span>
            <span class="nb">super</span><span class="p">(</span><span class="n">FilterResults</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">update_representation</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>

        <span class="c1"># Save the options as boolean variables</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filter_options</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span></div>


<div class="viewcode-block" id="FilterResults.update_filter">
<a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.kalman_filter.FilterResults.update_filter.html#statsmodels.tsa.statespace.kalman_filter.FilterResults.update_filter">[docs]</a>
    <span class="k">def</span> <span class="nf">update_filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kalman_filter</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update the filter results</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        kalman_filter : statespace.kalman_filter.KalmanFilter</span>
<span class="sd">            The model object from which to take the updated values.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method is rarely required except for internal usage.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># State initialization</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initial_state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="n">kalman_filter</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">initial_state</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initial_state_cov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="n">kalman_filter</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">initial_state_cov</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>

        <span class="c1"># Save Kalman filter parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filter_method</span> <span class="o">=</span> <span class="n">kalman_filter</span><span class="o">.</span><span class="n">filter_method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inversion_method</span> <span class="o">=</span> <span class="n">kalman_filter</span><span class="o">.</span><span class="n">inversion_method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stability_method</span> <span class="o">=</span> <span class="n">kalman_filter</span><span class="o">.</span><span class="n">stability_method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">conserve_memory</span> <span class="o">=</span> <span class="n">kalman_filter</span><span class="o">.</span><span class="n">conserve_memory</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filter_timing</span> <span class="o">=</span> <span class="n">kalman_filter</span><span class="o">.</span><span class="n">filter_timing</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tolerance</span> <span class="o">=</span> <span class="n">kalman_filter</span><span class="o">.</span><span class="n">tolerance</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loglikelihood_burn</span> <span class="o">=</span> <span class="n">kalman_filter</span><span class="o">.</span><span class="n">loglikelihood_burn</span>

        <span class="c1"># Save Kalman filter output</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">converged</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">kalman_filter</span><span class="o">.</span><span class="n">converged</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">period_converged</span> <span class="o">=</span> <span class="n">kalman_filter</span><span class="o">.</span><span class="n">period_converged</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">univariate_filter</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">kalman_filter</span><span class="o">.</span><span class="n">univariate_filter</span><span class="p">,</span>
                                          <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">filtered_state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">kalman_filter</span><span class="o">.</span><span class="n">filtered_state</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filtered_state_cov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="n">kalman_filter</span><span class="o">.</span><span class="n">filtered_state_cov</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">predicted_state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="n">kalman_filter</span><span class="o">.</span><span class="n">predicted_state</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">predicted_state_cov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="n">kalman_filter</span><span class="o">.</span><span class="n">predicted_state_cov</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>

        <span class="c1"># Reset caches</span>
        <span class="n">has_missing</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nmissing</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">memory_no_std_forecast</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">invert_lu</span> <span class="ow">or</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">solve_lu</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_collapsed</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">has_missing</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_standardized_forecasts_error</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                    <span class="n">reorder_missing_vector</span><span class="p">(</span>
                        <span class="n">kalman_filter</span><span class="o">.</span><span class="n">standardized_forecast_error</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">missing</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">prefix</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_standardized_forecasts_error</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                    <span class="n">kalman_filter</span><span class="o">.</span><span class="n">standardized_forecast_error</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_standardized_forecasts_error</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># In the partially missing data case, all entries will</span>
        <span class="c1"># be in the upper left submatrix rather than the correct placement</span>
        <span class="c1"># Re-ordering does not make sense in the collapsed case.</span>
        <span class="k">if</span> <span class="n">has_missing</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">memory_no_gain</span> <span class="ow">and</span>
                            <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_collapsed</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_kalman_gain</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">reorder_missing_matrix</span><span class="p">(</span>
                <span class="n">kalman_filter</span><span class="o">.</span><span class="n">kalman_gain</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">missing</span><span class="p">,</span> <span class="n">reorder_cols</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">prefix</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">prefix</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tmp1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">reorder_missing_matrix</span><span class="p">(</span>
                <span class="n">kalman_filter</span><span class="o">.</span><span class="n">tmp1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">missing</span><span class="p">,</span> <span class="n">reorder_cols</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">prefix</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">prefix</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tmp2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">reorder_missing_vector</span><span class="p">(</span>
                <span class="n">kalman_filter</span><span class="o">.</span><span class="n">tmp2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">missing</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">prefix</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tmp3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">reorder_missing_matrix</span><span class="p">(</span>
                <span class="n">kalman_filter</span><span class="o">.</span><span class="n">tmp3</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">missing</span><span class="p">,</span> <span class="n">reorder_rows</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">prefix</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">prefix</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tmp4</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">reorder_missing_matrix</span><span class="p">(</span>
                <span class="n">kalman_filter</span><span class="o">.</span><span class="n">tmp4</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">missing</span><span class="p">,</span> <span class="n">reorder_cols</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">reorder_rows</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">prefix</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">memory_no_gain</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_kalman_gain</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                    <span class="n">kalman_filter</span><span class="o">.</span><span class="n">kalman_gain</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tmp1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">kalman_filter</span><span class="o">.</span><span class="n">tmp1</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tmp2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">kalman_filter</span><span class="o">.</span><span class="n">tmp2</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tmp3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">kalman_filter</span><span class="o">.</span><span class="n">tmp3</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tmp4</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">kalman_filter</span><span class="o">.</span><span class="n">tmp4</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">kalman_filter</span><span class="o">.</span><span class="n">M</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">M_diffuse</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">kalman_filter</span><span class="o">.</span><span class="n">M_inf</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Note: use forecasts rather than forecast, so as not to interfer</span>
        <span class="c1"># with the `forecast` methods in subclasses</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">forecasts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">kalman_filter</span><span class="o">.</span><span class="n">forecast</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">forecasts_error</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="n">kalman_filter</span><span class="o">.</span><span class="n">forecast_error</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">forecasts_error_cov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="n">kalman_filter</span><span class="o">.</span><span class="n">forecast_error_cov</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>
        <span class="c1"># Note: below we will set self.llf, and in the memory_no_likelihood</span>
        <span class="c1"># case we will replace self.llf_obs = None at that time.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">llf_obs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">kalman_filter</span><span class="o">.</span><span class="n">loglikelihood</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Diffuse objects</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nobs_diffuse</span> <span class="o">=</span> <span class="n">kalman_filter</span><span class="o">.</span><span class="n">nobs_diffuse</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initial_diffuse_state_cov</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">forecasts_error_diffuse_cov</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">predicted_diffuse_state_cov</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs_diffuse</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">initial_diffuse_state_cov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="n">kalman_filter</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">initial_diffuse_state_cov</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">predicted_diffuse_state_cov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                    <span class="n">kalman_filter</span><span class="o">.</span><span class="n">predicted_diffuse_state_cov</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">has_missing</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_collapsed</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">forecasts_error_diffuse_cov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                    <span class="n">reorder_missing_matrix</span><span class="p">(</span>
                        <span class="n">kalman_filter</span><span class="o">.</span><span class="n">forecast_error_diffuse_cov</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">missing</span><span class="p">,</span> <span class="n">reorder_cols</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">reorder_rows</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                        <span class="n">prefix</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">prefix</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">forecasts_error_diffuse_cov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                    <span class="n">kalman_filter</span><span class="o">.</span><span class="n">forecast_error_diffuse_cov</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># If there was missing data, save the original values from the Kalman</span>
        <span class="c1"># filter output, since below will set the values corresponding to</span>
        <span class="c1"># the missing observations to nans.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">missing_forecasts</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">missing_forecasts_error</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">missing_forecasts_error_cov</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nmissing</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Copy the provided arrays (which are as the Kalman filter dataset)</span>
            <span class="c1"># into new variables</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">missing_forecasts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">forecasts</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">missing_forecasts_error</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">forecasts_error</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">missing_forecasts_error_cov</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">forecasts_error_cov</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="c1"># Save the collapsed values</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">collapsed_forecasts</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">collapsed_forecasts_error</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">collapsed_forecasts_error_cov</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_collapsed</span><span class="p">:</span>
            <span class="c1"># Copy the provided arrays (which are from the collapsed dataset)</span>
            <span class="c1"># into new variables</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">collapsed_forecasts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">forecasts</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">k_states</span><span class="p">,</span> <span class="p">:]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">collapsed_forecasts_error</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">forecasts_error</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">k_states</span><span class="p">,</span> <span class="p">:]</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">collapsed_forecasts_error_cov</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">forecasts_error_cov</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">k_states</span><span class="p">,</span> <span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">k_states</span><span class="p">,</span> <span class="p">:]</span>
            <span class="p">)</span>
            <span class="c1"># Recreate the original arrays (which should be from the original</span>
            <span class="c1"># dataset) in the appropriate dimension</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">collapsed_forecasts</span><span class="o">.</span><span class="n">dtype</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">forecasts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">forecasts_error</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="p">),</span>
                                            <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">forecasts_error_cov</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="c1"># Fill in missing values in the forecast, forecast error, and</span>
        <span class="c1"># forecast error covariance matrix (this is required due to how the</span>
        <span class="c1"># Kalman filter implements observations that are either partly or</span>
        <span class="c1"># completely missing)</span>
        <span class="c1"># Construct the predictions, forecasts</span>
        <span class="n">can_compute_mean</span> <span class="o">=</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">memory_no_forecast_mean</span> <span class="ow">or</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">memory_no_predicted_mean</span><span class="p">)</span>
        <span class="n">can_compute_cov</span> <span class="o">=</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">memory_no_forecast_cov</span> <span class="ow">or</span>
                               <span class="bp">self</span><span class="o">.</span><span class="n">memory_no_predicted_cov</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">can_compute_mean</span> <span class="ow">or</span> <span class="n">can_compute_cov</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="p">):</span>
                <span class="n">design_t</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">design</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">t</span>
                <span class="n">obs_cov_t</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">obs_cov</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">t</span>
                <span class="n">obs_intercept_t</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">obs_intercept</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">t</span>

                <span class="c1"># For completely missing observations, the Kalman filter will</span>
                <span class="c1"># produce forecasts, but forecast errors and the forecast</span>
                <span class="c1"># error covariance matrix will be zeros - make them nan to</span>
                <span class="c1"># improve clarity of results.</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nmissing</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">mask</span> <span class="o">=</span> <span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">missing</span><span class="p">[:,</span> <span class="n">t</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>
                    <span class="c1"># We can recover forecasts</span>
                    <span class="c1"># For partially missing observations, the Kalman filter</span>
                    <span class="c1"># will produce all elements (forecasts, forecast errors,</span>
                    <span class="c1"># forecast error covariance matrices) as usual, but their</span>
                    <span class="c1"># dimension will only be equal to the number of non-missing</span>
                    <span class="c1"># elements, and their location in memory will be in the</span>
                    <span class="c1"># first blocks (e.g. for the forecasts_error, the first</span>
                    <span class="c1"># k_endog - nmissing[t] columns will be filled in),</span>
                    <span class="c1"># regardless of which endogenous variables they refer to</span>
                    <span class="c1"># (i.e. the non- missing endogenous variables for that</span>
                    <span class="c1"># observation). Furthermore, the forecast error covariance</span>
                    <span class="c1"># matrix is only valid for those elements. What is done is</span>
                    <span class="c1"># to set all elements to nan for these observations so that</span>
                    <span class="c1"># they are flagged as missing. The variables</span>
                    <span class="c1"># missing_forecasts, etc. then provide the forecasts, etc.</span>
                    <span class="c1"># provided by the Kalman filter, from which the data can be</span>
                    <span class="c1"># retrieved if desired.</span>
                    <span class="k">if</span> <span class="n">can_compute_mean</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">forecasts</span><span class="p">[:,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">design</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">design_t</span><span class="p">],</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">predicted_state</span><span class="p">[:,</span> <span class="n">t</span><span class="p">]</span>
                        <span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">obs_intercept</span><span class="p">[:,</span> <span class="n">obs_intercept_t</span><span class="p">]</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">forecasts_error</span><span class="p">[:,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">forecasts_error</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">endog</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">forecasts</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span> <span class="n">t</span><span class="p">])</span>
                    <span class="c1"># TODO: We should only fill in the non-masked elements of</span>
                    <span class="c1"># this array. Also, this will give the multivariate version</span>
                    <span class="c1"># even if univariate filtering was selected. Instead, we</span>
                    <span class="c1"># should use the reordering methods and then replace the</span>
                    <span class="c1"># masked values with NaNs</span>
                    <span class="k">if</span> <span class="n">can_compute_cov</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">forecasts_error_cov</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
                            <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">design</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">design_t</span><span class="p">],</span>
                                   <span class="bp">self</span><span class="o">.</span><span class="n">predicted_state_cov</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">t</span><span class="p">]),</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">design</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">design_t</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>
                        <span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">obs_cov</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">obs_cov_t</span><span class="p">]</span>
                <span class="c1"># In the collapsed case, everything just needs to be rebuilt</span>
                <span class="c1"># for the original observed data, since the Kalman filter</span>
                <span class="c1"># produced these values for the collapsed data.</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_collapsed</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">can_compute_mean</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">forecasts</span><span class="p">[:,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">design</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">design_t</span><span class="p">],</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">predicted_state</span><span class="p">[:,</span> <span class="n">t</span><span class="p">]</span>
                        <span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">obs_intercept</span><span class="p">[:,</span> <span class="n">obs_intercept_t</span><span class="p">]</span>

                        <span class="bp">self</span><span class="o">.</span><span class="n">forecasts_error</span><span class="p">[:,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">endog</span><span class="p">[:,</span> <span class="n">t</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">forecasts</span><span class="p">[:,</span> <span class="n">t</span><span class="p">]</span>
                        <span class="p">)</span>

                    <span class="k">if</span> <span class="n">can_compute_cov</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">forecasts_error_cov</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
                            <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">design</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">design_t</span><span class="p">],</span>
                                   <span class="bp">self</span><span class="o">.</span><span class="n">predicted_state_cov</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">t</span><span class="p">]),</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">design</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">design_t</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>
                        <span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">obs_cov</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">obs_cov_t</span><span class="p">]</span>

        <span class="c1"># Note: if we concentrated out the scale, need to adjust the</span>
        <span class="c1"># loglikelihood values and all of the covariance matrices and the</span>
        <span class="c1"># values that depend on the covariance matrices</span>
        <span class="c1"># Note: concentrated computation is not permitted with collapsed</span>
        <span class="c1"># version, so we do not need to modify collapsed arrays.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scale</span> <span class="o">=</span> <span class="mf">1.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_concentrated</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">_scale</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loglikelihood_burn</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs_diffuse</span><span class="p">)</span>
            <span class="c1"># Compute the scale</span>
            <span class="n">nmissing</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">kalman_filter</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">nmissing</span><span class="p">)</span>
            <span class="n">nobs_k_endog</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span> <span class="o">-</span> <span class="n">nmissing</span><span class="p">[</span><span class="n">d</span><span class="p">:])</span>

            <span class="c1"># In the univariate case, we need to subtract observations</span>
            <span class="c1"># associated with a singular forecast error covariance matrix</span>
            <span class="n">nobs_k_endog</span> <span class="o">-=</span> <span class="n">kalman_filter</span><span class="o">.</span><span class="n">nobs_kendog_univariate_singular</span>

            <span class="n">scale_obs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">kalman_filter</span><span class="o">.</span><span class="n">scale</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">memory_no_likelihood</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">scale</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">scale_obs</span><span class="p">[</span><span class="n">d</span><span class="p">:])</span> <span class="o">/</span> <span class="n">nobs_k_endog</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">scale</span> <span class="o">=</span> <span class="n">scale_obs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">nobs_k_endog</span>

            <span class="c1"># Need to modify this for diffuse initialization, since for</span>
            <span class="c1"># diffuse periods we only need to add in the scale value if the</span>
            <span class="c1"># diffuse forecast error covariance matrix element was singular</span>
            <span class="n">nsingular</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="n">kalman_filter</span><span class="o">.</span><span class="n">nobs_diffuse</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">Finf</span> <span class="o">=</span> <span class="n">kalman_filter</span><span class="o">.</span><span class="n">forecast_error_diffuse_cov</span>
                <span class="n">singular</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diagonal</span><span class="p">(</span><span class="n">Finf</span><span class="p">)</span><span class="o">.</span><span class="n">real</span> <span class="o">&lt;=</span>
                            <span class="n">kalman_filter</span><span class="o">.</span><span class="n">tolerance_diffuse</span><span class="p">)</span>
                <span class="n">nsingular</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">~</span><span class="n">singular</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

            <span class="c1"># Adjust the loglikelihood obs (see `KalmanFilter.loglikeobs` for</span>
            <span class="c1"># defaults on the adjustment)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">memory_no_likelihood</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">llf_obs</span> <span class="o">+=</span> <span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span>
                    <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span> <span class="o">-</span> <span class="n">nmissing</span> <span class="o">-</span> <span class="n">nsingular</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">)</span>
                    <span class="o">+</span> <span class="n">scale_obs</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">llf_obs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                        <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span> <span class="o">-</span> <span class="n">nmissing</span> <span class="o">-</span> <span class="n">nsingular</span><span class="p">)</span>
                        <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">)</span>
                    <span class="p">)</span>
                    <span class="o">+</span> <span class="n">scale_obs</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span>
                <span class="p">)</span>

            <span class="c1"># Scale the filter output</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">obs_cov</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">obs_cov</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">state_cov</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">state_cov</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">initial_state_cov</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">initial_state_cov</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">predicted_state_cov</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predicted_state_cov</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">filtered_state_cov</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filtered_state_cov</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">forecasts_error_cov</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">forecasts_error_cov</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">missing_forecasts_error_cov</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">missing_forecasts_error_cov</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">missing_forecasts_error_cov</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">)</span>

            <span class="c1"># Note: do not have to adjust the Kalman gain or tmp4</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tmp1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tmp1</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tmp2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tmp2</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tmp3</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tmp3</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">memory_no_std_forecast</span> <span class="ow">or</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">invert_lu</span> <span class="ow">or</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">solve_lu</span> <span class="ow">or</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">filter_collapsed</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_standardized_forecasts_error</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_standardized_forecasts_error</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="o">**</span><span class="mf">0.5</span><span class="p">)</span>
        <span class="c1"># The self.model._scale value is only not None within a fixed_scale</span>
        <span class="c1"># context, in which case it is set and indicates that we should</span>
        <span class="c1"># generally view this results object as using a concentrated scale</span>
        <span class="c1"># (e.g. for d.o.f. computations), but because the fixed scale was</span>
        <span class="c1"># actually applied to the model prior to filtering, we do not need to</span>
        <span class="c1"># make any adjustments to the filter output, etc.</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">_scale</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">filter_concentrated</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">_scale</span>

        <span class="c1"># Now, save self.llf, and handle the memory_no_likelihood case</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">memory_no_likelihood</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">llf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">llf_obs</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">loglikelihood_burn</span><span class="p">:])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">llf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">llf_obs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">llf_obs</span> <span class="o">=</span> <span class="kc">None</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">kalman_gain</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Kalman gain matrices</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kalman_gain</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># k x n</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_kalman_gain</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_states</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="p">):</span>
                <span class="c1"># In the case of entirely missing observations, let the Kalman</span>
                <span class="c1"># gain be zeros.</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nmissing</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="n">design_t</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">design</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">t</span>
                <span class="n">transition_t</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">transition</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">t</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nmissing</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_kalman_gain</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">transition</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">transition_t</span><span class="p">],</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">predicted_state_cov</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">t</span><span class="p">]</span>
                        <span class="p">),</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
                            <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">design</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">design_t</span><span class="p">]),</span>
                            <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">forecasts_error_cov</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">t</span><span class="p">])</span>
                        <span class="p">)</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">mask</span> <span class="o">=</span> <span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">missing</span><span class="p">[:,</span> <span class="n">t</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>
                    <span class="n">F</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">forecasts_error_cov</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="p">[</span><span class="n">t</span><span class="p">])]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_kalman_gain</span><span class="p">[:,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">transition</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">transition_t</span><span class="p">],</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">predicted_state_cov</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">t</span><span class="p">]</span>
                        <span class="p">),</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
                            <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">design</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span> <span class="p">:,</span> <span class="n">design_t</span><span class="p">]),</span>
                            <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">F</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">])</span>
                        <span class="p">)</span>
                    <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kalman_gain</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">standardized_forecasts_error</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Standardized forecast errors</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The forecast errors produced by the Kalman filter are</span>

<span class="sd">        .. math::</span>

<span class="sd">            v_t \sim N(0, F_t)</span>

<span class="sd">        Hypothesis tests are usually applied to the standardized residuals</span>

<span class="sd">        .. math::</span>

<span class="sd">            v_t^s = B_t v_t \sim N(0, I)</span>

<span class="sd">        where :math:`B_t = L_t^{-1}` and :math:`F_t = L_t L_t&#39;`; then</span>
<span class="sd">        :math:`F_t^{-1} = (L_t&#39;)^{-1} L_t^{-1} = B_t&#39; B_t`; :math:`B_t`</span>
<span class="sd">        and :math:`L_t` are lower triangular. Finally,</span>
<span class="sd">        :math:`B_t v_t \sim N(0, B_t F_t B_t&#39;)` and</span>
<span class="sd">        :math:`B_t F_t B_t&#39; = L_t^{-1} L_t L_t&#39; (L_t&#39;)^{-1} = I`.</span>

<span class="sd">        Thus we can rewrite :math:`v_t^s = L_t^{-1} v_t` or</span>
<span class="sd">        :math:`L_t v_t^s = v_t`; the latter equation is the form required to</span>
<span class="sd">        use a linear solver to recover :math:`v_t^s`. Since :math:`L_t` is</span>
<span class="sd">        lower triangular, we can use a triangular solver (?TRTRS).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_standardized_forecasts_error</span> <span class="ow">is</span> <span class="kc">None</span>
                <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">memory_no_forecast</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_standardized_forecasts_error</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">forecasts_error</span> <span class="o">/</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">forecasts_error_cov</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:]</span><span class="o">**</span><span class="mf">0.5</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">linalg</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_standardized_forecasts_error</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">forecasts_error</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">forecasts_error_cov</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]):</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nmissing</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_standardized_forecasts_error</span><span class="p">[:,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nmissing</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">:</span>
                        <span class="n">mask</span> <span class="o">=</span> <span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">missing</span><span class="p">[:,</span> <span class="n">t</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>
                        <span class="n">F</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">forecasts_error_cov</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="p">[</span><span class="n">t</span><span class="p">])]</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="n">upper</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">cho_factor</span><span class="p">(</span><span class="n">F</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">])</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_standardized_forecasts_error</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                                <span class="n">linalg</span><span class="o">.</span><span class="n">solve_triangular</span><span class="p">(</span>
                                    <span class="n">upper</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">forecasts_error</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span> <span class="n">t</span><span class="p">],</span>
                                    <span class="n">trans</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
                        <span class="k">except</span> <span class="n">linalg</span><span class="o">.</span><span class="n">LinAlgError</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_standardized_forecasts_error</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                                <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_standardized_forecasts_error</span>

<div class="viewcode-block" id="FilterResults.predict">
<a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.kalman_filter.FilterResults.predict.html#statsmodels.tsa.statespace.kalman_filter.FilterResults.predict">[docs]</a>
    <span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dynamic</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        In-sample and out-of-sample prediction for state space models generally</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        start : int, optional</span>
<span class="sd">            Zero-indexed observation number at which to start prediction, i.e.,</span>
<span class="sd">            the first prediction will be at start.</span>
<span class="sd">        end : int, optional</span>
<span class="sd">            Zero-indexed observation number at which to end prediction, i.e.,</span>
<span class="sd">            the last prediction will be at end.</span>
<span class="sd">        dynamic : int, optional</span>
<span class="sd">            Offset relative to `start` at which to begin dynamic prediction.</span>
<span class="sd">            Prior to this observation, true endogenous values will be used for</span>
<span class="sd">            prediction; starting with this observation and continuing through</span>
<span class="sd">            the end of prediction, predicted endogenous values will be used</span>
<span class="sd">            instead.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            If the prediction range is outside of the sample range, any</span>
<span class="sd">            of the state space representation matrices that are time-varying</span>
<span class="sd">            must have updated values provided for the out-of-sample range.</span>
<span class="sd">            For example, of `obs_intercept` is a time-varying component and</span>
<span class="sd">            the prediction range extends 10 periods beyond the end of the</span>
<span class="sd">            sample, a (`k_endog` x 10) matrix must be provided with the new</span>
<span class="sd">            intercept values.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        results : kalman_filter.PredictionResults</span>
<span class="sd">            A PredictionResults object.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        All prediction is performed by applying the deterministic part of the</span>
<span class="sd">        measurement equation using the predicted state variables.</span>

<span class="sd">        Out-of-sample prediction first applies the Kalman filter to missing</span>
<span class="sd">        data for the number of periods desired to obtain the predicted states.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get the start and the end of the entire prediction range</span>
        <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">elif</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Cannot predict values previous to the sample.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">end</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span>

        <span class="c1"># Prediction and forecasting is performed by iterating the Kalman</span>
        <span class="c1"># Kalman filter through the entire range [0, end]</span>
        <span class="c1"># Then, everything is returned corresponding to the range [start, end].</span>
        <span class="c1"># In order to perform the calculations, the range is separately split</span>
        <span class="c1"># up into the following categories:</span>
        <span class="c1"># - static:   (in-sample) the Kalman filter is run as usual</span>
        <span class="c1"># - dynamic:  (in-sample) the Kalman filter is run, but on missing data</span>
        <span class="c1"># - forecast: (out-of-sample) the Kalman filter is run, but on missing</span>
        <span class="c1">#             data</span>

        <span class="c1"># Short-circuit if end is before start</span>
        <span class="k">if</span> <span class="n">end</span> <span class="o">&lt;=</span> <span class="n">start</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;End of prediction must be after start.&#39;</span><span class="p">)</span>

        <span class="c1"># Get the number of forecasts to make after the end of the sample</span>
        <span class="n">nforecast</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">end</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="p">)</span>

        <span class="c1"># Get the number of dynamic prediction periods</span>

        <span class="c1"># If `dynamic=True`, then assume that we want to begin dynamic</span>
        <span class="c1"># prediction at the start of the sample prediction.</span>
        <span class="k">if</span> <span class="n">dynamic</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">dynamic</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># If `dynamic=False`, then assume we want no dynamic prediction</span>
        <span class="k">if</span> <span class="n">dynamic</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">dynamic</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Check validity of dynamic and warn or error if issues</span>
        <span class="n">dynamic</span><span class="p">,</span> <span class="n">ndynamic</span> <span class="o">=</span> <span class="n">_check_dynamic</span><span class="p">(</span><span class="n">dynamic</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="p">)</span>

        <span class="c1"># Get the number of in-sample static predictions</span>
        <span class="k">if</span> <span class="n">dynamic</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">nstatic</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">end</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="p">)</span> <span class="o">-</span> <span class="nb">min</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># (use max(., 0), since dynamic can be prior to start)</span>
            <span class="n">nstatic</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">dynamic</span> <span class="o">-</span> <span class="n">start</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Cannot do in-sample prediction if we do not have appropriate</span>
        <span class="c1"># arrays (we can do out-of-sample forecasting, however)</span>
        <span class="k">if</span> <span class="n">nstatic</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">memory_no_forecast_mean</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;In-sample prediction is not available if memory&#39;</span>
                             <span class="s1">&#39; conservation has been used to avoid storing&#39;</span>
                             <span class="s1">&#39; forecast means.&#39;</span><span class="p">)</span>
        <span class="c1"># Cannot do dynamic in-sample prediction if we do not have appropriate</span>
        <span class="c1"># arrays (we can do out-of-sample forecasting, however)</span>
        <span class="k">if</span> <span class="n">ndynamic</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">memory_no_predicted</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;In-sample dynamic prediction is not available if&#39;</span>
                             <span class="s1">&#39; memory conservation has been used to avoid&#39;</span>
                             <span class="s1">&#39; storing forecasted or predicted state means&#39;</span>
                             <span class="s1">&#39; or covariances.&#39;</span><span class="p">)</span>

        <span class="c1"># Construct the predicted state and covariance matrix for each time</span>
        <span class="c1"># period depending on whether that time period corresponds to</span>
        <span class="c1"># one-step-ahead prediction, dynamic prediction, or out-of-sample</span>
        <span class="c1"># forecasting.</span>

        <span class="c1"># If we only have simple prediction, then we can use the already saved</span>
        <span class="c1"># Kalman filter output</span>
        <span class="k">if</span> <span class="n">ndynamic</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">nforecast</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">results</span> <span class="o">=</span> <span class="bp">self</span>
            <span class="n">oos_results</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># If we have dynamic prediction or forecasting, then we need to</span>
        <span class="c1"># re-apply the Kalman filter</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Figure out the period for which we need to run the Kalman filter</span>
            <span class="k">if</span> <span class="n">dynamic</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">kf_start</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">dynamic</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">kf_start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nobs</span>
            <span class="n">kf_end</span> <span class="o">=</span> <span class="n">end</span>

            <span class="c1"># Make start, end consistent with the results that we&#39;re generating</span>
            <span class="c1"># start = max(start - kf_start, 0)</span>
            <span class="c1"># end = kf_end - kf_start</span>

            <span class="c1"># We must at least store forecasts and predictions</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;conserve_memory&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">conserve_memory</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">MEMORY_NO_FORECAST</span> <span class="o">&amp;</span>
                <span class="o">~</span><span class="n">MEMORY_NO_PREDICTED</span><span class="p">)</span>

            <span class="c1"># Can&#39;t use Chandrasekhar recursions for prediction</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;filter_method&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">filter_method</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">FILTER_CHANDRASEKHAR</span><span class="p">)</span>

            <span class="c1"># TODO: there is a corner case here when the filter has not</span>
            <span class="c1">#       exited the diffuse filter, in which case this known</span>
            <span class="c1">#       initialization is not correct.</span>
            <span class="c1"># Even if we have not stored all predicted values (means and covs),</span>
            <span class="c1"># we can still do pure out-of-sample forecasting because we will</span>
            <span class="c1"># always have stored the last predicted values. In this case, we</span>
            <span class="c1"># will initialize the forecasting filter with these values</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">memory_no_predicted</span><span class="p">:</span>
                <span class="n">constant</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predicted_state</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">stationary_cov</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predicted_state_cov</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="c1"># Otherwise initialize with the predicted state / cov from the</span>
            <span class="c1"># existing results, at index kf_start (note that the time</span>
            <span class="c1"># dimension of predicted_state and predicted_state_cov is</span>
            <span class="c1"># self.nobs + 1; so e.g. in the case of pure forecasting we should</span>
            <span class="c1"># be using the very last predicted state and predicted state cov</span>
            <span class="c1"># elements, and kf_start will equal self.nobs which is correct)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">constant</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predicted_state</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">kf_start</span><span class="p">]</span>
                <span class="n">stationary_cov</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predicted_state_cov</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">kf_start</span><span class="p">]</span>

            <span class="n">kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s1">&#39;initialization&#39;</span><span class="p">:</span> <span class="s1">&#39;known&#39;</span><span class="p">,</span>
                           <span class="s1">&#39;constant&#39;</span><span class="p">:</span> <span class="n">constant</span><span class="p">,</span>
                           <span class="s1">&#39;stationary_cov&#39;</span><span class="p">:</span> <span class="n">stationary_cov</span><span class="p">})</span>

            <span class="c1"># Construct the new endogenous array.</span>
            <span class="n">endog</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nforecast</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_endog</span><span class="p">))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
                <span class="n">endog</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="n">kf_start</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="n">kf_end</span> <span class="o">-</span> <span class="n">nforecast</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="c1"># Have to retroactively modify the model&#39;s endog</span>
            <span class="k">if</span> <span class="n">ndynamic</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">model</span><span class="o">.</span><span class="n">endog</span><span class="p">[:,</span> <span class="o">-</span><span class="p">(</span><span class="n">ndynamic</span> <span class="o">+</span> <span class="n">nforecast</span><span class="p">):]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

            <span class="k">with</span> <span class="n">model</span><span class="o">.</span><span class="n">fixed_scale</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">):</span>
                <span class="n">oos_results</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">filter</span><span class="p">()</span>

            <span class="n">results</span> <span class="o">=</span> <span class="bp">self</span>

        <span class="k">return</span> <span class="n">PredictionResults</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">nstatic</span><span class="p">,</span> <span class="n">ndynamic</span><span class="p">,</span>
                                 <span class="n">nforecast</span><span class="p">,</span> <span class="n">oos_results</span><span class="o">=</span><span class="n">oos_results</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="PredictionResults">
<a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.kalman_filter.PredictionResults.html#statsmodels.tsa.statespace.kalman_filter.PredictionResults">[docs]</a>
<span class="k">class</span> <span class="nc">PredictionResults</span><span class="p">(</span><span class="n">FilterResults</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Results of in-sample and out-of-sample prediction for state space models</span>
<span class="sd">    generally</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    results : FilterResults</span>
<span class="sd">        Output from filtering, corresponding to the prediction desired</span>
<span class="sd">    start : int</span>
<span class="sd">        Zero-indexed observation number at which to start forecasting,</span>
<span class="sd">        i.e., the first forecast will be at start.</span>
<span class="sd">    end : int</span>
<span class="sd">        Zero-indexed observation number at which to end forecasting, i.e.,</span>
<span class="sd">        the last forecast will be at end.</span>
<span class="sd">    nstatic : int</span>
<span class="sd">        Number of in-sample static predictions (these are always the first</span>
<span class="sd">        elements of the prediction output).</span>
<span class="sd">    ndynamic : int</span>
<span class="sd">        Number of in-sample dynamic predictions (these always follow the static</span>
<span class="sd">        predictions directly, and are directly followed by the forecasts).</span>
<span class="sd">    nforecast : int</span>
<span class="sd">        Number of in-sample forecasts (these always follow the dynamic</span>
<span class="sd">        predictions directly).</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    npredictions : int</span>
<span class="sd">        Number of observations in the predicted series; this is not necessarily</span>
<span class="sd">        the same as the number of observations in the original model from which</span>
<span class="sd">        prediction was performed.</span>
<span class="sd">    start : int</span>
<span class="sd">        Zero-indexed observation number at which to start prediction,</span>
<span class="sd">        i.e., the first predict will be at `start`; this is relative to the</span>
<span class="sd">        original model from which prediction was performed.</span>
<span class="sd">    end : int</span>
<span class="sd">        Zero-indexed observation number at which to end prediction,</span>
<span class="sd">        i.e., the last predict will be at `end`; this is relative to the</span>
<span class="sd">        original model from which prediction was performed.</span>
<span class="sd">    nstatic : int</span>
<span class="sd">        Number of in-sample static predictions.</span>
<span class="sd">    ndynamic : int</span>
<span class="sd">        Number of in-sample dynamic predictions.</span>
<span class="sd">    nforecast : int</span>
<span class="sd">        Number of in-sample forecasts.</span>
<span class="sd">    endog : ndarray</span>
<span class="sd">        The observation vector.</span>
<span class="sd">    design : ndarray</span>
<span class="sd">        The design matrix, :math:`Z`.</span>
<span class="sd">    obs_intercept : ndarray</span>
<span class="sd">        The intercept for the observation equation, :math:`d`.</span>
<span class="sd">    obs_cov : ndarray</span>
<span class="sd">        The covariance matrix for the observation equation :math:`H`.</span>
<span class="sd">    transition : ndarray</span>
<span class="sd">        The transition matrix, :math:`T`.</span>
<span class="sd">    state_intercept : ndarray</span>
<span class="sd">        The intercept for the transition equation, :math:`c`.</span>
<span class="sd">    selection : ndarray</span>
<span class="sd">        The selection matrix, :math:`R`.</span>
<span class="sd">    state_cov : ndarray</span>
<span class="sd">        The covariance matrix for the state equation :math:`Q`.</span>
<span class="sd">    filtered_state : ndarray</span>
<span class="sd">        The filtered state vector at each time period.</span>
<span class="sd">    filtered_state_cov : ndarray</span>
<span class="sd">        The filtered state covariance matrix at each time period.</span>
<span class="sd">    predicted_state : ndarray</span>
<span class="sd">        The predicted state vector at each time period.</span>
<span class="sd">    predicted_state_cov : ndarray</span>
<span class="sd">        The predicted state covariance matrix at each time period.</span>
<span class="sd">    forecasts : ndarray</span>
<span class="sd">        The one-step-ahead forecasts of observations at each time period.</span>
<span class="sd">    forecasts_error : ndarray</span>
<span class="sd">        The forecast errors at each time period.</span>
<span class="sd">    forecasts_error_cov : ndarray</span>
<span class="sd">        The forecast error covariance matrices at each time period.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The provided ranges must be conformable, meaning that it must be that</span>
<span class="sd">    `end - start == nstatic + ndynamic + nforecast`.</span>

<span class="sd">    This class is essentially a view to the FilterResults object, but</span>
<span class="sd">    returning the appropriate ranges for everything.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">representation_attributes</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s1">&#39;endog&#39;</span><span class="p">,</span> <span class="s1">&#39;design&#39;</span><span class="p">,</span> <span class="s1">&#39;obs_intercept&#39;</span><span class="p">,</span>
        <span class="s1">&#39;obs_cov&#39;</span><span class="p">,</span> <span class="s1">&#39;transition&#39;</span><span class="p">,</span> <span class="s1">&#39;state_intercept&#39;</span><span class="p">,</span> <span class="s1">&#39;selection&#39;</span><span class="p">,</span>
        <span class="s1">&#39;state_cov&#39;</span>
    <span class="p">]</span>
    <span class="n">filter_attributes</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s1">&#39;filtered_state&#39;</span><span class="p">,</span> <span class="s1">&#39;filtered_state_cov&#39;</span><span class="p">,</span>
        <span class="s1">&#39;predicted_state&#39;</span><span class="p">,</span> <span class="s1">&#39;predicted_state_cov&#39;</span><span class="p">,</span>
        <span class="s1">&#39;forecasts&#39;</span><span class="p">,</span> <span class="s1">&#39;forecasts_error&#39;</span><span class="p">,</span> <span class="s1">&#39;forecasts_error_cov&#39;</span>
    <span class="p">]</span>
    <span class="n">smoother_attributes</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s1">&#39;smoothed_state&#39;</span><span class="p">,</span> <span class="s1">&#39;smoothed_state_cov&#39;</span><span class="p">,</span>
    <span class="p">]</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">results</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">nstatic</span><span class="p">,</span> <span class="n">ndynamic</span><span class="p">,</span> <span class="n">nforecast</span><span class="p">,</span>
                 <span class="n">oos_results</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># Save the filter results object</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">results</span> <span class="o">=</span> <span class="n">results</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">oos_results</span> <span class="o">=</span> <span class="n">oos_results</span>

        <span class="c1"># Save prediction ranges</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">npredictions</span> <span class="o">=</span> <span class="n">start</span> <span class="o">-</span> <span class="n">end</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">start</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">end</span> <span class="o">=</span> <span class="n">end</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nstatic</span> <span class="o">=</span> <span class="n">nstatic</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ndynamic</span> <span class="o">=</span> <span class="n">ndynamic</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nforecast</span> <span class="o">=</span> <span class="n">nforecast</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_predicted_signal</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_predicted_signal_cov</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_filtered_signal</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_filtered_signal_cov</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_smoothed_signal</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_smoothed_signal_cov</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_filtered_forecasts</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_filtered_forecasts_error_cov</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_smoothed_forecasts</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_smoothed_forecasts_error_cov</span> <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="PredictionResults.clear">
<a class="viewcode-back" href="../../../../generated/statsmodels.tsa.statespace.kalman_filter.PredictionResults.clear.html#statsmodels.tsa.statespace.kalman_filter.PredictionResults.clear">[docs]</a>
    <span class="k">def</span> <span class="nf">clear</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">attributes</span> <span class="o">=</span> <span class="p">([</span><span class="s1">&#39;endog&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">representation_attributes</span>
                      <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_attributes</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">attributes</span><span class="p">:</span>
            <span class="n">_attr</span> <span class="o">=</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">attr</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_attr</span><span class="p">):</span>
                <span class="nb">delattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_attr</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Provide access to the representation and filtered output in the</span>
<span class="sd">        appropriate range (`start` - `end`).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Prevent infinite recursive lookups</span>
        <span class="k">if</span> <span class="n">attr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;_&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;&#39;</span><span class="si">%s</span><span class="s2">&#39; object has no attribute &#39;</span><span class="si">%s</span><span class="s2">&#39;&quot;</span> <span class="o">%</span>
                                 <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">attr</span><span class="p">))</span>

        <span class="n">_attr</span> <span class="o">=</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">attr</span>

        <span class="c1"># Cache the attribute</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_attr</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">attr</span> <span class="o">==</span> <span class="s1">&#39;endog&#39;</span> <span class="ow">or</span> <span class="n">attr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_attributes</span><span class="p">:</span>
                <span class="c1"># Get a copy</span>
                <span class="n">value</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndynamic</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">end</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndynamic</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">nforecast</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:</span><span class="n">end</span><span class="p">]</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">oos_results</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">oos_value</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">oos_results</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

                    <span class="c1"># Note that the last element of the results predicted state</span>
                    <span class="c1"># and state cov will overlap with the first element of the</span>
                    <span class="c1"># oos predicted state and state cov, so eliminate the</span>
                    <span class="c1"># last element of the results versions</span>
                    <span class="c1"># But if we have dynamic prediction, then we have already</span>
                    <span class="c1"># eliminated the last element of the predicted state, so</span>
                    <span class="c1"># we do not need to do it here.</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndynamic</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">attr</span><span class="p">[:</span><span class="mi">9</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;predicted&#39;</span><span class="p">:</span>
                        <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

                    <span class="n">value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">value</span><span class="p">,</span> <span class="n">oos_value</span><span class="p">],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

                <span class="c1"># Subset to the correct time frame</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">end</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">attr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">smoother_attributes</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndynamic</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                        <span class="s1">&#39;Cannot retrieve smoothed attributes when using&#39;</span>
                        <span class="s1">&#39; dynamic prediction, since the information set used&#39;</span>
                        <span class="s1">&#39; to compute the smoothed results differs from the&#39;</span>
                        <span class="s1">&#39; information set implied by the dynamic prediction.&#39;</span><span class="p">)</span>
                <span class="c1"># Get a copy</span>
                <span class="n">value</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

                <span class="c1"># The oos_results object is only dynamic or out-of-sample,</span>
                <span class="c1"># so filtered == smoothed</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">oos_results</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">filtered_attr</span> <span class="o">=</span> <span class="s1">&#39;filtered&#39;</span> <span class="o">+</span> <span class="n">attr</span><span class="p">[</span><span class="mi">8</span><span class="p">:]</span>
                    <span class="n">oos_value</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">oos_results</span><span class="p">,</span> <span class="n">filtered_attr</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">value</span><span class="p">,</span> <span class="n">oos_value</span><span class="p">],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

                <span class="c1"># Subset to the correct time frame</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">end</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">attr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">representation_attributes</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="c1"># If a time-invariant matrix, return it. Otherwise, subset to</span>
                <span class="c1"># the correct period.</span>
                <span class="k">if</span> <span class="n">value</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndynamic</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">end</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndynamic</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">nforecast</span>
                        <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:</span><span class="n">end</span><span class="p">]</span>

                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">oos_results</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">oos_value</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">oos_results</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                        <span class="n">value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">value</span><span class="p">,</span> <span class="n">oos_value</span><span class="p">],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">end</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;&#39;</span><span class="si">%s</span><span class="s2">&#39; object has no attribute &#39;</span><span class="si">%s</span><span class="s2">&#39;&quot;</span> <span class="o">%</span>
                                     <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">attr</span><span class="p">))</span>

            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_attr</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_attr</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_compute_forecasts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">states</span><span class="p">,</span> <span class="n">states_cov</span><span class="p">,</span> <span class="n">signal_only</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">obs_intercept</span>
        <span class="n">Z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">design</span>
        <span class="n">H</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">obs_cov</span>

        <span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">d</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">Z</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">signal_only</span><span class="p">:</span>
                <span class="n">forecasts</span> <span class="o">=</span> <span class="n">d</span> <span class="o">+</span> <span class="n">Z</span> <span class="o">@</span> <span class="n">states</span>
                <span class="n">forecasts_error_cov</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">Z</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">@</span> <span class="n">states_cov</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">Z</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">+</span> <span class="n">H</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">forecasts</span> <span class="o">=</span> <span class="n">Z</span> <span class="o">@</span> <span class="n">states</span>
                <span class="n">forecasts_error_cov</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">Z</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">@</span> <span class="n">states_cov</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">Z</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="o">...</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">signal_only</span><span class="p">:</span>
                <span class="n">forecasts</span> <span class="o">=</span> <span class="n">d</span> <span class="o">+</span> <span class="p">(</span><span class="n">Z</span> <span class="o">*</span> <span class="n">states</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:])</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">tmp</span> <span class="o">=</span> <span class="n">Z</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">*</span> <span class="n">states_cov</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
                <span class="n">tmp</span> <span class="o">=</span> <span class="p">(</span><span class="n">tmp</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>
                       <span class="o">*</span> <span class="n">Z</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:,</span> <span class="kc">None</span><span class="p">,</span> <span class="o">...</span><span class="p">])</span>
                <span class="n">forecasts_error_cov</span> <span class="o">=</span> <span class="p">(</span><span class="n">tmp</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">T</span> <span class="o">+</span> <span class="n">H</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">forecasts</span> <span class="o">=</span> <span class="p">(</span><span class="n">Z</span> <span class="o">*</span> <span class="n">states</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:])</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">tmp</span> <span class="o">=</span> <span class="n">Z</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">*</span> <span class="n">states_cov</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
                <span class="n">tmp</span> <span class="o">=</span> <span class="p">(</span><span class="n">tmp</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>
                       <span class="o">*</span> <span class="n">Z</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:,</span> <span class="kc">None</span><span class="p">,</span> <span class="o">...</span><span class="p">])</span>
                <span class="n">forecasts_error_cov</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">forecasts</span><span class="p">,</span> <span class="n">forecasts_error_cov</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">predicted_signal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_predicted_signal</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_predicted_signal</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_predicted_signal_cov</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_compute_forecasts</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">predicted_state</span><span class="p">,</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">predicted_state_cov</span><span class="p">,</span>
                                        <span class="n">signal_only</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_predicted_signal</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">predicted_signal_cov</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_predicted_signal_cov</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_predicted_signal</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_predicted_signal_cov</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_compute_forecasts</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">predicted_state</span><span class="p">,</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">predicted_state_cov</span><span class="p">,</span>
                                        <span class="n">signal_only</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_predicted_signal_cov</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">filtered_signal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filtered_signal</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_filtered_signal</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filtered_signal_cov</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_compute_forecasts</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filtered_state</span><span class="p">,</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">filtered_state_cov</span><span class="p">,</span>
                                        <span class="n">signal_only</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filtered_signal</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">filtered_signal_cov</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filtered_signal_cov</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_filtered_signal</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filtered_signal_cov</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_compute_forecasts</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filtered_state</span><span class="p">,</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">filtered_state_cov</span><span class="p">,</span>
                                        <span class="n">signal_only</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filtered_signal_cov</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">smoothed_signal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_smoothed_signal</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_smoothed_signal</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_smoothed_signal_cov</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_compute_forecasts</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">smoothed_state</span><span class="p">,</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">smoothed_state_cov</span><span class="p">,</span>
                                        <span class="n">signal_only</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_smoothed_signal</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">smoothed_signal_cov</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_smoothed_signal_cov</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_smoothed_signal</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_smoothed_signal_cov</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_compute_forecasts</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">smoothed_state</span><span class="p">,</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">smoothed_state_cov</span><span class="p">,</span>
                                        <span class="n">signal_only</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_smoothed_signal_cov</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">filtered_forecasts</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filtered_forecasts</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_filtered_forecasts</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filtered_forecasts_cov</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_compute_forecasts</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filtered_state</span><span class="p">,</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">filtered_state_cov</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filtered_forecasts</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">filtered_forecasts_error_cov</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filtered_forecasts_cov</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_filtered_forecasts</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filtered_forecasts_cov</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_compute_forecasts</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filtered_state</span><span class="p">,</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">filtered_state_cov</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filtered_forecasts_cov</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">smoothed_forecasts</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_smoothed_forecasts</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_smoothed_forecasts</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_smoothed_forecasts_cov</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_compute_forecasts</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">smoothed_state</span><span class="p">,</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">smoothed_state_cov</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_smoothed_forecasts</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">smoothed_forecasts_error_cov</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_smoothed_forecasts_cov</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_smoothed_forecasts</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_smoothed_forecasts_cov</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_compute_forecasts</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">smoothed_state</span><span class="p">,</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">smoothed_state_cov</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_smoothed_forecasts_cov</span></div>



<span class="k">def</span> <span class="nf">_check_dynamic</span><span class="p">(</span><span class="n">dynamic</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">nobs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Verify dynamic and warn or error if issues</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    dynamic : {int, None}</span>
<span class="sd">        The offset relative to start of the dynamic forecasts. None if no</span>
<span class="sd">        dynamic forecasts are required.</span>
<span class="sd">    start : int</span>
<span class="sd">        The location of the first forecast.</span>
<span class="sd">    end : int</span>
<span class="sd">        The location of the final forecast (inclusive).</span>
<span class="sd">    nobs : int</span>
<span class="sd">        The number of observations in the time series.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dynamic : {int, None}</span>
<span class="sd">        The start location of the first dynamic forecast. None if there</span>
<span class="sd">        are no in-sample dynamic forecasts.</span>
<span class="sd">    ndynamic : int</span>
<span class="sd">        The number of dynamic forecasts</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">dynamic</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">dynamic</span><span class="p">,</span> <span class="mi">0</span>

    <span class="c1"># Replace the relative dynamic offset with an absolute offset</span>
    <span class="n">dynamic</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">dynamic</span>

    <span class="c1"># Validate the `dynamic` parameter</span>
    <span class="k">if</span> <span class="n">dynamic</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Dynamic prediction cannot begin prior to the&#39;</span>
                         <span class="s1">&#39; first observation in the sample.&#39;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">dynamic</span> <span class="o">&gt;</span> <span class="n">end</span><span class="p">:</span>
        <span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Dynamic prediction specified to begin after the end of&#39;</span>
             <span class="s1">&#39; prediction, and so has no effect.&#39;</span><span class="p">,</span> <span class="n">ValueWarning</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="mi">0</span>
    <span class="k">elif</span> <span class="n">dynamic</span> <span class="o">&gt;</span> <span class="n">nobs</span><span class="p">:</span>
        <span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Dynamic prediction specified to begin during&#39;</span>
             <span class="s1">&#39; out-of-sample forecasting period, and so has no&#39;</span>
             <span class="s1">&#39; effect.&#39;</span><span class="p">,</span> <span class="n">ValueWarning</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="mi">0</span>

    <span class="c1"># Get the total size of the desired dynamic forecasting component</span>
    <span class="c1"># Note: the first `dynamic` periods of prediction are actually</span>
    <span class="c1"># *not* dynamic, because dynamic prediction begins at observation</span>
    <span class="c1"># `dynamic`.</span>
    <span class="n">ndynamic</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">end</span><span class="p">,</span> <span class="n">nobs</span><span class="p">)</span> <span class="o">-</span> <span class="n">dynamic</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">dynamic</span><span class="p">,</span> <span class="n">ndynamic</span>
</code></pre></div>

  <hr>
<div class="md-source-file">
  <small>
    
      Last update:
      Sep 01, 2023
    
  </small>
</div>





                
              </article>
            </div>
          
          
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  
  
  <div class="md-footer-meta md-typeset">
    
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
    <div class="md-footer-copyright__highlight">
        &#169; Copyright 2009-2023, Josef Perktold, Skipper Seabold, Jonathan Taylor, statsmodels-developers.
        
    </div>
  
    Created using
    <a href="https://www.sphinx-doc.org/" target="_blank" rel="noopener">Sphinx</a>
    7.2.5.
     and
    <a href="https://github.com/jbms/sphinx-immaterial/" target="_blank" rel="noopener">Sphinx-Immaterial</a>
  
</div>
      
        <div class="md-social">
  
    
    
    <a href="https://github.com/statsmodels/statsmodels/" target="_blank" rel="noopener" title="Source on github.com" class="md-social__link">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc.--><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg>
    </a>
  
    
    
      
      
    
    <a href="https://pypi.org/project/statsmodels/" target="_blank" rel="noopener" title="pypi.org" class="md-social__link">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc.--><path d="M439.8 200.5c-7.7-30.9-22.3-54.2-53.4-54.2h-40.1v47.4c0 36.8-31.2 67.8-66.8 67.8H172.7c-29.2 0-53.4 25-53.4 54.3v101.8c0 29 25.2 46 53.4 54.3 33.8 9.9 66.3 11.7 106.8 0 26.9-7.8 53.4-23.5 53.4-54.3v-40.7H226.2v-13.6h160.2c31.1 0 42.6-21.7 53.4-54.2 11.2-33.5 10.7-65.7 0-108.6zM286.2 404c11.1 0 20.1 9.1 20.1 20.3 0 11.3-9 20.4-20.1 20.4-11 0-20.1-9.2-20.1-20.4.1-11.3 9.1-20.3 20.1-20.3zM167.8 248.1h106.8c29.7 0 53.4-24.5 53.4-54.3V91.9c0-29-24.4-50.7-53.4-55.6-35.8-5.9-74.7-5.6-106.8.1-45.2 8-53.4 24.7-53.4 55.6v40.7h106.9v13.6h-147c-31.1 0-58.3 18.7-66.8 54.2-9.8 40.7-10.2 66.1 0 108.6 7.6 31.6 25.7 54.2 56.8 54.2H101v-48.8c0-35.3 30.5-66.4 66.8-66.4zm-6.7-142.6c-11.1 0-20.1-9.1-20.1-20.3.1-11.3 9-20.4 20.1-20.4 11 0 20.1 9.2 20.1 20.4s-9 20.3-20.1 20.3z"/></svg>
    </a>
  
    
    
      
      
    
    <a href="https://doi.org/10.5281/zenodo.593847" target="_blank" rel="noopener" title="doi.org" class="md-social__link">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc.--><path d="M0 216C0 149.7 53.7 96 120 96h8c17.7 0 32 14.3 32 32s-14.3 32-32 32h-8c-30.9 0-56 25.1-56 56v8h64c35.3 0 64 28.7 64 64v64c0 35.3-28.7 64-64 64H64c-35.3 0-64-28.7-64-64V216zm256 0c0-66.3 53.7-120 120-120h8c17.7 0 32 14.3 32 32s-14.3 32-32 32h-8c-30.9 0-56 25.1-56 56v8h64c35.3 0 64 28.7 64 64v64c0 35.3-28.7 64-64 64h-64c-35.3 0-64-28.7-64-64V216z"/></svg>
    </a>
  
</div>
      
    </div>
    
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    <script id="__config" type="application/json">{"base": "../../../..", "features": [], "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.config.lang": "en", "search.config.pipeline": "trimmer, stopWordFilter", "search.config.separator": "[\\s\\-]+", "search.placeholder": "Search", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version.title": "Select version"}, "version": {"provider": "mike", "staticVersions": null, "versionPath": "../versions-v3.json"}}</script>
    
      
        <script src="../../../../_static/sphinx_immaterial_theme.1b5b7a2d5891aec19.min.js?v=1e7b0789"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    
  </body>
</html>